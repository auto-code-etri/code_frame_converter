{"file_name":"address_v4_function_1.cpp","line_count":4,"code":"address_v4 make_address_v4(const address_v4::bytes_type& bytes)\n{\n  return address_v4(bytes);\n}","mark":8.0}
{"file_name":"address_v6_function_2.cpp","line_count":9,"code":"void combine_4_bytes(std::size_t& seed, const unsigned char* bytes)\n  {\n    const std::size_t bytes_hash =\n      (static_cast<std::size_t>(bytes[0]) << 24) |\n      (static_cast<std::size_t>(bytes[1]) << 16) |\n      (static_cast<std::size_t>(bytes[2]) << 8) |\n      (static_cast<std::size_t>(bytes[3]));\n    seed ^= bytes_hash + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n  }","mark":8.0}
{"file_name":"AlgorithmFind_function_1.cpp","line_count":12,"code":"ForwardIterator findIf(ForwardIterator first, ForwardIterator last, UnaryPredicate&& predicate)\n{\n    SC_ASSERT_DEBUG(first <= last);\n    for (auto it = first; it != last; ++it)\n    {\n        if (predicate(*it))\n        {\n            return it;\n        }\n    }\n    return last;\n}","mark":8.0}
{"file_name":"Allocator_function_3.cpp","line_count":3,"code":"void deallocate(TYPE* p, std::size_t n) {\n        mArena.free(p, n * sizeof(TYPE));\n    }","mark":8.0}
{"file_name":"AnyMapHolder_function_1.cpp","line_count":3,"code":"AnyValue create_AnyValue() {\n  return AnyValue{std::monostate{}};\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_10.cpp","line_count":3,"code":"bool is_AnyValue_number(const AnyValue& value) {\n  return std::holds_alternative<double>(value);\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_12.cpp","line_count":3,"code":"bool is_AnyValue_string(const AnyValue& value) {\n  return std::holds_alternative<std::string>(value);\n}","mark":9.0}
{"file_name":"AnyMapHolder_function_13.cpp","line_count":3,"code":"bool is_AnyValue_AnyArray(const AnyValue& value) {\n  return std::holds_alternative<AnyArray>(value);\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_14.cpp","line_count":3,"code":"bool is_AnyValue_AnyObject(const AnyValue& value) {\n  return std::holds_alternative<AnyObject>(value);\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_16.cpp","line_count":3,"code":"bool get_AnyValue_bool(const AnyValue& value) {\n  return std::get<bool>(value);\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_17.cpp","line_count":3,"code":"double get_AnyValue_number(const AnyValue& value) {\n  return std::get<double>(value);\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_18.cpp","line_count":3,"code":"int64_t get_AnyValue_bigint(const AnyValue& value) {\n  return std::get<int64_t>(value);\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_2.cpp","line_count":3,"code":"AnyValue create_AnyValue(bool boolValue) {\n  return AnyValue{boolValue};\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_22.cpp","line_count":7,"code":"AnyValue getAnyObjectValue(const AnyObject& object, const std::string& key) {\n  auto item = object.find(key);\n  if (item == object.end()) {\n    throw std::runtime_error(\"Couldn't find \" + key + \" in AnyObject!\");\n  }\n  return item->second;\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_4.cpp","line_count":3,"code":"AnyValue create_AnyValue(int64_t bigintValue) {\n  return AnyValue{bigintValue};\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_5.cpp","line_count":3,"code":"AnyValue create_AnyValue(const std::string& stringValue) {\n  return AnyValue{stringValue};\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_6.cpp","line_count":3,"code":"AnyValue create_AnyValue(const AnyArray& arrayValue) {\n  return AnyValue{arrayValue};\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_7.cpp","line_count":3,"code":"AnyValue create_AnyValue(const AnyObject& objectValue) {\n  return AnyValue{objectValue};\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_8.cpp","line_count":3,"code":"bool is_AnyValue_null(const AnyValue& value) {\n  return std::holds_alternative<std::monostate>(value);\n}","mark":8.0}
{"file_name":"AnyMapHolder_function_9.cpp","line_count":3,"code":"bool is_AnyValue_bool(const AnyValue& value) {\n  return std::holds_alternative<bool>(value);\n}","mark":9.0}
{"file_name":"Array_function_3.cpp","line_count":1,"code":"bool reserve(size_t newCapacity) { return newCapacity <= capacity(); }","mark":8.0}
{"file_name":"Array_function_6.cpp","line_count":1,"code":"bool shrink_to_fit() { return true; }","mark":8.0}
{"file_name":"asio_function_1.cpp","line_count":3,"code":"bool is_neg(T duration) {\n            return duration.count() < 0;\n        }","mark":8.0}
{"file_name":"asio_function_3.cpp","line_count":3,"code":"bool is_neg(T duration) {\n                return duration.count() < 0;\n            }","mark":8.0}
{"file_name":"asio_function_6.cpp","line_count":3,"code":"bool is_neg(T duration) {\n                return duration.is_negative();\n            }","mark":8.0}
{"file_name":"AsyncLinuxAPI_function_15.cpp","line_count":5,"code":"void io_uring_prep_send(struct io_uring_sqe* sqe, int sockfd, const void* buf, size_t len, int flags)\n    {\n        io_uring_prep_rw(IORING_OP_SEND, sqe, sockfd, buf, (__u32)len, 0);\n        sqe->msg_flags = (__u32)flags;\n    }","mark":8.0}
{"file_name":"AsyncLinuxAPI_function_16.cpp","line_count":5,"code":"void io_uring_prep_recv(struct io_uring_sqe* sqe, int sockfd, void* buf, size_t len, int flags)\n    {\n        io_uring_prep_rw(IORING_OP_RECV, sqe, sockfd, buf, (__u32)len, 0);\n        sqe->msg_flags = (__u32)flags;\n    }","mark":8.0}
{"file_name":"AsyncLinuxAPI_function_17.cpp","line_count":4,"code":"void io_uring_prep_close(struct io_uring_sqe* sqe, int fd)\n    {\n        io_uring_prep_rw(IORING_OP_CLOSE, sqe, fd, NULL, 0, 0);\n    }","mark":8.0}
{"file_name":"AsyncLinuxAPI_function_18.cpp","line_count":4,"code":"void io_uring_prep_read(struct io_uring_sqe* sqe, int fd, void* buf, unsigned nbytes, __u64 offset)\n    {\n        io_uring_prep_rw(IORING_OP_READ, sqe, fd, buf, nbytes, offset);\n    }","mark":8.0}
{"file_name":"AsyncRequestStreams_function_1.cpp","line_count":1,"code":"bool isEnded(AsyncFileRead::Result& result) { return result.completionData.endOfFile; }","mark":8.0}
{"file_name":"AsyncRequestStreams_function_2.cpp","line_count":1,"code":"bool isEnded(AsyncSocketReceive::Result& result) { return result.completionData.disconnected; }","mark":8.0}
{"file_name":"AsyncTest_function_9.cpp","line_count":35,"code":"Result snippetForSocketAccept(AsyncEventLoop& eventLoop, Console& console)\n{\n\/\/! [AsyncSocketAcceptSnippet]\n\/\/ Assuming an already created (and running) AsyncEventLoop named eventLoop\n\/\/ ...\n\/\/ Create a listening socket\nconstexpr uint32_t numWaitingConnections = 2;\nSocketDescriptor   serverSocket;\nuint16_t           tcpPort = 5050;\nSocketIPAddress    nativeAddress;\nSC_TRY(nativeAddress.fromAddressPort(\"127.0.0.1\", tcpPort));\nSC_TRY(eventLoop.createAsyncTCPSocket(nativeAddress.getAddressFamily(), serverSocket));\nSocketServer server(serverSocket);\nSC_TRY(server.bind(nativeAddress));\nSC_TRY(server.listen(numWaitingConnections));\n\/\/ Accept connect for new clients\nAsyncSocketAccept accept;\naccept.callback = [&](AsyncSocketAccept::Result& res)\n{\n    SocketDescriptor client;\n    if(res.moveTo(client))\n    {\n        \/\/ ...do something with new client\n        console.printLine(\"New client connected!\");\n        res.reactivateRequest(true); \/\/ We want to receive more clients\n    }\n};\nSC_TRY(accept.start(eventLoop, serverSocket));\n\/\/ ... at some later point\n\/\/ Stop accepting new clients\nSC_TRY(accept.stop());\n\/\/! [AsyncSocketAcceptSnippet]\nSC_TRY(eventLoop.run());\nreturn Result(true);\n}","mark":8.0}
{"file_name":"Async_function_1.cpp","line_count":1,"code":"void cacheInternalEventLoop(AsyncEventLoop& loop) { eventLoop = &loop; }","mark":8.0}
{"file_name":"Async_function_10.cpp","line_count":5,"code":"void setOffset(uint64_t fileOffset)\n    {\n        useOffset = true;\n        offset    = fileOffset;\n    }","mark":8.0}
{"file_name":"Async_function_2.cpp","line_count":1,"code":"void reactivateRequest(bool value) { shouldBeReactivated = value; }","mark":8.0}
{"file_name":"Async_function_8.cpp","line_count":5,"code":"void setOffset(uint64_t fileOffset)\n    {\n        useOffset = true;\n        offset    = fileOffset;\n    }","mark":8.0}
{"file_name":"atomic_count_function_11.cpp","line_count":1,"code":"void ref_count_up(atomic_count& a) { ++a; }","mark":8.0}
{"file_name":"atomic_count_function_3.cpp","line_count":1,"code":"void ref_count_up(atomic_count& a) { ++a; }","mark":8.0}
{"file_name":"atomic_count_function_7.cpp","line_count":4,"code":"void ref_count_up(atomic_count& a)\n{\n  a.fetch_add(1, std::memory_order_relaxed);\n}","mark":8.0}
{"file_name":"atomic_count_function_8.cpp","line_count":9,"code":"bool ref_count_down(atomic_count& a)\n{\n  if (a.fetch_sub(1, std::memory_order_release) == 1)\n  {\n    std::atomic_thread_fence(std::memory_order_acquire);\n    return true;\n  }\n  return false;\n}","mark":8.0}
{"file_name":"AutomationEngine_function_1.cpp","line_count":1,"code":"void signalBatchMode() { mBatchModeAllowed = true; }","mark":8.0}
{"file_name":"AutomationEngine_function_2.cpp","line_count":1,"code":"void stopRunning() { mIsRunning = false; }","mark":8.0}
{"file_name":"AutomationEngine_function_3.cpp","line_count":1,"code":"void setOptions(Options options) { mOptions = options; }","mark":8.0}
{"file_name":"AutomationEngine_function_4.cpp","line_count":1,"code":"void requestClose() { mShouldClose = true; }","mark":8.0}
{"file_name":"AvatarCache_function_1.cpp","line_count":1,"code":"void SetSizeOverride(int so) { sizeOverride = so; }","mark":8.0}
{"file_name":"awaitable_function_12.cpp","line_count":4,"code":"void destroy()\n  {\n    coro_.destroy();\n  }","mark":8.0}
{"file_name":"awaitable_function_3.cpp","line_count":4,"code":"void set_error(const asio::error_code& ec)\n  {\n    this->set_except(std::make_exception_ptr(asio::system_error(ec)));\n  }","mark":8.0}
{"file_name":"awaitable_function_5.cpp","line_count":8,"code":"void rethrow_exception()\n  {\n    if (pending_exception_)\n    {\n      std::exception_ptr ex = std::exchange(pending_exception_, nullptr);\n      std::rethrow_exception(ex);\n    }\n  }","mark":8.0}
{"file_name":"base_from_cancellation_state_function_1.cpp","line_count":5,"code":"void reset_cancellation_state(const Handler& handler)\n  {\n    cancellation_state_ = cancellation_state(\n        asio::get_associated_cancellation_slot(handler));\n  }","mark":8.0}
{"file_name":"base_function_1.cpp","line_count":3,"code":"error_code make_error_code(error::value e) {\n    return lib::error_code(static_cast<int>(e), get_category());\n}","mark":8.0}
{"file_name":"base_function_3.cpp","line_count":3,"code":"error_code make_error_code(error::value e) {\n    return lib::error_code(static_cast<int>(e), get_category());\n}","mark":8.0}
{"file_name":"basic_channel_function_1.cpp","line_count":4,"code":"void reset()\n  {\n    service_->reset(impl_);\n  }","mark":8.0}
{"file_name":"basic_channel_function_2.cpp","line_count":4,"code":"void close()\n  {\n    service_->close(impl_);\n  }","mark":8.0}
{"file_name":"basic_channel_function_3.cpp","line_count":4,"code":"void cancel()\n  {\n    service_->cancel(impl_);\n  }","mark":8.0}
{"file_name":"basic_concurrent_channel_function_1.cpp","line_count":4,"code":"void reset()\n  {\n    service_->reset(impl_);\n  }","mark":8.0}
{"file_name":"basic_concurrent_channel_function_2.cpp","line_count":4,"code":"void close()\n  {\n    service_->close(impl_);\n  }","mark":8.0}
{"file_name":"basic_concurrent_channel_function_3.cpp","line_count":4,"code":"void cancel()\n  {\n    service_->cancel(impl_);\n  }","mark":8.0}
{"file_name":"basic_datagram_socket_function_1.cpp","line_count":8,"code":"size_t send(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().send(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"send\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_datagram_socket_function_7.cpp","line_count":8,"code":"size_t receive(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().receive(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"receive\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_deadline_timer_function_1.cpp","line_count":7,"code":"size_t cancel()\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_deadline_timer_function_10.cpp","line_count":4,"code":"void wait(asio::error_code& ec)\n  {\n    impl_.get_service().wait(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_deadline_timer_function_2.cpp","line_count":4,"code":"size_t cancel(asio::error_code& ec)\n  {\n    return impl_.get_service().cancel(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_deadline_timer_function_3.cpp","line_count":8,"code":"size_t cancel_one()\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().cancel_one(\n        impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel_one\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_deadline_timer_function_4.cpp","line_count":4,"code":"size_t cancel_one(asio::error_code& ec)\n  {\n    return impl_.get_service().cancel_one(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_deadline_timer_function_5.cpp","line_count":8,"code":"size_t expires_at(const time_type& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_at(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_at\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_deadline_timer_function_7.cpp","line_count":8,"code":"size_t expires_from_now(const duration_type& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_from_now(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_from_now\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_descriptor_function_1.cpp","line_count":7,"code":"void assign(const native_handle_type& native_descriptor)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(),\n        native_descriptor, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }","mark":8.0}
{"file_name":"basic_descriptor_function_11.cpp","line_count":6,"code":"void non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().non_blocking(impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"non_blocking\");\n  }","mark":8.0}
{"file_name":"basic_descriptor_function_13.cpp","line_count":7,"code":"void native_non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().native_non_blocking(\n        impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"native_non_blocking\");\n  }","mark":8.0}
{"file_name":"basic_descriptor_function_15.cpp","line_count":6,"code":"void wait(wait_type w)\n  {\n    asio::error_code ec;\n    impl_.get_service().wait(impl_.get_implementation(), w, ec);\n    asio::detail::throw_error(ec, \"wait\");\n  }","mark":8.0}
{"file_name":"basic_descriptor_function_3.cpp","line_count":6,"code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }","mark":8.0}
{"file_name":"basic_descriptor_function_5.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_descriptor_function_6.cpp","line_count":4,"code":"native_handle_type release()\n  {\n    return impl_.get_service().release(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_descriptor_function_7.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"basic_descriptor_function_9.cpp","line_count":6,"code":"void io_control(IoControlCommand& command)\n  {\n    asio::error_code ec;\n    impl_.get_service().io_control(impl_.get_implementation(), command, ec);\n    asio::detail::throw_error(ec, \"io_control\");\n  }","mark":8.0}
{"file_name":"basic_endpoint_function_1.cpp","line_count":4,"code":"void resize(std::size_t new_size)\n  {\n    impl_.resize(new_size);\n  }","mark":8.0}
{"file_name":"basic_file_function_1.cpp","line_count":6,"code":"void open(const char* path, file_base::flags open_flags)\n  {\n    asio::error_code ec;\n    impl_.get_service().open(impl_.get_implementation(), path, open_flags, ec);\n    asio::detail::throw_error(ec, \"open\");\n  }","mark":8.0}
{"file_name":"basic_file_function_10.cpp","line_count":4,"code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_file_function_11.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_file_function_12.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"basic_file_function_14.cpp","line_count":6,"code":"void resize(uint64_t n)\n  {\n    asio::error_code ec;\n    impl_.get_service().resize(impl_.get_implementation(), n, ec);\n    asio::detail::throw_error(ec, \"resize\");\n  }","mark":8.0}
{"file_name":"basic_file_function_16.cpp","line_count":6,"code":"void sync_all()\n  {\n    asio::error_code ec;\n    impl_.get_service().sync_all(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"sync_all\");\n  }","mark":8.0}
{"file_name":"basic_file_function_18.cpp","line_count":6,"code":"void sync_data()\n  {\n    asio::error_code ec;\n    impl_.get_service().sync_data(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"sync_data\");\n  }","mark":8.0}
{"file_name":"basic_file_function_5.cpp","line_count":7,"code":"void assign(const native_handle_type& native_file)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(\n        impl_.get_implementation(), native_file, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }","mark":8.0}
{"file_name":"basic_file_function_7.cpp","line_count":6,"code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }","mark":8.0}
{"file_name":"basic_function_1.cpp","line_count":3,"code":"void set_ostream(std::ostream * out = &std::cout) {\n        m_out = out;\n    }","mark":8.0}
{"file_name":"basic_function_3.cpp","line_count":4,"code":"void clear_channels(level channels) {\n        scoped_lock_type lock(m_lock);\n        m_dynamic_channels &= ~channels;\n    }","mark":8.0}
{"file_name":"basic_object_handle_function_1.cpp","line_count":6,"code":"void assign(const native_handle_type& handle)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(), handle, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }","mark":8.0}
{"file_name":"basic_object_handle_function_3.cpp","line_count":6,"code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }","mark":8.0}
{"file_name":"basic_object_handle_function_5.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_object_handle_function_6.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"basic_object_handle_function_9.cpp","line_count":4,"code":"void wait(asio::error_code& ec)\n  {\n    impl_.get_service().wait(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_overlapped_handle_function_1.cpp","line_count":6,"code":"void assign(const native_handle_type& handle)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(), handle, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }","mark":8.0}
{"file_name":"basic_overlapped_handle_function_3.cpp","line_count":6,"code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }","mark":8.0}
{"file_name":"basic_overlapped_handle_function_6.cpp","line_count":4,"code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_overlapped_handle_function_7.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_overlapped_handle_function_8.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"basic_raw_socket_function_1.cpp","line_count":8,"code":"size_t send(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().send(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"send\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_raw_socket_function_7.cpp","line_count":8,"code":"size_t receive(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().receive(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"receive\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_readable_pipe_function_1.cpp","line_count":6,"code":"void assign(const native_handle_type& native_pipe)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(), native_pipe, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }","mark":8.0}
{"file_name":"basic_readable_pipe_function_10.cpp","line_count":8,"code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().read_some(\n        impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_readable_pipe_function_3.cpp","line_count":6,"code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }","mark":8.0}
{"file_name":"basic_readable_pipe_function_6.cpp","line_count":4,"code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_readable_pipe_function_7.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_readable_pipe_function_8.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"basic_regex_creator_function_1.cpp","line_count":7,"code":"void add_single(const digraph_type& s)\n   {\n      m_singles.insert(s);\n      if(s.second)\n         m_has_digraphs = true;\n      m_empty = false;\n   }","mark":8.0}
{"file_name":"basic_regex_creator_function_10.cpp","line_count":4,"code":"flag_type flags()\n   {\n      return m_pdata->m_flags;\n   }","mark":8.0}
{"file_name":"basic_regex_creator_function_14.cpp","line_count":4,"code":"bool char_less(char t1, char t2)\n{\n   return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);\n}","mark":8.0}
{"file_name":"basic_regex_creator_function_15.cpp","line_count":4,"code":"bool char_less(signed char t1, signed char t2)\n{\n   return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);\n}","mark":8.0}
{"file_name":"basic_regex_creator_function_5.cpp","line_count":10,"code":"void add_equivalent(const digraph_type& s)\n   {\n      m_equivalents.insert(s);\n      if(s.second)\n      {\n         m_has_digraphs = true;\n         add_single(s);\n      }\n      m_empty = false;\n   }","mark":8.0}
{"file_name":"basic_regex_creator_function_8.cpp","line_count":4,"code":"ptrdiff_t getoffset(const void* addr, const void* base)\n   {\n      return static_cast<const char*>(addr) - static_cast<const char*>(base);\n   }","mark":9.0}
{"file_name":"basic_regex_creator_function_9.cpp","line_count":5,"code":"void init(unsigned l_flags)\n   {\n      m_pdata->m_flags = l_flags;\n      m_icase = l_flags & regex_constants::icase;\n   }","mark":8.0}
{"file_name":"basic_regex_function_3.cpp","line_count":5,"code":"void swap(name& other)\n      {\n         std::swap(index, other.index);\n         std::swap(hash, other.hash);\n      }","mark":8.0}
{"file_name":"basic_resolver_function_1.cpp","line_count":4,"code":"void cancel()\n  {\n    return impl_.get_service().cancel(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_resolver_function_12.cpp","line_count":8,"code":"results_type resolve(const endpoint_type& e)\n  {\n    asio::error_code ec;\n    results_type i = impl_.get_service().resolve(\n        impl_.get_implementation(), e, ec);\n    asio::detail::throw_error(ec, \"resolve\");\n    return i;\n  }","mark":8.0}
{"file_name":"basic_resolver_function_2.cpp","line_count":8,"code":"results_type resolve(const query& q)\n  {\n    asio::error_code ec;\n    results_type r = impl_.get_service().resolve(\n        impl_.get_implementation(), q, ec);\n    asio::detail::throw_error(ec, \"resolve\");\n    return r;\n  }","mark":8.0}
{"file_name":"basic_resolver_function_3.cpp","line_count":4,"code":"results_type resolve(const query& q, asio::error_code& ec)\n  {\n    return impl_.get_service().resolve(impl_.get_implementation(), q, ec);\n  }","mark":8.0}
{"file_name":"basic_serial_port_function_1.cpp","line_count":6,"code":"void open(const std::string& device)\n  {\n    asio::error_code ec;\n    impl_.get_service().open(impl_.get_implementation(), device, ec);\n    asio::detail::throw_error(ec, \"open\");\n  }","mark":8.0}
{"file_name":"basic_serial_port_function_10.cpp","line_count":6,"code":"void send_break()\n  {\n    asio::error_code ec;\n    impl_.get_service().send_break(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"send_break\");\n  }","mark":8.0}
{"file_name":"basic_serial_port_function_12.cpp","line_count":6,"code":"void set_option(const SettableSerialPortOption& option)\n  {\n    asio::error_code ec;\n    impl_.get_service().set_option(impl_.get_implementation(), option, ec);\n    asio::detail::throw_error(ec, \"set_option\");\n  }","mark":8.0}
{"file_name":"basic_serial_port_function_14.cpp","line_count":8,"code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().write_some(\n        impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_serial_port_function_16.cpp","line_count":8,"code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().read_some(\n        impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_serial_port_function_3.cpp","line_count":7,"code":"void assign(const native_handle_type& native_serial_port)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(),\n        native_serial_port, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }","mark":8.0}
{"file_name":"basic_serial_port_function_5.cpp","line_count":6,"code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }","mark":8.0}
{"file_name":"basic_serial_port_function_7.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_serial_port_function_8.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"basic_signal_set_function_3.cpp","line_count":6,"code":"void add(int signal_number, flags_t f)\n  {\n    asio::error_code ec;\n    impl_.get_service().add(impl_.get_implementation(), signal_number, f, ec);\n    asio::detail::throw_error(ec, \"add\");\n  }","mark":8.0}
{"file_name":"basic_signal_set_function_9.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_11.cpp","line_count":4,"code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_12.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_13.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_15.cpp","line_count":6,"code":"void set_option(const SettableSocketOption& option)\n  {\n    asio::error_code ec;\n    impl_.get_service().set_option(impl_.get_implementation(), option, ec);\n    asio::detail::throw_error(ec, \"set_option\");\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_17.cpp","line_count":6,"code":"void io_control(IoControlCommand& command)\n  {\n    asio::error_code ec;\n    impl_.get_service().io_control(impl_.get_implementation(), command, ec);\n    asio::detail::throw_error(ec, \"io_control\");\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_19.cpp","line_count":6,"code":"void non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().non_blocking(impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"non_blocking\");\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_21.cpp","line_count":7,"code":"void native_non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().native_non_blocking(\n        impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"native_non_blocking\");\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_4.cpp","line_count":6,"code":"void bind(const endpoint_type& endpoint)\n  {\n    asio::error_code ec;\n    impl_.get_service().bind(impl_.get_implementation(), endpoint, ec);\n    asio::detail::throw_error(ec, \"bind\");\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_6.cpp","line_count":6,"code":"void listen(int backlog = socket_base::max_listen_connections)\n  {\n    asio::error_code ec;\n    impl_.get_service().listen(impl_.get_implementation(), backlog, ec);\n    asio::detail::throw_error(ec, \"listen\");\n  }","mark":8.0}
{"file_name":"basic_socket_acceptor_function_8.cpp","line_count":6,"code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }","mark":8.0}
{"file_name":"basic_socket_function_11.cpp","line_count":6,"code":"void bind(const endpoint_type& endpoint)\n  {\n    asio::error_code ec;\n    impl_.get_service().bind(impl_.get_implementation(), endpoint, ec);\n    asio::detail::throw_error(ec, \"bind\");\n  }","mark":8.0}
{"file_name":"basic_socket_function_15.cpp","line_count":6,"code":"void set_option(const SettableSocketOption& option)\n  {\n    asio::error_code ec;\n    impl_.get_service().set_option(impl_.get_implementation(), option, ec);\n    asio::detail::throw_error(ec, \"set_option\");\n  }","mark":8.0}
{"file_name":"basic_socket_function_17.cpp","line_count":6,"code":"void io_control(IoControlCommand& command)\n  {\n    asio::error_code ec;\n    impl_.get_service().io_control(impl_.get_implementation(), command, ec);\n    asio::detail::throw_error(ec, \"io_control\");\n  }","mark":8.0}
{"file_name":"basic_socket_function_19.cpp","line_count":6,"code":"void non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().non_blocking(impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"non_blocking\");\n  }","mark":8.0}
{"file_name":"basic_socket_function_21.cpp","line_count":7,"code":"void native_non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().native_non_blocking(\n        impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"native_non_blocking\");\n  }","mark":8.0}
{"file_name":"basic_socket_function_23.cpp","line_count":6,"code":"void shutdown(shutdown_type what)\n  {\n    asio::error_code ec;\n    impl_.get_service().shutdown(impl_.get_implementation(), what, ec);\n    asio::detail::throw_error(ec, \"shutdown\");\n  }","mark":8.0}
{"file_name":"basic_socket_function_4.cpp","line_count":6,"code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }","mark":8.0}
{"file_name":"basic_socket_function_7.cpp","line_count":4,"code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_socket_function_8.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_socket_function_9.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"basic_socket_iostream_function_4.cpp","line_count":4,"code":"void expires_after(const duration& expiry_time)\n  {\n    rdbuf()->expires_after(expiry_time);\n  }","mark":8.0}
{"file_name":"basic_streambuf_function_10.cpp","line_count":4,"code":"void consume(std::size_t n)\n  {\n    return sb_.consume(n);\n  }","mark":8.0}
{"file_name":"basic_streambuf_function_2.cpp","line_count":6,"code":"void commit(std::size_t n)\n  {\n    n = std::min<std::size_t>(n, epptr() - pptr());\n    pbump(static_cast<int>(n));\n    setg(eback(), gptr(), pptr());\n  }","mark":8.0}
{"file_name":"basic_streambuf_function_8.cpp","line_count":4,"code":"mutable_buffers_type prepare(std::size_t n)\n  {\n    return sb_.prepare(n);\n  }","mark":8.0}
{"file_name":"basic_streambuf_function_9.cpp","line_count":4,"code":"void commit(std::size_t n)\n  {\n    return sb_.commit(n);\n  }","mark":8.0}
{"file_name":"basic_stream_descriptor_function_1.cpp","line_count":8,"code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().write_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_stream_descriptor_function_3.cpp","line_count":8,"code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().read_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_stream_file_function_1.cpp","line_count":8,"code":"uint64_t seek(int64_t offset, file_base::seek_basis whence)\n  {\n    asio::error_code ec;\n    uint64_t n = this->impl_.get_service().seek(\n        this->impl_.get_implementation(), offset, whence, ec);\n    asio::detail::throw_error(ec, \"seek\");\n    return n;\n  }","mark":8.0}
{"file_name":"basic_stream_file_function_3.cpp","line_count":8,"code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().write_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_stream_file_function_5.cpp","line_count":8,"code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().read_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_stream_handle_function_1.cpp","line_count":8,"code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().write_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_stream_handle_function_3.cpp","line_count":8,"code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().read_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_stream_socket_function_1.cpp","line_count":8,"code":"size_t send(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().send(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"send\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_stream_socket_function_4.cpp","line_count":8,"code":"size_t receive(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().receive(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"receive\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_stream_socket_function_7.cpp","line_count":8,"code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().send(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_stream_socket_function_9.cpp","line_count":8,"code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().receive(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_waitable_timer_function_1.cpp","line_count":7,"code":"size_t cancel()\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_waitable_timer_function_11.cpp","line_count":4,"code":"void wait(asio::error_code& ec)\n  {\n    impl_.get_service().wait(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_waitable_timer_function_2.cpp","line_count":4,"code":"size_t cancel(asio::error_code& ec)\n  {\n    return impl_.get_service().cancel(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_waitable_timer_function_3.cpp","line_count":8,"code":"size_t cancel_one()\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().cancel_one(\n        impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel_one\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_waitable_timer_function_4.cpp","line_count":4,"code":"size_t cancel_one(asio::error_code& ec)\n  {\n    return impl_.get_service().cancel_one(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_waitable_timer_function_5.cpp","line_count":8,"code":"size_t expires_at(const time_point& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_at(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_at\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_waitable_timer_function_7.cpp","line_count":8,"code":"size_t expires_after(const duration& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_after(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_after\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_waitable_timer_function_8.cpp","line_count":8,"code":"size_t expires_from_now(const duration& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_from_now(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_from_now\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_writable_pipe_function_1.cpp","line_count":6,"code":"void assign(const native_handle_type& native_pipe)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(), native_pipe, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }","mark":8.0}
{"file_name":"basic_writable_pipe_function_10.cpp","line_count":8,"code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().write_some(\n        impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }","mark":8.0}
{"file_name":"basic_writable_pipe_function_3.cpp","line_count":6,"code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }","mark":8.0}
{"file_name":"basic_writable_pipe_function_6.cpp","line_count":4,"code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }","mark":8.0}
{"file_name":"basic_writable_pipe_function_7.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }","mark":8.0}
{"file_name":"basic_writable_pipe_function_8.cpp","line_count":6,"code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }","mark":8.0}
{"file_name":"Bias_Dx11_function_1.cpp","line_count":23,"code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n{\n    switch (format) {\n        case DXGI_FORMAT_R32G32B32A32_TYPELESS:\n            return DXGI_FORMAT_R32G32B32A32_FLOAT;\n        case DXGI_FORMAT_R32G32B32_TYPELESS:\n            return DXGI_FORMAT_R32G32B32_FLOAT;\n        case DXGI_FORMAT_R16G16B16A16_TYPELESS:\n            return DXGI_FORMAT_R16G16B16A16_FLOAT;\n        case DXGI_FORMAT_R10G10B10A2_TYPELESS:\n            return DXGI_FORMAT_R10G10B10A2_UINT;\n        case DXGI_FORMAT_R8G8B8A8_TYPELESS:\n            return DXGI_FORMAT_R8G8B8A8_UNORM;\n        case DXGI_FORMAT_B8G8R8A8_TYPELESS:\n            return DXGI_FORMAT_B8G8R8A8_UNORM;\n        case DXGI_FORMAT_R16G16_TYPELESS:\n            return DXGI_FORMAT_R16G16_FLOAT;\n        case DXGI_FORMAT_R32G32_TYPELESS:\n            return DXGI_FORMAT_R32G32_FLOAT;\n        default:\n            return format;\n    }\n}","mark":8.0}
{"file_name":"Bias_Dx12_function_1.cpp","line_count":23,"code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n{\n\tswitch (format) {\n\t\tcase DXGI_FORMAT_R32G32B32A32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32B32A32_FLOAT;\n\t\tcase DXGI_FORMAT_R32G32B32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32B32_FLOAT;\n\t\tcase DXGI_FORMAT_R16G16B16A16_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R16G16B16A16_FLOAT;\n\t\tcase DXGI_FORMAT_R10G10B10A2_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R10G10B10A2_UINT;\n\t\tcase DXGI_FORMAT_R8G8B8A8_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R8G8B8A8_UNORM;\n\t\tcase DXGI_FORMAT_B8G8R8A8_TYPELESS:\n\t\t\treturn DXGI_FORMAT_B8G8R8A8_UNORM;\n\t\tcase DXGI_FORMAT_R16G16_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R16G16_FLOAT;\n\t\tcase DXGI_FORMAT_R32G32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32_FLOAT;\n\t\tdefault:\n\t\t\treturn format;\n\t}\n}","mark":8.0}
{"file_name":"buffered_stream_function_1.cpp","line_count":4,"code":"void close()\n  {\n    stream_impl_.close();\n  }","mark":8.0}
{"file_name":"buffered_stream_function_11.cpp","line_count":4,"code":"size_t peek(const MutableBufferSequence& buffers)\n  {\n    return stream_impl_.peek(buffers);\n  }","mark":8.0}
{"file_name":"buffered_stream_function_13.cpp","line_count":4,"code":"size_t in_avail()\n  {\n    return stream_impl_.in_avail();\n  }","mark":8.0}
{"file_name":"buffered_stream_function_14.cpp","line_count":4,"code":"size_t in_avail(asio::error_code& ec)\n  {\n    return stream_impl_.in_avail(ec);\n  }","mark":8.0}
{"file_name":"buffered_stream_function_3.cpp","line_count":4,"code":"size_t flush()\n  {\n    return stream_impl_.next_layer().flush();\n  }","mark":8.0}
{"file_name":"buffered_stream_function_4.cpp","line_count":4,"code":"size_t flush(asio::error_code& ec)\n  {\n    return stream_impl_.next_layer().flush(ec);\n  }","mark":8.0}
{"file_name":"buffered_stream_function_5.cpp","line_count":4,"code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    return stream_impl_.write_some(buffers);\n  }","mark":8.0}
{"file_name":"buffered_stream_function_7.cpp","line_count":4,"code":"size_t fill()\n  {\n    return stream_impl_.fill();\n  }","mark":8.0}
{"file_name":"buffered_stream_function_8.cpp","line_count":4,"code":"size_t fill(asio::error_code& ec)\n  {\n    return stream_impl_.fill(ec);\n  }","mark":8.0}
{"file_name":"buffered_stream_function_9.cpp","line_count":4,"code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    return stream_impl_.read_some(buffers);\n  }","mark":8.0}
{"file_name":"buffered_stream_storage_function_1.cpp","line_count":5,"code":"void clear()\n  {\n    begin_offset_ = 0;\n    end_offset_ = 0;\n  }","mark":8.0}
{"file_name":"buffered_stream_storage_function_4.cpp","line_count":7,"code":"void consume(size_type count)\n  {\n    ASIO_ASSERT(begin_offset_ + count <= end_offset_);\n    begin_offset_ += count;\n    if (empty())\n      clear();\n  }","mark":8.0}
{"file_name":"buffer_sequence_adapter_function_3.cpp","line_count":4,"code":"void init_iov_base(void*& base, void* addr)\n  {\n    base = addr;\n  }","mark":8.0}
{"file_name":"buffer_sequence_adapter_function_47.cpp","line_count":4,"code":"bool all_empty(const boost::array<Elem, 2>& buffer_sequence)\n  {\n    return buffer_sequence[0].size() == 0 && buffer_sequence[1].size() == 0;\n  }","mark":8.0}
{"file_name":"buffer_sequence_adapter_function_52.cpp","line_count":4,"code":"bool all_empty(const std::array<Elem, 2>& buffer_sequence)\n  {\n    return buffer_sequence[0].size() == 0 && buffer_sequence[1].size() == 0;\n  }","mark":8.0}
{"file_name":"buffer_sequence_adapter_function_7.cpp","line_count":6,"code":"bool all_empty(const Buffers& buffer_sequence)\n  {\n    return buffer_sequence_adapter::all_empty(\n        asio::buffer_sequence_begin(buffer_sequence),\n        asio::buffer_sequence_end(buffer_sequence));\n  }","mark":8.0}
{"file_name":"buffer_sequence_adapter_function_8.cpp","line_count":6,"code":"void validate(const Buffers& buffer_sequence)\n  {\n    buffer_sequence_adapter::validate(\n        asio::buffer_sequence_begin(buffer_sequence),\n        asio::buffer_sequence_end(buffer_sequence));\n  }","mark":8.0}
{"file_name":"buffer_sequence_adapter_function_9.cpp","line_count":6,"code":"Buffer first(const Buffers& buffer_sequence)\n  {\n    return buffer_sequence_adapter::first(\n        asio::buffer_sequence_begin(buffer_sequence),\n        asio::buffer_sequence_end(buffer_sequence));\n  }","mark":8.0}
{"file_name":"BuildWriter_function_2.cpp","line_count":19,"code":"StringView getExtension(RenderItem::Type type)\n        {\n            switch (type)\n            {\n            case RenderItem::CppFile: {\n                return \".cpp\";\n            }\n            case RenderItem::CFile: {\n                return \".c\";\n            }\n            case RenderItem::ObjCFile: {\n                return \".m\";\n            }\n            case RenderItem::ObjCppFile: {\n                return \".mm\";\n            }\n            default: return StringView();\n            }\n        }","mark":8.0}
{"file_name":"Build_function_1.cpp","line_count":12,"code":"StringView toString(Type type)\n    {\n        switch (type)\n        {\n        case Unknown: return \"unknown\";\n        case Windows: return \"windows\";\n        case Apple: return \"apple\";\n        case Linux: return \"linux\";\n        case Wasm: return \"wasm\";\n        }\n        Assert::unreachable();\n    }","mark":8.0}
{"file_name":"Build_function_10.cpp","line_count":9,"code":"bool addFrameworks(Span<const StringView> frameworks, PlatformApple appleOS = PlatformApple::Any)\n    {\n        switch (appleOS)\n        {\n        case PlatformApple::macOS: return getOrCreate<Link::linkFrameworksMacOS>()->append(frameworks);\n        case PlatformApple::iOS: return getOrCreate<Link::linkFrameworksIOS>()->append(frameworks);\n        default: return getOrCreate<Link::linkFrameworksAny>()->append(frameworks);\n        }\n    }","mark":8.0}
{"file_name":"Build_function_11.cpp","line_count":4,"code":"bool addLibraries(Span<const StringView> libraries)\n    {\n        return getOrCreate<Link::linkLibraries>()->append(libraries);\n    }","mark":8.0}
{"file_name":"Build_function_12.cpp","line_count":11,"code":"StringView PresetToString(Preset preset)\n    {\n        switch (preset)\n        {\n        case Configuration::Preset::Debug: return \"Debug\";\n        case Configuration::Preset::DebugCoverage: return \"DebugCoverage\";\n        case Configuration::Preset::Release: return \"Release\";\n        case Configuration::Preset::None: return \"None\";\n        }\n        Assert::unreachable();\n    }","mark":8.0}
{"file_name":"Build_function_2.cpp","line_count":12,"code":"StringView toString(Type type)\n    {\n        switch (type)\n        {\n        case Any: return \"Any\";\n        case Intel32: return \"Intel32\";\n        case Intel64: return \"Intel64\";\n        case Arm64: return \"Arm64\";\n        case Wasm: return \"Wasm\";\n        }\n        Assert::unreachable();\n    }","mark":8.0}
{"file_name":"Build_function_6.cpp","line_count":4,"code":"bool addIncludes(Span<const StringView> includes)\n    {\n        return getOrCreate<Compile::includePaths>()->append(includes);\n    }","mark":8.0}
{"file_name":"Build_function_7.cpp","line_count":4,"code":"bool addDefines(Span<const StringView> defines)\n    {\n        return getOrCreate<Compile::preprocessorDefines>()->append(defines);\n    }","mark":8.0}
{"file_name":"Build_function_8.cpp","line_count":16,"code":"StringView typeToString(Type type)\n    {\n        switch (type)\n        {\n        case libraryPaths: return \"libraryPaths\";\n        case linkFrameworksAny: return \"linkFrameworksAny\";\n        case linkFrameworksMacOS: return \"linkFrameworksMacOS\";\n        case linkFrameworksIOS: return \"linkFrameworksIOS\";\n        case linkLibraries: return \"linkLibraries\";\n        case guiApplication: return \"guiApplication\";\n        case enableLTO: return \"enableLTO\";\n        case enableASAN: return \"enableASAN\";\n        case enableStdCpp: return \"enableStdCpp\";\n        }\n        Assert::unreachable();\n    }","mark":8.0}
{"file_name":"Build_function_9.cpp","line_count":4,"code":"bool addSearchPath(Span<const StringView> libraries)\n    {\n        return getOrCreate<Link::libraryPaths>()->append(libraries);\n    }","mark":8.0}
{"file_name":"cancellation_signal_function_2.cpp","line_count":5,"code":"void emit(cancellation_type_t type)\n  {\n    if (handler_)\n      handler_->call(type);\n  }","mark":8.0}
{"file_name":"Car_function_2.cpp","line_count":11,"code":"Value toJSI(jsi::Runtime& runtime, const Car& arg) {\n      jsi::Object obj(runtime);\n      obj.setProperty(runtime, \"year\", JSIConverter<double>::toJSI(runtime, arg.year));\n      obj.setProperty(runtime, \"make\", JSIConverter<std::string>::toJSI(runtime, arg.make));\n      obj.setProperty(runtime, \"model\", JSIConverter<std::string>::toJSI(runtime, arg.model));\n      obj.setProperty(runtime, \"power\", JSIConverter<double>::toJSI(runtime, arg.power));\n      obj.setProperty(runtime, \"powertrain\", JSIConverter<Powertrain>::toJSI(runtime, arg.powertrain));\n      obj.setProperty(runtime, \"driver\", JSIConverter<std::optional<Person>>::toJSI(runtime, arg.driver));\n      obj.setProperty(runtime, \"isFast\", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.isFast));\n      return obj;\n    }","mark":8.0}
{"file_name":"Car_function_3.cpp","line_count":14,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isObject()) {\n        return false;\n      }\n      jsi::Object obj = value.getObject(runtime);\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"year\"))) return false;\n      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, \"make\"))) return false;\n      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, \"model\"))) return false;\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"power\"))) return false;\n      if (!JSIConverter<Powertrain>::canConvert(runtime, obj.getProperty(runtime, \"powertrain\"))) return false;\n      if (!JSIConverter<std::optional<Person>>::canConvert(runtime, obj.getProperty(runtime, \"driver\"))) return false;\n      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, \"isFast\"))) return false;\n      return true;\n    }","mark":8.0}
{"file_name":"ChannelView_function_1.cpp","line_count":4,"code":"int GetProfileBorderSize()\n{\n\treturn ScaleByDPI(Supports32BitIcons() ? (PROFILE_PICTURE_SIZE_DEF + 12) : 64);\n}","mark":8.0}
{"file_name":"ChannelView_function_4.cpp","line_count":4,"code":"bool IsChannelASubThread(Channel::eChannelType x)\n{\n\treturn x >= Channel::NEWSTHREAD && x < Channel::FORUM;\n}","mark":8.0}
{"file_name":"channel_error_function_1.cpp","line_count":5,"code":"error_code make_error_code(channel_errors e)\n{\n  return asio::error_code(\n      static_cast<int>(e), get_channel_category());\n}","mark":8.0}
{"file_name":"channel_payload_function_2.cpp","line_count":4,"code":"void receive(Handler& handler)\n  {\n    message_.receive(handler);\n  }","mark":8.0}
{"file_name":"channel_payload_function_3.cpp","line_count":8,"code":"void receive(Handler& handler)\n  {\n    std::visit(\n        [&](auto& message)\n        {\n          message.receive(handler);\n        }, message_);\n  }","mark":8.0}
{"file_name":"channel_service_function_17.cpp","line_count":4,"code":"payload_type buffer_front()\n  {\n    return payload_type({0, first_.value_});\n  }","mark":8.0}
{"file_name":"channel_service_function_4.cpp","line_count":7,"code":"size_t buffer_push_n(std::size_t count, payload_type payload)\n  {\n    std::size_t i = 0;\n    for (; i < count && buffer_.size() < this->max_buffer_size_; ++i)\n      buffer_.push_back(payload);\n    return i;\n  }","mark":8.0}
{"file_name":"channel_service_function_5.cpp","line_count":4,"code":"payload_type buffer_front()\n  {\n    return ASIO_MOVE_CAST(payload_type)(buffer_.front());\n  }","mark":8.0}
{"file_name":"channel_service_function_6.cpp","line_count":4,"code":"void buffer_pop()\n  {\n    buffer_.pop_front();\n  }","mark":8.0}
{"file_name":"channel_service_function_7.cpp","line_count":4,"code":"void buffer_clear()\n  {\n    buffer_.clear();\n  }","mark":8.0}
{"file_name":"chrono_time_traits_function_4.cpp","line_count":4,"code":"bool less_than(const time_type& t1, const time_type& t2)\n  {\n    return t1 < t2;\n  }","mark":8.0}
{"file_name":"client_endpoint_function_1.cpp","line_count":18,"code":"connection_ptr get_connection(uri_ptr location, lib::error_code & ec) {\n        if (location->get_secure() && !transport_type::is_secure()) {\n            ec = error::make_error_code(error::endpoint_not_secure);\n            return connection_ptr();\n        }\n\n        connection_ptr con = endpoint_type::create_connection();\n\n        if (!con) {\n            ec = error::make_error_code(error::con_creation_failed);\n            return con;\n        }\n\n        con->set_uri(location);\n\n        ec = lib::error_code();\n        return con;\n    }","mark":8.0}
{"file_name":"client_endpoint_function_2.cpp","line_count":10,"code":"connection_ptr get_connection(std::string const & u, lib::error_code & ec) {\n        uri_ptr location = lib::make_shared<uri>(u);\n\n        if (!location->get_valid()) {\n            ec = error::make_error_code(error::invalid_uri);\n            return connection_ptr();\n        }\n\n        return get_connection(location, ec);\n    }","mark":8.0}
{"file_name":"client_endpoint_function_4.cpp","line_count":13,"code":"void handle_connect(connection_ptr con, lib::error_code const & ec) {\n        if (ec) {\n            con->terminate(ec);\n\n            endpoint_type::m_elog->write(log::elevel::rerror,\n                    \"handle_connect error: \"+ec.message());\n        } else {\n            endpoint_type::m_alog->write(log::alevel::connect,\n                \"Successful connection\");\n\n            con->start();\n        }\n    }","mark":8.0}
{"file_name":"ColorTransform_function_13.cpp","line_count":10,"code":"LinearImage toLinearFromRGBM( filament::math::float4 const* src, uint32_t w, uint32_t h) {\n    LinearImage result(w, h, 3);\n    auto dst = result.get< filament::math::float3>();\n    for (uint32_t row = 0; row < h; ++row) {\n        for (uint32_t col = 0; col < w; ++col, ++src, ++dst) {\n            *dst = RGBMtoLinear(*src);\n        }\n    }\n    return result;\n}","mark":8.0}
{"file_name":"ColorTransform_function_14.cpp","line_count":13,"code":"LinearImage fromLinearToRGBM(const LinearImage& image) {\n    assert(image.getChannels() == 3);\n    const uint32_t w = image.getWidth(), h = image.getHeight();\n    LinearImage result(w, h, 4);\n    auto src = image.get< filament::math::float3>();\n    auto dst = result.get< filament::math::float4>();\n    for (uint32_t row = 0; row < h; ++row) {\n        for (uint32_t col = 0; col < w; ++col, ++src, ++dst) {\n            *dst = linearToRGBM(*src);\n        }\n    }\n    return result;\n}","mark":8.0}
{"file_name":"ColorTransform_function_4.cpp","line_count":15,"code":"float3 linearTosRGB(const T& linear) {\n    using filament::math::float3;\n    constexpr float a = 0.055f;\n    constexpr float a1 = 1.055f;\n    constexpr float p = 1 \/ 2.4f;\n    float3 sRGB;\n    for (size_t i=0 ; i<3 ; i++) {\n        if (linear[i] <= 0.0031308f) {\n            sRGB[i] = linear[i] * 12.92f;\n        } else {\n            sRGB[i] = a1 * std::pow(linear[i], p) - a;\n        }\n    }\n    return sRGB;\n}","mark":8.25}
{"file_name":"ColorTransform_function_5.cpp","line_count":10,"code":"float linearTosRGB(float linear) {\n    if (linear <= 0.0031308f) {\n        return linear * 12.92f;\n    } else {\n        constexpr float a = 0.055f;\n        constexpr float a1 = 1.055f;\n        constexpr float p = 1 \/ 2.4f;\n        return a1 * std::pow(linear, p) - a;\n    }\n}","mark":8.0}
{"file_name":"ColorTransform_function_7.cpp","line_count":16,"code":"float4 sRGBToLinear(const filament::math::float4& sRGB) {\n    using filament::math::float4;\n    constexpr float a = 0.055f;\n    constexpr float a1 = 1.055f;\n    constexpr float p = 2.4f;\n    float4 linear;\n    for (size_t i=0 ; i<3 ; i++) {\n        if (sRGB[i] <= 0.04045f) {\n            linear[i] = sRGB[i] * (1.0f \/ 12.92f);\n        } else {\n            linear[i] = std::pow((sRGB[i] + a) \/ a1, p);\n        }\n    }\n    linear[3] = sRGB[3];\n    return linear;\n}","mark":8.25}
{"file_name":"Compiler_function_1.cpp","line_count":6,"code":"void swap(T& t1, T& t2)\n{\n    T temp = move(t1);\n    t1     = move(t2);\n    t2     = move(temp);\n}","mark":8.0}
{"file_name":"completion_condition_function_1.cpp","line_count":4,"code":"size_t adapt_completion_condition_result(bool result)\n{\n  return result ? 0 : default_max_transfer_size;\n}","mark":8.0}
{"file_name":"completion_condition_function_2.cpp","line_count":4,"code":"size_t adapt_completion_condition_result(std::size_t result)\n{\n  return result;\n}","mark":8.0}
{"file_name":"completion_condition_function_3.cpp","line_count":4,"code":"transfer_all_t transfer_all()\n{\n  return detail::transfer_all_t();\n}","mark":8.0}
{"file_name":"completion_condition_function_4.cpp","line_count":4,"code":"transfer_at_least_t transfer_at_least(std::size_t minimum)\n{\n  return detail::transfer_at_least_t(minimum);\n}","mark":8.0}
{"file_name":"completion_condition_function_5.cpp","line_count":4,"code":"transfer_exactly_t transfer_exactly(std::size_t size)\n{\n  return detail::transfer_exactly_t(size);\n}","mark":8.0}
{"file_name":"composed_work_function_3.cpp","line_count":5,"code":"void reset()\n  {\n    head_.reset();\n    tail_.reset();\n  }","mark":8.0}
{"file_name":"composed_work_function_4.cpp","line_count":4,"code":"void reset()\n  {\n    head_.reset();\n  }","mark":8.0}
{"file_name":"composed_work_function_5.cpp","line_count":4,"code":"void reset()\n  {\n    head_.reset();\n  }","mark":8.0}
{"file_name":"composed_work_function_6.cpp","line_count":5,"code":"void reset()\n  {\n    head_.reset();\n    tail_.reset();\n  }","mark":8.0}
{"file_name":"conditionally_enabled_mutex_function_2.cpp","line_count":8,"code":"void unlock()\n    {\n      if (locked_)\n      {\n        mutex_.unlock();\n        locked_ = false;\n      }\n    }","mark":8.0}
{"file_name":"conditionally_enabled_mutex_function_4.cpp","line_count":5,"code":"void unlock()\n  {\n    if (enabled_)\n      mutex_.unlock();\n  }","mark":8.0}
{"file_name":"confighttp_function_10.cpp","line_count":4,"code":"void\n  getPinPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"pin.html\", true);\n  }","mark":8.0}
{"file_name":"confighttp_function_12.cpp","line_count":4,"code":"void\n  getConfigPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"config.html\", true);\n  }","mark":8.0}
{"file_name":"confighttp_function_13.cpp","line_count":4,"code":"void\n  getPasswordPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"password.html\", true);\n  }","mark":8.0}
{"file_name":"confighttp_function_16.cpp","line_count":4,"code":"void\n  getTroubleshootingPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"troubleshooting.html\", true);\n  }","mark":8.0}
{"file_name":"confighttp_function_4.cpp","line_count":17,"code":"string getCookieValue(const std::string& cookieString, const std::string& key) {\n    std::string keyWithEqual = key + \"=\";\n    std::size_t startPos = cookieString.find(keyWithEqual);\n\n    if (startPos == std::string::npos) {\n      return \"\";\n    }\n\n    startPos += keyWithEqual.length();\n    std::size_t endPos = cookieString.find(\";\", startPos);\n\n    if (endPos == std::string::npos) {\n      return cookieString.substr(startPos);\n    }\n\n    return cookieString.substr(startPos, endPos - startPos);\n  }","mark":8.0}
{"file_name":"confighttp_function_9.cpp","line_count":4,"code":"void\n  getIndexPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"index.html\", true);\n  }","mark":8.0}
{"file_name":"Config_function_1.cpp","line_count":9,"code":"int64_t GetTicks()\n{\n    LARGE_INTEGER ticks;\n\n    if (!QueryPerformanceCounter(&ticks))\n        return 0;\n\n    return ticks.QuadPart;\n}","mark":8.0}
{"file_name":"Config_function_2.cpp","line_count":4,"code":"bool isInteger(const std::string& str, int& value) {\n    std::istringstream iss(str);\n    return (iss >> value) && iss.eof();\n}","mark":8.0}
{"file_name":"Config_function_3.cpp","line_count":4,"code":"bool isUInt(const std::string& str, uint32_t& value) {\n    std::istringstream iss(str);\n    return (iss >> value) && iss.eof();\n}","mark":8.0}
{"file_name":"Config_function_4.cpp","line_count":4,"code":"bool isFloat(const std::string& str, float& value) {\n    std::istringstream iss(str);\n    return (iss >> value) && iss.eof();\n}","mark":8.0}
{"file_name":"Config_function_5.cpp","line_count":7,"code":"string GetBoolValue(std::optional<bool> value)\n{\n    if (!value.has_value())\n        return \"auto\";\n\n    return value.value() ? \"true\" : \"false\";\n}","mark":8.0}
{"file_name":"Config_function_6.cpp","line_count":7,"code":"string GetIntValue(std::optional<int> value)\n{\n    if (!value.has_value())\n        return \"auto\";\n\n    return std::to_string(value.value());\n}","mark":8.0}
{"file_name":"Config_function_7.cpp","line_count":7,"code":"string GetFloatValue(std::optional<float> value)\n{\n    if (!value.has_value())\n        return \"auto\";\n\n    return std::to_string(value.value());\n}","mark":8.0}
{"file_name":"config_function_8_1.cpp","line_count":4,"code":"bool\n  endline(char ch) {\n    return ch == '\\r' || ch == '\\n';\n  }","mark":8.0}
{"file_name":"config_function_9_1.cpp","line_count":4,"code":"bool\n  space_tab(char ch) {\n    return ch == ' ' || ch == '\\t';\n  }","mark":8.0}
{"file_name":"connection_function_13.cpp","line_count":3,"code":"void async_shutdown(shutdown_handler handler) {\n        handler(lib::error_code());\n    }","mark":8.0}
{"file_name":"connection_function_14.cpp","line_count":3,"code":"void set_vector_write_handler(vector_write_handler h) {\n        m_vector_write_handler = h;\n    }","mark":8.0}
{"file_name":"connection_function_15.cpp","line_count":3,"code":"void set_shutdown_handler(shutdown_handler h) {\n        m_shutdown_handler = h;\n    }","mark":8.0}
{"file_name":"connection_function_23.cpp","line_count":3,"code":"void set_handle(connection_hdl hdl) {\n        m_connection_hdl = hdl;\n    }","mark":8.0}
{"file_name":"connection_function_27.cpp","line_count":20,"code":"size_t read_some_impl(char const * buf, size_t len) {\n        m_alog->write(log::alevel::devel,\"iostream_con read_some\");\n\n        if (!m_reading) {\n            m_elog->write(log::elevel::devel,\"write while not reading\");\n            return 0;\n        }\n\n        size_t bytes_to_copy = (std::min)(len,m_len-m_cursor);\n\n        std::copy(buf,buf+bytes_to_copy,m_buf+m_cursor);\n\n        m_cursor += bytes_to_copy;\n\n        if (m_cursor >= m_bytes_needed) {\n            complete_read(lib::error_code());\n        }\n\n        return bytes_to_copy;\n    }","mark":8.0}
{"file_name":"connection_function_28.cpp","line_count":8,"code":"void complete_read(lib::error_code const & ec) {\n        m_reading = false;\n\n        read_handler handler = m_read_handler;\n        m_read_handler = read_handler();\n\n        handler(ec,m_cursor);\n    }","mark":8.0}
{"file_name":"connection_function_35.cpp","line_count":4,"code":"void set_handle(connection_hdl hdl) {\n        m_connection_hdl = hdl;\n        socket_con_type::set_handle(hdl);\n    }","mark":8.0}
{"file_name":"connection_function_36.cpp","line_count":8,"code":"error_code interrupt(interrupt_handler handler) {\n        if (config::enable_multithreading) {\n            m_io_service->post(m_strand->wrap(handler));\n        } else {\n            m_io_service->post(handler);\n        }\n        return lib::error_code();\n    }","mark":8.0}
{"file_name":"connection_function_38.cpp","line_count":3,"code":"void handle_interrupt(interrupt_handler handler) {\n        handler();\n    }","mark":8.0}
{"file_name":"connection_function_43.cpp","line_count":5,"code":"void log_err(log::level l, const char * msg, const error_type & ec) {\n        std::stringstream s;\n        s << msg << \" error: \" << ec << \" (\" << ec.message() << \")\";\n        m_elog->write(l,s.str());\n    }","mark":8.0}
{"file_name":"connection_impl_function_12.cpp","line_count":8,"code":"else if (m_state == session::state::closed) {\n            \/\/ The connection was canceled while the response was being sent,\n            \/\/ usually by the handshake timer. This is basically expected\n            \/\/ (though hopefully rare) and there is nothing we can do so ignore.\n            m_alog->write(log::alevel::devel,\n                \"handle_write_http_response invoked after connection was closed\");\n            return;\n        }","mark":8.0}
{"file_name":"connection_impl_function_14.cpp","line_count":8,"code":"else if (m_state == session::state::closed) {\n            \/\/ The connection was canceled while the response was being sent,\n            \/\/ usually by the handshake timer. This is basically expected\n            \/\/ (though hopefully rare) and there is nothing we can do so ignore.\n            m_alog->write(log::alevel::devel,\n                \"handle_send_http_request invoked after connection was closed\");\n            return;\n        }","mark":8.0}
{"file_name":"connection_impl_function_15.cpp","line_count":8,"code":"else if (m_state == session::state::closed) {\n            \/\/ The connection was canceled while the response was being sent,\n            \/\/ usually by the handshake timer. This is basically expected\n            \/\/ (though hopefully rare) and there is nothing we can do so ignore.\n            m_alog->write(log::alevel::devel,\n                \"handle_read_http_response invoked after connection was closed\");\n            return;\n        }","mark":8.0}
{"file_name":"connection_impl_function_24.cpp","line_count":8,"code":"else if (op == frame::opcode::PONG) {\n        if (m_pong_handler) {\n            m_pong_handler(m_connection_hdl, msg->get_payload());\n        }\n        if (m_ping_timer) {\n            m_ping_timer->cancel();\n        }\n    }","mark":8.0}
{"file_name":"connection_impl_function_29.cpp","line_count":6,"code":"else if (m_remote_close_code == close::status::no_status) {\n        m_alog->write(log::alevel::devel,\n            \"acknowledging a no-status close with normal code\");\n        m_local_close_code = close::status::normal;\n        m_local_close_reason.clear();\n    }","mark":8.0}
{"file_name":"connection_impl_function_3.cpp","line_count":8,"code":"else if (m_state == session::state::closed) {\n            \/\/ The connection was canceled while the response was being sent,\n            \/\/ usually by the handshake timer. This is basically expected\n            \/\/ (though hopefully rare) and there is nothing we can do so ignore.\n            m_alog->write(log::alevel::devel,\n                \"handle_read_handshake invoked after connection was closed\");\n            return;\n        }","mark":8.0}
{"file_name":"connection_impl_function_5.cpp","line_count":7,"code":"else if (m_state == session::state::closing && !m_is_server) {\n                \/\/ If we are a client we expect to get eof in the closing state,\n                \/\/ this is a signal to terminate our end of the connection after\n                \/\/ the closing handshake\n                terminate(lib::error_code());\n                return;\n            }","mark":8.0}
{"file_name":"constants_function_3.cpp","line_count":3,"code":"bool is_whitespace_char(unsigned char c) {\n        return (c == 9 || c == 32);\n    }","mark":8.0}
{"file_name":"constants_function_4.cpp","line_count":3,"code":"bool is_not_whitespace_char(unsigned char c) {\n        return (c != 9 && c != 32);\n    }","mark":8.0}
{"file_name":"consuming_buffers_function_4.cpp","line_count":4,"code":"void consume(std::size_t size)\n  {\n    total_consumed_ += size;\n  }","mark":8.0}
{"file_name":"consuming_buffers_function_5.cpp","line_count":4,"code":"void consume(std::size_t size)\n  {\n    total_consumed_ += size;\n  }","mark":8.0}
{"file_name":"consuming_buffers_function_6.cpp","line_count":4,"code":"void consume(std::size_t size)\n  {\n    total_consumed_ += size;\n  }","mark":8.0}
{"file_name":"ContentType_function_1.cpp","line_count":9,"code":"eType GetFromString(const std::string& str) {\n\t\t\/\/OutputPrintf(\"Content type: %s\", str.c_str());\n\t\tif (str == \"image\/png\")  return PNG;\n\t\tif (str == \"image\/jpeg\") return JPEG;\n\t\tif (str == \"image\/gif\")  return GIF;\n\t\tif (str == \"image\/webp\") return WEBP;\n\n\t\treturn BLOB;\n\t}","mark":8.0}
{"file_name":"coro_function_13.cpp","line_count":4,"code":"void reset_error()\n  {\n    error_ = std::exception_ptr{};\n  }","mark":8.0}
{"file_name":"coro_function_34.cpp","line_count":4,"code":"void return_value(Return&& r)\n  {\n    result_ = std::move(r);\n  }","mark":8.0}
{"file_name":"coro_function_35.cpp","line_count":1,"code":"void return_void() {}","mark":8.0}
{"file_name":"coro_function_40.cpp","line_count":4,"code":"auto get_handle()\n  {\n    return coroutine_handle<coro_promise>::from_promise(*this);\n  }","mark":8.0}
{"file_name":"coro_function_5.cpp","line_count":4,"code":"error_code interrupted()\n  {\n    return asio::error::interrupted;\n  }","mark":8.0}
{"file_name":"CountTrailingOptionals_function_2.cpp","line_count":4,"code":"if constexpr (isOptional) {\n        \/\/ last item is an optional, finally return the final number incremented by one.\n        return N + 1;\n      }","mark":8.0}
{"file_name":"crypto_function_15.cpp","line_count":4,"code":"bool\n  verify256(const x509_t &x509, const std::string_view &data, const std::string_view &signature) {\n    return verify(x509, data, signature, EVP_sha256());\n  }","mark":8.0}
{"file_name":"CubemapSH_function_2.cpp","line_count":3,"code":"size_t SHindex(ssize_t m, size_t l) {\n        return l * (l + 1) + m;\n    }","mark":8.0}
{"file_name":"Cubemap_function_1.cpp","line_count":3,"code":"void writeAt(void* data, const Texel& texel) {\n        *static_cast<Texel*>(data) = texel;\n    }","mark":8.0}
{"file_name":"d3dx12_function_101.cpp","line_count":1,"code":"void SetStateObjectType(D3D12_STATE_OBJECT_TYPE Type) { m_Desc.Type = Type; }","mark":8.0}
{"file_name":"d3dx12_function_103.cpp","line_count":9,"code":"void Init(D3D12_STATE_OBJECT_TYPE Type)\n    {\n        SetStateObjectType(Type);\n        m_Desc.pSubobjects = nullptr;\n        m_Desc.NumSubobjects = 0;\n        m_SubobjectList.clear();\n        m_SubobjectArray.clear();\n        m_RepointedAssociations.clear();\n    }","mark":8.0}
{"file_name":"d3dx12_function_105.cpp","line_count":1,"code":"void clear() { m_Strings.clear(); }","mark":9.0}
{"file_name":"d3dx12_function_107.cpp","line_count":1,"code":"void Init() { m_pSubobject = nullptr; }","mark":8.0}
{"file_name":"d3dx12_function_108.cpp","line_count":5,"code":"void SetDXILLibrary(D3D12_SHADER_BYTECODE*pCode)\n    {\n        static const D3D12_SHADER_BYTECODE Default = {};\n        m_Desc.DXILLibrary = pCode ? *pCode : Default;\n    }","mark":8.0}
{"file_name":"d3dx12_function_110.cpp","line_count":7,"code":"void DefineExports(LPCWSTR* Exports, UINT N)\n    {\n        for (UINT i = 0; i < N; i++)\n        {\n            DefineExport(Exports[i]);\n        }\n    }","mark":8.0}
{"file_name":"d3dx12_function_111.cpp","line_count":7,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        m_Strings.clear();\n        m_Exports.clear();\n    }","mark":8.0}
{"file_name":"d3dx12_function_112.cpp","line_count":5,"code":"void SetExistingCollection(ID3D12StateObject*pExistingCollection)\n    {\n        m_Desc.pExistingCollection = pExistingCollection;\n        m_CollectionRef = pExistingCollection;\n    }","mark":8.0}
{"file_name":"d3dx12_function_114.cpp","line_count":7,"code":"void DefineExports(LPCWSTR* Exports, UINT N)\n    {\n        for (UINT i = 0; i < N; i++)\n        {\n            DefineExport(Exports[i]);\n        }\n    }","mark":8.0}
{"file_name":"d3dx12_function_115.cpp","line_count":8,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        m_CollectionRef = nullptr;\n        m_Strings.clear();\n        m_Exports.clear();\n    }","mark":8.0}
{"file_name":"d3dx12_function_118.cpp","line_count":7,"code":"void AddExports(LPCWSTR* Exports, UINT N)\n    {\n        for (UINT i = 0; i < N; i++)\n        {\n            AddExport(Exports[i]);\n        }\n    }","mark":8.0}
{"file_name":"d3dx12_function_119.cpp","line_count":7,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        m_Strings.clear();\n        m_Exports.clear();\n    }","mark":8.0}
{"file_name":"d3dx12_function_120.cpp","line_count":4,"code":"void SetSubobjectNameToAssociate(LPCWSTR SubobjectToAssociate)\n    {\n        m_Desc.SubobjectToAssociate = m_SubobjectName.LocalCopy(SubobjectToAssociate, true);\n    }","mark":8.0}
{"file_name":"d3dx12_function_122.cpp","line_count":7,"code":"void AddExports(LPCWSTR* Exports, UINT N)\n    {\n        for (UINT i = 0; i < N; i++)\n        {\n            AddExport(Exports[i]);\n        }\n    }","mark":8.0}
{"file_name":"d3dx12_function_123.cpp","line_count":8,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        m_Strings.clear();\n        m_SubobjectName.clear();\n        m_Exports.clear();\n    }","mark":8.0}
{"file_name":"d3dx12_function_124.cpp","line_count":4,"code":"void SetHitGroupExport(LPCWSTR exportName)\n    {\n        m_Desc.HitGroupExport = m_Strings[0].LocalCopy(exportName, true);\n    }","mark":8.0}
{"file_name":"d3dx12_function_125.cpp","line_count":1,"code":"void SetHitGroupType(D3D12_HIT_GROUP_TYPE Type) { m_Desc.Type = Type; }","mark":8.0}
{"file_name":"d3dx12_function_127.cpp","line_count":4,"code":"void SetClosestHitShaderImport(LPCWSTR importName)\n    {\n        m_Desc.ClosestHitShaderImport = m_Strings[2].LocalCopy(importName, true);\n    }","mark":8.0}
{"file_name":"d3dx12_function_129.cpp","line_count":9,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        for (UINT i = 0; i < m_NumStrings; i++)\n        {\n            m_Strings[i].clear();\n        }\n    }","mark":8.0}
{"file_name":"d3dx12_function_130.cpp","line_count":5,"code":"void Config(UINT MaxPayloadSizeInBytes, UINT MaxAttributeSizeInBytes)\n    {\n        m_Desc.MaxPayloadSizeInBytes = MaxPayloadSizeInBytes;\n        m_Desc.MaxAttributeSizeInBytes = MaxAttributeSizeInBytes;\n    }","mark":8.0}
{"file_name":"d3dx12_function_131.cpp","line_count":5,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n    }","mark":8.0}
{"file_name":"d3dx12_function_132.cpp","line_count":4,"code":"void Config(UINT MaxTraceRecursionDepth)\n    {\n        m_Desc.MaxTraceRecursionDepth = MaxTraceRecursionDepth;\n    }","mark":8.0}
{"file_name":"d3dx12_function_133.cpp","line_count":5,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n    }","mark":8.0}
{"file_name":"d3dx12_function_134.cpp","line_count":4,"code":"void SetRootSignature(ID3D12RootSignature* pRootSig)\n    {\n        m_pRootSig = pRootSig;\n    }","mark":8.0}
{"file_name":"d3dx12_function_135.cpp","line_count":5,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_pRootSig = nullptr;\n    }","mark":8.0}
{"file_name":"d3dx12_function_136.cpp","line_count":4,"code":"void SetRootSignature(ID3D12RootSignature* pRootSig)\n    {\n        m_pRootSig = pRootSig;\n    }","mark":8.0}
{"file_name":"d3dx12_function_137.cpp","line_count":5,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_pRootSig = nullptr;\n    }","mark":8.0}
{"file_name":"d3dx12_function_138.cpp","line_count":4,"code":"void SetFlags(D3D12_STATE_OBJECT_FLAGS Flags)\n    {\n        m_Desc.Flags = Flags;\n    }","mark":8.0}
{"file_name":"d3dx12_function_139.cpp","line_count":5,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n    }","mark":8.0}
{"file_name":"d3dx12_function_140.cpp","line_count":4,"code":"void SetNodeMask(UINT NodeMask)\n    {\n        m_Desc.NodeMask = NodeMask;\n    }","mark":8.0}
{"file_name":"d3dx12_function_141.cpp","line_count":5,"code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n    }","mark":8.0}
{"file_name":"d3dx12_function_25.cpp","line_count":5,"code":"void Init(_Out_ D3D12_ROOT_DESCRIPTOR &table, UINT shaderRegister, UINT registerSpace = 0)\n    {\n        table.ShaderRegister = shaderRegister;\n        table.RegisterSpace = registerSpace;\n    }","mark":8.0}
{"file_name":"d3dx12_function_53.cpp","line_count":4,"code":"void InitOffsetted(_Out_ D3D12_CPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_CPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize)\n    {\n        handle.ptr = static_cast<SIZE_T>(base.ptr + INT64(offsetInDescriptors) * UINT64(descriptorIncrementSize));\n    }","mark":8.0}
{"file_name":"d3dx12_function_57.cpp","line_count":4,"code":"void InitOffsetted(_Out_ D3D12_GPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_GPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize)\n    {\n        handle.ptr = static_cast<UINT64>(base.ptr + INT64(offsetInDescriptors) * UINT64(descriptorIncrementSize));\n    }","mark":8.0}
{"file_name":"d3dx12_function_58.cpp","line_count":4,"code":"UINT D3D12CalcSubresource( UINT MipSlice, UINT ArraySlice, UINT PlaneSlice, UINT MipLevels, UINT ArraySize )\n{\n    return MipSlice + ArraySlice * MipLevels + PlaneSlice * MipLevels * ArraySize;\n}","mark":8.0}
{"file_name":"d3dx12_function_59.cpp","line_count":6,"code":"void D3D12DecomposeSubresource( UINT Subresource, UINT MipLevels, UINT ArraySize, _Out_ T& MipSlice, _Out_ U& ArraySlice, _Out_ V& PlaneSlice )\n{\n    MipSlice = static_cast<T>(Subresource % MipLevels);\n    ArraySlice = static_cast<U>((Subresource \/ MipLevels) % ArraySize);\n    PlaneSlice = static_cast<V>(Subresource \/ (MipLevels * ArraySize));\n}","mark":8.0}
{"file_name":"d3dx12_function_70.cpp","line_count":2,"code":"bool D3D12IsLayoutOpaque( D3D12_TEXTURE_LAYOUT Layout )\n{ return Layout == D3D12_TEXTURE_LAYOUT_UNKNOWN || Layout == D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE; }","mark":8.0}
{"file_name":"deadline_timer_service_function_2.cpp","line_count":5,"code":"void construct(implementation_type& impl)\n  {\n    impl.expiry = time_type();\n    impl.might_have_pending_waits = false;\n  }","mark":8.0}
{"file_name":"decode_function_1.cpp","line_count":4,"code":"int WebPIsPremultipliedMode(WEBP_CSP_MODE mode) {\n  return (mode == MODE_rgbA || mode == MODE_bgrA || mode == MODE_Argb ||\n          mode == MODE_rgbA_4444);\n}","mark":8.0}
{"file_name":"decode_function_2.cpp","line_count":5,"code":"int WebPIsAlphaMode(WEBP_CSP_MODE mode) {\n  return (mode == MODE_RGBA || mode == MODE_BGRA || mode == MODE_ARGB ||\n          mode == MODE_RGBA_4444 || mode == MODE_YUVA ||\n          WebPIsPremultipliedMode(mode));\n}","mark":8.0}
{"file_name":"decode_function_4.cpp","line_count":3,"code":"int WebPInitDecBuffer(WebPDecBuffer* buffer) {\n  return WebPInitDecBufferInternal(buffer, WEBP_DECODER_ABI_VERSION);\n}","mark":8.0}
{"file_name":"decode_function_6.cpp","line_count":3,"code":"int WebPInitDecoderConfig(WebPDecoderConfig* config) {\n  return WebPInitDecoderConfigInternal(config, WEBP_DECODER_ABI_VERSION);\n}","mark":8.0}
{"file_name":"Deferred_function_1_1.cpp","line_count":1,"code":"void disarm() { armed = false; }","mark":8.0}
{"file_name":"DiscordInstance_function_2.cpp","line_count":3,"code":"void SetToken(const std::string& token){\n\t\tm_token = token;\n\t}","mark":8.0}
{"file_name":"DiscordInstance_function_5.cpp","line_count":4,"code":"void OnJsonException(Json::exception & ex)\n{\n\tGetFrontend()->OnJsonException(ex.what());\n}","mark":8.0}
{"file_name":"display_base_function_4.cpp","line_count":20,"code":"else if (status == platf::capture_e::timeout) {\n          \/\/ The D3D11 device is protected by an unfair lock that is held the entire time that\n          \/\/ IDXGIOutputDuplication::AcquireNextFrame() is running. This is normally harmless,\n          \/\/ however sometimes the encoding thread needs to interact with our ID3D11Device to\n          \/\/ create dummy images or initialize the shared state that is used to pass textures\n          \/\/ between the capture and encoding ID3D11Devices.\n          \/\/\n          \/\/ When we're in a state where we're not actively receiving frames regularly, we will\n          \/\/ spend almost 100% of our time in AcquireNextFrame() holding that critical lock.\n          \/\/ Worse still, since it's unfair, we can monopolize it while the encoding thread\n          \/\/ is starved. The encoding thread may acquire it for a few moments across a few\n          \/\/ ID3D11Device calls before losing it again to us for another long time waiting in\n          \/\/ AcquireNextFrame(). The starvation caused by this lock contention causes encoder\n          \/\/ reinitialization to take several seconds instead of a fraction of a second.\n          \/\/\n          \/\/ To avoid starving the encoding thread, sleep without the lock held for a little\n          \/\/ while each time we reach our max frame timeout. This will only happen when nothing\n          \/\/ is updating the display, so no visible stutter should be introduced by the sleep.\n          std::this_thread::sleep_for(10ms);\n        }","mark":8.0}
{"file_name":"display_vram_function_16.cpp","line_count":8,"code":"void\n      reset() {\n        capture_texture_p = nullptr;\n        encoder_texture.reset();\n        encoder_input_res.reset();\n        encoder_mutex.reset();\n        img_weak.reset();\n      }","mark":8.0}
{"file_name":"display_vram_function_8.cpp","line_count":4,"code":"blob_t\n  compile_pixel_shader(LPCSTR file) {\n    return compile_shader(file, \"main_ps\", \"ps_5_0\");\n  }","mark":8.0}
{"file_name":"dllmain_function_2_1.cpp","line_count":6,"code":"void truncate_log_file() {\n        if (std::filesystem::exists(_filename)) {\n            std::ofstream ofs(_filename, std::ofstream::out | std::ofstream::trunc);\n            ofs.close();\n        }\n    }","mark":8.0}
{"file_name":"dllmain_function_45.cpp","line_count":3,"code":"else if (!FrameGenMotionBlurLockoutScanResult || !FrameGenMotionBlurLogicScanResult) {\n            spdlog::error(\"Frame Generation Motion Blur: Pattern scan failed.\");\n        }","mark":8.0}
{"file_name":"dllmain_function_62.cpp","line_count":17,"code":"DWORD GetMainThreadId (void)\n{\n    THREADENTRY32 te32 { .dwSize = sizeof (THREADENTRY32) };\n\n    const DWORD dwProcId   = GetCurrentProcessId ();\n    HANDLE hThreadSnapshot = CreateToolhelp32Snapshot (TH32CS_SNAPTHREAD, 0);\n\n    if (Thread32First (hThreadSnapshot, &te32)) {\n        do {\n            if (te32.th32OwnerProcessID == dwProcId) {\n                return te32.th32ThreadID;\n            }\n        } while (Thread32Next (hThreadSnapshot, &te32));\n    }\n\n    return 0;\n}","mark":8.0}
{"file_name":"DriverEnums_function_1.cpp","line_count":20,"code":"bool isUnsignedIntFormat(TextureFormat format) {\n    switch (format) {\n        case TextureFormat::R8UI:\n        case TextureFormat::R16UI:\n        case TextureFormat::R32UI:\n        case TextureFormat::RG8UI:\n        case TextureFormat::RG16UI:\n        case TextureFormat::RG32UI:\n        case TextureFormat::RGB8UI:\n        case TextureFormat::RGB16UI:\n        case TextureFormat::RGB32UI:\n        case TextureFormat::RGBA8UI:\n        case TextureFormat::RGBA16UI:\n        case TextureFormat::RGBA32UI:\n            return true;\n\n        default:\n            return false;\n    }\n}","mark":8.0}
{"file_name":"DriverEnums_function_2.cpp","line_count":20,"code":"bool isSignedIntFormat(TextureFormat format) {\n    switch (format) {\n        case TextureFormat::R8I:\n        case TextureFormat::R16I:\n        case TextureFormat::R32I:\n        case TextureFormat::RG8I:\n        case TextureFormat::RG16I:\n        case TextureFormat::RG32I:\n        case TextureFormat::RGB8I:\n        case TextureFormat::RGB16I:\n        case TextureFormat::RGB32I:\n        case TextureFormat::RGBA8I:\n        case TextureFormat::RGBA16I:\n        case TextureFormat::RGBA32I:\n            return true;\n\n        default:\n            return false;\n    }\n}","mark":8.0}
{"file_name":"Dxgi_function_15.cpp","line_count":5,"code":"void _DXGIDeclareAdapterRemovalSupport()\n{\n    LOG_FUNC();\n    dxgi.DeclareAdapterRemovalSupport();\n}","mark":8.0}
{"file_name":"Dxgi_function_17.cpp","line_count":5,"code":"void _ApplyCompatResolutionQuirking()\n{\n    LOG_FUNC();\n    dxgi.ApplyCompatResolutionQuirking();\n}","mark":8.0}
{"file_name":"Dxgi_function_25.cpp","line_count":5,"code":"void _DXGIDumpJournal()\n{\n    LOG_FUNC();\n    dxgi.DumpJournal();\n}","mark":8.0}
{"file_name":"Dxgi_function_27.cpp","line_count":5,"code":"void _PIXBeginCapture()\n{\n    LOG_FUNC();\n    dxgi.PIXBeginCapture();\n}","mark":8.0}
{"file_name":"Dxgi_function_28.cpp","line_count":5,"code":"void _PIXEndCapture()\n{\n    LOG_FUNC();\n    dxgi.PIXEndCapture();\n}","mark":8.0}
{"file_name":"Dxgi_function_29.cpp","line_count":5,"code":"void _PIXGetCaptureState()\n{\n    LOG_FUNC();\n    dxgi.PIXGetCaptureState();\n}","mark":8.0}
{"file_name":"Dxgi_function_30.cpp","line_count":5,"code":"void _SetAppCompatStringPointer()\n{\n    LOG_FUNC();\n    dxgi.SetAppCompatStringPointer();\n}","mark":8.0}
{"file_name":"Dxgi_function_31.cpp","line_count":5,"code":"void _UpdateHMDEmulationStatus()\n{\n    LOG_FUNC();\n    dxgi.UpdateHMDEmulationStatus();\n}","mark":8.0}
{"file_name":"egl_function_16.cpp","line_count":9,"code":"void glad_close_dlopen_handle(void* handle) {\n    if (handle != NULL) {\n#if GLAD_PLATFORM_WIN32\n        FreeLibrary((HMODULE) handle);\n#else\n        dlclose(handle);\n#endif\n    }\n}","mark":8.0}
{"file_name":"egl_function_17.cpp","line_count":11,"code":"GLADapiproc glad_dlsym_handle(void* handle, const char *name) {\n    if (handle == NULL) {\n        return NULL;\n    }\n\n#if GLAD_PLATFORM_WIN32\n    return (GLADapiproc) GetProcAddress((HMODULE) handle, name);\n#else\n    return GLAD_GNUC_EXTENSION (GLADapiproc) dlsym(handle, name);\n#endif\n}","mark":8.0}
{"file_name":"egl_function_22.cpp","line_count":6,"code":"void gladLoaderUnloadEGL() {\n    if (_egl_handle != NULL) {\n        glad_close_dlopen_handle(_egl_handle);\n        _egl_handle = NULL;\n    }\n}","mark":8.0}
{"file_name":"enabled_function_1.cpp","line_count":3,"code":"error_code make_error_code(error::value e) {\n    return lib::error_code(static_cast<int>(e), get_category());\n}","mark":8.0}
{"file_name":"enabled_function_16.cpp","line_count":25,"code":"string generate_response() {\n        std::string ret = \"permessage-deflate\";\n\n        if (m_server_no_context_takeover) {\n            ret += \"; server_no_context_takeover\";\n        }\n\n        if (m_client_no_context_takeover) {\n            ret += \"; client_no_context_takeover\";\n        }\n\n        if (m_server_max_window_bits < default_server_max_window_bits) {\n            std::stringstream s;\n            s << int(m_server_max_window_bits);\n            ret += \"; server_max_window_bits=\"+s.str();\n        }\n\n        if (m_client_max_window_bits < default_client_max_window_bits) {\n            std::stringstream s;\n            s << int(m_client_max_window_bits);\n            ret += \"; client_max_window_bits=\"+s.str();\n        }\n\n        return ret;\n    }","mark":8.0}
{"file_name":"enabled_function_3.cpp","line_count":3,"code":"void enable_server_no_context_takeover() {\n        m_server_no_context_takeover = true;\n    }","mark":8.0}
{"file_name":"enabled_function_4.cpp","line_count":3,"code":"void enable_client_no_context_takeover() {\n        m_client_no_context_takeover = true;\n    }","mark":8.0}
{"file_name":"encode_function_1.cpp","line_count":4,"code":"int WebPConfigInit(WebPConfig* config) {\n  return WebPConfigInitInternal(config, WEBP_PRESET_DEFAULT, 75.f,\n                                WEBP_ENCODER_ABI_VERSION);\n}","mark":8.0}
{"file_name":"encode_function_3.cpp","line_count":3,"code":"int WebPPictureInit(WebPPicture* picture) {\n  return WebPPictureInitInternal(picture, WEBP_ENCODER_ABI_VERSION);\n}","mark":8.0}
{"file_name":"endpoint_function_10.cpp","line_count":3,"code":"void set_tcp_pre_init_handler(tcp_init_handler h) {\n        m_tcp_pre_init_handler = h;\n    }","mark":8.0}
{"file_name":"endpoint_function_11.cpp","line_count":3,"code":"void set_tcp_init_handler(tcp_init_handler h) {\n        set_tcp_pre_init_handler(h);\n    }","mark":8.0}
{"file_name":"endpoint_function_13.cpp","line_count":3,"code":"void set_listen_backlog(int backlog) {\n        m_listen_backlog = backlog;\n    }","mark":8.0}
{"file_name":"endpoint_function_14.cpp","line_count":3,"code":"void set_reuse_addr(bool value) {\n        m_reuse_addr = value;\n    }","mark":8.0}
{"file_name":"endpoint_function_15.cpp","line_count":8,"code":"endpoint get_local_endpoint(lib::asio::error_code & ec) {\n        if (m_acceptor) {\n            return m_acceptor->local_endpoint(ec);\n        } else {\n            ec = lib::asio::error::make_error_code(lib::asio::error::bad_descriptor);\n            return lib::asio::ip::tcp::endpoint();\n        }\n    }","mark":8.0}
{"file_name":"endpoint_function_20.cpp","line_count":5,"code":"void listen(InternetProtocol const & internet_protocol, uint16_t port)\n    {\n        lib::asio::ip::tcp::endpoint ep(internet_protocol, port);\n        listen(ep);\n    }","mark":8.0}
{"file_name":"endpoint_function_25.cpp","line_count":13,"code":"void stop_listening(lib::error_code & ec) {\n        if (m_state != LISTENING) {\n            m_elog->write(log::elevel::library,\n                \"asio::listen called from the wrong state\");\n            using websocketpp::error::make_error_code;\n            ec = make_error_code(websocketpp::error::invalid_state);\n            return;\n        }\n\n        m_acceptor->close();\n        m_state = READY;\n        ec = lib::error_code();\n    }","mark":8.0}
{"file_name":"endpoint_function_27.cpp","line_count":3,"code":"size_t run() {\n        return m_io_service->run();\n    }","mark":8.0}
{"file_name":"endpoint_function_28.cpp","line_count":3,"code":"size_t run_one() {\n        return m_io_service->run_one();\n    }","mark":8.0}
{"file_name":"endpoint_function_29.cpp","line_count":3,"code":"void stop() {\n        m_io_service->stop();\n    }","mark":8.0}
{"file_name":"endpoint_function_30.cpp","line_count":3,"code":"size_t poll() {\n        return m_io_service->poll();\n    }","mark":8.0}
{"file_name":"endpoint_function_31.cpp","line_count":3,"code":"size_t poll_one() {\n        return m_io_service->poll_one();\n    }","mark":8.0}
{"file_name":"endpoint_function_32.cpp","line_count":3,"code":"void reset() {\n        m_io_service->reset();\n    }","mark":8.0}
{"file_name":"endpoint_function_34.cpp","line_count":3,"code":"void stop_perpetual() {\n        m_work.reset();\n    }","mark":8.0}
{"file_name":"endpoint_function_49.cpp","line_count":5,"code":"void log_err(log::level l, char const * msg, error_type const & ec) {\n        std::stringstream s;\n        s << msg << \" error: \" << ec << \" (\" << ec.message() << \")\";\n        m_elog->write(l,s.str());\n    }","mark":8.0}
{"file_name":"endpoint_function_50.cpp","line_count":7,"code":"error_code clean_up_listen_after_error(error_type const & ec) {\n        if (m_acceptor->is_open()) {\n            m_acceptor->close();\n        }\n        log_err(log::elevel::info,\"asio listen\",ec);\n        return socket_con_type::translate_ec(ec);\n    }","mark":8.0}
{"file_name":"endpoint_function_9.cpp","line_count":3,"code":"void set_tcp_pre_bind_handler(tcp_pre_bind_handler h) {\n        m_tcp_pre_bind_handler = h;\n    }","mark":8.0}
{"file_name":"entry_handler_function_8.cpp","line_count":8,"code":"void\n  debug_trap() {\n#ifdef _WIN32\n    DebugBreak();\n#else\n    std::raise(SIGTRAP);\n#endif\n  }","mark":8.0}
{"file_name":"entry_handler_function_9.cpp","line_count":6,"code":"void\nlog_publisher_data() {\n  BOOST_LOG(info) << \"Package Publisher: \"sv << SUNSHINE_PUBLISHER_NAME;\n  BOOST_LOG(info) << \"Publisher Website: \"sv << SUNSHINE_PUBLISHER_WEBSITE;\n  BOOST_LOG(info) << \"Get support: \"sv << SUNSHINE_PUBLISHER_ISSUE_URL;\n}","mark":8.0}
{"file_name":"epoll_reactor_function_1.cpp","line_count":1,"code":"void set_ready_events(uint32_t events) { task_result_ = events; }","mark":8.0}
{"file_name":"epoll_reactor_function_2.cpp","line_count":1,"code":"void add_ready_events(uint32_t events) { task_result_ |= events; }","mark":8.0}
{"file_name":"error_function_4.cpp","line_count":5,"code":"error_code make_error_code(addrinfo_errors e)\n{\n  return asio::error_code(\n      static_cast<int>(e), get_addrinfo_category());\n}","mark":8.0}
{"file_name":"error_function_5.cpp","line_count":5,"code":"error_code make_error_code(misc_errors e)\n{\n  return asio::error_code(\n      static_cast<int>(e), get_misc_category());\n}","mark":8.0}
{"file_name":"Event_function_3.cpp","line_count":16,"code":"bool addListener(Func&& func, int* idx = nullptr)\n    {\n        if (numListeners + 1 > MaxListeners)\n        {\n            return false;\n        }\n        else\n        {\n            if (idx)\n            {\n                *idx = numListeners;\n            }\n            listeners[numListeners++] = move(func);\n            return true;\n        }\n    }","mark":8.0}
{"file_name":"Event_function_4.cpp","line_count":11,"code":"bool removeListener(Func& func)\n    {\n        for (int idx = 0; idx < numListeners; ++idx)\n        {\n            if (listeners[idx] == func)\n            {\n                return removeListenerAt(idx);\n            }\n        }\n        return false;\n    }","mark":8.0}
{"file_name":"extension_function_1.cpp","line_count":3,"code":"error_code make_error_code(error::value e) {\n    return lib::error_code(static_cast<int>(e), get_category());\n}","mark":8.0}
{"file_name":"FfxApi_Proxy_function_18.cpp","line_count":14,"code":"string ReturnCodeToString(ffxReturnCode_t result)\n    {\n        switch (result)\n        {\n            case FFX_API_RETURN_OK: return \"The oparation was successful.\";\n            case FFX_API_RETURN_ERROR: return \"An error occurred that is not further specified.\";\n            case FFX_API_RETURN_ERROR_UNKNOWN_DESCTYPE: return \"The structure type given was not recognized for the function or context with which it was used. This is likely a programming error.\";\n            case FFX_API_RETURN_ERROR_RUNTIME_ERROR: return \"The underlying runtime (e.g. D3D12, Vulkan) or effect returned an error code.\";\n            case FFX_API_RETURN_NO_PROVIDER: return \"No provider was found for the given structure type. This is likely a programming error.\";\n            case FFX_API_RETURN_ERROR_MEMORY: return \"A memory allocation failed.\";\n            case FFX_API_RETURN_ERROR_PARAMETER: return \"A parameter was invalid, e.g. a null pointer, empty resource or out-of-bounds enum value.\";\n            default: return \"Unknown\";\n        }\n    }","mark":8.0}
{"file_name":"ffx_a_function_14.cpp","line_count":1,"code":"AD1 AAbsD1(AD1 a){return __builtin_fabs(a);}","mark":8.0}
{"file_name":"ffx_a_function_475.cpp","line_count":1,"code":"AH2 ALerpH2(AH2 x,AH2 y,AH2 a){return lerp(x,y,a);}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_17.cpp","line_count":5,"code":"FfxFloat32 MinDividedByMax(const FfxFloat32 v0, const FfxFloat32 v1)\n{\n    const FfxFloat32 m = ffxMax(v0, v1);\n    return m != 0 ? ffxMin(v0, v1) \/ m : 0;\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_19.cpp","line_count":13,"code":"FfxFloat32x3 YCoCgToRGB(FfxFloat32x3 fYCoCg)\n{\n    FfxFloat32x3 fRgb;\n\n    fYCoCg.yz -= FfxFloat32x2(0.5f, 0.5f);  \/\/ [0,1] -> [-0.5,0.5]\n\n    fRgb = FfxFloat32x3(\n        fYCoCg.x + fYCoCg.y - fYCoCg.z,\n        fYCoCg.x + fYCoCg.z,\n        fYCoCg.x - fYCoCg.y - fYCoCg.z);\n\n    return fRgb;\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_23.cpp","line_count":4,"code":"FfxFloat32 RGBToLuma(FfxFloat32x3 fLinearRgb)\n{\n    return dot(fLinearRgb, FfxFloat32x3(0.2126f, 0.7152f, 0.0722f));\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_24.cpp","line_count":4,"code":"FFX_MIN16_F RGBToLuma(FFX_MIN16_F3 fLinearRgb)\n{\n    return dot(fLinearRgb, FFX_MIN16_F3(0.2126f, 0.7152f, 0.0722f));\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_31.cpp","line_count":4,"code":"FfxInt32x2 ClampLoad(FfxInt32x2 iPxSample, FfxInt32x2 iPxOffset, FfxInt32x2 iTextureSize)\n{\n    return clamp(iPxSample + iPxOffset, FfxInt32x2(0, 0), iTextureSize - FfxInt32x2(1, 1));\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_32.cpp","line_count":4,"code":"FFX_MIN16_I2 ClampLoad(FFX_MIN16_I2 iPxSample, FFX_MIN16_I2 iPxOffset, FFX_MIN16_I2 iTextureSize)\n{\n    return clamp(iPxSample + iPxOffset, FFX_MIN16_I2(0, 0), iTextureSize - FFX_MIN16_I2(1, 1));\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_33.cpp","line_count":4,"code":"FfxBoolean IsOnScreen(FfxInt32x2 pos, FfxInt32x2 size)\n{\n    return all(FFX_GREATER_THAN_EQUAL(pos, FfxInt32x2(0, 0))) && all(FFX_LESS_THAN(pos, size));\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_40.cpp","line_count":4,"code":"FfxFloat32 GetViewSpaceDepthInMeters(FfxFloat32 fDeviceDepth)\n{\n    return GetViewSpaceDepth(fDeviceDepth) * ViewSpaceToMetersFactor();\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_41.cpp","line_count":12,"code":"FfxFloat32x3 GetViewSpacePosition(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth)\n{\n    const FfxFloat32x4 fDeviceToViewDepth = DeviceToViewSpaceTransformFactors();\n\n    const FfxFloat32 Z = GetViewSpaceDepth(fDeviceDepth);\n\n    const FfxFloat32x2 fNdcPos = ComputeNdc(iViewportPos, iViewportSize);\n    const FfxFloat32 X = fDeviceToViewDepth[2] * fNdcPos.x * Z;\n    const FfxFloat32 Y = fDeviceToViewDepth[3] * fNdcPos.y * Z;\n\n    return FfxFloat32x3(X, Y, Z);\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_42.cpp","line_count":4,"code":"FfxFloat32x3 GetViewSpacePositionInMeters(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth)\n{\n    return GetViewSpacePosition(iViewportPos, iViewportSize, fDeviceDepth) * ViewSpaceToMetersFactor();\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_44.cpp","line_count":9,"code":"FfxFloat32x3 PrepareRgb(FfxFloat32x3 fRgb, FfxFloat32 fExposure, FfxFloat32 fPreExposure)\n{\n    fRgb \/= fPreExposure;\n    fRgb *= fExposure;\n\n    fRgb = clamp(fRgb, 0.0f, FSR2_FP16_MAX);\n\n    return fRgb;\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_46.cpp","line_count":20,"code":"BilinearSamplingData GetBilinearSamplingData(FfxFloat32x2 fUv, FfxInt32x2 iSize)\n{\n    BilinearSamplingData data;\n\n    FfxFloat32x2 fPxSample = (fUv * iSize) - FfxFloat32x2(0.5f, 0.5f);\n    data.iBasePos = FfxInt32x2(floor(fPxSample));\n    FfxFloat32x2 fPxFrac = ffxFract(fPxSample);\n\n    data.iOffsets[0] = FfxInt32x2(0, 0);\n    data.iOffsets[1] = FfxInt32x2(1, 0);\n    data.iOffsets[2] = FfxInt32x2(0, 1);\n    data.iOffsets[3] = FfxInt32x2(1, 1);\n\n    data.fWeights[0] = (1 - fPxFrac.x) * (1 - fPxFrac.y);\n    data.fWeights[1] = (fPxFrac.x) * (1 - fPxFrac.y);\n    data.fWeights[2] = (1 - fPxFrac.x) * (fPxFrac.y);\n    data.fWeights[3] = (fPxFrac.x) * (fPxFrac.y);\n\n    return data;\n}","mark":8.0}
{"file_name":"ffx_fsr2_common_function_47.cpp","line_count":11,"code":"PlaneData GetPlaneFromPoints(FfxFloat32x3 fP0, FfxFloat32x3 fP1, FfxFloat32x3 fP2)\n{\n    PlaneData plane;\n\n    FfxFloat32x3 v0 = fP0 - fP1;\n    FfxFloat32x3 v1 = fP0 - fP2;\n    plane.fNormal = normalize(cross(v0, v1));\n    plane.fDistanceFromOrigin = -dot(fP0, plane.fNormal);\n\n    return plane;\n}","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_15.cpp","line_count":5,"code":"FfxFloat32 MinDividedByMax(const FfxFloat32 v0, const FfxFloat32 v1)\n    {\n        const FfxFloat32 m = ffxMax(v0, v1);\n        return m != 0 ? ffxMin(v0, v1) \/ m : 0;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_17.cpp","line_count":11,"code":"FfxFloat32x3 YCoCgToRGB(FfxFloat32x3 fYCoCg)\n    {\n        FfxFloat32x3 fRgb;\n\n        fRgb = FfxFloat32x3(\n            fYCoCg.x + fYCoCg.y - fYCoCg.z,\n            fYCoCg.x + fYCoCg.z,\n            fYCoCg.x - fYCoCg.y - fYCoCg.z);\n\n        return fRgb;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_18.cpp","line_count":11,"code":"FFX_MIN16_F3 YCoCgToRGB(FFX_MIN16_F3 fYCoCg)\n    {\n        FFX_MIN16_F3 fRgb;\n\n        fRgb = FFX_MIN16_F3(\n            fYCoCg.x + fYCoCg.y - fYCoCg.z,\n            fYCoCg.x + fYCoCg.z,\n            fYCoCg.x - fYCoCg.y - fYCoCg.z);\n\n        return fRgb;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_19.cpp","line_count":11,"code":"FfxFloat32x3 RGBToYCoCg(FfxFloat32x3 fRgb)\n    {\n        FfxFloat32x3 fYCoCg;\n\n        fYCoCg = FfxFloat32x3(\n            0.25f * fRgb.r + 0.5f * fRgb.g + 0.25f * fRgb.b,\n            0.5f * fRgb.r - 0.5f * fRgb.b,\n            -0.25f * fRgb.r + 0.5f * fRgb.g - 0.25f * fRgb.b);\n\n        return fYCoCg;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_20.cpp","line_count":11,"code":"FFX_MIN16_F3 RGBToYCoCg(FFX_MIN16_F3 fRgb)\n    {\n        FFX_MIN16_F3 fYCoCg;\n\n        fYCoCg = FFX_MIN16_F3(\n            0.25 * fRgb.r + 0.5 * fRgb.g + 0.25 * fRgb.b,\n            0.5 * fRgb.r - 0.5 * fRgb.b,\n            -0.25 * fRgb.r + 0.5 * fRgb.g - 0.25 * fRgb.b);\n\n        return fYCoCg;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_21.cpp","line_count":4,"code":"FfxFloat32 RGBToLuma(FfxFloat32x3 fLinearRgb)\n    {\n        return dot(fLinearRgb, FfxFloat32x3(0.2126f, 0.7152f, 0.0722f));\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_22.cpp","line_count":4,"code":"FFX_MIN16_F RGBToLuma(FFX_MIN16_F3 fLinearRgb)\n    {\n        return dot(fLinearRgb, FFX_MIN16_F3(0.2126f, 0.7152f, 0.0722f));\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_23.cpp","line_count":14,"code":"FfxFloat32 RGBToPerceivedLuma(FfxFloat32x3 fLinearRgb)\n    {\n        FfxFloat32 fLuminance = RGBToLuma(fLinearRgb);\n\n        FfxFloat32 fPercievedLuminance = 0;\n        if (fLuminance <= 216.0f \/ 24389.0f) {\n            fPercievedLuminance = fLuminance * (24389.0f \/ 27.0f);\n        }\n        else {\n            fPercievedLuminance = ffxPow(fLuminance, 1.0f \/ 3.0f) * 116.0f - 16.0f;\n        }\n\n        return fPercievedLuminance * 0.01f;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_31.cpp","line_count":8,"code":"FfxFloat32x2 ClampUv(FfxFloat32x2 fUv, FfxInt32x2 iTextureSize, FfxInt32x2 iResourceSize)\n    {\n        const FfxFloat32x2 fSampleLocation = fUv * iTextureSize;\n        const FfxFloat32x2 fClampedLocation = ffxMax(FfxFloat32x2(0.5f, 0.5f), ffxMin(fSampleLocation, FfxFloat32x2(iTextureSize) - FfxFloat32x2(0.5f, 0.5f)));\n        const FfxFloat32x2 fClampedUv = fClampedLocation \/ FfxFloat32x2(iResourceSize);\n\n        return fClampedUv;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_36.cpp","line_count":7,"code":"FfxInt32x2 ComputeHrPosFromLrPos(FfxInt32x2 iPxLrPos)\n    {\n        FfxFloat32x2 fSrcJitteredPos = FfxFloat32x2(iPxLrPos) + 0.5f - Jitter();\n        FfxFloat32x2 fLrPosInHr = (fSrcJitteredPos \/ RenderSize()) * DisplaySize();\n        FfxInt32x2 iPxHrPos = FfxInt32x2(floor(fLrPosInHr));\n        return iPxHrPos;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_38.cpp","line_count":4,"code":"FfxFloat32x2 ComputeNdc(FfxFloat32x2 fPxPos, FfxInt32x2 iSize)\n    {\n        return fPxPos \/ FfxFloat32x2(iSize) * FfxFloat32x2(2.0f, -2.0f) + FfxFloat32x2(-1.0f, 1.0f);\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_40.cpp","line_count":4,"code":"FfxFloat32 GetViewSpaceDepthInMeters(FfxFloat32 fDeviceDepth)\n    {\n        return GetViewSpaceDepth(fDeviceDepth) * ViewSpaceToMetersFactor();\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_41.cpp","line_count":12,"code":"FfxFloat32x3 GetViewSpacePosition(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth)\n    {\n        const FfxFloat32x4 fDeviceToViewDepth = DeviceToViewSpaceTransformFactors();\n\n        const FfxFloat32 Z = GetViewSpaceDepth(fDeviceDepth);\n\n        const FfxFloat32x2 fNdcPos = ComputeNdc(iViewportPos, iViewportSize);\n        const FfxFloat32 X = fDeviceToViewDepth[2] * fNdcPos.x * Z;\n        const FfxFloat32 Y = fDeviceToViewDepth[3] * fNdcPos.y * Z;\n\n        return FfxFloat32x3(X, Y, Z);\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_42.cpp","line_count":4,"code":"FfxFloat32x3 GetViewSpacePositionInMeters(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth)\n    {\n        return GetViewSpacePosition(iViewportPos, iViewportSize, fDeviceDepth) * ViewSpaceToMetersFactor();\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_44.cpp","line_count":9,"code":"FfxFloat32x3 PrepareRgb(FfxFloat32x3 fRgb, FfxFloat32 fExposure, FfxFloat32 fPreExposure)\n    {\n        fRgb \/= fPreExposure;\n        fRgb *= fExposure;\n\n        fRgb = clamp(fRgb, 0.0f, FSR3UPSCALER_FP16_MAX);\n\n        return fRgb;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_45.cpp","line_count":9,"code":"FfxFloat16x3 PrepareRgb(FfxFloat16x3 fRgb, FfxFloat16 fExposure, FfxFloat16 fPreExposure)\n    {\n        fRgb \/= fPreExposure;\n        fRgb *= fExposure;\n\n        fRgb = clamp(fRgb, FFX_MIN16_F(0.0f), FFX_MIN16_F(FSR3UPSCALER_FP16_MAX));\n\n        return fRgb;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_48.cpp","line_count":20,"code":"BilinearSamplingData GetBilinearSamplingData(FfxFloat32x2 fUv, FfxInt32x2 iSize)\n    {\n        BilinearSamplingData data;\n\n        FfxFloat32x2 fPxSample = (fUv * iSize) - FfxFloat32x2(0.5f, 0.5f);\n        data.iBasePos = FfxInt32x2(floor(fPxSample));\n        FfxFloat32x2 fPxFrac = ffxFract(fPxSample);\n\n        data.iOffsets[0] = FfxInt32x2(0, 0);\n        data.iOffsets[1] = FfxInt32x2(1, 0);\n        data.iOffsets[2] = FfxInt32x2(0, 1);\n        data.iOffsets[3] = FfxInt32x2(1, 1);\n\n        data.fWeights[0] = (1 - fPxFrac.x) * (1 - fPxFrac.y);\n        data.fWeights[1] = (fPxFrac.x) * (1 - fPxFrac.y);\n        data.fWeights[2] = (1 - fPxFrac.x) * (fPxFrac.y);\n        data.fWeights[3] = (fPxFrac.x) * (fPxFrac.y);\n\n        return data;\n    }","mark":8.0}
{"file_name":"ffx_fsr3upscaler_common_function_49.cpp","line_count":11,"code":"PlaneData GetPlaneFromPoints(FfxFloat32x3 fP0, FfxFloat32x3 fP1, FfxFloat32x3 fP2)\n    {\n        PlaneData plane;\n\n        FfxFloat32x3 v0 = fP0 - fP1;\n        FfxFloat32x3 v1 = fP0 - fP2;\n        plane.fNormal = normalize(cross(v0, v1));\n        plane.fDistanceFromOrigin = -dot(fP0, plane.fNormal);\n\n        return plane;\n    }","mark":8.0}
{"file_name":"FileSystemWatcherTest_function_1.cpp","line_count":11,"code":"void initClose()\n    {\n        if (test_section(\"Init\/Close\"))\n        {\n            FileSystemWatcher::ThreadRunner runner;\n\n            FileSystemWatcher fileEventsWatcher;\n            SC_TEST_EXPECT(fileEventsWatcher.init(runner));\n            SC_TEST_EXPECT(fileEventsWatcher.close());\n        }\n    }","mark":8.0}
{"file_name":"file_handler_function_1.cpp","line_count":11,"code":"string\n  get_parent_directory(const std::string &path) {\n    \/\/ remove any trailing path separators\n    std::string trimmed_path = path;\n    while (!trimmed_path.empty() && trimmed_path.back() == '\/') {\n      trimmed_path.pop_back();\n    }\n\n    std::filesystem::path p(trimmed_path);\n    return p.parent_path().string();\n  }","mark":8.0}
{"file_name":"FixedCapacityVector_function_11.cpp","line_count":4,"code":"void resize(size_type count, const_reference v) {\n        assertCapacityForSize(count);\n        resize_non_trivial(count, v);\n    }","mark":8.0}
{"file_name":"FixedCapacityVector_function_12.cpp","line_count":6,"code":"void swap(FixedCapacityVector& other) {\n        using std::swap;\n        swap(mData, other.mData);\n        swap(mSize, other.mSize);\n        mCapacityAllocator.swap(other.mCapacityAllocator);\n    }","mark":8.0}
{"file_name":"FixedCapacityVector_function_19.cpp","line_count":3,"code":"if constexpr(!std::is_trivially_destructible_v<value_type>) {\n            destroy_non_trivial(first, last);\n        }","mark":8.0}
{"file_name":"FixedCapacityVector_function_7.cpp","line_count":4,"code":"iterator erase(const_iterator pos) {\n        assert(pos != end());\n        return erase(pos, pos + 1);\n    }","mark":8.0}
{"file_name":"FormattedText_function_1.cpp","line_count":13,"code":"void SetContentOverride(const std::string & oride)\n\t{\n\t\tif (oride.empty())\n\t\t{\n\t\t\tm_contentOverride = \"\";\n\t\t\tm_ifContent.Set(m_content);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_contentOverride = oride;\n\t\t\tm_ifContent.Set(m_contentOverride);\n\t\t}\n\t}","mark":8.0}
{"file_name":"FormattedText_function_2.cpp","line_count":4,"code":"void UpdateIfContent()\n\t{\n\t\tm_ifContent.Set(GetContentOverride());\n\t}","mark":8.0}
{"file_name":"FormattedText_function_3.cpp","line_count":7,"code":"void Clear() {\n\t\tm_rawMessage.clear();\n\t\tm_blocks.clear();\n\t\tm_tokens.clear();\n\t\tm_words.clear();\n\t\tm_bFormatted = false;\n\t}","mark":9.0}
{"file_name":"FormattedText_function_4.cpp","line_count":7,"code":"void ClearFormatting() {\n\t\tm_bFormatted = false;\n\n\t\tfor (auto& w : m_words) {\n\t\t\tw.m_rect = {};\n\t\t}\n\t}","mark":8.0}
{"file_name":"FormattedText_function_5.cpp","line_count":3,"code":"void AddWord(const Word& w) {\n\t\tm_words.push_back(w);\n\t}","mark":8.0}
{"file_name":"FormattedText_function_6.cpp","line_count":10,"code":"blocks\n\tfor (auto& w : m_words)\n\t{\n\t\tif (w.m_flags & WORD_MLCODE) {\n\t\t\tRect rc = w.m_rect;\n\t\t\trc.top    += offsetY;\n\t\t\trc.bottom += offsetY;\n\t\t\tMdDrawCodeBackground(context, rc);\n\t\t}\n\t}","mark":8.0}
{"file_name":"frame_function_1.cpp","line_count":4,"code":"bool reserved(value v) {\n        return (v >= rsv3 && v <= rsv7) ||\n               (v >= control_rsvb && v <= control_rsvf);\n    }","mark":8.0}
{"file_name":"frame_function_10.cpp","line_count":3,"code":"void set_rsv1(basic_header &h, bool value) {\n    h.b0 = (value ? h.b0 | BHB0_RSV1 : h.b0 & ~BHB0_RSV1);\n}","mark":8.0}
{"file_name":"frame_function_11.cpp","line_count":3,"code":"bool get_rsv2(const basic_header &h) {\n    return ((h.b0 & BHB0_RSV2) == BHB0_RSV2);\n}","mark":8.0}
{"file_name":"frame_function_13.cpp","line_count":3,"code":"bool get_rsv3(const basic_header &h) {\n    return ((h.b0 & BHB0_RSV3) == BHB0_RSV3);\n}","mark":8.0}
{"file_name":"frame_function_16.cpp","line_count":3,"code":"bool get_masked(basic_header const & h) {\n    return ((h.b1 & BHB1_MASK) == BHB1_MASK);\n}","mark":8.0}
{"file_name":"frame_function_17.cpp","line_count":3,"code":"void set_masked(basic_header & h, bool value) {\n    h.b1 = (value ? h.b1 | BHB1_MASK : h.b1 & ~BHB1_MASK);\n}","mark":8.0}
{"file_name":"frame_function_20.cpp","line_count":9,"code":"int get_masking_key_offset(const basic_header &h) {\n    if (get_basic_size(h) == payload_size_code_16bit) {\n        return 2;\n    } else if (get_basic_size(h) == payload_size_code_64bit) {\n        return 8;\n    } else {\n        return 0;\n    }\n}","mark":8.0}
{"file_name":"frame_function_7.cpp","line_count":3,"code":"bool get_fin(basic_header const & h) {\n    return ((h.b0 & BHB0_FIN) == BHB0_FIN);\n}","mark":8.0}
{"file_name":"frame_function_9.cpp","line_count":3,"code":"bool get_rsv1(const basic_header &h) {\n    return ((h.b0 & BHB0_RSV1) == BHB0_RSV1);\n}","mark":8.0}
{"file_name":"FSR2Feature_212_function_1.cpp","line_count":23,"code":"string ResultToString212(Fsr212::FfxErrorCode result)\n{\n\tswitch (result)\n\t{\n\tcase Fsr212::FFX_OK: return \"The operation completed successfully.\";\n\tcase Fsr212::FFX_ERROR_INVALID_POINTER: return \"The operation failed due to an invalid pointer.\";\n\tcase Fsr212::FFX_ERROR_INVALID_ALIGNMENT: return \"The operation failed due to an invalid alignment.\";\n\tcase Fsr212::FFX_ERROR_INVALID_SIZE: return \"The operation failed due to an invalid size.\";\n\tcase Fsr212::FFX_EOF: return \"The end of the file was encountered.\";\n\tcase Fsr212::FFX_ERROR_INVALID_PATH: return \"The operation failed because the specified path was invalid.\";\n\tcase Fsr212::FFX_ERROR_EOF: return \"The operation failed because end of file was reached.\";\n\tcase Fsr212::FFX_ERROR_MALFORMED_DATA: return \"The operation failed because of some malformed data.\";\n\tcase Fsr212::FFX_ERROR_OUT_OF_MEMORY: return \"The operation failed because it ran out memory.\";\n\tcase Fsr212::FFX_ERROR_INCOMPLETE_INTERFACE: return \"The operation failed because the interface was not fully configured.\";\n\tcase Fsr212::FFX_ERROR_INVALID_ENUM: return \"The operation failed because of an invalid enumeration value.\";\n\tcase Fsr212::FFX_ERROR_INVALID_ARGUMENT: return \"The operation failed because an argument was invalid.\";\n\tcase Fsr212::FFX_ERROR_OUT_OF_RANGE: return \"The operation failed because a value was out of range.\";\n\tcase Fsr212::FFX_ERROR_NULL_DEVICE: return \"The operation failed because a device was null.\";\n\tcase Fsr212::FFX_ERROR_BACKEND_API_ERROR: return \"The operation failed because the backend API returned an error code.\";\n\tcase Fsr212::FFX_ERROR_INSUFFICIENT_MEMORY: return \"The operation failed because there was not enough memory.\";\n\tdefault: return \"Unknown\";\n\t}\n}","mark":8.0}
{"file_name":"FSR2Feature_function_1.cpp","line_count":23,"code":"string ResultToString(FfxErrorCode result)\n{\n\tswitch (result)\n\t{\n\tcase FFX_OK: return \"The operation completed successfully.\";\n\tcase FFX_ERROR_INVALID_POINTER: return \"The operation failed due to an invalid pointer.\";\n\tcase FFX_ERROR_INVALID_ALIGNMENT: return \"The operation failed due to an invalid alignment.\";\n\tcase FFX_ERROR_INVALID_SIZE: return \"The operation failed due to an invalid size.\";\n\tcase FFX_EOF: return \"The end of the file was encountered.\";\n\tcase FFX_ERROR_INVALID_PATH: return \"The operation failed because the specified path was invalid.\";\n\tcase FFX_ERROR_EOF: return \"The operation failed because end of file was reached.\";\n\tcase FFX_ERROR_MALFORMED_DATA: return \"The operation failed because of some malformed data.\";\n\tcase FFX_ERROR_OUT_OF_MEMORY: return \"The operation failed because it ran out memory.\";\n\tcase FFX_ERROR_INCOMPLETE_INTERFACE: return \"The operation failed because the interface was not fully configured.\";\n\tcase FFX_ERROR_INVALID_ENUM: return \"The operation failed because of an invalid enumeration value.\";\n\tcase FFX_ERROR_INVALID_ARGUMENT: return \"The operation failed because an argument was invalid.\";\n\tcase FFX_ERROR_OUT_OF_RANGE: return \"The operation failed because a value was out of range.\";\n\tcase FFX_ERROR_NULL_DEVICE: return \"The operation failed because a device was null.\";\n\tcase FFX_ERROR_BACKEND_API_ERROR: return \"The operation failed because the backend API returned an error code.\";\n\tcase FFX_ERROR_INSUFFICIENT_MEMORY: return \"The operation failed because there was not enough memory.\";\n\tdefault: return \"Unknown\";\n\t}\n}","mark":8.0}
{"file_name":"FSR2Feature_Vk_212_function_1.cpp","line_count":28,"code":"void transitionImageToShaderReadOnly(VkCommandBuffer commandBuffer, VkImage image, VkFormat format, VkAccessFlagBits flag = VK_ACCESS_SHADER_READ_BIT) \n{\n    VkImageMemoryBarrier barrier = {};\n    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;\n    barrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED; \/\/ Previous layout is unknown or irrelevant\n    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier.image = image;\n    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\n    barrier.subresourceRange.baseMipLevel = 0;\n    barrier.subresourceRange.levelCount = 1;\n    barrier.subresourceRange.baseArrayLayer = 0;\n    barrier.subresourceRange.layerCount = 1;\n\n    barrier.srcAccessMask = 0; \/\/ No previous accesses need to be waited on\n    barrier.dstAccessMask = flag; \n\n    vkCmdPipelineBarrier(\n        commandBuffer,\n        VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, \/\/ Earliest possible stage\n        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \/\/ Transition to fragment shader stage\n        0, \/\/ No special flags\n        0, nullptr, \/\/ No memory barriers\n        0, nullptr, \/\/ No buffer barriers\n        1, &barrier \/\/ One image barrier\n    );\n}","mark":8.25}
{"file_name":"FSR31Feature_Dx11_function_1.cpp","line_count":23,"code":"string ResultToString(Fsr31::FfxErrorCode result)\n    {\n        switch (result)\n        {\n        case Fsr31::FFX_OK: return \"The operation completed successfully.\";\n        case Fsr31::FFX_ERROR_INVALID_POINTER: return \"The operation failed due to an invalid pointer.\";\n        case Fsr31::FFX_ERROR_INVALID_ALIGNMENT: return \"The operation failed due to an invalid alignment.\";\n        case Fsr31::FFX_ERROR_INVALID_SIZE: return \"The operation failed due to an invalid size.\";\n        case Fsr31::FFX_EOF: return \"The end of the file was encountered.\";\n        case Fsr31::FFX_ERROR_INVALID_PATH: return \"The operation failed because the specified path was invalid.\";\n        case Fsr31::FFX_ERROR_EOF: return \"The operation failed because end of file was reached.\";\n        case Fsr31::FFX_ERROR_MALFORMED_DATA: return \"The operation failed because of some malformed data.\";\n        case Fsr31::FFX_ERROR_OUT_OF_MEMORY: return \"The operation failed because it ran out memory.\";\n        case Fsr31::FFX_ERROR_INCOMPLETE_INTERFACE: return \"The operation failed because the interface was not fully configured.\";\n        case Fsr31::FFX_ERROR_INVALID_ENUM: return \"The operation failed because of an invalid enumeration value.\";\n        case Fsr31::FFX_ERROR_INVALID_ARGUMENT: return \"The operation failed because an argument was invalid.\";\n        case Fsr31::FFX_ERROR_OUT_OF_RANGE: return \"The operation failed because a value was out of range.\";\n        case Fsr31::FFX_ERROR_NULL_DEVICE: return \"The operation failed because a device was null.\";\n        case Fsr31::FFX_ERROR_BACKEND_API_ERROR: return \"The operation failed because the backend API returned an error code.\";\n        case Fsr31::FFX_ERROR_INSUFFICIENT_MEMORY: return \"The operation failed because there was not enough memory.\";\n        default: return \"Unknown\";\n        }\n    }","mark":8.5}
{"file_name":"FSR31Feature_Vk_function_1.cpp","line_count":31,"code":"FfxApiResourceDescription ffxApiGetImageResourceDescriptionVKLocal(NVSDK_NGX_Resource_VK* vkResource, bool uav = false)\n{\n    FfxApiResourceDescription resourceDescription = {};\n\n    \/\/ This is valid\n    if (vkResource->Resource.ImageViewInfo.Image == VK_NULL_HANDLE)\n        return resourceDescription;\n\n    \/\/ Set flags properly for resource registration\n    resourceDescription.flags = FFX_API_RESOURCE_FLAGS_NONE;\n\n    \/\/ Unordered access use\n    if (uav)\n        resourceDescription.usage = FFX_API_RESOURCE_USAGE_UAV;\n    else\n        resourceDescription.usage = FFX_API_RESOURCE_USAGE_READ_ONLY;\n\n    resourceDescription.type = FFX_API_RESOURCE_TYPE_TEXTURE2D;\n    resourceDescription.width = vkResource->Resource.ImageViewInfo.Width;\n    resourceDescription.height = vkResource->Resource.ImageViewInfo.Height;\n    resourceDescription.mipCount = 1;\n    resourceDescription.depth = 1;\n\n    \/\/ For No Man's Sky\n    if (vkResource->Resource.ImageViewInfo.Format == VK_FORMAT_D32_SFLOAT_S8_UINT)\n        resourceDescription.format = FFX_API_SURFACE_FORMAT_R32_FLOAT;\n    else\n        resourceDescription.format = ffxApiGetSurfaceFormatVK(vkResource->Resource.ImageViewInfo.Format);\n\n    return resourceDescription;\n}","mark":8.0}
{"file_name":"functional_function_2.cpp","line_count":3,"code":"void clear_function(T & x) {\n        x.clear();\n    }","mark":8.0}
{"file_name":"FunctionTest_function_1.cpp","line_count":1,"code":"void setValue(int value) { data = value; }","mark":8.0}
{"file_name":"FunctionTest_function_2.cpp","line_count":1,"code":"int freeFunc(int value) { return value + 1; }","mark":8.0}
{"file_name":"FunctionTest_function_3.cpp","line_count":1,"code":"int freeFunc2(int value) { return value - 1; }","mark":8.0}
{"file_name":"Function_function_2.cpp","line_count":1,"code":"int someFunc(float a) { return static_cast<int>(a * 2); }","mark":8.0}
{"file_name":"gl_function_10.cpp","line_count":18,"code":"void glad_gl_load_GL_VERSION_3_1(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) {\n    if(!context->VERSION_3_1) return;\n    context->BindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, \"glBindBufferBase\");\n    context->BindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, \"glBindBufferRange\");\n    context->CopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) load(userptr, \"glCopyBufferSubData\");\n    context->DrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) load(userptr, \"glDrawArraysInstanced\");\n    context->DrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) load(userptr, \"glDrawElementsInstanced\");\n    context->GetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) load(userptr, \"glGetActiveUniformBlockName\");\n    context->GetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) load(userptr, \"glGetActiveUniformBlockiv\");\n    context->GetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC) load(userptr, \"glGetActiveUniformName\");\n    context->GetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) load(userptr, \"glGetActiveUniformsiv\");\n    context->GetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, \"glGetIntegeri_v\");\n    context->GetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) load(userptr, \"glGetUniformBlockIndex\");\n    context->GetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) load(userptr, \"glGetUniformIndices\");\n    context->PrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC) load(userptr, \"glPrimitiveRestartIndex\");\n    context->TexBuffer = (PFNGLTEXBUFFERPROC) load(userptr, \"glTexBuffer\");\n    context->UniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) load(userptr, \"glUniformBlockBinding\");\n}","mark":8.0}
{"file_name":"gl_function_11.cpp","line_count":22,"code":"void glad_gl_load_GL_VERSION_3_2(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) {\n    if(!context->VERSION_3_2) return;\n    context->ClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) load(userptr, \"glClientWaitSync\");\n    context->DeleteSync = (PFNGLDELETESYNCPROC) load(userptr, \"glDeleteSync\");\n    context->DrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) load(userptr, \"glDrawElementsBaseVertex\");\n    context->DrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) load(userptr, \"glDrawElementsInstancedBaseVertex\");\n    context->DrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) load(userptr, \"glDrawRangeElementsBaseVertex\");\n    context->FenceSync = (PFNGLFENCESYNCPROC) load(userptr, \"glFenceSync\");\n    context->FramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) load(userptr, \"glFramebufferTexture\");\n    context->GetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC) load(userptr, \"glGetBufferParameteri64v\");\n    context->GetInteger64i_v = (PFNGLGETINTEGER64I_VPROC) load(userptr, \"glGetInteger64i_v\");\n    context->GetInteger64v = (PFNGLGETINTEGER64VPROC) load(userptr, \"glGetInteger64v\");\n    context->GetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) load(userptr, \"glGetMultisamplefv\");\n    context->GetSynciv = (PFNGLGETSYNCIVPROC) load(userptr, \"glGetSynciv\");\n    context->IsSync = (PFNGLISSYNCPROC) load(userptr, \"glIsSync\");\n    context->MultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) load(userptr, \"glMultiDrawElementsBaseVertex\");\n    context->ProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) load(userptr, \"glProvokingVertex\");\n    context->SampleMaski = (PFNGLSAMPLEMASKIPROC) load(userptr, \"glSampleMaski\");\n    context->TexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC) load(userptr, \"glTexImage2DMultisample\");\n    context->TexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC) load(userptr, \"glTexImage3DMultisample\");\n    context->WaitSync = (PFNGLWAITSYNCPROC) load(userptr, \"glWaitSync\");\n}","mark":8.0}
{"file_name":"gl_function_13.cpp","line_count":49,"code":"void glad_gl_load_GL_VERSION_4_0(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) {\n    if(!context->VERSION_4_0) return;\n    context->BeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC) load(userptr, \"glBeginQueryIndexed\");\n    context->BindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) load(userptr, \"glBindTransformFeedback\");\n    context->BlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) load(userptr, \"glBlendEquationSeparatei\");\n    context->BlendEquationi = (PFNGLBLENDEQUATIONIPROC) load(userptr, \"glBlendEquationi\");\n    context->BlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) load(userptr, \"glBlendFuncSeparatei\");\n    context->BlendFunci = (PFNGLBLENDFUNCIPROC) load(userptr, \"glBlendFunci\");\n    context->DeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) load(userptr, \"glDeleteTransformFeedbacks\");\n    context->DrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) load(userptr, \"glDrawArraysIndirect\");\n    context->DrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) load(userptr, \"glDrawElementsIndirect\");\n    context->DrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) load(userptr, \"glDrawTransformFeedback\");\n    context->DrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) load(userptr, \"glDrawTransformFeedbackStream\");\n    context->EndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC) load(userptr, \"glEndQueryIndexed\");\n    context->GenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) load(userptr, \"glGenTransformFeedbacks\");\n    context->GetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC) load(userptr, \"glGetActiveSubroutineName\");\n    context->GetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) load(userptr, \"glGetActiveSubroutineUniformName\");\n    context->GetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) load(userptr, \"glGetActiveSubroutineUniformiv\");\n    context->GetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC) load(userptr, \"glGetProgramStageiv\");\n    context->GetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC) load(userptr, \"glGetQueryIndexediv\");\n    context->GetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC) load(userptr, \"glGetSubroutineIndex\");\n    context->GetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) load(userptr, \"glGetSubroutineUniformLocation\");\n    context->GetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC) load(userptr, \"glGetUniformSubroutineuiv\");\n    context->GetUniformdv = (PFNGLGETUNIFORMDVPROC) load(userptr, \"glGetUniformdv\");\n    context->IsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) load(userptr, \"glIsTransformFeedback\");\n    context->MinSampleShading = (PFNGLMINSAMPLESHADINGPROC) load(userptr, \"glMinSampleShading\");\n    context->PatchParameterfv = (PFNGLPATCHPARAMETERFVPROC) load(userptr, \"glPatchParameterfv\");\n    context->PatchParameteri = (PFNGLPATCHPARAMETERIPROC) load(userptr, \"glPatchParameteri\");\n    context->PauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) load(userptr, \"glPauseTransformFeedback\");\n    context->ResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) load(userptr, \"glResumeTransformFeedback\");\n    context->Uniform1d = (PFNGLUNIFORM1DPROC) load(userptr, \"glUniform1d\");\n    context->Uniform1dv = (PFNGLUNIFORM1DVPROC) load(userptr, \"glUniform1dv\");\n    context->Uniform2d = (PFNGLUNIFORM2DPROC) load(userptr, \"glUniform2d\");\n    context->Uniform2dv = (PFNGLUNIFORM2DVPROC) load(userptr, \"glUniform2dv\");\n    context->Uniform3d = (PFNGLUNIFORM3DPROC) load(userptr, \"glUniform3d\");\n    context->Uniform3dv = (PFNGLUNIFORM3DVPROC) load(userptr, \"glUniform3dv\");\n    context->Uniform4d = (PFNGLUNIFORM4DPROC) load(userptr, \"glUniform4d\");\n    context->Uniform4dv = (PFNGLUNIFORM4DVPROC) load(userptr, \"glUniform4dv\");\n    context->UniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC) load(userptr, \"glUniformMatrix2dv\");\n    context->UniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC) load(userptr, \"glUniformMatrix2x3dv\");\n    context->UniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC) load(userptr, \"glUniformMatrix2x4dv\");\n    context->UniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC) load(userptr, \"glUniformMatrix3dv\");\n    context->UniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC) load(userptr, \"glUniformMatrix3x2dv\");\n    context->UniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC) load(userptr, \"glUniformMatrix3x4dv\");\n    context->UniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC) load(userptr, \"glUniformMatrix4dv\");\n    context->UniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC) load(userptr, \"glUniformMatrix4x2dv\");\n    context->UniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC) load(userptr, \"glUniformMatrix4x3dv\");\n    context->UniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC) load(userptr, \"glUniformSubroutinesuiv\");\n}","mark":8.0}
{"file_name":"gl_function_30.cpp","line_count":9,"code":"void glad_close_dlopen_handle(void* handle) {\n    if (handle != NULL) {\n#if GLAD_PLATFORM_WIN32\n        FreeLibrary((HMODULE) handle);\n#else\n        dlclose(handle);\n#endif\n    }\n}","mark":8.0}
{"file_name":"gl_function_31.cpp","line_count":11,"code":"GLADapiproc glad_dlsym_handle(void* handle, const char *name) {\n    if (handle == NULL) {\n        return NULL;\n    }\n\n#if GLAD_PLATFORM_WIN32\n    return (GLADapiproc) GetProcAddress((HMODULE) handle, name);\n#else\n    return GLAD_GNUC_EXTENSION (GLADapiproc) dlsym(handle, name);\n#endif\n}","mark":8.0}
{"file_name":"gl_function_36.cpp","line_count":6,"code":"void gladLoaderUnloadGL(void) {\n    if (_gl_handle != NULL) {\n        glad_close_dlopen_handle(_gl_handle);\n        _gl_handle = NULL;\n    }\n}","mark":8.0}
{"file_name":"gl_function_6.cpp","line_count":22,"code":"void glad_gl_load_GL_VERSION_1_5(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) {\n    if(!context->VERSION_1_5) return;\n    context->BeginQuery = (PFNGLBEGINQUERYPROC) load(userptr, \"glBeginQuery\");\n    context->BindBuffer = (PFNGLBINDBUFFERPROC) load(userptr, \"glBindBuffer\");\n    context->BufferData = (PFNGLBUFFERDATAPROC) load(userptr, \"glBufferData\");\n    context->BufferSubData = (PFNGLBUFFERSUBDATAPROC) load(userptr, \"glBufferSubData\");\n    context->DeleteBuffers = (PFNGLDELETEBUFFERSPROC) load(userptr, \"glDeleteBuffers\");\n    context->DeleteQueries = (PFNGLDELETEQUERIESPROC) load(userptr, \"glDeleteQueries\");\n    context->EndQuery = (PFNGLENDQUERYPROC) load(userptr, \"glEndQuery\");\n    context->GenBuffers = (PFNGLGENBUFFERSPROC) load(userptr, \"glGenBuffers\");\n    context->GenQueries = (PFNGLGENQUERIESPROC) load(userptr, \"glGenQueries\");\n    context->GetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC) load(userptr, \"glGetBufferParameteriv\");\n    context->GetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC) load(userptr, \"glGetBufferPointerv\");\n    context->GetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC) load(userptr, \"glGetBufferSubData\");\n    context->GetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC) load(userptr, \"glGetQueryObjectiv\");\n    context->GetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC) load(userptr, \"glGetQueryObjectuiv\");\n    context->GetQueryiv = (PFNGLGETQUERYIVPROC) load(userptr, \"glGetQueryiv\");\n    context->IsBuffer = (PFNGLISBUFFERPROC) load(userptr, \"glIsBuffer\");\n    context->IsQuery = (PFNGLISQUERYPROC) load(userptr, \"glIsQuery\");\n    context->MapBuffer = (PFNGLMAPBUFFERPROC) load(userptr, \"glMapBuffer\");\n    context->UnmapBuffer = (PFNGLUNMAPBUFFERPROC) load(userptr, \"glUnmapBuffer\");\n}","mark":8.0}
{"file_name":"GuildHeader_function_1.cpp","line_count":3,"code":"bool IsPlacementGuildType(eButtonPlacement pl) {\n\t\treturn pl == BUTTON_GUILD_LEFT || pl == BUTTON_GUILD_RIGHT;\n\t}","mark":9.0}
{"file_name":"GuildHeader_function_2.cpp","line_count":3,"code":"bool IsPlacementChannelType(eButtonPlacement pl) {\n\t\treturn pl == BUTTON_RIGHT || pl == BUTTON_LEFT;\n\t}","mark":8.0}
{"file_name":"GuildLister_function_1.cpp","line_count":4,"code":"int GetProfileBorderRenderSize()\n{\n\treturn ScaleByDPI(Supports32BitIcons() ? (PROFILE_PICTURE_SIZE_DEF + 12) : 64);\n}","mark":8.0}
{"file_name":"Guild_function_1.cpp","line_count":3,"code":"void AddKnownMember(Snowflake sf) {\n\t\tm_knownMembers.insert(sf);\n\t}","mark":8.0}
{"file_name":"handler_work_function_4.cpp","line_count":7,"code":"void dispatch(Function& function, Handler& handler)\n  {\n    \/\/ When using a native implementation, I\/O completion handlers are\n    \/\/ already dispatched according to the execution context's executor's\n    \/\/ rules. We can call the function directly.\n    asio_handler_invoke_helpers::invoke(function, handler);\n  }","mark":8.0}
{"file_name":"hash_map_function_4.cpp","line_count":4,"code":"iterator begin()\n  {\n    return values_.begin();\n  }","mark":8.0}
{"file_name":"hash_map_function_9.cpp","line_count":11,"code":"void clear()\n  {\n    \/\/ Clear the values.\n    values_.clear();\n    size_ = 0;\n\n    \/\/ Initialise all buckets to empty.\n    iterator end_it = values_.end();\n    for (size_t i = 0; i < num_buckets_; ++i)\n      buckets_[i].first = buckets_[i].last = end_it;\n  }","mark":8.0}
{"file_name":"helper_function_5.cpp","line_count":7,"code":"int HexStringToInt(const std::string& hexString) {\n        int num;\n        std::stringstream ss;\n        ss << std::hex << hexString;\n        ss >> num;\n        return num;\n    }","mark":8.0}
{"file_name":"helper_math_function_100.cpp","line_count":4,"code":"float\nlength(float3 v) {\n  return sqrtf(dot(v, v));\n}","mark":8.0}
{"file_name":"helper_math_function_104.cpp","line_count":5,"code":"float4\nnormalize(float4 v) {\n  float invLen = rsqrtf(dot(v, v));\n  return v * invLen;\n}","mark":8.0}
{"file_name":"helper_math_function_105.cpp","line_count":4,"code":"float2\nfloorf(float2 v) {\n  return make_float2(floorf(v.x), floorf(v.y));\n}","mark":8.0}
{"file_name":"helper_math_function_106.cpp","line_count":4,"code":"float3\nfloorf(float3 v) {\n  return make_float3(floorf(v.x), floorf(v.y), floorf(v.z));\n}","mark":8.0}
{"file_name":"helper_math_function_107.cpp","line_count":4,"code":"float4\nfloorf(float4 v) {\n  return make_float4(floorf(v.x), floorf(v.y), floorf(v.z), floorf(v.w));\n}","mark":8.0}
{"file_name":"helper_math_function_108.cpp","line_count":4,"code":"float\nfracf(float v) {\n  return v - floorf(v);\n}","mark":8.0}
{"file_name":"helper_math_function_114.cpp","line_count":4,"code":"float4\nfmodf(float4 a, float4 b) {\n  return make_float4(fmodf(a.x, b.x), fmodf(a.y, b.y), fmodf(a.z, b.z), fmodf(a.w, b.w));\n}","mark":8.0}
{"file_name":"helper_math_function_117.cpp","line_count":4,"code":"float4\nfabs(float4 v) {\n  return make_float4(fabs(v.x), fabs(v.y), fabs(v.z), fabs(v.w));\n}","mark":8.0}
{"file_name":"helper_math_function_121.cpp","line_count":4,"code":"float3\nreflect(float3 i, float3 n) {\n  return i - 2.0f * n * dot(n, i);\n}","mark":8.0}
{"file_name":"helper_math_function_122.cpp","line_count":4,"code":"float3\ncross(float3 a, float3 b) {\n  return make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}","mark":8.0}
{"file_name":"helper_math_function_123.cpp","line_count":5,"code":"float\nsmoothstep(float a, float b, float x) {\n  float y = clamp((x - a) \/ (b - a), 0.0f, 1.0f);\n  return (y * y * (3.0f - (2.0f * y)));\n}","mark":8.0}
{"file_name":"helper_math_function_126.cpp","line_count":5,"code":"float4\nsmoothstep(float4 a, float4 b, float4 x) {\n  float4 y = clamp((x - a) \/ (b - a), 0.0f, 1.0f);\n  return (y * y * (make_float4(3.0f) - (make_float4(2.0f) * y)));\n}","mark":8.0}
{"file_name":"helper_math_function_2.cpp","line_count":4,"code":"float\nfmaxf(float a, float b) {\n  return a > b ? a : b;\n}","mark":8.0}
{"file_name":"helper_math_function_21.cpp","line_count":4,"code":"float3\nmake_float3(int3 a) {\n  return make_float3(float(a.x), float(a.y), float(a.z));\n}","mark":8.0}
{"file_name":"helper_math_function_22.cpp","line_count":4,"code":"float3\nmake_float3(uint3 a) {\n  return make_float3(float(a.x), float(a.y), float(a.z));\n}","mark":8.0}
{"file_name":"helper_math_function_3.cpp","line_count":4,"code":"int\nmax(int a, int b) {\n  return a > b ? a : b;\n}","mark":8.0}
{"file_name":"helper_math_function_33.cpp","line_count":4,"code":"float4\nmake_float4(float s) {\n  return make_float4(s, s, s, s);\n}","mark":8.0}
{"file_name":"helper_math_function_34.cpp","line_count":4,"code":"float4\nmake_float4(float3 a) {\n  return make_float4(a.x, a.y, a.z, 0.0f);\n}","mark":8.0}
{"file_name":"helper_math_function_35.cpp","line_count":4,"code":"float4\nmake_float4(float3 a, float w) {\n  return make_float4(a.x, a.y, a.z, w);\n}","mark":8.0}
{"file_name":"helper_math_function_36.cpp","line_count":4,"code":"float4\nmake_float4(int4 a) {\n  return make_float4(float(a.x), float(a.y), float(a.z), float(a.w));\n}","mark":8.0}
{"file_name":"helper_math_function_37.cpp","line_count":4,"code":"float4\nmake_float4(uint4 a) {\n  return make_float4(float(a.x), float(a.y), float(a.z), float(a.w));\n}","mark":8.0}
{"file_name":"helper_math_function_4.cpp","line_count":4,"code":"int\nmin(int a, int b) {\n  return a < b ? a : b;\n}","mark":8.0}
{"file_name":"helper_math_function_53.cpp","line_count":4,"code":"uint2\nmin(uint2 a, uint2 b) {\n  return make_uint2(min(a.x, b.x), min(a.y, b.y));\n}","mark":8.0}
{"file_name":"helper_math_function_65.cpp","line_count":4,"code":"float\nlerp(float a, float b, float t) {\n  return a + t * (b - a);\n}","mark":8.0}
{"file_name":"helper_math_function_66.cpp","line_count":4,"code":"float2\nlerp(float2 a, float2 b, float t) {\n  return a + t * (b - a);\n}","mark":8.0}
{"file_name":"helper_math_function_67.cpp","line_count":4,"code":"float3\nlerp(float3 a, float3 b, float t) {\n  return a + t * (b - a);\n}","mark":8.0}
{"file_name":"helper_math_function_68.cpp","line_count":4,"code":"float4\nlerp(float4 a, float4 b, float t) {\n  return a + t * (b - a);\n}","mark":8.0}
{"file_name":"helper_math_function_69.cpp","line_count":4,"code":"float\nclamp(float f, float a, float b) {\n  return fmaxf(a, fminf(f, b));\n}","mark":8.0}
{"file_name":"helper_math_function_71.cpp","line_count":4,"code":"uint\nclamp(uint f, uint a, uint b) {\n  return max(a, min(f, b));\n}","mark":8.0}
{"file_name":"helper_math_function_84.cpp","line_count":4,"code":"uint2\nclamp(uint2 v, uint a, uint b) {\n  return make_uint2(clamp(v.x, a, b), clamp(v.y, a, b));\n}","mark":8.0}
{"file_name":"helper_math_function_85.cpp","line_count":4,"code":"uint2\nclamp(uint2 v, uint2 a, uint2 b) {\n  return make_uint2(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y));\n}","mark":8.0}
{"file_name":"helper_math_function_90.cpp","line_count":4,"code":"float\ndot(float2 a, float2 b) {\n  return a.x * b.x + a.y * b.y;\n}","mark":8.0}
{"file_name":"helper_math_function_91.cpp","line_count":4,"code":"float\ndot(float3 a, float3 b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}","mark":8.0}
{"file_name":"helper_math_function_92.cpp","line_count":4,"code":"float\ndot(float4 a, float4 b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n}","mark":8.0}
{"file_name":"HotReloadSystem_function_7.cpp","line_count":25,"code":"void onFileChange(const FileSystemWatcher::Notification& notification)\n    {\n        if (notification.relativePath.endsWith(\".cpp\"))\n        {\n            const size_t numberOfPlugins = registry.getNumberOfEntries();\n            for (size_t idx = 0; idx < numberOfPlugins; ++idx)\n            {\n                const PluginDynamicLibrary& library = registry.getPluginDynamicLibraryAt(idx);\n                for (const PluginFile& file : library.definition.files)\n                {\n                    if (file.absolutePath.view().endsWith(notification.relativePath))\n                    {\n                        const Time::Relative elapsed = Time::Absolute::now().subtract(library.lastLoadTime);\n                        if (elapsed.inRoundedUpperMilliseconds().ms > 500)\n                        {\n                            \/\/ Only reload if at least 500ms have passed, as sometimes FSEvents on macOS\n                            \/\/ likes to send multiple events that are difficult to filter properly\n                            (void)load(registry.getIdentifierAt(idx).view());\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n    }","mark":8.0}
{"file_name":"httplib_function_102.cpp","line_count":11,"code":"string params_to_query_str(const Params &params) {\n  std::string query;\n\n  for (auto it = params.begin(); it != params.end(); ++it) {\n\tif (it != params.begin()) { query += \"&\"; }\n\tquery += it->first;\n\tquery += \"=\";\n\tquery += encode_query_param(it->second);\n  }\n  return query;\n}","mark":8.0}
{"file_name":"httplib_function_109.cpp","line_count":5,"code":"void clear_file_info() {\n\tfile_.name.clear();\n\tfile_.filename.clear();\n\tfile_.content_type.clear();\n  }","mark":8.0}
{"file_name":"httplib_function_11.cpp","line_count":7,"code":"void duration_to_sec_and_usec(const T &duration, U callback) {\n  auto sec = std::chrono::duration_cast<std::chrono::seconds>(duration).count();\n  auto usec = std::chrono::duration_cast<std::chrono::microseconds>(\n\t\t\t\t  duration - std::chrono::seconds(sec))\n\t\t\t\t  .count();\n  callback(static_cast<time_t>(sec), static_cast<time_t>(usec));\n}","mark":8.0}
{"file_name":"httplib_function_112.cpp","line_count":9,"code":"string to_lower(const char *beg, const char *end) {\n  std::string out;\n  auto it = beg;\n  while (it != end) {\n\tout += static_cast<char>(::tolower(*it));\n\tit++;\n  }\n  return out;\n}","mark":8.0}
{"file_name":"httplib_function_113.cpp","line_count":21,"code":"string make_multipart_data_boundary() {\n  static const char data[] =\n\t  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n  \/\/ std::random_device might actually be deterministic on some\n  \/\/ platforms, but due to lack of support in the c++ standard library,\n  \/\/ doing better requires either some ugly hacks or breaking portability.\n  std::random_device seed_gen;\n\n  \/\/ Request 128 bits of entropy for initialization\n  std::seed_seq seed_sequence{seed_gen(), seed_gen(), seed_gen(), seed_gen()};\n  std::mt19937 engine(seed_sequence);\n\n  std::string result = \"--cpp-httplib-multipart-data-\";\n\n  for (auto i = 0; i < 16; i++) {\n\tresult += data[engine() % (sizeof(data) - 1)];\n  }\n\n  return result;\n}","mark":8.0}
{"file_name":"httplib_function_114.cpp","line_count":11,"code":"bool is_multipart_boundary_chars_valid(const std::string &boundary) {\n  auto valid = true;\n  for (size_t i = 0; i < boundary.size(); i++) {\n\tauto c = boundary[i];\n\tif (!std::isalnum(c) && c != '-' && c != '_') {\n\t  valid = false;\n\t  break;\n\t}\n  }\n  return valid;\n}","mark":8.0}
{"file_name":"httplib_function_116.cpp","line_count":1,"code":"string serialize_multipart_formdata_item_end() { return \"\\r\\n\"; }","mark":8.0}
{"file_name":"httplib_function_117.cpp","line_count":4,"code":"string\nserialize_multipart_formdata_finish(const std::string &boundary) {\n  return \"--\" + boundary + \"--\\r\\n\";\n}","mark":8.0}
{"file_name":"httplib_function_128.cpp","line_count":8,"code":"bool has_crlf(const std::string &s) {\n  auto p = s.c_str();\n  while (*p) {\n\tif (*p == '\\r' || *p == '\\n') { return true; }\n\tp++;\n  }\n  return false;\n}","mark":8.0}
{"file_name":"httplib_function_129.cpp","line_count":19,"code":"string message_digest(const std::string &s, const EVP_MD *algo) {\n  auto context = std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)>(\n\t  EVP_MD_CTX_new(), EVP_MD_CTX_free);\n\n  unsigned int hash_length = 0;\n  unsigned char hash[EVP_MAX_MD_SIZE];\n\n  EVP_DigestInit_ex(context.get(), algo, nullptr);\n  EVP_DigestUpdate(context.get(), s.c_str(), s.size());\n  EVP_DigestFinal_ex(context.get(), hash, &hash_length);\n\n  std::stringstream ss;\n  for (auto i = 0u; i < hash_length; ++i) {\n\tss << std::hex << std::setw(2) << std::setfill('0')\n\t   << (unsigned int)hash[i];\n  }\n\n  return ss.str();\n}","mark":8.0}
{"file_name":"httplib_function_130.cpp","line_count":3,"code":"string MD5(const std::string &s) {\n  return message_digest(s, EVP_md5());\n}","mark":8.0}
{"file_name":"httplib_function_131.cpp","line_count":3,"code":"string SHA_256(const std::string &s) {\n  return message_digest(s, EVP_sha256());\n}","mark":8.0}
{"file_name":"httplib_function_132.cpp","line_count":3,"code":"string SHA_512(const std::string &s) {\n  return message_digest(s, EVP_sha512());\n}","mark":8.0}
{"file_name":"httplib_function_136.cpp","line_count":12,"code":"string random_string(size_t length) {\n  auto randchar = []() -> char {\n\tconst char charset[] = \"0123456789\"\n\t\t\t\t\t\t   \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\t\t\t\t   \"abcdefghijklmnopqrstuvwxyz\";\n\tconst size_t max_index = (sizeof(charset) - 1);\n\treturn charset[static_cast<size_t>(std::rand()) % max_index];\n  };\n  std::string str(length, 0);\n  std::generate_n(str.begin(), length, randchar);\n  return str;\n}","mark":8.0}
{"file_name":"httplib_function_14.cpp","line_count":22,"code":"string to_string(const Error error) {\n  switch (error) {\n  case Error::Success: return \"Success (no error)\";\n  case Error::Connection: return \"Could not establish connection\";\n  case Error::BindIPAddress: return \"Failed to bind IP address\";\n  case Error::Read: return \"Failed to read connection\";\n  case Error::Write: return \"Failed to write connection\";\n  case Error::ExceedRedirectCount: return \"Maximum redirect count exceeded\";\n  case Error::Canceled: return \"Connection handling canceled\";\n  case Error::SSLConnection: return \"SSL connection failed\";\n  case Error::SSLLoadingCerts: return \"SSL certificate loading failed\";\n  case Error::SSLServerVerification: return \"SSL server verification failed\";\n  case Error::UnsupportedMultipartBoundaryChars:\n\treturn \"Unsupported HTTP multipart boundary characters\";\n  case Error::Compression: return \"Compression failed\";\n  case Error::ConnectionTimeout: return \"Connection timed out\";\n  case Error::Unknown: return \"Unknown\";\n  default: break;\n  }\n\n  return \"Invalid\";\n}","mark":8.0}
{"file_name":"httplib_function_157.cpp","line_count":3,"code":"else if (type == detail::EncodingType::Brotli) {\n\t\t\tres.set_header(\"Content-Encoding\", \"br\");\n\t\t  }","mark":8.0}
{"file_name":"httplib_function_26.cpp","line_count":27,"code":"string base64_encode(const std::string &in) {\n  static const auto lookup =\n\t  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/\";\n\n  std::string out;\n  out.reserve(in.size());\n\n  int val = 0;\n  int valb = -6;\n\n  for (auto c : in) {\n\tval = (val << 8) + static_cast<uint8_t>(c);\n\tvalb += 8;\n\twhile (valb >= 0) {\n\t  out.push_back(lookup[(val >> valb) & 0x3F]);\n\t  valb -= 6;\n\t}\n  }\n\n  if (valb > -6) { out.push_back(lookup[((val << 8) >> (valb + 8)) & 0x3F]); }\n\n  while (out.size() % 4) {\n\tout.push_back('=');\n  }\n\n  return out;\n}","mark":8.0}
{"file_name":"httplib_function_27.cpp","line_count":8,"code":"bool is_file(const std::string &path) {\n#if defined(_WIN32) && !defined(MINGW_SPECIFIC_HACKS)\n  return _access_s(path.c_str(), 0) == 0;\n#else\n  struct stat st;\n  return stat(path.c_str(), &st) >= 0 && S_ISREG(st.st_mode);\n#endif\n}","mark":8.0}
{"file_name":"httplib_function_28.cpp","line_count":4,"code":"bool is_dir(const std::string &path) {\n  struct stat st;\n  return stat(path.c_str(), &st) >= 0 && S_ISDIR(st.st_mode);\n}","mark":8.0}
{"file_name":"httplib_function_3.cpp","line_count":4,"code":"void hl__freeaddrinfo(struct addrinfo* ai)\n{\n\tasio::detail::socket_ops::freeaddrinfo(ai);\n}","mark":8.0}
{"file_name":"httplib_function_30.cpp","line_count":20,"code":"string encode_query_param(const std::string &value) {\n  std::ostringstream escaped;\n  escaped.fill('0');\n  escaped << std::hex;\n\n  for (auto c : value) {\n\tif (std::isalnum(static_cast<uint8_t>(c)) || c == '-' || c == '_' ||\n\t\tc == '.' || c == '!' || c == '~' || c == '*' || c == '\\'' || c == '(' ||\n\t\tc == ')') {\n\t  escaped << c;\n\t} else {\n\t  escaped << std::uppercase;\n\t  escaped << '%' << std::setw(2)\n\t\t\t  << static_cast<int>(static_cast<unsigned char>(c));\n\t  escaped << std::nouppercase;\n\t}\n  }\n\n  return escaped.str();\n}","mark":8.0}
{"file_name":"httplib_function_35.cpp","line_count":6,"code":"string file_extension(const std::string &path) {\n  std::smatch m;\n  static auto re = std::regex(\"\\\\.([a-zA-Z0-9]+)$\");\n  if (std::regex_search(path, m, re)) { return m[1].str(); }\n  return std::string();\n}","mark":8.0}
{"file_name":"httplib_function_36.cpp","line_count":1,"code":"bool is_space_or_tab(char c) { return c == ' ' || c == '\\t'; }","mark":9.0}
{"file_name":"httplib_function_39.cpp","line_count":7,"code":"int close_socket(socket_t sock) {\n#ifdef _WIN32\n  return closesocket(sock);\n#else\n  return close(sock);\n#endif\n}","mark":8.0}
{"file_name":"httplib_function_62.cpp","line_count":7,"code":"int shutdown_socket(socket_t sock) {\n#ifdef _WIN32\n  return shutdown(sock, SD_BOTH);\n#else\n  return shutdown(sock, SHUT_RDWR);\n#endif\n}","mark":8.0}
{"file_name":"httplib_function_67.cpp","line_count":10,"code":"void set_nonblocking(socket_t sock, bool nonblocking) {\n#ifdef _WIN32\n  auto flags = nonblocking ? 1UL : 0UL;\n  ioctlsocket(sock, FIONBIO, &flags);\n#else\n  auto flags = fcntl(sock, F_GETFL, 0);\n  fcntl(sock, F_SETFL,\n\t\tnonblocking ? (flags | O_NONBLOCK) : (flags & (~O_NONBLOCK)));\n#endif\n}","mark":8.0}
{"file_name":"httplib_function_82.cpp","line_count":3,"code":"bool has_header(const Headers &headers, const std::string &key) {\n  return headers.find(key) != headers.end();\n}","mark":8.0}
{"file_name":"httplib_function_9.cpp","line_count":4,"code":"streamsize xsputn(const char *s, std::streamsize n) {\n\t  sink_.write(s, static_cast<size_t>(n));\n\t  return n;\n\t}","mark":8.0}
{"file_name":"httplib_function_90.cpp","line_count":4,"code":"bool is_chunked_transfer_encoding(const Headers &headers) {\n  return !strcasecmp(get_header_value(headers, \"Transfer-Encoding\", 0, \"\"),\n\t\t\t\t\t \"chunked\");\n}","mark":8.0}
{"file_name":"httplib_function_94.cpp","line_count":13,"code":"ssize_t write_headers(Stream &strm, const Headers &headers) {\n  ssize_t write_len = 0;\n  for (const auto &x : headers) {\n\tauto len =\n\t\tstrm.write_format(\"%s: %s\\r\\n\", x.first.c_str(), x.second.c_str());\n\tif (len < 0) { return len; }\n\twrite_len += len;\n  }\n  auto len = strm.write(\"\\r\\n\");\n  if (len < 0) { return len; }\n  write_len += len;\n  return write_len;\n}","mark":8.0}
{"file_name":"httplib_function_95.cpp","line_count":9,"code":"bool write_data(Stream &strm, const char *d, size_t l) {\n  size_t offset = 0;\n  while (offset < l) {\n\tauto length = strm.write(d + offset, l - offset);\n\tif (length < 0) { return false; }\n\toffset += static_cast<size_t>(length);\n  }\n  return true;\n}","mark":8.0}
{"file_name":"hybi13_function_12.cpp","line_count":13,"code":"void reset_headers() {\n        m_state = HEADER_BASIC;\n        m_bytes_needed = frame::BASIC_HEADER_LENGTH;\n\n        m_basic_header.b0 = 0x00;\n        m_basic_header.b1 = 0x00;\n\n        std::fill_n(\n            m_extended_header.bytes,\n            frame::MAX_EXTENDED_HEADER_LENGTH,\n            0x00\n        );\n    }","mark":8.0}
{"file_name":"hybi13_function_20.cpp","line_count":9,"code":"size_t copy_extended_header_bytes(uint8_t const * buf, size_t len) {\n        size_t bytes_to_read = (std::min)(m_bytes_needed,len);\n\n        std::copy(buf,buf+bytes_to_read,m_extended_header.bytes+m_cursor);\n        m_cursor += bytes_to_read;\n        m_bytes_needed -= bytes_to_read;\n\n        return bytes_to_read;\n    }","mark":8.0}
{"file_name":"HybridObjectPrototype_function_1.cpp","line_count":7,"code":"void ensureInitialized() {\n    if (!_didLoadMethods) [[unlikely]] {\n      \/\/ lazy-load all exposed methods\n      loadHybridMethods();\n      _didLoadMethods = true;\n    }\n  }","mark":8.0}
{"file_name":"icu_function_2.cpp","line_count":10,"code":"size_type length(const char_type* p)\n   {\n      size_type result = 0;\n      while (*p)\n      {\n         ++p;\n         ++result;\n      }\n      return result;\n   }","mark":8.0}
{"file_name":"icu_function_57.cpp","line_count":4,"code":"BaseIterator extract_output_base(const utf8_output_iterator<BaseIterator>& b)\n{\n   return b.base();\n}","mark":8.0}
{"file_name":"icu_function_58.cpp","line_count":4,"code":"BaseIterator extract_output_base(const utf16_output_iterator<BaseIterator>& b)\n{\n   return b.base();\n}","mark":8.0}
{"file_name":"IFeature_function_1.cpp","line_count":1,"code":"void SetInit(bool InValue) { _isInited = InValue; }","mark":8.0}
{"file_name":"IFeature_function_2.cpp","line_count":1,"code":"int GetNextHandleId() { return handleCounter++; }","mark":8.0}
{"file_name":"IFeature_function_3.cpp","line_count":1,"code":"long FrameCount() { return _frameCount; }","mark":8.0}
{"file_name":"ImageFormat_function_2.cpp","line_count":9,"code":"Value toJSI(jsi::Runtime& runtime, ImageFormat arg) {\n      switch (arg) {\n        case ImageFormat::JPG: return JSIConverter<std::string>::toJSI(runtime, \"jpg\");\n        case ImageFormat::PNG: return JSIConverter<std::string>::toJSI(runtime, \"png\");\n        default: [[unlikely]]\n          throw std::invalid_argument(\"Cannot convert ImageFormat to JS - invalid value: \"\n                                    + std::to_string(static_cast<int>(arg)) + \"!\");\n      }\n    }","mark":8.5}
{"file_name":"ImageLoader_function_1.cpp","line_count":1,"code":"void NopFree(void* unused) {}","mark":8.0}
{"file_name":"ImageSize_function_2.cpp","line_count":6,"code":"Value toJSI(jsi::Runtime& runtime, const ImageSize& arg) {\n      jsi::Object obj(runtime);\n      obj.setProperty(runtime, \"width\", JSIConverter<double>::toJSI(runtime, arg.width));\n      obj.setProperty(runtime, \"height\", JSIConverter<double>::toJSI(runtime, arg.height));\n      return obj;\n    }","mark":8.0}
{"file_name":"ImageSize_function_3.cpp","line_count":9,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isObject()) {\n        return false;\n      }\n      jsi::Object obj = value.getObject(runtime);\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"width\"))) return false;\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"height\"))) return false;\n      return true;\n    }","mark":8.0}
{"file_name":"ImageViewer_function_1.cpp","line_count":6,"code":"void KillImageBitmaps()\n{\n\tif (g_hBitmapFull)    delete g_hBitmapFull;\n\tif (g_hBitmapPreview) delete g_hBitmapPreview;\n\tg_hBitmapFull = g_hBitmapPreview = NULL;\n}","mark":8.0}
{"file_name":"ImageViewer_function_12.cpp","line_count":9,"code":"void KillImageViewer()\n{\n\tif (!g_ivHwnd)\n\t\treturn;\n\n\tDestroyWindow(g_ivHwnd);\n\tg_ivHwnd = NULL;\n\tg_ivChildHwnd = NULL;\n}","mark":8.0}
{"file_name":"ImageViewer_function_13.cpp","line_count":5,"code":"void ImageViewerFinishSaveIfNeeded()\n{\n\tif (g_ivHwnd)\n\t\tSendMessage(g_ivHwnd, WM_IMAGESAVED, 0, 0);\n}","mark":8.0}
{"file_name":"ImageViewer_function_14.cpp","line_count":5,"code":"void ImageViewerClearSaveIfNeeded()\n{\n\tif (g_ivHwnd)\n\t\tSendMessage(g_ivHwnd, WM_IMAGECLEARSAVE, 0, 0);\n}","mark":8.0}
{"file_name":"ImageViewer_function_4.cpp","line_count":4,"code":"bool ImageViewerNeedScrollBars(int winWidth, int winHeight)\n{\n\treturn g_bChildZoomedIn && (g_ivWidth != winWidth || g_ivHeight != winHeight);\n}","mark":8.0}
{"file_name":"ImageViewer_function_8.cpp","line_count":4,"code":"void ImageViewerOnLoadNT(NetRequest* pRequest)\n{\n\tSendMessage(g_ivHwnd, WM_REQUESTDONE, 0, (LPARAM)pRequest);\n}","mark":8.0}
{"file_name":"ImguiSpdLog_function_2.cpp","line_count":13,"code":"void ClearLogBuffers(IN bool DisableLock = false)\n\t{\n\t\tif (!DisableLock)\n\t\t\tsink_t::mutex_.lock();\n\n\t\tLoggedContent.clear();\n\t\tLogMetaData.clear();\n\t\tNumberOfLogEntries = 0;\n\t\tIndicesInBytes = 0;\n\n\t\tif (!DisableLock)\n\t\t\tsink_t::mutex_.unlock();\n\t}","mark":8.0}
{"file_name":"imgui_common_function_1.cpp","line_count":1,"code":"void Dx11Inited() { _dx11Ready = true; }","mark":8.0}
{"file_name":"imgui_common_function_2.cpp","line_count":1,"code":"void Dx12Inited() { _dx12Ready = true; }","mark":8.0}
{"file_name":"imgui_common_function_3.cpp","line_count":1,"code":"void VulkanInited() { _vulkanReady = true; }","mark":8.0}
{"file_name":"imgui_common_function_4.cpp","line_count":1,"code":"bool IsInited() { return _isInited; }","mark":8.0}
{"file_name":"imgui_common_function_5.cpp","line_count":1,"code":"bool IsVisible() { return _isVisible; }","mark":8.0}
{"file_name":"imgui_common_function_6.cpp","line_count":1,"code":"bool IsResetRequested() { return _isResetRequested; }","mark":9.0}
{"file_name":"imgui_common_function_7.cpp","line_count":1,"code":"HWND Handle() { return _handle; }","mark":8.0}
{"file_name":"imgui_demo_function_1.cpp","line_count":11,"code":"void HelpMarker(const char* desc)\n{\n    ImGui::TextDisabled(\"(?)\");\n    if (ImGui::BeginItemTooltip())\n    {\n        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);\n        ImGui::TextUnformatted(desc);\n        ImGui::PopTextWrapPos();\n        ImGui::EndTooltip();\n    }\n}","mark":8.0}
{"file_name":"imgui_demo_function_103.cpp","line_count":9,"code":"void NotifyOfDocumentsClosedElsewhere()\n    {\n        for (MyDocument& doc : Documents)\n        {\n            if (!doc.Open && doc.OpenPrev)\n                ImGui::SetTabItemClosed(doc.Name);\n            doc.OpenPrev = doc.Open;\n        }\n    }","mark":8.0}
{"file_name":"imgui_demo_function_112.cpp","line_count":5,"code":"void ClearItems()\n    {\n        Items.clear();\n        Selection.Clear();\n    }","mark":8.0}
{"file_name":"imgui_demo_function_117.cpp","line_count":6,"code":"void ShowExampleAppAssetsBrowser(bool* p_open)\n{\n    IMGUI_DEMO_MARKER(\"Examples\/Assets Browser\");\n    static ExampleAssetsBrowser assets_browser;\n    assets_browser.Draw(\"Example: Assets Browser\", p_open);\n}","mark":8.0}
{"file_name":"imgui_demo_function_13.cpp","line_count":11,"code":"int MyResizeCallback(ImGuiInputTextCallbackData* data)\n                {\n                    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)\n                    {\n                        ImVector<char>* my_str = (ImVector<char>*)data->UserData;\n                        IM_ASSERT(my_str->begin() == data->Buf);\n                        my_str->resize(data->BufSize); \/\/ NB: On resizing calls, generally data->BufSize == data->BufTextLen + 1\n                        data->Buf = my_str->begin();\n                    }\n                    return 0;\n                }","mark":8.0}
{"file_name":"imgui_demo_function_2.cpp","line_count":63,"code":"void ShowDemoWindowMenuBar(ImGuiDemoWindowData* demo_data)\n{\n    IMGUI_DEMO_MARKER(\"Menu\");\n    if (ImGui::BeginMenuBar())\n    {\n        if (ImGui::BeginMenu(\"Menu\"))\n        {\n            IMGUI_DEMO_MARKER(\"Menu\/File\");\n            ShowExampleMenuFile();\n            ImGui::EndMenu();\n        }\n        if (ImGui::BeginMenu(\"Examples\"))\n        {\n            IMGUI_DEMO_MARKER(\"Menu\/Examples\");\n            ImGui::MenuItem(\"Main menu bar\", NULL, &demo_data->ShowMainMenuBar);\n\n            ImGui::SeparatorText(\"Mini apps\");\n            ImGui::MenuItem(\"Assets Browser\", NULL, &demo_data->ShowAppAssetsBrowser);\n            ImGui::MenuItem(\"Console\", NULL, &demo_data->ShowAppConsole);\n            ImGui::MenuItem(\"Custom rendering\", NULL, &demo_data->ShowAppCustomRendering);\n            ImGui::MenuItem(\"Documents\", NULL, &demo_data->ShowAppDocuments);\n            ImGui::MenuItem(\"Log\", NULL, &demo_data->ShowAppLog);\n            ImGui::MenuItem(\"Property editor\", NULL, &demo_data->ShowAppPropertyEditor);\n            ImGui::MenuItem(\"Simple layout\", NULL, &demo_data->ShowAppLayout);\n            ImGui::MenuItem(\"Simple overlay\", NULL, &demo_data->ShowAppSimpleOverlay);\n\n            ImGui::SeparatorText(\"Concepts\");\n            ImGui::MenuItem(\"Auto-resizing window\", NULL, &demo_data->ShowAppAutoResize);\n            ImGui::MenuItem(\"Constrained-resizing window\", NULL, &demo_data->ShowAppConstrainedResize);\n            ImGui::MenuItem(\"Fullscreen window\", NULL, &demo_data->ShowAppFullscreen);\n            ImGui::MenuItem(\"Long text display\", NULL, &demo_data->ShowAppLongText);\n            ImGui::MenuItem(\"Manipulating window titles\", NULL, &demo_data->ShowAppWindowTitles);\n\n            ImGui::EndMenu();\n        }\n        \/\/if (ImGui::MenuItem(\"MenuItem\")) {} \/\/ You can also use MenuItem() inside a menu bar!\n        if (ImGui::BeginMenu(\"Tools\"))\n        {\n            IMGUI_DEMO_MARKER(\"Menu\/Tools\");\n            ImGuiIO& io = ImGui::GetIO();\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n            const bool has_debug_tools = true;\n#else\n            const bool has_debug_tools = false;\n#endif\n            ImGui::MenuItem(\"Metrics\/Debugger\", NULL, &demo_data->ShowMetrics, has_debug_tools);\n            ImGui::MenuItem(\"Debug Log\", NULL, &demo_data->ShowDebugLog, has_debug_tools);\n            ImGui::MenuItem(\"ID Stack Tool\", NULL, &demo_data->ShowIDStackTool, has_debug_tools);\n            bool is_debugger_present = io.ConfigDebugIsDebuggerPresent;\n            if (ImGui::MenuItem(\"Item Picker\", NULL, false, has_debug_tools && is_debugger_present))\n                ImGui::DebugStartItemPicker();\n            if (!is_debugger_present)\n                ImGui::SetItemTooltip(\"Requires io.ConfigDebugIsDebuggerPresent=true to be set.\\n\\nWe otherwise disable the menu option to avoid casual users crashing the application.\\n\\nYou can however always access the Item Picker in Metrics->Tools.\");\n            ImGui::MenuItem(\"Style Editor\", NULL, &demo_data->ShowStyleEditor);\n            ImGui::MenuItem(\"About Dear ImGui\", NULL, &demo_data->ShowAbout);\n\n            ImGui::SeparatorText(\"Debug Options\");\n            ImGui::MenuItem(\"Highlight ID Conflicts\", NULL, &io.ConfigDebugHighlightIdConflicts, has_debug_tools);\n            ImGui::EndMenu();\n        }\n        ImGui::EndMenuBar();\n    }\n}","mark":8.0}
{"file_name":"imgui_demo_function_45.cpp","line_count":297,"code":"void ShowDemoWindowPopups()\n{\n    IMGUI_DEMO_MARKER(\"Popups\");\n    if (!ImGui::CollapsingHeader(\"Popups & Modal windows\"))\n        return;\n\n    \/\/ The properties of popups windows are:\n    \/\/ - They block normal mouse hovering detection outside them. (*)\n    \/\/ - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.\n    \/\/ - Their visibility state (~bool) is held internally by Dear ImGui instead of being held by the programmer as\n    \/\/   we are used to with regular Begin() calls. User can manipulate the visibility state by calling OpenPopup().\n    \/\/ (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even\n    \/\/     when normally blocked by a popup.\n    \/\/ Those three properties are connected. The library needs to hold their visibility state BECAUSE it can close\n    \/\/ popups at any time.\n\n    \/\/ Typical use for regular windows:\n    \/\/   bool my_tool_is_active = false; if (ImGui::Button(\"Open\")) my_tool_is_active = true; [...] if (my_tool_is_active) Begin(\"My Tool\", &my_tool_is_active) { [...] } End();\n    \/\/ Typical use for popups:\n    \/\/   if (ImGui::Button(\"Open\")) ImGui::OpenPopup(\"MyPopup\"); if (ImGui::BeginPopup(\"MyPopup\") { [...] EndPopup(); }\n\n    \/\/ With popups we have to go through a library call (here OpenPopup) to manipulate the visibility state.\n    \/\/ This may be a bit confusing at first but it should quickly make sense. Follow on the examples below.\n\n    IMGUI_DEMO_MARKER(\"Popups\/Popups\");\n    if (ImGui::TreeNode(\"Popups\"))\n    {\n        ImGui::TextWrapped(\n            \"When a popup is active, it inhibits interacting with windows that are behind the popup. \"\n            \"Clicking outside the popup closes it.\");\n\n        static int selected_fish = -1;\n        const char* names[] = { \"Bream\", \"Haddock\", \"Mackerel\", \"Pollock\", \"Tilefish\" };\n        static bool toggles[] = { true, false, false, false, false };\n\n        \/\/ Simple selection popup (if you want to show the current selection inside the Button itself,\n        \/\/ you may want to build a string using the \"###\" operator to preserve a constant ID with a variable label)\n        if (ImGui::Button(\"Select..\"))\n            ImGui::OpenPopup(\"my_select_popup\");\n        ImGui::SameLine();\n        ImGui::TextUnformatted(selected_fish == -1 ? \"<None>\" : names[selected_fish]);\n        if (ImGui::BeginPopup(\"my_select_popup\"))\n        {\n            ImGui::SeparatorText(\"Aquarium\");\n            for (int i = 0; i < IM_ARRAYSIZE(names); i++)\n                if (ImGui::Selectable(names[i]))\n                    selected_fish = i;\n            ImGui::EndPopup();\n        }\n\n        \/\/ Showing a menu with toggles\n        if (ImGui::Button(\"Toggle..\"))\n            ImGui::OpenPopup(\"my_toggle_popup\");\n        if (ImGui::BeginPopup(\"my_toggle_popup\"))\n        {\n            for (int i = 0; i < IM_ARRAYSIZE(names); i++)\n                ImGui::MenuItem(names[i], \"\", &toggles[i]);\n            if (ImGui::BeginMenu(\"Sub-menu\"))\n            {\n                ImGui::MenuItem(\"Click me\");\n                ImGui::EndMenu();\n            }\n\n            ImGui::Separator();\n            ImGui::Text(\"Tooltip here\");\n            ImGui::SetItemTooltip(\"I am a tooltip over a popup\");\n\n            if (ImGui::Button(\"Stacked Popup\"))\n                ImGui::OpenPopup(\"another popup\");\n            if (ImGui::BeginPopup(\"another popup\"))\n            {\n                for (int i = 0; i < IM_ARRAYSIZE(names); i++)\n                    ImGui::MenuItem(names[i], \"\", &toggles[i]);\n                if (ImGui::BeginMenu(\"Sub-menu\"))\n                {\n                    ImGui::MenuItem(\"Click me\");\n                    if (ImGui::Button(\"Stacked Popup\"))\n                        ImGui::OpenPopup(\"another popup\");\n                    if (ImGui::BeginPopup(\"another popup\"))\n                    {\n                        ImGui::Text(\"I am the last one here.\");\n                        ImGui::EndPopup();\n                    }\n                    ImGui::EndMenu();\n                }\n                ImGui::EndPopup();\n            }\n            ImGui::EndPopup();\n        }\n\n        \/\/ Call the more complete ShowExampleMenuFile which we use in various places of this demo\n        if (ImGui::Button(\"With a menu..\"))\n            ImGui::OpenPopup(\"my_file_popup\");\n        if (ImGui::BeginPopup(\"my_file_popup\", ImGuiWindowFlags_MenuBar))\n        {\n            if (ImGui::BeginMenuBar())\n            {\n                if (ImGui::BeginMenu(\"File\"))\n                {\n                    ShowExampleMenuFile();\n                    ImGui::EndMenu();\n                }\n                if (ImGui::BeginMenu(\"Edit\"))\n                {\n                    ImGui::MenuItem(\"Dummy\");\n                    ImGui::EndMenu();\n                }\n                ImGui::EndMenuBar();\n            }\n            ImGui::Text(\"Hello from popup!\");\n            ImGui::Button(\"This is a dummy button..\");\n            ImGui::EndPopup();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Popups\/Context menus\");\n    if (ImGui::TreeNode(\"Context menus\"))\n    {\n        HelpMarker(\"\\\"Context\\\" functions are simple helpers to associate a Popup to a given Item or Window identifier.\");\n\n        \/\/ BeginPopupContextItem() is a helper to provide common\/simple popup behavior of essentially doing:\n        \/\/     if (id == 0)\n        \/\/         id = GetItemID(); \/\/ Use last item id\n        \/\/     if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))\n        \/\/         OpenPopup(id);\n        \/\/     return BeginPopup(id);\n        \/\/ For advanced uses you may want to replicate and customize this code.\n        \/\/ See more details in BeginPopupContextItem().\n\n        \/\/ Example 1\n        \/\/ When used after an item that has an ID (e.g. Button), we can skip providing an ID to BeginPopupContextItem(),\n        \/\/ and BeginPopupContextItem() will use the last item ID as the popup ID.\n        {\n            const char* names[5] = { \"Label1\", \"Label2\", \"Label3\", \"Label4\", \"Label5\" };\n            static int selected = -1;\n            for (int n = 0; n < 5; n++)\n            {\n                if (ImGui::Selectable(names[n], selected == n))\n                    selected = n;\n                if (ImGui::BeginPopupContextItem()) \/\/ <-- use last item id as popup id\n                {\n                    selected = n;\n                    ImGui::Text(\"This a popup for \\\"%s\\\"!\", names[n]);\n                    if (ImGui::Button(\"Close\"))\n                        ImGui::CloseCurrentPopup();\n                    ImGui::EndPopup();\n                }\n                ImGui::SetItemTooltip(\"Right-click to open popup\");\n            }\n        }\n\n        \/\/ Example 2\n        \/\/ Popup on a Text() element which doesn't have an identifier: we need to provide an identifier to BeginPopupContextItem().\n        \/\/ Using an explicit identifier is also convenient if you want to activate the popups from different locations.\n        {\n            HelpMarker(\"Text() elements don't have stable identifiers so we need to provide one.\");\n            static float value = 0.5f;\n            ImGui::Text(\"Value = %.3f <-- (1) right-click this text\", value);\n            if (ImGui::BeginPopupContextItem(\"my popup\"))\n            {\n                if (ImGui::Selectable(\"Set to zero\")) value = 0.0f;\n                if (ImGui::Selectable(\"Set to PI\")) value = 3.1415f;\n                ImGui::SetNextItemWidth(-FLT_MIN);\n                ImGui::DragFloat(\"##Value\", &value, 0.1f, 0.0f, 0.0f);\n                ImGui::EndPopup();\n            }\n\n            \/\/ We can also use OpenPopupOnItemClick() to toggle the visibility of a given popup.\n            \/\/ Here we make it that right-clicking this other text element opens the same popup as above.\n            \/\/ The popup itself will be submitted by the code above.\n            ImGui::Text(\"(2) Or right-click this text\");\n            ImGui::OpenPopupOnItemClick(\"my popup\", ImGuiPopupFlags_MouseButtonRight);\n\n            \/\/ Back to square one: manually open the same popup.\n            if (ImGui::Button(\"(3) Or click this button\"))\n                ImGui::OpenPopup(\"my popup\");\n        }\n\n        \/\/ Example 3\n        \/\/ When using BeginPopupContextItem() with an implicit identifier (NULL == use last item ID),\n        \/\/ we need to make sure your item identifier is stable.\n        \/\/ In this example we showcase altering the item label while preserving its identifier, using the ### operator (see FAQ).\n        {\n            HelpMarker(\"Showcase using a popup ID linked to item ID, with the item having a changing label + stable ID using the ### operator.\");\n            static char name[32] = \"Label1\";\n            char buf[64];\n            sprintf(buf, \"Button: %s###Button\", name); \/\/ ### operator override ID ignoring the preceding label\n            ImGui::Button(buf);\n            if (ImGui::BeginPopupContextItem())\n            {\n                ImGui::Text(\"Edit name:\");\n                ImGui::InputText(\"##edit\", name, IM_ARRAYSIZE(name));\n                if (ImGui::Button(\"Close\"))\n                    ImGui::CloseCurrentPopup();\n                ImGui::EndPopup();\n            }\n            ImGui::SameLine(); ImGui::Text(\"(<-- right-click here)\");\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Popups\/Modals\");\n    if (ImGui::TreeNode(\"Modals\"))\n    {\n        ImGui::TextWrapped(\"Modal windows are like popups but the user cannot close them by clicking outside.\");\n\n        if (ImGui::Button(\"Delete..\"))\n            ImGui::OpenPopup(\"Delete?\");\n\n        \/\/ Always center this window when appearing\n        ImVec2 center = ImGui::GetMainViewport()->GetCenter();\n        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));\n\n        if (ImGui::BeginPopupModal(\"Delete?\", NULL, ImGuiWindowFlags_AlwaysAutoResize))\n        {\n            ImGui::Text(\"All those beautiful files will be deleted.\\nThis operation cannot be undone!\");\n            ImGui::Separator();\n\n            \/\/static int unused_i = 0;\n            \/\/ImGui::Combo(\"Combo\", &unused_i, \"Delete\\0Delete harder\\0\");\n\n            static bool dont_ask_me_next_time = false;\n            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));\n            ImGui::Checkbox(\"Don't ask me next time\", &dont_ask_me_next_time);\n            ImGui::PopStyleVar();\n\n            if (ImGui::Button(\"OK\", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }\n            ImGui::SetItemDefaultFocus();\n            ImGui::SameLine();\n            if (ImGui::Button(\"Cancel\", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }\n            ImGui::EndPopup();\n        }\n\n        if (ImGui::Button(\"Stacked modals..\"))\n            ImGui::OpenPopup(\"Stacked 1\");\n        if (ImGui::BeginPopupModal(\"Stacked 1\", NULL, ImGuiWindowFlags_MenuBar))\n        {\n            if (ImGui::BeginMenuBar())\n            {\n                if (ImGui::BeginMenu(\"File\"))\n                {\n                    if (ImGui::MenuItem(\"Some menu item\")) {}\n                    ImGui::EndMenu();\n                }\n                ImGui::EndMenuBar();\n            }\n            ImGui::Text(\"Hello from Stacked The First\\nUsing style.Colors[ImGuiCol_ModalWindowDimBg] behind it.\");\n\n            \/\/ Testing behavior of widgets stacking their own regular popups over the modal.\n            static int item = 1;\n            static float color[4] = { 0.4f, 0.7f, 0.0f, 0.5f };\n            ImGui::Combo(\"Combo\", &item, \"aaaa\\0bbbb\\0cccc\\0dddd\\0eeee\\0\\0\");\n            ImGui::ColorEdit4(\"Color\", color);\n\n            if (ImGui::Button(\"Add another modal..\"))\n                ImGui::OpenPopup(\"Stacked 2\");\n\n            \/\/ Also demonstrate passing a bool* to BeginPopupModal(), this will create a regular close button which\n            \/\/ will close the popup. Note that the visibility state of popups is owned by imgui, so the input value\n            \/\/ of the bool actually doesn't matter here.\n            bool unused_open = true;\n            if (ImGui::BeginPopupModal(\"Stacked 2\", &unused_open))\n            {\n                ImGui::Text(\"Hello from Stacked The Second!\");\n                ImGui::ColorEdit4(\"Color\", color); \/\/ Allow opening another nested popup\n                if (ImGui::Button(\"Close\"))\n                    ImGui::CloseCurrentPopup();\n                ImGui::EndPopup();\n            }\n\n            if (ImGui::Button(\"Close\"))\n                ImGui::CloseCurrentPopup();\n            ImGui::EndPopup();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Popups\/Menus inside a regular window\");\n    if (ImGui::TreeNode(\"Menus inside a regular window\"))\n    {\n        ImGui::TextWrapped(\"Below we are testing adding menu items to a regular window. It's rather unusual but should work!\");\n        ImGui::Separator();\n\n        ImGui::MenuItem(\"Menu item\", \"CTRL+M\");\n        if (ImGui::BeginMenu(\"Menu inside a regular window\"))\n        {\n            ShowExampleMenuFile();\n            ImGui::EndMenu();\n        }\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n}","mark":8.5}
{"file_name":"imgui_demo_function_49.cpp","line_count":4,"code":"void PopStyleCompact()\n{\n    ImGui::PopStyleVar(2);\n}","mark":8.0}
{"file_name":"imgui_demo_function_52.cpp","line_count":7,"code":"void ShowTableColumnsStatusFlags(ImGuiTableColumnFlags flags)\n{\n    ImGui::CheckboxFlags(\"_IsEnabled\", &flags, ImGuiTableColumnFlags_IsEnabled);\n    ImGui::CheckboxFlags(\"_IsVisible\", &flags, ImGuiTableColumnFlags_IsVisible);\n    ImGui::CheckboxFlags(\"_IsSorted\", &flags, ImGuiTableColumnFlags_IsSorted);\n    ImGui::CheckboxFlags(\"_IsHovered\", &flags, ImGuiTableColumnFlags_IsHovered);\n}","mark":8.0}
{"file_name":"imgui_demo_function_59.cpp","line_count":205,"code":"void ShowDemoWindowColumns()\n{\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\");\n    bool open = ImGui::TreeNode(\"Legacy Columns API\");\n    ImGui::SameLine();\n    HelpMarker(\"Columns() is an old API! Prefer using the more flexible and powerful BeginTable() API!\");\n    if (!open)\n        return;\n\n    \/\/ Basic columns\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Basic\");\n    if (ImGui::TreeNode(\"Basic\"))\n    {\n        ImGui::Text(\"Without border:\");\n        ImGui::Columns(3, \"mycolumns3\", false);  \/\/ 3-ways, no border\n        ImGui::Separator();\n        for (int n = 0; n < 14; n++)\n        {\n            char label[32];\n            sprintf(label, \"Item %d\", n);\n            if (ImGui::Selectable(label)) {}\n            \/\/if (ImGui::Button(label, ImVec2(-FLT_MIN,0.0f))) {}\n            ImGui::NextColumn();\n        }\n        ImGui::Columns(1);\n        ImGui::Separator();\n\n        ImGui::Text(\"With border:\");\n        ImGui::Columns(4, \"mycolumns\"); \/\/ 4-ways, with border\n        ImGui::Separator();\n        ImGui::Text(\"ID\"); ImGui::NextColumn();\n        ImGui::Text(\"Name\"); ImGui::NextColumn();\n        ImGui::Text(\"Path\"); ImGui::NextColumn();\n        ImGui::Text(\"Hovered\"); ImGui::NextColumn();\n        ImGui::Separator();\n        const char* names[3] = { \"One\", \"Two\", \"Three\" };\n        const char* paths[3] = { \"\/path\/one\", \"\/path\/two\", \"\/path\/three\" };\n        static int selected = -1;\n        for (int i = 0; i < 3; i++)\n        {\n            char label[32];\n            sprintf(label, \"%04d\", i);\n            if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))\n                selected = i;\n            bool hovered = ImGui::IsItemHovered();\n            ImGui::NextColumn();\n            ImGui::Text(names[i]); ImGui::NextColumn();\n            ImGui::Text(paths[i]); ImGui::NextColumn();\n            ImGui::Text(\"%d\", hovered); ImGui::NextColumn();\n        }\n        ImGui::Columns(1);\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Borders\");\n    if (ImGui::TreeNode(\"Borders\"))\n    {\n        \/\/ NB: Future columns API should allow automatic horizontal borders.\n        static bool h_borders = true;\n        static bool v_borders = true;\n        static int columns_count = 4;\n        const int lines_count = 3;\n        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n        ImGui::DragInt(\"##columns_count\", &columns_count, 0.1f, 2, 10, \"%d columns\");\n        if (columns_count < 2)\n            columns_count = 2;\n        ImGui::SameLine();\n        ImGui::Checkbox(\"horizontal\", &h_borders);\n        ImGui::SameLine();\n        ImGui::Checkbox(\"vertical\", &v_borders);\n        ImGui::Columns(columns_count, NULL, v_borders);\n        for (int i = 0; i < columns_count * lines_count; i++)\n        {\n            if (h_borders && ImGui::GetColumnIndex() == 0)\n                ImGui::Separator();\n            ImGui::PushID(i);\n            ImGui::Text(\"%c%c%c\", 'a' + i, 'a' + i, 'a' + i);\n            ImGui::Text(\"Width %.2f\", ImGui::GetColumnWidth());\n            ImGui::Text(\"Avail %.2f\", ImGui::GetContentRegionAvail().x);\n            ImGui::Text(\"Offset %.2f\", ImGui::GetColumnOffset());\n            ImGui::Text(\"Long text that is likely to clip\");\n            ImGui::Button(\"Button\", ImVec2(-FLT_MIN, 0.0f));\n            ImGui::PopID();\n            ImGui::NextColumn();\n        }\n        ImGui::Columns(1);\n        if (h_borders)\n            ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    \/\/ Create multiple items in a same cell before switching to next column\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Mixed items\");\n    if (ImGui::TreeNode(\"Mixed items\"))\n    {\n        ImGui::Columns(3, \"mixed\");\n        ImGui::Separator();\n\n        ImGui::Text(\"Hello\");\n        ImGui::Button(\"Banana\");\n        ImGui::NextColumn();\n\n        ImGui::Text(\"ImGui\");\n        ImGui::Button(\"Apple\");\n        static float foo = 1.0f;\n        ImGui::InputFloat(\"red\", &foo, 0.05f, 0, \"%.3f\");\n        ImGui::Text(\"An extra line here.\");\n        ImGui::NextColumn();\n\n        ImGui::Text(\"Sailor\");\n        ImGui::Button(\"Corniflower\");\n        static float bar = 1.0f;\n        ImGui::InputFloat(\"blue\", &bar, 0.05f, 0, \"%.3f\");\n        ImGui::NextColumn();\n\n        if (ImGui::CollapsingHeader(\"Category A\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\n        if (ImGui::CollapsingHeader(\"Category B\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\n        if (ImGui::CollapsingHeader(\"Category C\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\n        ImGui::Columns(1);\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    \/\/ Word wrapping\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Word-wrapping\");\n    if (ImGui::TreeNode(\"Word-wrapping\"))\n    {\n        ImGui::Columns(2, \"word-wrapping\");\n        ImGui::Separator();\n        ImGui::TextWrapped(\"The quick brown fox jumps over the lazy dog.\");\n        ImGui::TextWrapped(\"Hello Left\");\n        ImGui::NextColumn();\n        ImGui::TextWrapped(\"The quick brown fox jumps over the lazy dog.\");\n        ImGui::TextWrapped(\"Hello Right\");\n        ImGui::Columns(1);\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Horizontal Scrolling\");\n    if (ImGui::TreeNode(\"Horizontal Scrolling\"))\n    {\n        ImGui::SetNextWindowContentSize(ImVec2(1500.0f, 0.0f));\n        ImVec2 child_size = ImVec2(0, ImGui::GetFontSize() * 20.0f);\n        ImGui::BeginChild(\"##ScrollingRegion\", child_size, ImGuiChildFlags_None, ImGuiWindowFlags_HorizontalScrollbar);\n        ImGui::Columns(10);\n\n        \/\/ Also demonstrate using clipper for large vertical lists\n        int ITEMS_COUNT = 2000;\n        ImGuiListClipper clipper;\n        clipper.Begin(ITEMS_COUNT);\n        while (clipper.Step())\n        {\n            for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n                for (int j = 0; j < 10; j++)\n                {\n                    ImGui::Text(\"Line %d Column %d...\", i, j);\n                    ImGui::NextColumn();\n                }\n        }\n        ImGui::Columns(1);\n        ImGui::EndChild();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Tree\");\n    if (ImGui::TreeNode(\"Tree\"))\n    {\n        ImGui::Columns(2, \"tree\", true);\n        for (int x = 0; x < 3; x++)\n        {\n            bool open1 = ImGui::TreeNode((void*)(intptr_t)x, \"Node%d\", x);\n            ImGui::NextColumn();\n            ImGui::Text(\"Node contents\");\n            ImGui::NextColumn();\n            if (open1)\n            {\n                for (int y = 0; y < 3; y++)\n                {\n                    bool open2 = ImGui::TreeNode((void*)(intptr_t)y, \"Node%d.%d\", x, y);\n                    ImGui::NextColumn();\n                    ImGui::Text(\"Node contents\");\n                    if (open2)\n                    {\n                        ImGui::Text(\"Even more contents\");\n                        if (ImGui::TreeNode(\"Tree in column\"))\n                        {\n                            ImGui::Text(\"The quick brown fox jumps over the lazy dog\");\n                            ImGui::TreePop();\n                        }\n                    }\n                    ImGui::NextColumn();\n                    if (open2)\n                        ImGui::TreePop();\n                }\n                ImGui::TreePop();\n            }\n        }\n        ImGui::Columns(1);\n        ImGui::TreePop();\n    }\n\n    ImGui::TreePop();\n}","mark":8.0}
{"file_name":"imgui_demo_function_62.cpp","line_count":1,"code":"bool IsLegacyNativeDupe(ImGuiKey key) { return key >= 0 && key < 512 && ImGui::GetIO().KeyMap[key] != -1; }","mark":8.0}
{"file_name":"imgui_demo_function_63.cpp","line_count":22,"code":"void ShowExampleAppMainMenuBar()\n{\n    if (ImGui::BeginMainMenuBar())\n    {\n        if (ImGui::BeginMenu(\"File\"))\n        {\n            ShowExampleMenuFile();\n            ImGui::EndMenu();\n        }\n        if (ImGui::BeginMenu(\"Edit\"))\n        {\n            if (ImGui::MenuItem(\"Undo\", \"CTRL+Z\")) {}\n            if (ImGui::MenuItem(\"Redo\", \"CTRL+Y\", false, false)) {}  \/\/ Disabled item\n            ImGui::Separator();\n            if (ImGui::MenuItem(\"Cut\", \"CTRL+X\")) {}\n            if (ImGui::MenuItem(\"Copy\", \"CTRL+C\")) {}\n            if (ImGui::MenuItem(\"Paste\", \"CTRL+V\")) {}\n            ImGui::EndMenu();\n        }\n        ImGui::EndMainMenuBar();\n    }\n}","mark":8.0}
{"file_name":"imgui_demo_function_71.cpp","line_count":5,"code":"int TextEditCallbackStub(ImGuiInputTextCallbackData* data)\n    {\n        ExampleAppConsole* console = (ExampleAppConsole*)data->UserData;\n        return console->TextEditCallback(data);\n    }","mark":8.0}
{"file_name":"imgui_demo_function_76.cpp","line_count":6,"code":"void    Clear()\n    {\n        Buf.clear();\n        LineOffsets.clear();\n        LineOffsets.push_back(0);\n    }","mark":8.0}
{"file_name":"imgui_demo_function_86.cpp","line_count":19,"code":"void ShowExampleAppAutoResize(bool* p_open)\n{\n    if (!ImGui::Begin(\"Example: Auto-resizing window\", p_open, ImGuiWindowFlags_AlwaysAutoResize))\n    {\n        ImGui::End();\n        return;\n    }\n    IMGUI_DEMO_MARKER(\"Examples\/Auto-resizing window\");\n\n    static int lines = 10;\n    ImGui::TextUnformatted(\n        \"Window will resize every-frame to the size of its content.\\n\"\n        \"Note that you probably don't want to query the window size to\\n\"\n        \"output your content because that would create a feedback loop.\");\n    ImGui::SliderInt(\"Number of lines\", &lines, 1, 20);\n    for (int i = 0; i < lines; i++)\n        ImGui::Text(\"%*sThis is line %d\", i * 4, \"\", i); \/\/ Pad with space to extend size horizontally\n    ImGui::End();\n}","mark":8.0}
{"file_name":"imgui_demo_function_89.cpp","line_count":4,"code":"void Square(ImGuiSizeCallbackData* data)\n        {\n            data->DesiredSize.x = data->DesiredSize.y = IM_MAX(data->DesiredSize.x, data->DesiredSize.y);\n        }","mark":8.0}
{"file_name":"imgui_demo_function_93.cpp","line_count":30,"code":"void ShowExampleAppFullscreen(bool* p_open)\n{\n    static bool use_work_area = true;\n    static ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings;\n\n    \/\/ We demonstrate using the full viewport area or the work area (without menu-bars, task-bars etc.)\n    \/\/ Based on your use case you may want one or the other.\n    const ImGuiViewport* viewport = ImGui::GetMainViewport();\n    ImGui::SetNextWindowPos(use_work_area ? viewport->WorkPos : viewport->Pos);\n    ImGui::SetNextWindowSize(use_work_area ? viewport->WorkSize : viewport->Size);\n\n    if (ImGui::Begin(\"Example: Fullscreen window\", p_open, flags))\n    {\n        ImGui::Checkbox(\"Use work area instead of main area\", &use_work_area);\n        ImGui::SameLine();\n        HelpMarker(\"Main Area = entire viewport,\\nWork Area = entire viewport minus sections used by the main menu bars, task bars etc.\\n\\nEnable the main-menu bar in Examples menu to see the difference.\");\n\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoBackground\", &flags, ImGuiWindowFlags_NoBackground);\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoDecoration\", &flags, ImGuiWindowFlags_NoDecoration);\n        ImGui::Indent();\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoTitleBar\", &flags, ImGuiWindowFlags_NoTitleBar);\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoCollapse\", &flags, ImGuiWindowFlags_NoCollapse);\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoScrollbar\", &flags, ImGuiWindowFlags_NoScrollbar);\n        ImGui::Unindent();\n\n        if (p_open && ImGui::Button(\"Close this window\"))\n            *p_open = false;\n    }\n    ImGui::End();\n}","mark":8.0}
{"file_name":"imgui_demo_function_96.cpp","line_count":300,"code":"void ShowExampleAppCustomRendering(bool* p_open)\n{\n    if (!ImGui::Begin(\"Example: Custom rendering\", p_open))\n    {\n        ImGui::End();\n        return;\n    }\n    IMGUI_DEMO_MARKER(\"Examples\/Custom Rendering\");\n\n    \/\/ Tip: If you do a lot of custom rendering, you probably want to use your own geometrical types and benefit of\n    \/\/ overloaded operators, etc. Define IM_VEC2_CLASS_EXTRA in imconfig.h to create implicit conversions between your\n    \/\/ types and ImVec2\/ImVec4. Dear ImGui defines overloaded operators but they are internal to imgui.cpp and not\n    \/\/ exposed outside (to avoid messing with your types) In this example we are not using the maths operators!\n\n    if (ImGui::BeginTabBar(\"##TabBar\"))\n    {\n        if (ImGui::BeginTabItem(\"Primitives\"))\n        {\n            ImGui::PushItemWidth(-ImGui::GetFontSize() * 15);\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n\n            \/\/ Draw gradients\n            \/\/ (note that those are currently exacerbating our sRGB\/Linear issues)\n            \/\/ Calling ImGui::GetColorU32() multiplies the given colors by the current Style Alpha, but you may pass the IM_COL32() directly as well..\n            ImGui::Text(\"Gradients\");\n            ImVec2 gradient_size = ImVec2(ImGui::CalcItemWidth(), ImGui::GetFrameHeight());\n            {\n                ImVec2 p0 = ImGui::GetCursorScreenPos();\n                ImVec2 p1 = ImVec2(p0.x + gradient_size.x, p0.y + gradient_size.y);\n                ImU32 col_a = ImGui::GetColorU32(IM_COL32(0, 0, 0, 255));\n                ImU32 col_b = ImGui::GetColorU32(IM_COL32(255, 255, 255, 255));\n                draw_list->AddRectFilledMultiColor(p0, p1, col_a, col_b, col_b, col_a);\n                ImGui::InvisibleButton(\"##gradient1\", gradient_size);\n            }\n            {\n                ImVec2 p0 = ImGui::GetCursorScreenPos();\n                ImVec2 p1 = ImVec2(p0.x + gradient_size.x, p0.y + gradient_size.y);\n                ImU32 col_a = ImGui::GetColorU32(IM_COL32(0, 255, 0, 255));\n                ImU32 col_b = ImGui::GetColorU32(IM_COL32(255, 0, 0, 255));\n                draw_list->AddRectFilledMultiColor(p0, p1, col_a, col_b, col_b, col_a);\n                ImGui::InvisibleButton(\"##gradient2\", gradient_size);\n            }\n\n            \/\/ Draw a bunch of primitives\n            ImGui::Text(\"All primitives\");\n            static float sz = 36.0f;\n            static float thickness = 3.0f;\n            static int ngon_sides = 6;\n            static bool circle_segments_override = false;\n            static int circle_segments_override_v = 12;\n            static bool curve_segments_override = false;\n            static int curve_segments_override_v = 8;\n            static ImVec4 colf = ImVec4(1.0f, 1.0f, 0.4f, 1.0f);\n            ImGui::DragFloat(\"Size\", &sz, 0.2f, 2.0f, 100.0f, \"%.0f\");\n            ImGui::DragFloat(\"Thickness\", &thickness, 0.05f, 1.0f, 8.0f, \"%.02f\");\n            ImGui::SliderInt(\"N-gon sides\", &ngon_sides, 3, 12);\n            ImGui::Checkbox(\"##circlesegmentoverride\", &circle_segments_override);\n            ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n            circle_segments_override |= ImGui::SliderInt(\"Circle segments override\", &circle_segments_override_v, 3, 40);\n            ImGui::Checkbox(\"##curvessegmentoverride\", &curve_segments_override);\n            ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n            curve_segments_override |= ImGui::SliderInt(\"Curves segments override\", &curve_segments_override_v, 3, 40);\n            ImGui::ColorEdit4(\"Color\", &colf.x);\n\n            const ImVec2 p = ImGui::GetCursorScreenPos();\n            const ImU32 col = ImColor(colf);\n            const float spacing = 10.0f;\n            const ImDrawFlags corners_tl_br = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBottomRight;\n            const float rounding = sz \/ 5.0f;\n            const int circle_segments = circle_segments_override ? circle_segments_override_v : 0;\n            const int curve_segments = curve_segments_override ? curve_segments_override_v : 0;\n            const ImVec2 cp3[3] = { ImVec2(0.0f, sz * 0.6f), ImVec2(sz * 0.5f, -sz * 0.4f), ImVec2(sz, sz) }; \/\/ Control points for curves\n            const ImVec2 cp4[4] = { ImVec2(0.0f, 0.0f), ImVec2(sz * 1.3f, sz * 0.3f), ImVec2(sz - sz * 1.3f, sz - sz * 0.3f), ImVec2(sz, sz) };\n\n            float x = p.x + 4.0f;\n            float y = p.y + 4.0f;\n            for (int n = 0; n < 2; n++)\n            {\n                \/\/ First line uses a thickness of 1.0f, second line uses the configurable thickness\n                float th = (n == 0) ? 1.0f : thickness;\n                draw_list->AddNgon(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, ngon_sides, th);                 x += sz + spacing;  \/\/ N-gon\n                draw_list->AddCircle(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, circle_segments, th);          x += sz + spacing;  \/\/ Circle\n                draw_list->AddEllipse(ImVec2(x + sz*0.5f, y + sz*0.5f), ImVec2(sz*0.5f, sz*0.3f), col, -0.3f, circle_segments, th); x += sz + spacing;\t\/\/ Ellipse\n                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 0.0f, ImDrawFlags_None, th);          x += sz + spacing;  \/\/ Square\n                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, rounding, ImDrawFlags_None, th);      x += sz + spacing;  \/\/ Square with all rounded corners\n                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, rounding, corners_tl_br, th);         x += sz + spacing;  \/\/ Square with two rounded corners\n                draw_list->AddTriangle(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col, th);x += sz + spacing;  \/\/ Triangle\n                \/\/draw_list->AddTriangle(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col, th);x+= sz*0.4f + spacing; \/\/ Thin triangle\n                PathConcaveShape(draw_list, x, y, sz); draw_list->PathStroke(col, ImDrawFlags_Closed, th);          x += sz + spacing;  \/\/ Concave Shape\n                \/\/draw_list->AddPolyline(concave_shape, IM_ARRAYSIZE(concave_shape), col, ImDrawFlags_Closed, th);\n                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y), col, th);                                       x += sz + spacing;  \/\/ Horizontal line (note: drawing a filled rectangle will be faster!)\n                draw_list->AddLine(ImVec2(x, y), ImVec2(x, y + sz), col, th);                                       x += spacing;       \/\/ Vertical line (note: drawing a filled rectangle will be faster!)\n                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y + sz), col, th);                                  x += sz + spacing;  \/\/ Diagonal line\n\n                \/\/ Path\n                draw_list->PathArcTo(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, 3.141592f, 3.141592f * -0.5f);\n                draw_list->PathStroke(col, ImDrawFlags_None, th);\n                x += sz + spacing;\n\n                \/\/ Quadratic Bezier Curve (3 control points)\n                draw_list->AddBezierQuadratic(ImVec2(x + cp3[0].x, y + cp3[0].y), ImVec2(x + cp3[1].x, y + cp3[1].y), ImVec2(x + cp3[2].x, y + cp3[2].y), col, th, curve_segments);\n                x += sz + spacing;\n\n                \/\/ Cubic Bezier Curve (4 control points)\n                draw_list->AddBezierCubic(ImVec2(x + cp4[0].x, y + cp4[0].y), ImVec2(x + cp4[1].x, y + cp4[1].y), ImVec2(x + cp4[2].x, y + cp4[2].y), ImVec2(x + cp4[3].x, y + cp4[3].y), col, th, curve_segments);\n\n                x = p.x + 4;\n                y += sz + spacing;\n            }\n\n            \/\/ Filled shapes\n            draw_list->AddNgonFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, col, ngon_sides);             x += sz + spacing;  \/\/ N-gon\n            draw_list->AddCircleFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, col, circle_segments);      x += sz + spacing;  \/\/ Circle\n            draw_list->AddEllipseFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), ImVec2(sz * 0.5f, sz * 0.3f), col, -0.3f, circle_segments); x += sz + spacing;\/\/ Ellipse\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col);                                    x += sz + spacing;  \/\/ Square\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f);                             x += sz + spacing;  \/\/ Square with all rounded corners\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_tl_br);              x += sz + spacing;  \/\/ Square with two rounded corners\n            draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col);  x += sz + spacing;  \/\/ Triangle\n            \/\/draw_list->AddTriangleFilled(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col); x += sz*0.4f + spacing; \/\/ Thin triangle\n            PathConcaveShape(draw_list, x, y, sz); draw_list->PathFillConcave(col);                                 x += sz + spacing;  \/\/ Concave shape\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + thickness), col);                             x += sz + spacing;  \/\/ Horizontal line (faster than AddLine, but only handle integer thickness)\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + thickness, y + sz), col);                             x += spacing * 2.0f;\/\/ Vertical line (faster than AddLine, but only handle integer thickness)\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + 1, y + 1), col);                                      x += sz;            \/\/ Pixel (faster than AddLine)\n\n            \/\/ Path\n            draw_list->PathArcTo(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, 3.141592f * -0.5f, 3.141592f);\n            draw_list->PathFillConvex(col);\n            x += sz + spacing;\n\n            \/\/ Quadratic Bezier Curve (3 control points)\n            draw_list->PathLineTo(ImVec2(x + cp3[0].x, y + cp3[0].y));\n            draw_list->PathBezierQuadraticCurveTo(ImVec2(x + cp3[1].x, y + cp3[1].y), ImVec2(x + cp3[2].x, y + cp3[2].y), curve_segments);\n            draw_list->PathFillConvex(col);\n            x += sz + spacing;\n\n            draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x + sz, y + sz), IM_COL32(0, 0, 0, 255), IM_COL32(255, 0, 0, 255), IM_COL32(255, 255, 0, 255), IM_COL32(0, 255, 0, 255));\n            x += sz + spacing;\n\n            ImGui::Dummy(ImVec2((sz + spacing) * 13.2f, (sz + spacing) * 3.0f));\n            ImGui::PopItemWidth();\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"Canvas\"))\n        {\n            static ImVector<ImVec2> points;\n            static ImVec2 scrolling(0.0f, 0.0f);\n            static bool opt_enable_grid = true;\n            static bool opt_enable_context_menu = true;\n            static bool adding_line = false;\n\n            ImGui::Checkbox(\"Enable grid\", &opt_enable_grid);\n            ImGui::Checkbox(\"Enable context menu\", &opt_enable_context_menu);\n            ImGui::Text(\"Mouse Left: drag to add lines,\\nMouse Right: drag to scroll, click for context menu.\");\n\n            \/\/ Typically you would use a BeginChild()\/EndChild() pair to benefit from a clipping region + own scrolling.\n            \/\/ Here we demonstrate that this can be replaced by simple offsetting + custom drawing + PushClipRect\/PopClipRect() calls.\n            \/\/ To use a child window instead we could use, e.g:\n            \/\/      ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));      \/\/ Disable padding\n            \/\/      ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(50, 50, 50, 255));  \/\/ Set a background color\n            \/\/      ImGui::BeginChild(\"canvas\", ImVec2(0.0f, 0.0f), ImGuiChildFlags_Borders, ImGuiWindowFlags_NoMove);\n            \/\/      ImGui::PopStyleColor();\n            \/\/      ImGui::PopStyleVar();\n            \/\/      [...]\n            \/\/      ImGui::EndChild();\n\n            \/\/ Using InvisibleButton() as a convenience 1) it will advance the layout cursor and 2) allows us to use IsItemHovered()\/IsItemActive()\n            ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();      \/\/ ImDrawList API uses screen coordinates!\n            ImVec2 canvas_sz = ImGui::GetContentRegionAvail();   \/\/ Resize canvas to what's available\n            if (canvas_sz.x < 50.0f) canvas_sz.x = 50.0f;\n            if (canvas_sz.y < 50.0f) canvas_sz.y = 50.0f;\n            ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);\n\n            \/\/ Draw border and background color\n            ImGuiIO& io = ImGui::GetIO();\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n            draw_list->AddRectFilled(canvas_p0, canvas_p1, IM_COL32(50, 50, 50, 255));\n            draw_list->AddRect(canvas_p0, canvas_p1, IM_COL32(255, 255, 255, 255));\n\n            \/\/ This will catch our interactions\n            ImGui::InvisibleButton(\"canvas\", canvas_sz, ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight);\n            const bool is_hovered = ImGui::IsItemHovered(); \/\/ Hovered\n            const bool is_active = ImGui::IsItemActive();   \/\/ Held\n            const ImVec2 origin(canvas_p0.x + scrolling.x, canvas_p0.y + scrolling.y); \/\/ Lock scrolled origin\n            const ImVec2 mouse_pos_in_canvas(io.MousePos.x - origin.x, io.MousePos.y - origin.y);\n\n            \/\/ Add first and second point\n            if (is_hovered && !adding_line && ImGui::IsMouseClicked(ImGuiMouseButton_Left))\n            {\n                points.push_back(mouse_pos_in_canvas);\n                points.push_back(mouse_pos_in_canvas);\n                adding_line = true;\n            }\n            if (adding_line)\n            {\n                points.back() = mouse_pos_in_canvas;\n                if (!ImGui::IsMouseDown(ImGuiMouseButton_Left))\n                    adding_line = false;\n            }\n\n            \/\/ Pan (we use a zero mouse threshold when there's no context menu)\n            \/\/ You may decide to make that threshold dynamic based on whether the mouse is hovering something etc.\n            const float mouse_threshold_for_pan = opt_enable_context_menu ? -1.0f : 0.0f;\n            if (is_active && ImGui::IsMouseDragging(ImGuiMouseButton_Right, mouse_threshold_for_pan))\n            {\n                scrolling.x += io.MouseDelta.x;\n                scrolling.y += io.MouseDelta.y;\n            }\n\n            \/\/ Context menu (under default mouse threshold)\n            ImVec2 drag_delta = ImGui::GetMouseDragDelta(ImGuiMouseButton_Right);\n            if (opt_enable_context_menu && drag_delta.x == 0.0f && drag_delta.y == 0.0f)\n                ImGui::OpenPopupOnItemClick(\"context\", ImGuiPopupFlags_MouseButtonRight);\n            if (ImGui::BeginPopup(\"context\"))\n            {\n                if (adding_line)\n                    points.resize(points.size() - 2);\n                adding_line = false;\n                if (ImGui::MenuItem(\"Remove one\", NULL, false, points.Size > 0)) { points.resize(points.size() - 2); }\n                if (ImGui::MenuItem(\"Remove all\", NULL, false, points.Size > 0)) { points.clear(); }\n                ImGui::EndPopup();\n            }\n\n            \/\/ Draw grid + all lines in the canvas\n            draw_list->PushClipRect(canvas_p0, canvas_p1, true);\n            if (opt_enable_grid)\n            {\n                const float GRID_STEP = 64.0f;\n                for (float x = fmodf(scrolling.x, GRID_STEP); x < canvas_sz.x; x += GRID_STEP)\n                    draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p1.y), IM_COL32(200, 200, 200, 40));\n                for (float y = fmodf(scrolling.y, GRID_STEP); y < canvas_sz.y; y += GRID_STEP)\n                    draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p1.x, canvas_p0.y + y), IM_COL32(200, 200, 200, 40));\n            }\n            for (int n = 0; n < points.Size; n += 2)\n                draw_list->AddLine(ImVec2(origin.x + points[n].x, origin.y + points[n].y), ImVec2(origin.x + points[n + 1].x, origin.y + points[n + 1].y), IM_COL32(255, 255, 0, 255), 2.0f);\n            draw_list->PopClipRect();\n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"BG\/FG draw lists\"))\n        {\n            static bool draw_bg = true;\n            static bool draw_fg = true;\n            ImGui::Checkbox(\"Draw in Background draw list\", &draw_bg);\n            ImGui::SameLine(); HelpMarker(\"The Background draw list will be rendered below every Dear ImGui windows.\");\n            ImGui::Checkbox(\"Draw in Foreground draw list\", &draw_fg);\n            ImGui::SameLine(); HelpMarker(\"The Foreground draw list will be rendered over every Dear ImGui windows.\");\n            ImVec2 window_pos = ImGui::GetWindowPos();\n            ImVec2 window_size = ImGui::GetWindowSize();\n            ImVec2 window_center = ImVec2(window_pos.x + window_size.x * 0.5f, window_pos.y + window_size.y * 0.5f);\n            if (draw_bg)\n                ImGui::GetBackgroundDrawList()->AddCircle(window_center, window_size.x * 0.6f, IM_COL32(255, 0, 0, 200), 0, 10 + 4);\n            if (draw_fg)\n                ImGui::GetForegroundDrawList()->AddCircle(window_center, window_size.y * 0.6f, IM_COL32(0, 255, 0, 200), 0, 10);\n            ImGui::EndTabItem();\n        }\n\n        \/\/ Demonstrate out-of-order rendering via channels splitting\n        \/\/ We use functions in ImDrawList as each draw list contains a convenience splitter,\n        \/\/ but you can also instantiate your own ImDrawListSplitter if you need to nest them.\n        if (ImGui::BeginTabItem(\"Draw Channels\"))\n        {\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n            {\n                ImGui::Text(\"Blue shape is drawn first: appears in back\");\n                ImGui::Text(\"Red shape is drawn after: appears in front\");\n                ImVec2 p0 = ImGui::GetCursorScreenPos();\n                draw_list->AddRectFilled(ImVec2(p0.x, p0.y), ImVec2(p0.x + 50, p0.y + 50), IM_COL32(0, 0, 255, 255)); \/\/ Blue\n                draw_list->AddRectFilled(ImVec2(p0.x + 25, p0.y + 25), ImVec2(p0.x + 75, p0.y + 75), IM_COL32(255, 0, 0, 255)); \/\/ Red\n                ImGui::Dummy(ImVec2(75, 75));\n            }\n            ImGui::Separator();\n            {\n                ImGui::Text(\"Blue shape is drawn first, into channel 1: appears in front\");\n                ImGui::Text(\"Red shape is drawn after, into channel 0: appears in back\");\n                ImVec2 p1 = ImGui::GetCursorScreenPos();\n\n                \/\/ Create 2 channels and draw a Blue shape THEN a Red shape.\n                \/\/ You can create any number of channels. Tables API use 1 channel per column in order to better batch draw calls.\n                draw_list->ChannelsSplit(2);\n                draw_list->ChannelsSetCurrent(1);\n                draw_list->AddRectFilled(ImVec2(p1.x, p1.y), ImVec2(p1.x + 50, p1.y + 50), IM_COL32(0, 0, 255, 255)); \/\/ Blue\n                draw_list->ChannelsSetCurrent(0);\n                draw_list->AddRectFilled(ImVec2(p1.x + 25, p1.y + 25), ImVec2(p1.x + 75, p1.y + 75), IM_COL32(255, 0, 0, 255)); \/\/ Red\n\n                \/\/ Flatten\/reorder channels. Red shape is in channel 0 and it appears below the Blue shape in channel 1.\n                \/\/ This works by copying draw indices only (vertices are not copied).\n                draw_list->ChannelsMerge();\n                ImGui::Dummy(ImVec2(75, 75));\n                ImGui::Text(\"After reordering, contents of channel 0 appears below channel 1.\");\n            }\n            ImGui::EndTabItem();\n        }\n\n        ImGui::EndTabBar();\n    }\n\n    ImGui::End();\n}","mark":8.25}
{"file_name":"imgui_draw_function_11.cpp","line_count":9,"code":"ImVec2 ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t)\n{\n    float u = 1.0f - t;\n    float w1 = u * u * u;\n    float w2 = 3 * u * u * t;\n    float w3 = 3 * u * t * t;\n    float w4 = t * t * t;\n    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y);\n}","mark":8.0}
{"file_name":"imgui_draw_function_12.cpp","line_count":8,"code":"ImVec2 ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t)\n{\n    float u = 1.0f - t;\n    float w1 = u * u;\n    float w2 = 2 * u * t;\n    float w3 = t * t;\n    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x, w1 * p1.y + w2 * p2.y + w3 * p3.y);\n}","mark":8.5}
{"file_name":"imgui_draw_function_21.cpp","line_count":1,"code":"int EstimateTriangleCount(int points_count)      { return (points_count < 3) ? 0 : points_count - 2; }","mark":8.0}
{"file_name":"imgui_dx_base_function_1.cpp","line_count":23,"code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n\t{\n\t\tswitch (format) {\n\t\t\tcase DXGI_FORMAT_R32G32B32A32_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R32G32B32A32_FLOAT;\n\t\t\tcase DXGI_FORMAT_R32G32B32_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R32G32B32_FLOAT;\n\t\t\tcase DXGI_FORMAT_R16G16B16A16_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R16G16B16A16_FLOAT;\n\t\t\tcase DXGI_FORMAT_R10G10B10A2_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R10G10B10A2_UINT;\n\t\t\tcase DXGI_FORMAT_R8G8B8A8_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R8G8B8A8_UNORM;\n\t\t\tcase DXGI_FORMAT_B8G8R8A8_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_B8G8R8A8_UNORM;\n\t\t\tcase DXGI_FORMAT_R16G16_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R16G16_FLOAT;\n\t\t\tcase DXGI_FORMAT_R32G32_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R32G32_FLOAT;\n\t\t\tdefault:\n\t\t\t\treturn format;\n\t\t}\n\t}","mark":8.0}
{"file_name":"imgui_dx_base_function_2.cpp","line_count":1,"code":"int Width() { return _width; }","mark":8.0}
{"file_name":"imgui_dx_base_function_3.cpp","line_count":1,"code":"int Height() { return _height; }","mark":8.0}
{"file_name":"imgui_dx_base_function_4.cpp","line_count":1,"code":"int Top() { return _top; }","mark":8.0}
{"file_name":"imgui_dx_base_function_5.cpp","line_count":1,"code":"int Left() { return _left; }","mark":8.0}
{"file_name":"imgui_dx_base_function_6.cpp","line_count":1,"code":"HWND Handle() { return _handle; }","mark":8.0}
{"file_name":"imgui_function_100.cpp","line_count":1,"code":"float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }","mark":8.0}
{"file_name":"imgui_function_101.cpp","line_count":1,"code":"bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }","mark":8.0}
{"file_name":"imgui_function_103.cpp","line_count":1,"code":"void  SetNextWindowPosCenter(ImGuiCond c=0) { SetNextWindowPos(GetMainViewport()->GetCenter(), c, ImVec2(0.5f,0.5f)); }","mark":8.0}
{"file_name":"imgui_function_104.cpp","line_count":1,"code":"bool  IsItemHoveredRect()                   { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }","mark":8.0}
{"file_name":"imgui_function_106.cpp","line_count":1,"code":"bool  IsMouseHoveringAnyWindow()            { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }","mark":8.0}
{"file_name":"imgui_function_107.cpp","line_count":1,"code":"bool  IsMouseHoveringWindow()               { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }","mark":8.0}
{"file_name":"imgui_function_109.cpp","line_count":1,"code":"float GetWindowFontSize()                   { return GetFontSize(); }","mark":8.0}
{"file_name":"imgui_function_114.cpp","line_count":12,"code":"ImGuiKeyChord GetModForLRModKey(ImGuiKey key)\n{\n    if (key == ImGuiKey_LeftCtrl || key == ImGuiKey_RightCtrl)\n        return ImGuiMod_Ctrl;\n    if (key == ImGuiKey_LeftShift || key == ImGuiKey_RightShift)\n        return ImGuiMod_Shift;\n    if (key == ImGuiKey_LeftAlt || key == ImGuiKey_RightAlt)\n        return ImGuiMod_Alt;\n    if (key == ImGuiKey_LeftSuper || key == ImGuiKey_RightSuper)\n        return ImGuiMod_Super;\n    return ImGuiMod_None;\n}","mark":8.0}
{"file_name":"imgui_function_115.cpp","line_count":5,"code":"ImGuiID GetRoutingIdFromOwnerId(ImGuiID owner_id)\n{\n    ImGuiContext& g = *GImGui;\n    return (owner_id != ImGuiKeyOwner_NoOwner && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId;\n}","mark":8.0}
{"file_name":"imgui_function_120.cpp","line_count":7,"code":"void UpdateAliasKey(ImGuiKey key, bool v, float analog_value)\n{\n    IM_ASSERT(ImGui::IsAliasKey(key));\n    ImGuiKeyData* key_data = ImGui::GetKeyData(key);\n    key_data->Down = v;\n    key_data->AnalogValue = analog_value;\n}","mark":8.0}
{"file_name":"imgui_function_121.cpp","line_count":9,"code":"ImGuiKeyChord GetMergedModsFromKeys()\n{\n    ImGuiKeyChord mods = 0;\n    if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }\n    if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }\n    if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }\n    if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }\n    return mods;\n}","mark":8.0}
{"file_name":"imgui_function_137.cpp","line_count":6,"code":"ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)\n{\n    if (ImFabs(dx) > ImFabs(dy))\n        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;\n    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;\n}","mark":8.0}
{"file_name":"imgui_function_164.cpp","line_count":7,"code":"void WindowSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)\n{\n    ImGuiContext& g = *ctx;\n    for (ImGuiWindow* window : g.Windows)\n        window->SettingsOffset = -1;\n    g.SettingsWindows.clear();\n}","mark":8.0}
{"file_name":"imgui_function_167.cpp","line_count":47,"code":"void WindowSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)\n{\n    \/\/ Gather data from windows that were active during this session\n    \/\/ (if a window wasn't opened in this session we preserve its settings)\n    ImGuiContext& g = *ctx;\n    for (ImGuiWindow* window : g.Windows)\n    {\n        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)\n            continue;\n\n        ImGuiWindowSettings* settings = ImGui::FindWindowSettingsByWindow(window);\n        if (!settings)\n        {\n            settings = ImGui::CreateNewWindowSettings(window->Name);\n            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);\n        }\n        IM_ASSERT(settings->ID == window->ID);\n        settings->Pos = ImVec2ih(window->Pos);\n        settings->Size = ImVec2ih(window->SizeFull);\n        settings->IsChild = (window->Flags & ImGuiWindowFlags_ChildWindow) != 0;\n        settings->Collapsed = window->Collapsed;\n        settings->WantDelete = false;\n    }\n\n    \/\/ Write to text buffer\n    buf->reserve(buf->size() + g.SettingsWindows.size() * 6); \/\/ ballpark reserve\n    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))\n    {\n        if (settings->WantDelete)\n            continue;\n        const char* settings_name = settings->GetName();\n        buf->appendf(\"[%s][%s]\\n\", handler->TypeName, settings_name);\n        if (settings->IsChild)\n        {\n            buf->appendf(\"IsChild=1\\n\");\n            buf->appendf(\"Size=%d,%d\\n\", settings->Size.x, settings->Size.y);\n        }\n        else\n        {\n            buf->appendf(\"Pos=%d,%d\\n\", settings->Pos.x, settings->Pos.y);\n            buf->appendf(\"Size=%d,%d\\n\", settings->Size.x, settings->Size.y);\n            if (settings->Collapsed)\n                buf->appendf(\"Collapsed=1\\n\");\n        }\n        buf->append(\"\\n\");\n    }\n}","mark":8.0}
{"file_name":"imgui_function_170.cpp","line_count":9,"code":"void Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext* ctx, const char* text)\n{\n    ImGuiContext& g = *ctx;\n    g.ClipboardHandlerData.clear();\n    const char* text_end = text + strlen(text);\n    g.ClipboardHandlerData.resize((int)(text_end - text) + 1);\n    memcpy(&g.ClipboardHandlerData[0], text, (size_t)(text_end - text));\n    g.ClipboardHandlerData[(int)(text_end - text)] = 0;\n}","mark":8.0}
{"file_name":"imgui_function_179.cpp","line_count":11,"code":"void MetricsHelpMarker(const char* desc)\n{\n    ImGui::TextDisabled(\"(?)\");\n    if (ImGui::BeginItemTooltip())\n    {\n        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);\n        ImGui::TextUnformatted(desc);\n        ImGui::PopTextWrapPos();\n        ImGui::EndTooltip();\n    }\n}","mark":8.0}
{"file_name":"imgui_function_204.cpp","line_count":1,"code":"bool IsLegacyNativeDupe(ImGuiKey key) { return key >= 0 && key < 512 && GetIO().KeyMap[key] != -1; }","mark":8.0}
{"file_name":"imgui_function_27.cpp","line_count":1,"code":"void                Clear() { Data.clear(); }","mark":8.0}
{"file_name":"imgui_function_30.cpp","line_count":1,"code":"void ForceDisplayRangeByIndices(int item_begin, int item_end) { IncludeItemsByIndex(item_begin, item_end); }","mark":8.0}
{"file_name":"imgui_function_34.cpp","line_count":1,"code":"ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r, g, b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r, g, b, a); }","mark":8.0}
{"file_name":"imgui_function_39.cpp","line_count":1,"code":"void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }","mark":8.0}
{"file_name":"imgui_function_4.cpp","line_count":1,"code":"void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }","mark":8.0}
{"file_name":"imgui_function_50.cpp","line_count":1,"code":"void  AddEllipse(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f) { AddEllipse(center, ImVec2(radius_x, radius_y), col, rot, num_segments, thickness); }","mark":8.0}
{"file_name":"imgui_function_51.cpp","line_count":1,"code":"void  AddEllipseFilled(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0) { AddEllipseFilled(center, ImVec2(radius_x, radius_y), col, rot, num_segments); }","mark":8.0}
{"file_name":"imgui_function_52.cpp","line_count":1,"code":"void  PathEllipticalArcTo(const ImVec2& center, float radius_x, float radius_y, float rot, float a_min, float a_max, int num_segments = 0) { PathEllipticalArcTo(center, ImVec2(radius_x, radius_y), rot, a_min, a_max, num_segments); }","mark":8.0}
{"file_name":"imgui_function_53.cpp","line_count":1,"code":"void  AddBezierCurve(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0) { AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments); }","mark":8.0}
{"file_name":"imgui_function_54.cpp","line_count":1,"code":"void  PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0) { PathBezierCubicCurveTo(p2, p3, p4, num_segments); }","mark":8.0}
{"file_name":"imgui_function_62.cpp","line_count":1,"code":"void  PushButtonRepeat(bool repeat)                           { PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat); }","mark":8.0}
{"file_name":"imgui_function_64.cpp","line_count":1,"code":"void  PushTabStop(bool tab_stop)                              { PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop); }","mark":8.0}
{"file_name":"imgui_function_66.cpp","line_count":1,"code":"bool  BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags window_flags = 0)  { return BeginChild(id, size, ImGuiChildFlags_FrameStyle, window_flags); }","mark":8.0}
{"file_name":"imgui_function_68.cpp","line_count":1,"code":"bool BeginChild(const char* str_id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags){ return BeginChild(str_id, size_arg, borders ? ImGuiChildFlags_Borders : ImGuiChildFlags_None, window_flags); }","mark":8.0}
{"file_name":"imgui_function_69.cpp","line_count":1,"code":"bool BeginChild(ImGuiID id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags)        { return BeginChild(id, size_arg, borders ? ImGuiChildFlags_Borders : ImGuiChildFlags_None, window_flags);     }","mark":8.0}
{"file_name":"imgui_function_71.cpp","line_count":1,"code":"void  PushAllowKeyboardFocus(bool tab_stop)                   { PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop); }","mark":8.0}
{"file_name":"imgui_function_74.cpp","line_count":1,"code":"void  CaptureKeyboardFromApp(bool want_capture_keyboard = true)     { SetNextFrameWantCaptureKeyboard(want_capture_keyboard); }","mark":8.0}
{"file_name":"imgui_function_76.cpp","line_count":1,"code":"float GetWindowContentRegionWidth()                                               { return GetWindowContentRegionMax().x - GetWindowContentRegionMin().x; }","mark":8.0}
{"file_name":"imgui_function_80.cpp","line_count":1,"code":"bool  DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power = 1.0f)    { return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power); }","mark":8.0}
{"file_name":"imgui_function_81.cpp","line_count":1,"code":"bool  DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power); }","mark":8.0}
{"file_name":"imgui_function_82.cpp","line_count":1,"code":"bool  DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power); }","mark":8.0}
{"file_name":"imgui_function_83.cpp","line_count":1,"code":"bool  DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power); }","mark":8.0}
{"file_name":"imgui_function_85.cpp","line_count":1,"code":"bool  SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power = 1.0f)              { return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power); }","mark":8.0}
{"file_name":"imgui_function_86.cpp","line_count":1,"code":"bool  SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power = 1.0f)              { return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power); }","mark":8.0}
{"file_name":"imgui_function_87.cpp","line_count":1,"code":"bool  SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power = 1.0f)              { return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power); }","mark":8.0}
{"file_name":"imgui_function_90.cpp","line_count":1,"code":"void  SetNextTreeNodeOpen(bool open, ImGuiCond cond = 0) { SetNextItemOpen(open, cond); }","mark":8.0}
{"file_name":"imgui_function_91.cpp","line_count":1,"code":"float GetContentRegionAvailWidth()          { return GetContentRegionAvail().x; }","mark":8.0}
{"file_name":"imgui_function_92.cpp","line_count":1,"code":"void  SetScrollHere(float ratio = 0.5f)     { SetScrollHereY(ratio); }","mark":8.0}
{"file_name":"imgui_function_94.cpp","line_count":1,"code":"bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }","mark":8.0}
{"file_name":"imgui_function_95.cpp","line_count":1,"code":"bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }","mark":8.0}
{"file_name":"imgui_function_97.cpp","line_count":1,"code":"bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }","mark":8.0}
{"file_name":"imgui_function_98.cpp","line_count":1,"code":"bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }","mark":8.0}
{"file_name":"imgui_impl_dx11_function_8.cpp","line_count":15,"code":"void ImGui_ImplDX11_Shutdown()\n{\n    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplDX11_InvalidateDeviceObjects();\n    if (bd->pFactory)             { bd->pFactory->Release(); }\n    if (bd->pd3dDevice)           { bd->pd3dDevice->Release(); }\n    if (bd->pd3dDeviceContext)    { bd->pd3dDeviceContext->Release(); }\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}","mark":8.0}
{"file_name":"imgui_impl_dx11_function_9.cpp","line_count":8,"code":"void ImGui_ImplDX11_NewFrame()\n{\n    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Context or backend not initialized! Did you call ImGui_ImplDX11_Init()?\");\n\n    if (!bd->pFontSampler)\n        ImGui_ImplDX11_CreateDeviceObjects();\n}","mark":8.0}
{"file_name":"imgui_impl_dx12_function_1.cpp","line_count":56,"code":"void ImGui_ImplDX12_SetupRenderState(ImDrawData* draw_data, ID3D12GraphicsCommandList* ctx, ImGui_ImplDX12_RenderBuffers* fr)\n{\n    ImGui_ImplDX12_Data* bd = ImGui_ImplDX12_GetBackendData();\n\n    \/\/ Setup orthographic projection matrix into our constant buffer\n    \/\/ Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right).\n    VERTEX_CONSTANT_BUFFER_DX12 vertex_constant_buffer;\n    {\n        float L = draw_data->DisplayPos.x;\n        float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;\n        float T = draw_data->DisplayPos.y;\n        float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;\n        float mvp[4][4] =\n        {\n            { 2.0f\/(R-L),   0.0f,           0.0f,       0.0f },\n            { 0.0f,         2.0f\/(T-B),     0.0f,       0.0f },\n            { 0.0f,         0.0f,           0.5f,       0.0f },\n            { (R+L)\/(L-R),  (T+B)\/(B-T),    0.5f,       1.0f },\n        };\n        memcpy(&vertex_constant_buffer.mvp, mvp, sizeof(mvp));\n    }\n\n    \/\/ Setup viewport\n    D3D12_VIEWPORT vp;\n    memset(&vp, 0, sizeof(D3D12_VIEWPORT));\n    vp.Width = draw_data->DisplaySize.x;\n    vp.Height = draw_data->DisplaySize.y;\n    vp.MinDepth = 0.0f;\n    vp.MaxDepth = 1.0f;\n    vp.TopLeftX = vp.TopLeftY = 0.0f;\n    ctx->RSSetViewports(1, &vp);\n\n    \/\/ Bind shader and vertex buffers\n    unsigned int stride = sizeof(ImDrawVert);\n    unsigned int offset = 0;\n    D3D12_VERTEX_BUFFER_VIEW vbv;\n    memset(&vbv, 0, sizeof(D3D12_VERTEX_BUFFER_VIEW));\n    vbv.BufferLocation = fr->VertexBuffer->GetGPUVirtualAddress() + offset;\n    vbv.SizeInBytes = fr->VertexBufferSize * stride;\n    vbv.StrideInBytes = stride;\n    ctx->IASetVertexBuffers(0, 1, &vbv);\n    D3D12_INDEX_BUFFER_VIEW ibv;\n    memset(&ibv, 0, sizeof(D3D12_INDEX_BUFFER_VIEW));\n    ibv.BufferLocation = fr->IndexBuffer->GetGPUVirtualAddress();\n    ibv.SizeInBytes = fr->IndexBufferSize * sizeof(ImDrawIdx);\n    ibv.Format = sizeof(ImDrawIdx) == 2 ? DXGI_FORMAT_R16_UINT : DXGI_FORMAT_R32_UINT;\n    ctx->IASetIndexBuffer(&ibv);\n    ctx->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n    ctx->SetPipelineState(bd->pPipelineState);\n    ctx->SetGraphicsRootSignature(bd->pRootSignature);\n    ctx->SetGraphicsRoot32BitConstants(0, 16, &vertex_constant_buffer, 0);\n\n    \/\/ Setup blend factor\n    const float blend_factor[4] = { 0.f, 0.f, 0.f, 0.f };\n    ctx->OMSetBlendFactor(blend_factor);\n}","mark":8.0}
{"file_name":"imgui_impl_dx12_function_10.cpp","line_count":8,"code":"void ImGui_ImplDX12_NewFrame()\n{\n    ImGui_ImplDX12_Data* bd = ImGui_ImplDX12_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Context or backend not initialized! Did you call ImGui_ImplDX12_Init()?\");\n\n    if (!bd->pPipelineState)\n        ImGui_ImplDX12_CreateDeviceObjects();\n}","mark":8.0}
{"file_name":"imgui_impl_dx12_function_2.cpp","line_count":6,"code":"void SafeRelease(T*& res)\n{\n    if (res)\n        res->Release();\n    res = nullptr;\n}","mark":8.0}
{"file_name":"imgui_impl_dx12_function_9.cpp","line_count":14,"code":"void ImGui_ImplDX12_Shutdown()\n{\n    ImGui_ImplDX12_Data* bd = ImGui_ImplDX12_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    \/\/ Clean up windows and device objects\n    ImGui_ImplDX12_InvalidateDeviceObjects();\n    delete[] bd->pFrameResources;\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}","mark":8.0}
{"file_name":"imgui_impl_vulkan_function_13.cpp","line_count":23,"code":"void ImGui_ImplVulkan_CreateShaderModules(VkDevice device, const VkAllocationCallbacks* allocator)\n{\n    \/\/ Create the shader modules\n    ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();\n    if (bd->ShaderModuleVert == VK_NULL_HANDLE)\n    {\n        VkShaderModuleCreateInfo vert_info = {};\n        vert_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;\n        vert_info.codeSize = sizeof(__glsl_shader_vert_spv);\n        vert_info.pCode = (uint32_t*)__glsl_shader_vert_spv;\n        VkResult err = vkCreateShaderModule(device, &vert_info, allocator, &bd->ShaderModuleVert);\n        check_vk_result(err);\n    }\n    if (bd->ShaderModuleFrag == VK_NULL_HANDLE)\n    {\n        VkShaderModuleCreateInfo frag_info = {};\n        frag_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;\n        frag_info.codeSize = sizeof(__glsl_shader_frag_spv);\n        frag_info.pCode = (uint32_t*)__glsl_shader_frag_spv;\n        VkResult err = vkCreateShaderModule(device, &frag_info, allocator, &bd->ShaderModuleFrag);\n        check_vk_result(err);\n    }\n}","mark":8.0}
{"file_name":"imgui_impl_vulkan_function_19.cpp","line_count":12,"code":"void ImGui_ImplVulkan_Shutdown()\n{\n    ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplVulkan_DestroyDeviceObjects();\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}","mark":8.0}
{"file_name":"imgui_impl_vulkan_function_20.cpp","line_count":8,"code":"void ImGui_ImplVulkan_NewFrame()\n{\n    ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Context or backend not initialized! Did you call ImGui_ImplVulkan_Init()?\");\n\n    if (!bd->FontDescriptorSet)\n        ImGui_ImplVulkan_CreateFontsTexture();\n}","mark":8.0}
{"file_name":"imgui_impl_vulkan_function_22.cpp","line_count":33,"code":"VkDescriptorSet ImGui_ImplVulkan_AddTexture(VkSampler sampler, VkImageView image_view, VkImageLayout image_layout)\n{\n    ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();\n    ImGui_ImplVulkan_InitInfo* v = &bd->VulkanInitInfo;\n\n    \/\/ Create Descriptor Set:\n    VkDescriptorSet descriptor_set;\n    {\n        VkDescriptorSetAllocateInfo alloc_info = {};\n        alloc_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;\n        alloc_info.descriptorPool = v->DescriptorPool;\n        alloc_info.descriptorSetCount = 1;\n        alloc_info.pSetLayouts = &bd->DescriptorSetLayout;\n        VkResult err = vkAllocateDescriptorSets(v->Device, &alloc_info, &descriptor_set);\n        check_vk_result(err);\n    }\n\n    \/\/ Update the Descriptor Set:\n    {\n        VkDescriptorImageInfo desc_image[1] = {};\n        desc_image[0].sampler = sampler;\n        desc_image[0].imageView = image_view;\n        desc_image[0].imageLayout = image_layout;\n        VkWriteDescriptorSet write_desc[1] = {};\n        write_desc[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;\n        write_desc[0].dstSet = descriptor_set;\n        write_desc[0].descriptorCount = 1;\n        write_desc[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;\n        write_desc[0].pImageInfo = desc_image;\n        vkUpdateDescriptorSets(v->Device, 1, write_desc, 0, nullptr);\n    }\n    return descriptor_set;\n}","mark":8.25}
{"file_name":"imgui_impl_vulkan_function_25.cpp","line_count":9,"code":"void ImGui_ImplVulkan_DestroyWindowRenderBuffers(VkDevice device, ImGui_ImplVulkan_WindowRenderBuffers* buffers, const VkAllocationCallbacks* allocator)\n{\n    for (uint32_t n = 0; n < buffers->Count; n++)\n        ImGui_ImplVulkan_DestroyFrameRenderBuffers(device, &buffers->FrameRenderBuffers[n], allocator);\n    IM_FREE(buffers->FrameRenderBuffers);\n    buffers->FrameRenderBuffers = nullptr;\n    buffers->Index = 0;\n    buffers->Count = 0;\n}","mark":8.0}
{"file_name":"imgui_impl_vulkan_function_37.cpp","line_count":6,"code":"void ImGui_ImplVulkanH_DestroyFrameSemaphores(VkDevice device, ImGui_ImplVulkanH_FrameSemaphores* fsd, const VkAllocationCallbacks* allocator)\n{\n    vkDestroySemaphore(device, fsd->ImageAcquiredSemaphore, allocator);\n    vkDestroySemaphore(device, fsd->RenderCompleteSemaphore, allocator);\n    fsd->ImageAcquiredSemaphore = fsd->RenderCompleteSemaphore = VK_NULL_HANDLE;\n}","mark":8.5}
{"file_name":"imgui_impl_vulkan_function_5.cpp","line_count":4,"code":"VkDeviceSize AlignBufferSize(VkDeviceSize size, VkDeviceSize alignment)\n{\n    return (size + alignment - 1) & ~(alignment - 1);\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_10.cpp","line_count":14,"code":"void ImGui_ImplWin32_ProcessKeyEventsWorkarounds()\n{\n    \/\/ Left & right Shift keys: when both are pressed together, Windows tend to not generate the WM_KEYUP event for the first released one.\n    if (ImGui::IsKeyDown(ImGuiKey_LeftShift) && !IsVkDown(VK_LSHIFT))\n        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_LeftShift, false, VK_LSHIFT);\n    if (ImGui::IsKeyDown(ImGuiKey_RightShift) && !IsVkDown(VK_RSHIFT))\n        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_RightShift, false, VK_RSHIFT);\n\n    \/\/ Sometimes WM_KEYUP for Win key is not passed down to the app (e.g. for Win+V on some setups, according to GLFW).\n    if (ImGui::IsKeyDown(ImGuiKey_LeftSuper) && !IsVkDown(VK_LWIN))\n        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_LeftSuper, false, VK_LWIN);\n    if (ImGui::IsKeyDown(ImGuiKey_RightSuper) && !IsVkDown(VK_RWIN))\n        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_RightSuper, false, VK_RWIN);\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_11.cpp","line_count":8,"code":"void ImGui_ImplWin32_UpdateKeyModifiers()\n{\n    ImGuiIO& io = ImGui::GetIO();\n    io.AddKeyEvent(ImGuiMod_Ctrl, IsVkDown(VK_CONTROL));\n    io.AddKeyEvent(ImGuiMod_Shift, IsVkDown(VK_SHIFT));\n    io.AddKeyEvent(ImGuiMod_Alt, IsVkDown(VK_MENU));\n    io.AddKeyEvent(ImGuiMod_Super, IsVkDown(VK_LWIN) || IsVkDown(VK_RWIN));\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_18.cpp","line_count":128,"code":"ImGuiKey ImGui_ImplWin32_KeyEventToImGuiKey(WPARAM wParam, LPARAM lParam)\n{\n    \/\/ There is no distinct VK_xxx for keypad enter, instead it is VK_RETURN + KF_EXTENDED.\n    if ((wParam == VK_RETURN) && (HIWORD(lParam) & KF_EXTENDED))\n        return ImGuiKey_KeypadEnter;\n\n    switch (wParam)\n    {\n        case VK_TAB: return ImGuiKey_Tab;\n        case VK_LEFT: return ImGuiKey_LeftArrow;\n        case VK_RIGHT: return ImGuiKey_RightArrow;\n        case VK_UP: return ImGuiKey_UpArrow;\n        case VK_DOWN: return ImGuiKey_DownArrow;\n        case VK_PRIOR: return ImGuiKey_PageUp;\n        case VK_NEXT: return ImGuiKey_PageDown;\n        case VK_HOME: return ImGuiKey_Home;\n        case VK_END: return ImGuiKey_End;\n        case VK_INSERT: return ImGuiKey_Insert;\n        case VK_DELETE: return ImGuiKey_Delete;\n        case VK_BACK: return ImGuiKey_Backspace;\n        case VK_SPACE: return ImGuiKey_Space;\n        case VK_RETURN: return ImGuiKey_Enter;\n        case VK_ESCAPE: return ImGuiKey_Escape;\n        case VK_OEM_7: return ImGuiKey_Apostrophe;\n        case VK_OEM_COMMA: return ImGuiKey_Comma;\n        case VK_OEM_MINUS: return ImGuiKey_Minus;\n        case VK_OEM_PERIOD: return ImGuiKey_Period;\n        case VK_OEM_2: return ImGuiKey_Slash;\n        case VK_OEM_1: return ImGuiKey_Semicolon;\n        case VK_OEM_PLUS: return ImGuiKey_Equal;\n        case VK_OEM_4: return ImGuiKey_LeftBracket;\n        case VK_OEM_5: return ImGuiKey_Backslash;\n        case VK_OEM_6: return ImGuiKey_RightBracket;\n        case VK_OEM_3: return ImGuiKey_GraveAccent;\n        case VK_CAPITAL: return ImGuiKey_CapsLock;\n        case VK_SCROLL: return ImGuiKey_ScrollLock;\n        case VK_NUMLOCK: return ImGuiKey_NumLock;\n        case VK_SNAPSHOT: return ImGuiKey_PrintScreen;\n        case VK_PAUSE: return ImGuiKey_Pause;\n        case VK_NUMPAD0: return ImGuiKey_Keypad0;\n        case VK_NUMPAD1: return ImGuiKey_Keypad1;\n        case VK_NUMPAD2: return ImGuiKey_Keypad2;\n        case VK_NUMPAD3: return ImGuiKey_Keypad3;\n        case VK_NUMPAD4: return ImGuiKey_Keypad4;\n        case VK_NUMPAD5: return ImGuiKey_Keypad5;\n        case VK_NUMPAD6: return ImGuiKey_Keypad6;\n        case VK_NUMPAD7: return ImGuiKey_Keypad7;\n        case VK_NUMPAD8: return ImGuiKey_Keypad8;\n        case VK_NUMPAD9: return ImGuiKey_Keypad9;\n        case VK_DECIMAL: return ImGuiKey_KeypadDecimal;\n        case VK_DIVIDE: return ImGuiKey_KeypadDivide;\n        case VK_MULTIPLY: return ImGuiKey_KeypadMultiply;\n        case VK_SUBTRACT: return ImGuiKey_KeypadSubtract;\n        case VK_ADD: return ImGuiKey_KeypadAdd;\n        case VK_LSHIFT: return ImGuiKey_LeftShift;\n        case VK_LCONTROL: return ImGuiKey_LeftCtrl;\n        case VK_LMENU: return ImGuiKey_LeftAlt;\n        case VK_LWIN: return ImGuiKey_LeftSuper;\n        case VK_RSHIFT: return ImGuiKey_RightShift;\n        case VK_RCONTROL: return ImGuiKey_RightCtrl;\n        case VK_RMENU: return ImGuiKey_RightAlt;\n        case VK_RWIN: return ImGuiKey_RightSuper;\n        case VK_APPS: return ImGuiKey_Menu;\n        case '0': return ImGuiKey_0;\n        case '1': return ImGuiKey_1;\n        case '2': return ImGuiKey_2;\n        case '3': return ImGuiKey_3;\n        case '4': return ImGuiKey_4;\n        case '5': return ImGuiKey_5;\n        case '6': return ImGuiKey_6;\n        case '7': return ImGuiKey_7;\n        case '8': return ImGuiKey_8;\n        case '9': return ImGuiKey_9;\n        case 'A': return ImGuiKey_A;\n        case 'B': return ImGuiKey_B;\n        case 'C': return ImGuiKey_C;\n        case 'D': return ImGuiKey_D;\n        case 'E': return ImGuiKey_E;\n        case 'F': return ImGuiKey_F;\n        case 'G': return ImGuiKey_G;\n        case 'H': return ImGuiKey_H;\n        case 'I': return ImGuiKey_I;\n        case 'J': return ImGuiKey_J;\n        case 'K': return ImGuiKey_K;\n        case 'L': return ImGuiKey_L;\n        case 'M': return ImGuiKey_M;\n        case 'N': return ImGuiKey_N;\n        case 'O': return ImGuiKey_O;\n        case 'P': return ImGuiKey_P;\n        case 'Q': return ImGuiKey_Q;\n        case 'R': return ImGuiKey_R;\n        case 'S': return ImGuiKey_S;\n        case 'T': return ImGuiKey_T;\n        case 'U': return ImGuiKey_U;\n        case 'V': return ImGuiKey_V;\n        case 'W': return ImGuiKey_W;\n        case 'X': return ImGuiKey_X;\n        case 'Y': return ImGuiKey_Y;\n        case 'Z': return ImGuiKey_Z;\n        case VK_F1: return ImGuiKey_F1;\n        case VK_F2: return ImGuiKey_F2;\n        case VK_F3: return ImGuiKey_F3;\n        case VK_F4: return ImGuiKey_F4;\n        case VK_F5: return ImGuiKey_F5;\n        case VK_F6: return ImGuiKey_F6;\n        case VK_F7: return ImGuiKey_F7;\n        case VK_F8: return ImGuiKey_F8;\n        case VK_F9: return ImGuiKey_F9;\n        case VK_F10: return ImGuiKey_F10;\n        case VK_F11: return ImGuiKey_F11;\n        case VK_F12: return ImGuiKey_F12;\n        case VK_F13: return ImGuiKey_F13;\n        case VK_F14: return ImGuiKey_F14;\n        case VK_F15: return ImGuiKey_F15;\n        case VK_F16: return ImGuiKey_F16;\n        case VK_F17: return ImGuiKey_F17;\n        case VK_F18: return ImGuiKey_F18;\n        case VK_F19: return ImGuiKey_F19;\n        case VK_F20: return ImGuiKey_F20;\n        case VK_F21: return ImGuiKey_F21;\n        case VK_F22: return ImGuiKey_F22;\n        case VK_F23: return ImGuiKey_F23;\n        case VK_F24: return ImGuiKey_F24;\n        case VK_BROWSER_BACK: return ImGuiKey_AppBack;\n        case VK_BROWSER_FORWARD: return ImGuiKey_AppForward;\n        default: return ImGuiKey_None;\n    }\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_19.cpp","line_count":9,"code":"ImGuiMouseSource GetMouseSourceFromMessageExtraInfo()\n{\n    LPARAM extra_info = ::GetMessageExtraInfo();\n    if ((extra_info & 0xFFFFFF80) == 0xFF515700)\n        return ImGuiMouseSource_Pen;\n    if ((extra_info & 0xFFFFFF80) == 0xFF515780)\n        return ImGuiMouseSource_TouchScreen;\n    return ImGuiMouseSource_Mouse;\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_2.cpp","line_count":9,"code":"void ImGui_ImplWin32_UpdateKeyboardCodePage()\n{\n    \/\/ Retrieve keyboard code page, required for handling of non-Unicode Windows.\n    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();\n    HKL keyboard_layout = ::GetKeyboardLayout(0);\n    LCID keyboard_lcid = MAKELCID(HIWORD(keyboard_layout), SORT_DEFAULT);\n    if (::GetLocaleInfoA(keyboard_lcid, (LOCALE_RETURN_NUMBER | LOCALE_IDEFAULTANSICODEPAGE), (LPSTR)&bd->KeyboardCodePage, sizeof(bd->KeyboardCodePage)) == 0)\n        bd->KeyboardCodePage = CP_ACP; \/\/ Fallback to default ANSI code page when fails.\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_27.cpp","line_count":5,"code":"float ImGui_ImplWin32_GetDpiScaleForHwnd(void* hwnd)\n{\n    HMONITOR monitor = ::MonitorFromWindow((HWND)hwnd, MONITOR_DEFAULTTONEAREST);\n    return ImGui_ImplWin32_GetDpiScaleForMonitor(monitor);\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_3.cpp","line_count":53,"code":"bool ImGui_ImplWin32_InitEx(void* hwnd, bool platform_has_own_dc)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    IMGUI_CHECKVERSION();\n    IM_ASSERT(io.BackendPlatformUserData == nullptr && \"Already initialized a platform backend!\");\n\n    INT64 perf_frequency, perf_counter;\n    if (!::QueryPerformanceFrequency((LARGE_INTEGER*)&perf_frequency))\n        return false;\n    if (!::QueryPerformanceCounter((LARGE_INTEGER*)&perf_counter))\n        return false;\n\n    \/\/ Setup backend capabilities flags\n    ImGui_ImplWin32_Data* bd = IM_NEW(ImGui_ImplWin32_Data)();\n    io.BackendPlatformUserData = (void*)bd;\n    io.BackendPlatformName = \"imgui_impl_win32\";\n    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         \/\/ We can honor GetMouseCursor() values (optional)\n    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          \/\/ We can honor io.WantSetMousePos requests (optional, rarely used)\n\n    bd->hWnd = (HWND)hwnd;\n    bd->TicksPerSecond = perf_frequency;\n    bd->Time = perf_counter;\n    bd->LastMouseCursor = ImGuiMouseCursor_COUNT;\n    ImGui_ImplWin32_UpdateKeyboardCodePage();\n\n    \/\/ Set platform dependent data in viewport\n    ImGuiViewport* main_viewport = ImGui::GetMainViewport();\n    main_viewport->PlatformHandle = main_viewport->PlatformHandleRaw = (void*)bd->hWnd;\n    IM_UNUSED(platform_has_own_dc); \/\/ Used in 'docking' branch\n\n    \/\/ Dynamically load XInput library\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n    bd->WantUpdateHasGamepad = true;\n    const char* xinput_dll_names[] =\n    {\n        \"xinput1_4.dll\",   \/\/ Windows 8+\n        \"xinput1_3.dll\",   \/\/ DirectX SDK\n        \"xinput9_1_0.dll\", \/\/ Windows Vista, Windows 7\n        \"xinput1_2.dll\",   \/\/ DirectX SDK\n        \"xinput1_1.dll\"    \/\/ DirectX SDK\n    };\n    for (int n = 0; n < IM_ARRAYSIZE(xinput_dll_names); n++)\n        if (HMODULE dll = ::LoadLibraryA(xinput_dll_names[n]))\n        {\n            bd->XInputDLL = dll;\n            bd->XInputGetCapabilities = (PFN_XInputGetCapabilities)::GetProcAddress(dll, \"XInputGetCapabilities\");\n            bd->XInputGetState = (PFN_XInputGetState)::GetProcAddress(dll, \"XInputGetState\");\n            break;\n        }\n#endif \/\/ IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n\n    return true;\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_4.cpp","line_count":4,"code":"bool     ImGui_ImplWin32_Init(void* hwnd)\n{\n    return ImGui_ImplWin32_InitEx(hwnd, false);\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_6.cpp","line_count":17,"code":"void    ImGui_ImplWin32_Shutdown()\n{\n    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No platform backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    \/\/ Unload XInput library\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n    if (bd->XInputDLL)\n        ::FreeLibrary(bd->XInputDLL);\n#endif \/\/ IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n\n    io.BackendPlatformName = nullptr;\n    io.BackendPlatformUserData = nullptr;\n    io.BackendFlags &= ~(ImGuiBackendFlags_HasMouseCursors | ImGuiBackendFlags_HasSetMousePos | ImGuiBackendFlags_HasGamepad);\n    IM_DELETE(bd);\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_8.cpp","line_count":4,"code":"bool IsVkDown(int vk)\n{\n    return (::GetKeyState(vk) & 0x8000) != 0;\n}","mark":8.0}
{"file_name":"imgui_impl_win32_function_9.cpp","line_count":7,"code":"void ImGui_ImplWin32_AddKeyEvent(ImGuiKey key, bool down, int native_keycode, int native_scancode = -1)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    io.AddKeyEvent(key, down);\n    io.SetKeyEventNativeData(key, native_keycode, native_scancode); \/\/ To support legacy indexing (<1.87 user code)\n    IM_UNUSED(native_scancode);\n}","mark":8.0}
{"file_name":"imgui_internal_function_1.cpp","line_count":1,"code":"bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }","mark":8.0}
{"file_name":"imgui_internal_function_102.cpp","line_count":1,"code":"void        ClearFreeMemory()           { TextA.clear(); InitialTextA.clear(); }","mark":8.0}
{"file_name":"imgui_internal_function_118.cpp","line_count":1,"code":"void             SetWindowParentWindowForFocusRoute(ImGuiWindow* window, ImGuiWindow* parent_window) { window->ParentWindowForFocusRoute = parent_window; }","mark":8.0}
{"file_name":"imgui_internal_function_123.cpp","line_count":1,"code":"void             ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& rect) { ScrollToRect(window, rect, ImGuiScrollFlags_KeepVisibleEdgeY); }","mark":8.0}
{"file_name":"imgui_internal_function_124.cpp","line_count":1,"code":"ImGuiItemStatusFlags GetItemStatusFlags() { ImGuiContext& g = *GImGui; return g.LastItemData.StatusFlags; }","mark":8.0}
{"file_name":"imgui_internal_function_129.cpp","line_count":1,"code":"bool             IsNamedKey(ImGuiKey key)                    { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; }","mark":8.0}
{"file_name":"imgui_internal_function_130.cpp","line_count":1,"code":"bool             IsNamedKeyOrMod(ImGuiKey key)               { return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super; }","mark":8.0}
{"file_name":"imgui_internal_function_131.cpp","line_count":1,"code":"bool             IsLegacyKey(ImGuiKey key)                   { return key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_LegacyNativeKey_END; }","mark":8.0}
{"file_name":"imgui_internal_function_132.cpp","line_count":1,"code":"bool             IsKeyboardKey(ImGuiKey key)                 { return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END; }","mark":8.0}
{"file_name":"imgui_internal_function_133.cpp","line_count":1,"code":"bool             IsGamepadKey(ImGuiKey key)                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }","mark":8.0}
{"file_name":"imgui_internal_function_134.cpp","line_count":1,"code":"bool             IsMouseKey(ImGuiKey key)                    { return key >= ImGuiKey_Mouse_BEGIN && key < ImGuiKey_Mouse_END; }","mark":8.0}
{"file_name":"imgui_internal_function_135.cpp","line_count":1,"code":"bool             IsAliasKey(ImGuiKey key)                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }","mark":8.0}
{"file_name":"imgui_internal_function_136.cpp","line_count":1,"code":"bool             IsLRModKey(ImGuiKey key)                    { return key >= ImGuiKey_LeftCtrl && key <= ImGuiKey_RightSuper; }","mark":8.0}
{"file_name":"imgui_internal_function_140.cpp","line_count":1,"code":"ImGuiID          GetCurrentFocusScope() { ImGuiContext& g = *GImGui; return g.CurrentFocusScopeId; }","mark":8.0}
{"file_name":"imgui_internal_function_145.cpp","line_count":1,"code":"bool     TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0)    { return TreeNodeUpdateNextOpen(id, flags); }","mark":8.0}
{"file_name":"imgui_internal_function_17.cpp","line_count":1,"code":"int    ImAbs(int x)               { return x < 0 ? -x : x; }","mark":8.0}
{"file_name":"imgui_internal_function_18.cpp","line_count":1,"code":"float  ImAbs(float x)             { return fabsf(x); }","mark":8.0}
{"file_name":"imgui_internal_function_19.cpp","line_count":1,"code":"double ImAbs(double x)            { return fabs(x); }","mark":8.0}
{"file_name":"imgui_internal_function_2.cpp","line_count":1,"code":"bool      ImIsPowerOfTwo(ImU64 v)         { return v != 0 && (v & (v - 1)) == 0; }","mark":8.0}
{"file_name":"imgui_internal_function_20.cpp","line_count":1,"code":"float  ImSign(float x)            { return (x < 0.0f) ? -1.0f : (x > 0.0f) ? 1.0f : 0.0f; }","mark":8.0}
{"file_name":"imgui_internal_function_21.cpp","line_count":1,"code":"double ImSign(double x)           { return (x < 0.0) ? -1.0 : (x > 0.0) ? 1.0 : 0.0; }","mark":8.0}
{"file_name":"imgui_internal_function_25.cpp","line_count":1,"code":"T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }","mark":8.0}
{"file_name":"imgui_internal_function_29.cpp","line_count":1,"code":"void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }","mark":8.0}
{"file_name":"imgui_internal_function_35.cpp","line_count":1,"code":"ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }","mark":8.0}
{"file_name":"imgui_internal_function_36.cpp","line_count":1,"code":"ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }","mark":8.0}
{"file_name":"imgui_internal_function_37.cpp","line_count":1,"code":"ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }","mark":8.0}
{"file_name":"imgui_internal_function_39.cpp","line_count":1,"code":"float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }","mark":8.0}
{"file_name":"imgui_internal_function_40.cpp","line_count":1,"code":"float  ImLengthSqr(const ImVec4& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w); }","mark":8.0}
{"file_name":"imgui_internal_function_45.cpp","line_count":1,"code":"ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2(ImFloor(v.x), ImFloor(v.y)); }","mark":8.0}
{"file_name":"imgui_internal_function_47.cpp","line_count":1,"code":"float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }","mark":9.0}
{"file_name":"imgui_internal_function_48.cpp","line_count":1,"code":"ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }","mark":8.0}
{"file_name":"imgui_internal_function_5.cpp","line_count":1,"code":"bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\\t'; }","mark":8.0}
{"file_name":"imgui_internal_function_51.cpp","line_count":1,"code":"ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }","mark":8.0}
{"file_name":"imgui_internal_function_6.cpp","line_count":1,"code":"bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\\t' || c == 0x3000; }","mark":8.0}
{"file_name":"imgui_internal_function_61.cpp","line_count":1,"code":"void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }","mark":8.0}
{"file_name":"imgui_internal_function_62.cpp","line_count":1,"code":"void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }","mark":8.0}
{"file_name":"imgui_internal_function_7.cpp","line_count":1,"code":"bool      ImCharIsXdigitA(char c)         { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'); }","mark":8.0}
{"file_name":"imgui_internal_function_77.cpp","line_count":1,"code":"void            Clear()                     { Storage.clear(); }","mark":8.0}
{"file_name":"imgui_overlay_dx_function_30.cpp","line_count":17,"code":"HRESULT hkD3D12CreateDevice(IUnknown* pAdapter, D3D_FEATURE_LEVEL MinimumFeatureLevel, REFIID riid, void** ppDevice)\n{\n    LOG_FUNC();\n\n    auto result = o_D3D12CreateDevice(pAdapter, MinimumFeatureLevel, riid, ppDevice);\n\n    if (result == S_OK)\n    {\n        LOG_INFO(\"Device captured\");\n        g_pd3dDeviceParam = (ID3D12Device*)*ppDevice;\n        HookToDevice(g_pd3dDeviceParam);\n    }\n\n    LOG_FUNC_RESULT(result);\n\n    return result;\n}","mark":8.0}
{"file_name":"imgui_overlay_vk_function_8.cpp","line_count":24,"code":"VkResult hkvkCreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)\n{\n    LOG_FUNC();\n\n    auto result = o_vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);\n\n    auto procHwnd = Util::GetProcessWindow();\n    LOG_DEBUG(\"procHwnd: {0:X}, swapchain hwnd: {1:X}\", (UINT64)procHwnd, (UINT64)pCreateInfo->hwnd);\n\n    if (result == VK_SUCCESS && !Config::Instance()->VulkanSkipHooks && procHwnd == pCreateInfo->hwnd)\n    {\n        DestroyVulkanObjects(false);\n\n        _instance = instance;\n        LOG_DEBUG(\"_instance captured: {0:X}\", (UINT64)_instance);\n        _hwnd = pCreateInfo->hwnd;\n        LOG_DEBUG(\"_hwnd captured: {0:X}\", (UINT64)_hwnd);\n    }\n\n    LOG_FUNC_RESULT(result);\n\n    return result;\n\n}","mark":8.0}
{"file_name":"imgui_tables_function_1.cpp","line_count":32,"code":"ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window)\n{\n    \/\/ Adjust flags: set default sizing policy\n    if ((flags & ImGuiTableFlags_SizingMask_) == 0)\n        flags |= ((flags & ImGuiTableFlags_ScrollX) || (outer_window->Flags & ImGuiWindowFlags_AlwaysAutoResize)) ? ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_SizingStretchSame;\n\n    \/\/ Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame\n    if ((flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)\n        flags |= ImGuiTableFlags_NoKeepColumnsVisible;\n\n    \/\/ Adjust flags: enforce borders when resizable\n    if (flags & ImGuiTableFlags_Resizable)\n        flags |= ImGuiTableFlags_BordersInnerV;\n\n    \/\/ Adjust flags: disable NoHostExtendX\/NoHostExtendY if we have any scrolling going on\n    if (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY))\n        flags &= ~(ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_NoHostExtendY);\n\n    \/\/ Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody\n    if (flags & ImGuiTableFlags_NoBordersInBodyUntilResize)\n        flags &= ~ImGuiTableFlags_NoBordersInBody;\n\n    \/\/ Adjust flags: disable saved settings if there's nothing to save\n    if ((flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Sortable)) == 0)\n        flags |= ImGuiTableFlags_NoSavedSettings;\n\n    \/\/ Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)\n    if (outer_window->RootWindow->Flags & ImGuiWindowFlags_NoSavedSettings)\n        flags |= ImGuiTableFlags_NoSavedSettings;\n\n    return flags;\n}","mark":8.25}
{"file_name":"imgui_tables_function_31.cpp","line_count":4,"code":"size_t TableSettingsCalcChunkSize(int columns_count)\n{\n    return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);\n}","mark":8.0}
{"file_name":"imgui_widgets_function_110.cpp","line_count":6,"code":"IMGUI_CDECL TabItemComparerByBeginOrder(const void* lhs, const void* rhs)\n{\n    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;\n    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;\n    return (int)(a->BeginOrder - b->BeginOrder);\n}","mark":8.0}
{"file_name":"imgui_widgets_function_12.cpp","line_count":6,"code":"int DataTypeCompareT(const T* lhs, const T* rhs)\n{\n    if (*lhs < *rhs) return -1;\n    if (*lhs > *rhs) return +1;\n    return 0;\n}","mark":8.0}
{"file_name":"imgui_widgets_function_27.cpp","line_count":1,"code":"int     STB_TEXTEDIT_STRINGLEN(const ImGuiInputTextState* obj)                             { return obj->CurLenA; }","mark":8.0}
{"file_name":"imgui_widgets_function_32.cpp","line_count":7,"code":"int IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL(ImGuiInputTextState* obj, int idx)\n{\n    if (idx <= 0)\n        return -1;\n    const char* p = ImTextFindPreviousUtf8Codepoint(obj->TextA.Data, obj->TextA.Data + idx);\n    return (int)(p - obj->TextA.Data);\n}","mark":8.0}
{"file_name":"imgui_widgets_function_78.cpp","line_count":7,"code":"else if (flags & ImGuiColorEditFlags_InputHSV)\n    {\n        if (flags & ImGuiColorEditFlags_NoAlpha)\n            Text(\"H: %.3f, S: %.3f, V: %.3f\", col[0], col[1], col[2]);\n        else\n            Text(\"H: %.3f, S: %.3f, V: %.3f, A: %.3f\", col[0], col[1], col[2], col[3]);\n    }","mark":8.0}
{"file_name":"imgui_widgets_function_86.cpp","line_count":12,"code":"void BoxSelectPreStartDrag(ImGuiID id, ImGuiSelectionUserData clicked_item)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiBoxSelectState* bs = &g.BoxSelectState;\n    bs->ID = id;\n    bs->IsStarting = true; \/\/ Consider starting box-select.\n    bs->IsStartedFromVoid = (clicked_item == ImGuiSelectionUserData_Invalid);\n    bs->IsStartedSetNavIdOnce = bs->IsStartedFromVoid;\n    bs->KeyMods = g.IO.KeyMods;\n    bs->StartPosRel = bs->EndPosRel = ImGui::WindowPosAbsToRel(g.CurrentWindow, g.IO.MousePos);\n    bs->ScrollAccum = ImVec2(0.0f, 0.0f);\n}","mark":8.0}
{"file_name":"imgui_widgets_function_88.cpp","line_count":11,"code":"void BoxSelectDeactivateDrag(ImGuiBoxSelectState* bs)\n{\n    ImGuiContext& g = *GImGui;\n    bs->IsActive = bs->IsStarting = false;\n    if (g.ActiveId == bs->ID)\n    {\n        IMGUI_DEBUG_LOG_SELECTION(\"[selection] BeginBoxSelect() 0X%08X: Deactivate\\n\", bs->ID);\n        ImGui::ClearActiveID();\n    }\n    bs->ID = 0;\n}","mark":8.0}
{"file_name":"imgui_widgets_function_9.cpp","line_count":7,"code":"float CalcMaxPopupHeightFromItemCount(int items_count)\n{\n    ImGuiContext& g = *GImGui;\n    if (items_count <= 0)\n        return FLT_MAX;\n    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);\n}","mark":8.0}
{"file_name":"imgui_widgets_function_98.cpp","line_count":6,"code":"IMGUI_CDECL PairComparerByValueInt(const void* lhs, const void* rhs)\n{\n    int lhs_v = ((const ImGuiStoragePair*)lhs)->val_i;\n    int rhs_v = ((const ImGuiStoragePair*)rhs)->val_i;\n    return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1 : 0);\n}","mark":8.0}
{"file_name":"imstb_textedit_function_17.cpp","line_count":7,"code":"void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)\n{\n   if (!STB_TEXT_HAS_SELECTION(state))\n      state->select_start = state->select_end = state->cursor;\n   else\n      state->cursor = state->select_end;\n}","mark":8.0}
{"file_name":"imstb_textedit_function_18.cpp","line_count":9,"code":"int stb_textedit_cut(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      stb_textedit_delete_selection(str,state); \/\/ implicitly clamps\n      state->has_preferred_x = 0;\n      return 1;\n   }\n   return 0;\n}","mark":8.0}
{"file_name":"imstb_textedit_function_33.cpp","line_count":4,"code":"void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)\n{\n   stb_text_createundo(&state->undostate, where, 0, length);\n}","mark":8.0}
{"file_name":"imstb_textedit_function_38.cpp","line_count":4,"code":"int stb_textedit_paste(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE const *ctext, int len)\n{\n   return stb_textedit_paste_internal(str, state, (IMSTB_TEXTEDIT_CHARTYPE *) ctext, len);\n}","mark":8.0}
{"file_name":"imstb_textedit_function_8.cpp","line_count":12,"code":"void stb_textedit_clamp(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   int n = STB_TEXTEDIT_STRINGLEN(str);\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      if (state->select_start > n) state->select_start = n;\n      if (state->select_end   > n) state->select_end = n;\n      \/\/ if clamping forced them to be equal, move the cursor to match\n      if (state->select_start == state->select_end)\n         state->cursor = state->select_start;\n   }\n   if (state->cursor > n) state->cursor = n;\n}","mark":8.0}
{"file_name":"imstb_truetype_function_11.cpp","line_count":8,"code":"stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)\n{\n   stbtt__buf r = stbtt__new_buf(NULL, 0);\n   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;\n   r.data = b->data + o;\n   r.size = s;\n   return r;\n}","mark":8.0}
{"file_name":"imstb_truetype_function_115.cpp","line_count":6,"code":"void stbtt__add_point(stbtt__point *points, int n, float x, float y)\n{\n   if (!points) return; \/\/ during first pass, it's unallocated\n   points[n].x = x;\n   points[n].y = y;\n}","mark":8.0}
{"file_name":"imstb_truetype_function_120.cpp","line_count":4,"code":"void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_122.cpp","line_count":4,"code":"void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_124.cpp","line_count":4,"code":"void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));\n}","mark":8.0}
{"file_name":"imstb_truetype_function_127.cpp","line_count":10,"code":"void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)\n{\n   con->width  = pw;\n   con->height = ph;\n   con->x = 0;\n   con->y = 0;\n   con->bottom_y = 0;\n   STBTT__NOTUSED(nodes);\n   STBTT__NOTUSED(num_nodes);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_130.cpp","line_count":5,"code":"void stbtt_PackEnd  (stbtt_pack_context *spc)\n{\n   STBTT_free(spc->nodes    , spc->user_allocator_context);\n   STBTT_free(spc->pack_info, spc->user_allocator_context);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_132.cpp","line_count":4,"code":"void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)\n{\n   spc->skip_missing = skip;\n}","mark":8.0}
{"file_name":"imstb_truetype_function_139.cpp","line_count":11,"code":"float stbtt__oversample_shift(int oversample)\n{\n   if (!oversample)\n      return 0.0f;\n\n   \/\/ The prefilter is a box filter of width \"oversample\",\n   \/\/ which shifts phase by (oversample - 1)\/2 pixels in\n   \/\/ oversampled space. We want to shift in the opposite\n   \/\/ direction to counter this.\n   return (float)-(oversample - 1) \/ (2.0f * (float)oversample);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_148.cpp","line_count":12,"code":"void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)\n{\n   int i_ascent, i_descent, i_lineGap;\n   float scale;\n   stbtt_fontinfo info;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));\n   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);\n   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);\n   *ascent  = (float) i_ascent  * scale;\n   *descent = (float) i_descent * scale;\n   *lineGap = (float) i_lineGap * scale;\n}","mark":8.0}
{"file_name":"imstb_truetype_function_160.cpp","line_count":4,"code":"void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_172.cpp","line_count":4,"code":"int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)\n{\n   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_173.cpp","line_count":4,"code":"int stbtt_GetNumberOfFonts(const unsigned char *data)\n{\n   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_174.cpp","line_count":4,"code":"int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)\n{\n   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_21.cpp","line_count":1,"code":"stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }","mark":8.0}
{"file_name":"imstb_truetype_function_22.cpp","line_count":1,"code":"stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }","mark":8.0}
{"file_name":"imstb_truetype_function_35.cpp","line_count":4,"code":"int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)\n{\n   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_36.cpp","line_count":8,"code":"void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)\n{\n   v->type = type;\n   v->x = (stbtt_int16) x;\n   v->y = (stbtt_int16) y;\n   v->cx = (stbtt_int16) cx;\n   v->cy = (stbtt_int16) cy;\n}","mark":8.5}
{"file_name":"imstb_truetype_function_40.cpp","line_count":4,"code":"int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)\n{\n   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_5.cpp","line_count":6,"code":"stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor++];\n}","mark":8.0}
{"file_name":"imstb_truetype_function_51.cpp","line_count":7,"code":"void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   stbtt__csctx_close_shape(ctx);\n   ctx->first_x = ctx->x = ctx->x + dx;\n   ctx->first_y = ctx->y = ctx->y + dy;\n   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_52.cpp","line_count":6,"code":"void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   ctx->x += dx;\n   ctx->y += dy;\n   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_6.cpp","line_count":6,"code":"stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor];\n}","mark":8.0}
{"file_name":"imstb_truetype_function_70.cpp","line_count":11,"code":"int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)\n{\n   int xAdvance = 0;\n\n   if (info->gpos)\n      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);\n   else if (info->kern)\n      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);\n\n   return xAdvance;\n}","mark":8.0}
{"file_name":"imstb_truetype_function_71.cpp","line_count":6,"code":"int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)\n{\n   if (!info->kern && !info->gpos) \/\/ if no kerning table, don't waste time looking up both codepoint->glyphs\n      return 0;\n   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));\n}","mark":8.0}
{"file_name":"imstb_truetype_function_72.cpp","line_count":4,"code":"void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_73.cpp","line_count":6,"code":"void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)\n{\n   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);\n   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);\n   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_74.cpp","line_count":10,"code":"int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)\n{\n   int tab = stbtt__find_table(info->data, info->fontstart, \"OS\/2\");\n   if (!tab)\n      return 0;\n   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);\n   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);\n   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);\n   return 1;\n}","mark":8.0}
{"file_name":"imstb_truetype_function_8.cpp","line_count":4,"code":"void stbtt__buf_skip(stbtt__buf *b, int o)\n{\n   stbtt__buf_seek(b, b->cursor + o);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_80.cpp","line_count":4,"code":"int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)\n{\n   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_82.cpp","line_count":4,"code":"void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_83.cpp","line_count":4,"code":"void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_84.cpp","line_count":4,"code":"void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);\n}","mark":8.0}
{"file_name":"imstb_truetype_function_86.cpp","line_count":9,"code":"void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)\n{\n   stbtt__hheap_chunk *c = hh->head;\n   while (c) {\n      stbtt__hheap_chunk *n = c->next;\n      STBTT_free(c, userdata);\n      c = n;\n   }\n}","mark":8.0}
{"file_name":"imstb_truetype_function_9.cpp","line_count":9,"code":"stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)\n{\n   stbtt_uint32 v = 0;\n   int i;\n   STBTT_assert(n >= 1 && n <= 4);\n   for (i = 0; i < n; i++)\n      v = (v << 8) | stbtt__buf_get8(b);\n   return v;\n}","mark":8.0}
{"file_name":"imstb_truetype_function_95.cpp","line_count":6,"code":"float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)\n{\n   STBTT_assert(top_width >= 0);\n   STBTT_assert(bottom_width >= 0);\n   return (top_width + bottom_width) \/ 2.0f * height;\n}","mark":8.0}
{"file_name":"imstb_truetype_function_97.cpp","line_count":4,"code":"float stbtt__sized_triangle_area(float height, float width)\n{\n   return height * width \/ 2;\n}","mark":8.0}
{"file_name":"inputtino_common_function_1.cpp","line_count":4,"code":"float\n  deg2rad(float degree) {\n    return degree * (M_PI \/ 180.f);\n  }","mark":8.0}
{"file_name":"input_function_53.cpp","line_count":4,"code":"else if (config::input.gamepad == \"ds4\"sv) {\n      BOOST_LOG(info) << \"Gamepad \" << id.globalIndex << \" will be DualShock 4 controller (manual selection)\"sv;\n      selectedGamepadType = DualShock4Wired;\n    }","mark":8.0}
{"file_name":"InstallNitro_function_2.cpp","line_count":5,"code":"void install(jsi::Runtime& runtime) {\n  \/\/ Installs global.NitroModulesProxy\n  auto proxy = std::make_shared<HybridNitroModulesProxy>();\n  runtime.global().setProperty(runtime, \"NitroModulesProxy\", proxy->toObject(runtime));\n}","mark":8.0}
{"file_name":"io_control_function_1.cpp","line_count":4,"code":"void set(std::size_t value)\n  {\n    value_ = static_cast<detail::ioctl_arg_type>(value);\n  }","mark":8.0}
{"file_name":"io_uring_file_service_function_4.cpp","line_count":4,"code":"void destroy(implementation_type& impl)\n  {\n    descriptor_service_.destroy(impl);\n  }","mark":8.0}
{"file_name":"io_uring_file_service_function_6.cpp","line_count":4,"code":"void set_is_stream(implementation_type& impl, bool is_stream)\n  {\n    impl.is_stream_ = is_stream;\n  }","mark":8.0}
{"file_name":"io_uring_service_function_1.cpp","line_count":1,"code":"void set_result(int r) { task_result_ = static_cast<unsigned>(r); }","mark":8.0}
{"file_name":"io_uring_socket_service_base_function_1.cpp","line_count":4,"code":"native_handle_type native_handle(base_implementation_type& impl)\n  {\n    return impl.socket_;\n  }","mark":8.0}
{"file_name":"io_uring_socket_service_function_6.cpp","line_count":4,"code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    return impl.socket_;\n  }","mark":8.0}
{"file_name":"iprogs_mutex_function_1.cpp","line_count":4,"code":"void lock()\n  {\n    mutex_.lock();\n  }","mark":8.0}
{"file_name":"iprogs_mutex_function_2.cpp","line_count":4,"code":"void unlock()\n  {\n    mutex_.unlock();\n  }","mark":8.0}
{"file_name":"iprogs_thread_function_1.cpp","line_count":5,"code":"void join()\n  {\n    if (thread_.joinable())\n      thread_.join();\n  }","mark":8.0}
{"file_name":"JAnyMap_function_1.cpp","line_count":3,"code":"bool contains(const std::string& key) {\n    return _map->contains(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_10.cpp","line_count":3,"code":"bool isObject(const std::string& key) {\n    return _map->isObject(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_11.cpp","line_count":3,"code":"double getDouble(const std::string& key) {\n    return _map->getDouble(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_12.cpp","line_count":3,"code":"bool getBoolean(const std::string& key) {\n    return _map->getBoolean(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_15.cpp","line_count":3,"code":"void setNull(const std::string& key) {\n    _map->setNull(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_16.cpp","line_count":3,"code":"void setDouble(const std::string& key, double value) {\n    _map->setDouble(key, value);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_17.cpp","line_count":3,"code":"void setBoolean(const std::string& key, bool value) {\n    _map->setBoolean(key, value);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_18.cpp","line_count":3,"code":"void setBigInt(const std::string& key, int64_t value) {\n    _map->setBigInt(key, value);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_19.cpp","line_count":3,"code":"void setString(const std::string& key, const std::string& value) {\n    _map->setString(key, value);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_20.cpp","line_count":10,"code":"void setAnyArray(const std::string& key, jni::alias_ref<JAnyArray> value) {\n    std::vector<AnyValue> vector;\n    size_t size = value->size();\n    vector.reserve(size);\n    for (size_t i = 0; i < size; i++) {\n      auto anyValue = value->getElement(i);\n      vector.push_back(anyValue->cthis()->getValue());\n    }\n    _map->setArray(key, vector);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_22.cpp","line_count":33,"code":"void registerNatives() {\n    registerHybrid({\n        \/\/ init\n        makeNativeMethod(\"initHybrid\", JAnyMap::initHybrid),\n        \/\/ helpers\n        makeNativeMethod(\"contains\", JAnyMap::contains),\n        makeNativeMethod(\"remove\", JAnyMap::remove),\n        makeNativeMethod(\"clear\", JAnyMap::clear),\n        \/\/ is\n        makeNativeMethod(\"isNull\", JAnyMap::isNull),\n        makeNativeMethod(\"isDouble\", JAnyMap::isDouble),\n        makeNativeMethod(\"isBoolean\", JAnyMap::isBoolean),\n        makeNativeMethod(\"isBigInt\", JAnyMap::isBigInt),\n        makeNativeMethod(\"isString\", JAnyMap::isString),\n        makeNativeMethod(\"isArray\", JAnyMap::isArray),\n        makeNativeMethod(\"isObject\", JAnyMap::isObject),\n        \/\/ get\n        makeNativeMethod(\"getDouble\", JAnyMap::getDouble),\n        makeNativeMethod(\"getBoolean\", JAnyMap::getBoolean),\n        makeNativeMethod(\"getBigInt\", JAnyMap::getBigInt),\n        makeNativeMethod(\"getString\", JAnyMap::getString),\n        makeNativeMethod(\"getAnyArray\", JAnyMap::getAnyArray),\n        makeNativeMethod(\"getAnyObject\", JAnyMap::getAnyObject),\n        \/\/ set\n        makeNativeMethod(\"setNull\", JAnyMap::setNull),\n        makeNativeMethod(\"setDouble\", JAnyMap::setDouble),\n        makeNativeMethod(\"setBoolean\", JAnyMap::setBoolean),\n        makeNativeMethod(\"setBigInt\", JAnyMap::setBigInt),\n        makeNativeMethod(\"setString\", JAnyMap::setString),\n        makeNativeMethod(\"setAnyArray\", JAnyMap::setAnyArray),\n        makeNativeMethod(\"setAnyObject\", JAnyMap::setAnyObject),\n    });\n  }","mark":8.0}
{"file_name":"JAnyMap_function_3.cpp","line_count":3,"code":"void clear() {\n    _map->clear();\n  }","mark":8.0}
{"file_name":"JAnyMap_function_4.cpp","line_count":3,"code":"bool isNull(const std::string& key) {\n    return _map->isNull(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_5.cpp","line_count":3,"code":"bool isDouble(const std::string& key) {\n    return _map->isDouble(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_6.cpp","line_count":3,"code":"bool isBoolean(const std::string& key) {\n    return _map->isBoolean(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_7.cpp","line_count":3,"code":"bool isBigInt(const std::string& key) {\n    return _map->isBigInt(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_8.cpp","line_count":3,"code":"bool isString(const std::string& key) {\n    return _map->isString(key);\n  }","mark":8.0}
{"file_name":"JAnyMap_function_9.cpp","line_count":3,"code":"bool isArray(const std::string& key) {\n    return _map->isArray(key);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_1.cpp","line_count":3,"code":"bool isNull() {\n    return std::holds_alternative<std::monostate>(_value);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_10.cpp","line_count":3,"code":"int64_t asBigInt() {\n    return std::get<int64_t>(_value);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_2.cpp","line_count":3,"code":"bool isDouble() {\n    return std::holds_alternative<double>(_value);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_3.cpp","line_count":3,"code":"bool isBoolean() {\n    return std::holds_alternative<bool>(_value);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_4.cpp","line_count":3,"code":"bool isBigInt() {\n    return std::holds_alternative<int64_t>(_value);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_5.cpp","line_count":3,"code":"bool isString() {\n    return std::holds_alternative<std::string>(_value);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_6.cpp","line_count":3,"code":"bool isAnyArray() {\n    return std::holds_alternative<AnyArray>(_value);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_7.cpp","line_count":3,"code":"bool isAnyObject() {\n    return std::holds_alternative<AnyObject>(_value);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_8.cpp","line_count":3,"code":"double asDouble() {\n    return std::get<double>(_value);\n  }","mark":8.0}
{"file_name":"JAnyValue_function_9.cpp","line_count":3,"code":"bool asBoolean() {\n    return std::get<bool>(_value);\n  }","mark":8.0}
{"file_name":"JArrayBuffer_function_1.cpp","line_count":4,"code":"bool getIsByteBuffer() {\n    auto byteBufferArrayBuffer = std::dynamic_pointer_cast<ByteBufferArrayBuffer>(_arrayBuffer);\n    return byteBufferArrayBuffer != nullptr;\n  }","mark":8.0}
{"file_name":"JArrayBuffer_function_2.cpp","line_count":3,"code":"bool getIsOwner() {\n    return _arrayBuffer->isOwner();\n  }","mark":8.0}
{"file_name":"JArrayBuffer_function_3.cpp","line_count":3,"code":"int getBufferSize() {\n    return static_cast<int>(_arrayBuffer->size());\n  }","mark":8.0}
{"file_name":"JFunc_void_function_2.cpp","line_count":3,"code":"void registerNatives() {\n      registerHybrid({makeNativeMethod(\"call\", JFunc_void::call)});\n    }","mark":8.0}
{"file_name":"JFunc_void_std__string_function_2.cpp","line_count":3,"code":"void registerNatives() {\n      registerHybrid({makeNativeMethod(\"call\", JFunc_void_std__string::call)});\n    }","mark":8.0}
{"file_name":"JNIOnLoad_function_1.cpp","line_count":13,"code":"JNICALL JNI_OnLoad(JavaVM* vm, void*) {\n  return facebook::jni::initialize(vm, [] {\n    \/\/ 1. Initialize all core Nitro Java bindings\n    JHybridObjectRegistry::registerNatives();\n    JArrayBuffer::registerNatives();\n    JAnyMap::registerNatives();\n    JAnyValue::registerNatives();\n    JPromise::registerNatives();\n\n    \/\/ 2. Initialize the React Native TurboModule C++ part\n    JNitroModules::registerNatives();\n  });\n}","mark":8.0}
{"file_name":"JPromise_function_3.cpp","line_count":9,"code":"void addOnResolvedListener(OnResolvedFunc&& onResolved) {\n    if (_result != nullptr) {\n      \/\/ Promise is already resolved! Call the callback immediately\n      onResolved(_result);\n    } else {\n      \/\/ Promise is not yet resolved, put the listener in our queue.\n      _onResolvedListeners.push_back(std::move(onResolved));\n    }\n  }","mark":8.0}
{"file_name":"JPromise_function_4.cpp","line_count":9,"code":"void addOnRejectedListener(OnRejectedFunc&& onRejected) {\n    if (_error != nullptr) {\n      \/\/ Promise is already rejected! Call the callback immediately\n      onRejected(_error);\n    } else {\n      \/\/ Promise is not yet rejected, put the listener in our queue.\n      _onRejectedListeners.push_back(std::move(onRejected));\n    }\n  }","mark":8.0}
{"file_name":"JPromise_function_5.cpp","line_count":7,"code":"void registerNatives() {\n    registerHybrid({\n        makeNativeMethod(\"initHybrid\", JPromise::initHybrid),\n        makeNativeMethod(\"nativeResolve\", JPromise::resolve),\n        makeNativeMethod(\"nativeReject\", JPromise::reject),\n    });\n  }","mark":8.0}
{"file_name":"JSIConverter+AnyMap_function_3.cpp","line_count":3,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    return JSIConverter<AnyValue::variant>::canConvert(runtime, value);\n  }","mark":8.0}
{"file_name":"JSIConverter+AnyMap_function_4.cpp","line_count":9,"code":"Value toJSI(jsi::Runtime& runtime, std::shared_ptr<AnyMap> map) {\n    jsi::Object object(runtime);\n    for (const auto& item : map->getMap()) {\n      jsi::String key = jsi::String::createFromUtf8(runtime, item.first);\n      jsi::Value value = JSIConverter<AnyValue>::toJSI(runtime, item.second);\n      object.setProperty(runtime, std::move(key), std::move(value));\n    }\n    return object;\n  }","mark":8.0}
{"file_name":"JSIConverter+AnyMap_function_5.cpp","line_count":18,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (!value.isObject()) {\n      return false;\n    }\n    jsi::Object object = value.getObject(runtime);\n    if (!isPlainObject(runtime, object)) {\n      return false;\n    }\n    jsi::Array properties = object.getPropertyNames(runtime);\n    size_t size = properties.size(runtime);\n    for (size_t i = 0; i < size; i++) {\n      bool canConvertProp = JSIConverter<AnyValue>::canConvert(runtime, properties.getValueAtIndex(runtime, i));\n      if (!canConvertProp) {\n        return false;\n      }\n    }\n    return true;\n  }","mark":8.0}
{"file_name":"JSIConverter+ArrayBuffer_function_2.cpp","line_count":7,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (value.isObject()) {\n      jsi::Object object = value.getObject(runtime);\n      return object.isArrayBuffer(runtime);\n    }\n    return false;\n  }","mark":8.0}
{"file_name":"JSIConverter+HostObject_function_3.cpp","line_count":7,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (value.isObject()) {\n      jsi::Object object = value.getObject(runtime);\n      return object.isHostObject<TPointee>(runtime);\n    }\n    return false;\n  }","mark":8.0}
{"file_name":"JSIConverter+HybridObject_function_4.cpp","line_count":7,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (value.isObject()) {\n      jsi::Object object = value.getObject(runtime);\n      return object.hasNativeState<TPointee>(runtime);\n    }\n    return false;\n  }","mark":8.0}
{"file_name":"JSIConverter+Optional_function_1.cpp","line_count":7,"code":"Value toJSI(jsi::Runtime& runtime, const std::optional<TInner>& arg) {\n    if (arg == std::nullopt) {\n      return jsi::Value::undefined();\n    } else {\n      return JSIConverter<TInner>::toJSI(runtime, arg.value());\n    }\n  }","mark":8.0}
{"file_name":"JSIConverter+Promise_function_2.cpp","line_count":5,"code":"if constexpr (std::is_void_v<TResult>) {\n              \/\/ it's returning void, just return undefined to JS\n              sharedFuture->get();\n              promise->resolve(runtime, jsi::Value::undefined());\n            }","mark":8.0}
{"file_name":"JSIConverter+UnorderedMap_function_1.cpp","line_count":8,"code":"Value toJSI(jsi::Runtime& runtime, const std::unordered_map<std::string, ValueType>& map) {\n    jsi::Object object(runtime);\n    for (const auto& pair : map) {\n      jsi::Value value = JSIConverter<ValueType>::toJSI(runtime, pair.second);\n      object.setProperty(runtime, pair.first.c_str(), std::move(value));\n    }\n    return object;\n  }","mark":8.0}
{"file_name":"JSIConverter+UnorderedMap_function_2.cpp","line_count":18,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (!value.isObject()) {\n      return false;\n    }\n    jsi::Object object = value.getObject(runtime);\n    if (!isPlainObject(runtime, object)) {\n      return false;\n    }\n    jsi::Array properties = object.getPropertyNames(runtime);\n    size_t size = properties.size(runtime);\n    for (size_t i = 0; i < size; i++) {\n      bool canConvertProp = JSIConverter<ValueType>::canConvert(runtime, properties.getValueAtIndex(runtime, i));\n      if (!canConvertProp) {\n        return false;\n      }\n    }\n    return true;\n  }","mark":8.0}
{"file_name":"JSIConverter+Variant_function_1.cpp","line_count":4,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    \/\/ Check each type in `Types...` to make sure we can convert `jsi::Value` to one of those.\n    return (JSIConverter<Types>::canConvert(runtime, value) || ...);\n  }","mark":8.0}
{"file_name":"JSIConverter_function_10.cpp","line_count":3,"code":"double fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return arg.asNumber();\n  }","mark":8.0}
{"file_name":"JSIConverter_function_12.cpp","line_count":3,"code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isNumber();\n  }","mark":8.0}
{"file_name":"JSIConverter_function_13.cpp","line_count":3,"code":"float fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return static_cast<float>(arg.asNumber());\n  }","mark":8.0}
{"file_name":"JSIConverter_function_15.cpp","line_count":3,"code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isNumber();\n  }","mark":8.0}
{"file_name":"JSIConverter_function_17.cpp","line_count":3,"code":"Value toJSI(jsi::Runtime& runtime, int64_t arg) {\n    return jsi::BigInt::fromInt64(runtime, arg);\n  }","mark":8.0}
{"file_name":"JSIConverter_function_20.cpp","line_count":3,"code":"Value toJSI(jsi::Runtime& runtime, uint64_t arg) {\n    return jsi::BigInt::fromUint64(runtime, arg);\n  }","mark":8.0}
{"file_name":"JSIConverter_function_22.cpp","line_count":3,"code":"bool fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return arg.asBool();\n  }","mark":8.0}
{"file_name":"JSIConverter_function_24.cpp","line_count":3,"code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isBool();\n  }","mark":8.0}
{"file_name":"JSIConverter_function_25.cpp","line_count":3,"code":"string fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {\n    return arg.asString(runtime).utf8(runtime);\n  }","mark":8.0}
{"file_name":"JSIConverter_function_26.cpp","line_count":3,"code":"Value toJSI(jsi::Runtime& runtime, const std::string& arg) {\n    return jsi::String::createFromUtf8(runtime, arg);\n  }","mark":8.0}
{"file_name":"JSIConverter_function_27.cpp","line_count":3,"code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isString();\n  }","mark":8.0}
{"file_name":"JSIConverter_function_4.cpp","line_count":3,"code":"int fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return static_cast<int>(arg.asNumber());\n  }","mark":8.0}
{"file_name":"JSIConverter_function_6.cpp","line_count":3,"code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isNumber();\n  }","mark":8.0}
{"file_name":"JSIHelpers_function_1.cpp","line_count":18,"code":"bool isPlainObject(jsi::Runtime& runtime, const jsi::Object& object) {\n  if (object.isArray(runtime)) {\n    return false;\n  }\n  if (object.isArrayBuffer(runtime)) {\n    return false;\n  }\n  if (object.isFunction(runtime)) {\n    return false;\n  }\n  if (object.isHostObject(runtime)) {\n    return false;\n  }\n  if (object.hasNativeState(runtime)) {\n    return false;\n  }\n  return true;\n}","mark":8.0}
{"file_name":"JSIHelpers_function_2.cpp","line_count":4,"code":"string getRuntimeId(jsi::Runtime& runtime) {\n  std::string threadName = ThreadUtils::getThreadName();\n  return runtime.description() + std::string(\" (\") + threadName + std::string(\")\");\n}","mark":8.0}
{"file_name":"JsonTokenizerTest_function_5.cpp","line_count":1,"code":"void runSerializationJsonTokenizerTest(SC::TestReport& report) { JsonTokenizerTest test(report); }","mark":8.0}
{"file_name":"json_function_107.cpp","line_count":4,"code":"adapter_type create(IteratorType first, IteratorType last)\n    {\n        return adapter_type(std::move(first), std::move(last));\n    }","mark":8.0}
{"file_name":"json_function_109.cpp","line_count":5,"code":"adapter_type input_adapter(IteratorType first, IteratorType last)\n{\n    using factory_type = iterator_input_adapter_factory<IteratorType>;\n    return factory_type::create(first, last);\n}","mark":8.0}
{"file_name":"json_function_110.cpp","line_count":4,"code":"adapter_type create(const ContainerType& container)\n{\n    return input_adapter(begin(container), end(container));\n}","mark":8.0}
{"file_name":"json_function_111.cpp","line_count":4,"code":"adapter_type input_adapter(const ContainerType& container)\n{\n    return container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);\n}","mark":8.0}
{"file_name":"json_function_123.cpp","line_count":11,"code":"bool start_object(std::size_t len)\n    {\n        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));\n\n        if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))\n        {\n            JSON_THROW(out_of_range::create(408, concat(\"excessive object size: \", std::to_string(len)), ref_stack.back()));\n        }\n\n        return true;\n    }","mark":8.0}
{"file_name":"json_function_125.cpp","line_count":9,"code":"bool end_object()\n    {\n        JSON_ASSERT(!ref_stack.empty());\n        JSON_ASSERT(ref_stack.back()->is_object());\n\n        ref_stack.back()->set_parents();\n        ref_stack.pop_back();\n        return true;\n    }","mark":8.0}
{"file_name":"json_function_151.cpp","line_count":4,"code":"bool end_object()\n    {\n        return true;\n    }","mark":8.0}
{"file_name":"json_function_152.cpp","line_count":4,"code":"bool end_array()\n    {\n        return true;\n    }","mark":8.0}
{"file_name":"json_function_173.cpp","line_count":8,"code":"void skip_whitespace()\n    {\n        do\n        {\n            get();\n        }\n        while (current == ' ' || current == '\\t' || current == '\\n' || current == '\\r');\n    }","mark":8.0}
{"file_name":"json_function_211.cpp","line_count":106,"code":"bool get_msgpack_binary(binary_t& result)\n    {\n        \/\/ helper function to set the subtype\n        auto assign_and_return_true = [&result](std::int8_t subtype)\n        {\n            result.set_subtype(static_cast<std::uint8_t>(subtype));\n            return true;\n        };\n\n        switch (current)\n        {\n            case 0xC4: \/\/ bin 8\n            {\n                std::uint8_t len{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_binary(input_format_t::msgpack, len, result);\n            }\n\n            case 0xC5: \/\/ bin 16\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_binary(input_format_t::msgpack, len, result);\n            }\n\n            case 0xC6: \/\/ bin 32\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_binary(input_format_t::msgpack, len, result);\n            }\n\n            case 0xC7: \/\/ ext 8\n            {\n                std::uint8_t len{};\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, len, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xC8: \/\/ ext 16\n            {\n                std::uint16_t len{};\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, len, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xC9: \/\/ ext 32\n            {\n                std::uint32_t len{};\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, len, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD4: \/\/ fixext 1\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 1, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD5: \/\/ fixext 2\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 2, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD6: \/\/ fixext 4\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 4, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD7: \/\/ fixext 8\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 8, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD8: \/\/ fixext 16\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 16, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            default:           \/\/ LCOV_EXCL_LINE\n                return false;  \/\/ LCOV_EXCL_LINE\n        }\n    }","mark":8.0}
{"file_name":"json_function_212.cpp","line_count":17,"code":"bool get_msgpack_array(const std::size_t len)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))\n        {\n            return false;\n        }\n\n        for (std::size_t i = 0; i < len; ++i)\n        {\n            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))\n            {\n                return false;\n            }\n        }\n\n        return sax->end_array();\n    }","mark":8.0}
{"file_name":"json_function_236.cpp","line_count":9,"code":"void pop_back()\n    {\n        if (JSON_HEDLEY_UNLIKELY(empty()))\n        {\n            JSON_THROW(detail::out_of_range::create(405, \"JSON pointer has no parent\", nullptr));\n        }\n\n        reference_tokens.pop_back();\n    }","mark":8.0}
{"file_name":"json_function_237.cpp","line_count":4,"code":"void push_back(const string_t& token)\n    {\n        reference_tokens.push_back(token);\n    }","mark":8.0}
{"file_name":"json_function_238.cpp","line_count":4,"code":"void push_back(string_t&& token)\n    {\n        reference_tokens.push_back(std::move(token));\n    }","mark":8.0}
{"file_name":"json_function_239.cpp","line_count":36,"code":"size_type array_index(const string_t& s)\n    {\n        using size_type = typename BasicJsonType::size_type;\n\n        \/\/ error condition (cf. RFC 6901, Sect. 4)\n        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))\n        {\n            JSON_THROW(detail::parse_error::create(106, 0, detail::concat(\"array index '\", s, \"' must not begin with '0'\"), nullptr));\n        }\n\n        \/\/ error condition (cf. RFC 6901, Sect. 4)\n        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))\n        {\n            JSON_THROW(detail::parse_error::create(109, 0, detail::concat(\"array index '\", s, \"' is not a number\"), nullptr));\n        }\n\n        const char* p = s.c_str();\n        char* p_end = nullptr;\n        errno = 0; \/\/ strtoull doesn't reset errno\n        const unsigned long long res = std::strtoull(p, &p_end, 10); \/\/ NOLINT(runtime\/int)\n        if (p == p_end \/\/ invalid input or empty string\n                || errno == ERANGE \/\/ out of range\n                || JSON_HEDLEY_UNLIKELY(static_cast<std::size_t>(p_end - p) != s.size())) \/\/ incomplete read\n        {\n            JSON_THROW(detail::out_of_range::create(404, detail::concat(\"unresolved reference token '\", s, \"'\"), nullptr));\n        }\n\n        \/\/ only triggered on special platforms (like 32bit), see also\n        \/\/ https:\/\/github.com\/nlohmann\/json\/pull\/2203\n        if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))  \/\/ NOLINT(runtime\/int)\n        {\n            JSON_THROW(detail::out_of_range::create(410, detail::concat(\"array index \", s, \" exceeds size_type\"), nullptr));   \/\/ LCOV_EXCL_LINE\n        }\n\n        return static_cast<size_type>(res);\n    }","mark":8.0}
{"file_name":"json_function_261.cpp","line_count":4,"code":"void write_bson_null(const string_t& name)\n    {\n        write_bson_entry_header(name, 0x0A);\n    }","mark":8.0}
{"file_name":"json_function_262.cpp","line_count":6,"code":"size_t calc_bson_integer_size(const std::int64_t value)\n    {\n        return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()\n               ? sizeof(std::int32_t)\n               : sizeof(std::int64_t);\n    }","mark":8.0}
{"file_name":"json_function_272.cpp","line_count":10,"code":"size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)\n    {\n        const std::size_t document_size = std::accumulate(value.begin(), value.end(), static_cast<std::size_t>(0),\n                                          [](size_t result, const typename BasicJsonType::object_t::value_type & el)\n        {\n            return result += calc_bson_element_size(el.first, el.second);\n        });\n\n        return sizeof(std::int32_t) + document_size + 1ul;\n    }","mark":8.0}
{"file_name":"json_function_314.cpp","line_count":4,"code":"bool is_negative_number(NumberType x)\n    {\n        return x < 0;\n    }","mark":8.0}
{"file_name":"json_function_32.cpp","line_count":7,"code":"OutStringType concat(Args && ... args)\n{\n    OutStringType str;\n    str.reserve(concat_length(args...));\n    concat_into(str, std::forward<Args>(args)...);\n    return str;\n}","mark":8.0}
{"file_name":"json_function_325.cpp","line_count":4,"code":"iterator erase(iterator pos)\n    {\n        return erase(pos, std::next(pos));\n    }","mark":8.0}
{"file_name":"json_function_329.cpp","line_count":7,"code":"void insert(InputIt first, InputIt last)\n    {\n        for (auto it = first; it != last; ++it)\n        {\n            insert(*it);\n        }\n    }","mark":8.0}
{"file_name":"json_function_330.cpp","line_count":4,"code":"allocator_type get_allocator()\n    {\n        return allocator_type();\n    }","mark":8.0}
{"file_name":"json_function_331.cpp","line_count":62,"code":"basic_json meta()\n    {\n        basic_json result;\n\n        result[\"copyright\"] = \"(C) 2013-2022 Niels Lohmann\";\n        result[\"name\"] = \"JSON for Modern C++\";\n        result[\"url\"] = \"https:\/\/github.com\/nlohmann\/json\";\n        result[\"version\"][\"string\"] =\n            detail::concat(std::to_string(NLOHMANN_JSON_VERSION_MAJOR), '.',\n                           std::to_string(NLOHMANN_JSON_VERSION_MINOR), '.',\n                           std::to_string(NLOHMANN_JSON_VERSION_PATCH));\n        result[\"version\"][\"major\"] = NLOHMANN_JSON_VERSION_MAJOR;\n        result[\"version\"][\"minor\"] = NLOHMANN_JSON_VERSION_MINOR;\n        result[\"version\"][\"patch\"] = NLOHMANN_JSON_VERSION_PATCH;\n\n#ifdef _WIN32\n        result[\"platform\"] = \"win32\";\n#elif defined __linux__\n        result[\"platform\"] = \"linux\";\n#elif defined __APPLE__\n        result[\"platform\"] = \"apple\";\n#elif defined __unix__\n        result[\"platform\"] = \"unix\";\n#else\n        result[\"platform\"] = \"unknown\";\n#endif\n\n#if defined(__ICC) || defined(__INTEL_COMPILER)\n        result[\"compiler\"] = {{\"family\", \"icc\"}, {\"version\", __INTEL_COMPILER}};\n#elif defined(__clang__)\n        result[\"compiler\"] = {{\"family\", \"clang\"}, {\"version\", __clang_version__}};\n#elif defined(__GNUC__) || defined(__GNUG__)\n        result[\"compiler\"] = {{\"family\", \"gcc\"}, {\"version\", detail::concat(\n                    std::to_string(__GNUC__), '.',\n                    std::to_string(__GNUC_MINOR__), '.',\n                    std::to_string(__GNUC_PATCHLEVEL__))\n            }\n        };\n#elif defined(__HP_cc) || defined(__HP_aCC)\n        result[\"compiler\"] = \"hp\"\n#elif defined(__IBMCPP__)\n        result[\"compiler\"] = {{\"family\", \"ilecpp\"}, {\"version\", __IBMCPP__}};\n#elif defined(_MSC_VER)\n        result[\"compiler\"] = {{\"family\", \"msvc\"}, {\"version\", _MSC_VER}};\n#elif defined(__PGI)\n        result[\"compiler\"] = {{\"family\", \"pgcpp\"}, {\"version\", __PGI}};\n#elif defined(__SUNPRO_CC)\n        result[\"compiler\"] = {{\"family\", \"sunpro\"}, {\"version\", __SUNPRO_CC}};\n#else\n        result[\"compiler\"] = {{\"family\", \"unknown\"}, {\"version\", \"unknown\"}};\n#endif\n\n\n#if defined(_MSVC_LANG)\n        result[\"compiler\"][\"c++\"] = std::to_string(_MSVC_LANG);\n#elif defined(__cplusplus)\n        result[\"compiler\"][\"c++\"] = std::to_string(__cplusplus);\n#else\n        result[\"compiler\"][\"c++\"] = \"unknown\";\n#endif\n        return result;\n    }","mark":8.0}
{"file_name":"json_function_342.cpp","line_count":7,"code":"basic_json binary(const typename binary_t::container_type& init)\n    {\n        auto res = basic_json();\n        res.m_type = value_t::binary;\n        res.m_value = init;\n        return res;\n    }","mark":8.0}
{"file_name":"json_function_343.cpp","line_count":7,"code":"basic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype)\n    {\n        auto res = basic_json();\n        res.m_type = value_t::binary;\n        res.m_value = binary_t(init, subtype);\n        return res;\n    }","mark":8.0}
{"file_name":"json_function_350.cpp","line_count":5,"code":"ReferenceType get_ref()\n    {\n        \/\/ delegate call to get_ref_impl\n        return get_ref_impl<ReferenceType>(*this);\n    }","mark":8.0}
{"file_name":"json_function_359.cpp","line_count":16,"code":"size_type erase_internal(KeyType && key)\n    {\n        \/\/ this erase only works for objects\n        if (JSON_HEDLEY_UNLIKELY(!is_object()))\n        {\n            JSON_THROW(type_error::create(307, detail::concat(\"cannot use erase() with \", type_name()), this));\n        }\n\n        const auto it = m_value.object->find(std::forward<KeyType>(key));\n        if (it != m_value.object->end())\n        {\n            m_value.object->erase(it);\n            return 1;\n        }\n        return 0;\n    }","mark":8.0}
{"file_name":"json_function_360.cpp","line_count":6,"code":"size_type erase(const typename object_t::key_type& key)\n    {\n        \/\/ the indirection via erase_internal() is added to avoid making this\n        \/\/ function a template and thus de-rank it during overload resolution\n        return erase_internal(key);\n    }","mark":8.0}
{"file_name":"json_function_361.cpp","line_count":4,"code":"size_type erase(KeyType && key)\n    {\n        return erase_internal(std::forward<KeyType>(key));\n    }","mark":8.0}
{"file_name":"json_function_365.cpp","line_count":22,"code":"void push_back(basic_json&& val)\n    {\n        \/\/ push_back only works for null objects or arrays\n        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))\n        {\n            JSON_THROW(type_error::create(308, detail::concat(\"cannot use push_back() with \", type_name()), this));\n        }\n\n        \/\/ transform null object into an array\n        if (is_null())\n        {\n            m_type = value_t::array;\n            m_value = value_t::array;\n            assert_invariant();\n        }\n\n        \/\/ add element to array (move semantics)\n        const auto old_capacity = m_value.array->capacity();\n        m_value.array->push_back(std::move(val));\n        set_parent(m_value.array->back(), old_capacity);\n        \/\/ if val is moved from, basic_json move constructor marks it null, so we do not call the destructor\n    }","mark":8.0}
{"file_name":"json_function_376.cpp","line_count":22,"code":"void insert(const_iterator first, const_iterator last)\n    {\n        \/\/ insert only works for objects\n        if (JSON_HEDLEY_UNLIKELY(!is_object()))\n        {\n            JSON_THROW(type_error::create(309, detail::concat(\"cannot use insert() with \", type_name()), this));\n        }\n\n        \/\/ check if range iterators belong to the same JSON object\n        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))\n        {\n            JSON_THROW(invalid_iterator::create(210, \"iterators do not fit\", this));\n        }\n\n        \/\/ passed iterators must belong to objects\n        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))\n        {\n            JSON_THROW(invalid_iterator::create(202, \"iterators first and last must point to objects\", this));\n        }\n\n        m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);\n    }","mark":8.0}
{"file_name":"json_function_377.cpp","line_count":4,"code":"void update(const_reference j, bool merge_objects = false)\n    {\n        update(j.begin(), j.end(), merge_objects);\n    }","mark":8.0}
{"file_name":"json_function_38.cpp","line_count":5,"code":"string position_string(const position_t& pos)\n    {\n        return concat(\" at line \", std::to_string(pos.lines_read + 1),\n                      \", column \", std::to_string(pos.chars_read_current_line));\n    }","mark":8.0}
{"file_name":"json_function_388.cpp","line_count":4,"code":"void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o)\n    {\n        binary_writer<std::uint8_t>(o).write_cbor(j);\n    }","mark":8.0}
{"file_name":"json_function_389.cpp","line_count":4,"code":"void to_cbor(const basic_json& j, detail::output_adapter<char> o)\n    {\n        binary_writer<char>(o).write_cbor(j);\n    }","mark":8.0}
{"file_name":"json_function_390.cpp","line_count":4,"code":"void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o)\n    {\n        binary_writer<std::uint8_t>(o).write_msgpack(j);\n    }","mark":8.0}
{"file_name":"json_function_391.cpp","line_count":4,"code":"void to_msgpack(const basic_json& j, detail::output_adapter<char> o)\n    {\n        binary_writer<char>(o).write_msgpack(j);\n    }","mark":8.0}
{"file_name":"json_function_396.cpp","line_count":4,"code":"void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o)\n    {\n        binary_writer<std::uint8_t>(o).write_bson(j);\n    }","mark":8.0}
{"file_name":"json_function_422.cpp","line_count":25,"code":"void merge_patch(const basic_json& apply_patch)\n    {\n        if (apply_patch.is_object())\n        {\n            if (!is_object())\n            {\n                *this = object();\n            }\n            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)\n            {\n                if (it.value().is_null())\n                {\n                    erase(it.key());\n                }\n                else\n                {\n                    operator[](it.key()).merge_patch(it.value());\n                }\n            }\n        }\n        else\n        {\n            *this = apply_patch;\n        }\n    }","mark":8.0}
{"file_name":"json_function_423.cpp","line_count":4,"code":"string to_string(const NLOHMANN_BASIC_JSON_TPL& j)\n{\n    return j.dump();\n}","mark":8.0}
{"file_name":"json_function_43.cpp","line_count":8,"code":"void from_json(const BasicJsonType& j, typename std::nullptr_t& n)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_null()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be null, but is \", j.type_name()), &j));\n    }\n    n = nullptr;\n}","mark":8.0}
{"file_name":"json_function_48.cpp","line_count":4,"code":"void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)\n{\n    get_arithmetic_value(j, val);\n}","mark":8.0}
{"file_name":"json_function_49.cpp","line_count":4,"code":"void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)\n{\n    get_arithmetic_value(j, val);\n}","mark":8.0}
{"file_name":"json_function_50.cpp","line_count":4,"code":"void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)\n{\n    get_arithmetic_value(j, val);\n}","mark":8.0}
{"file_name":"json_function_51.cpp","line_count":6,"code":"void from_json(const BasicJsonType& j, EnumType& e)\n{\n    typename std::underlying_type<EnumType>::type val;\n    get_arithmetic_value(j, val);\n    e = static_cast<EnumType>(val);\n}","mark":8.0}
{"file_name":"json_function_52.cpp","line_count":13,"code":"void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be array, but is \", j.type_name()), &j));\n    }\n    l.clear();\n    std::transform(j.rbegin(), j.rend(),\n                   std::front_inserter(l), [](const BasicJsonType & i)\n    {\n        return i.template get<T>();\n    });\n}","mark":8.0}
{"file_name":"json_function_53.cpp","line_count":13,"code":"void from_json(const BasicJsonType& j, std::valarray<T>& l)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be array, but is \", j.type_name()), &j));\n    }\n    l.resize(j.size());\n    std::transform(j.begin(), j.end(), std::begin(l),\n                   [](const BasicJsonType & elem)\n    {\n        return elem.template get<T>();\n    });\n}","mark":8.0}
{"file_name":"json_function_56.cpp","line_count":9,"code":"void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be binary, but is \", j.type_name()), &j));\n    }\n\n    bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();\n}","mark":8.0}
{"file_name":"json_function_63.cpp","line_count":8,"code":"void from_json(const BasicJsonType& j, std_fs::path& p)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be string, but is \", j.type_name()), &j));\n    }\n    p = *j.template get_ptr<const typename BasicJsonType::string_t*>();\n}","mark":8.0}
{"file_name":"json_function_64.cpp","line_count":6,"code":"void int_to_string( string_type& target, std::size_t value )\n{\n    \/\/ For ADL\n    using std::to_string;\n    target = to_string(value);\n}","mark":8.0}
{"file_name":"json_function_89.cpp","line_count":4,"code":"void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> \/*unused*\/)\n{\n    j = { std::get<Idx>(t)... };\n}","mark":8.0}
{"file_name":"json_function_91.cpp","line_count":4,"code":"void to_json(BasicJsonType& j, const std_fs::path& p)\n{\n    j = p.string();\n}","mark":8.0}
{"file_name":"json_function_92.cpp","line_count":86,"code":"size_t hash(const BasicJsonType& j)\n{\n    using string_t = typename BasicJsonType::string_t;\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n\n    const auto type = static_cast<std::size_t>(j.type());\n    switch (j.type())\n    {\n        case BasicJsonType::value_t::null:\n        case BasicJsonType::value_t::discarded:\n        {\n            return combine(type, 0);\n        }\n\n        case BasicJsonType::value_t::object:\n        {\n            auto seed = combine(type, j.size());\n            for (const auto& element : j.items())\n            {\n                const auto h = std::hash<string_t> {}(element.key());\n                seed = combine(seed, h);\n                seed = combine(seed, hash(element.value()));\n            }\n            return seed;\n        }\n\n        case BasicJsonType::value_t::array:\n        {\n            auto seed = combine(type, j.size());\n            for (const auto& element : j)\n            {\n                seed = combine(seed, hash(element));\n            }\n            return seed;\n        }\n\n        case BasicJsonType::value_t::string:\n        {\n            const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::boolean:\n        {\n            const auto h = std::hash<bool> {}(j.template get<bool>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::number_integer:\n        {\n            const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::number_unsigned:\n        {\n            const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::number_float:\n        {\n            const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::binary:\n        {\n            auto seed = combine(type, j.get_binary().size());\n            const auto h = std::hash<bool> {}(j.get_binary().has_subtype());\n            seed = combine(seed, h);\n            seed = combine(seed, static_cast<std::size_t>(j.get_binary().subtype()));\n            for (const auto byte : j.get_binary())\n            {\n                seed = combine(seed, std::hash<std::uint8_t> {}(byte));\n            }\n            return seed;\n        }\n\n        default:                   \/\/ LCOV_EXCL_LINE\n            JSON_ASSERT(false); \/\/ NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE\n            return 0;              \/\/ LCOV_EXCL_LINE\n    }\n}","mark":8.0}
{"file_name":"Ktx1Reader_function_1.cpp","line_count":55,"code":"T toCompressedFilamentEnum(uint32_t format) {\n        switch (format) {\n            case Ktx1Bundle::RGB_S3TC_DXT1: return T::DXT1_RGB;\n            case Ktx1Bundle::RGBA_S3TC_DXT1: return T::DXT1_RGBA;\n            case Ktx1Bundle::RGBA_S3TC_DXT3: return T::DXT3_RGBA;\n            case Ktx1Bundle::RGBA_S3TC_DXT5: return T::DXT5_RGBA;\n            case Ktx1Bundle::R_RGTC_BC4_UNORM: return T::RED_RGTC1;\n            case Ktx1Bundle::R_RGTC_BC4_SNORM: return T::SIGNED_RED_RGTC1;\n            case Ktx1Bundle::RG_RGTC_BC5_UNORM: return T::RED_GREEN_RGTC2;\n            case Ktx1Bundle::RG_RGTC_BC5_SNORM: return T::SIGNED_RED_GREEN_RGTC2;\n            case Ktx1Bundle::RGBA_BPTC_BC7: return T::RGBA_BPTC_UNORM;\n            case Ktx1Bundle::SRGB8_ALPHA8_BPTC_BC7: return T::SRGB_ALPHA_BPTC_UNORM;\n            case Ktx1Bundle::RGB_BPTC_BC6H_SNORM: return T::RGB_BPTC_SIGNED_FLOAT;\n            case Ktx1Bundle::RGB_BPTC_BC6H_UNORM: return T::RGB_BPTC_UNSIGNED_FLOAT;\n            case Ktx1Bundle::RGBA_ASTC_4x4: return T::RGBA_ASTC_4x4;\n            case Ktx1Bundle::RGBA_ASTC_5x4: return T::RGBA_ASTC_5x4;\n            case Ktx1Bundle::RGBA_ASTC_5x5: return T::RGBA_ASTC_5x5;\n            case Ktx1Bundle::RGBA_ASTC_6x5: return T::RGBA_ASTC_6x5;\n            case Ktx1Bundle::RGBA_ASTC_6x6: return T::RGBA_ASTC_6x6;\n            case Ktx1Bundle::RGBA_ASTC_8x5: return T::RGBA_ASTC_8x5;\n            case Ktx1Bundle::RGBA_ASTC_8x6: return T::RGBA_ASTC_8x6;\n            case Ktx1Bundle::RGBA_ASTC_8x8: return T::RGBA_ASTC_8x8;\n            case Ktx1Bundle::RGBA_ASTC_10x5: return T::RGBA_ASTC_10x5;\n            case Ktx1Bundle::RGBA_ASTC_10x6: return T::RGBA_ASTC_10x6;\n            case Ktx1Bundle::RGBA_ASTC_10x8: return T::RGBA_ASTC_10x8;\n            case Ktx1Bundle::RGBA_ASTC_10x10: return T::RGBA_ASTC_10x10;\n            case Ktx1Bundle::RGBA_ASTC_12x10: return T::RGBA_ASTC_12x10;\n            case Ktx1Bundle::RGBA_ASTC_12x12: return T::RGBA_ASTC_12x12;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_4x4: return T::SRGB8_ALPHA8_ASTC_4x4;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_5x4: return T::SRGB8_ALPHA8_ASTC_5x4;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_5x5: return T::SRGB8_ALPHA8_ASTC_5x5;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_6x5: return T::SRGB8_ALPHA8_ASTC_6x5;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_6x6: return T::SRGB8_ALPHA8_ASTC_6x6;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_8x5: return T::SRGB8_ALPHA8_ASTC_8x5;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_8x6: return T::SRGB8_ALPHA8_ASTC_8x6;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_8x8: return T::SRGB8_ALPHA8_ASTC_8x8;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_10x5: return T::SRGB8_ALPHA8_ASTC_10x5;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_10x6: return T::SRGB8_ALPHA8_ASTC_10x6;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_10x8: return T::SRGB8_ALPHA8_ASTC_10x8;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_10x10: return T::SRGB8_ALPHA8_ASTC_10x10;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_12x10: return T::SRGB8_ALPHA8_ASTC_12x10;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_12x12: return T::SRGB8_ALPHA8_ASTC_12x12;\n            case Ktx1Bundle::R11_EAC: return T::EAC_R11;\n            case Ktx1Bundle::SIGNED_R11_EAC: return T::EAC_R11_SIGNED;\n            case Ktx1Bundle::RG11_EAC: return T::EAC_RG11;\n            case Ktx1Bundle::SIGNED_RG11_EAC: return T::EAC_RG11_SIGNED;\n            case Ktx1Bundle::RGB8_ETC2: return T::ETC2_RGB8;\n            case Ktx1Bundle::SRGB8_ETC2: return T::ETC2_SRGB8;\n            case Ktx1Bundle::RGB8_ALPHA1_ETC2: return T::ETC2_RGB8_A1;\n            case Ktx1Bundle::SRGB8_ALPHA1_ETC: return T::ETC2_SRGB8_A1;\n            case Ktx1Bundle::RGBA8_ETC2_EAC: return T::ETC2_EAC_RGBA8;\n            case Ktx1Bundle::SRGB8_ALPHA8_ETC2_EAC: return T::ETC2_EAC_SRGBA8;\n        }\n        return (T) 0xffff;\n    }","mark":8.0}
{"file_name":"LinearImage_function_1.cpp","line_count":1,"code":"void reset() { *this = LinearImage(); }","mark":8.0}
{"file_name":"LocalSettings_function_1.cpp","line_count":3,"code":"void SetToken(const std::string& str) {\n\t\tm_token = str;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_10.cpp","line_count":3,"code":"void SetMinimizeToNotif(bool b) {\n\t\tm_bMinimizeToNotif = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_11.cpp","line_count":3,"code":"void SetMaximized(bool b) {\n\t\tm_bMaximized = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_12.cpp","line_count":3,"code":"void SetDiscordAPI(const std::string& str) {\n\t\tm_discordApi = str;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_13.cpp","line_count":3,"code":"void SetDiscordCDN(const std::string& str) {\n\t\tm_discordCdn = str;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_14.cpp","line_count":4,"code":"void SetCheckUpdates(bool b) {\n\t\tm_bCheckUpdates = b;\n\t\tm_bAskToCheckUpdates = false;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_15.cpp","line_count":3,"code":"void SetEnableTLSVerification(bool b) {\n\t\tm_bEnableTLSVerification = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_16.cpp","line_count":3,"code":"void SetAddExtraHeaders(bool b) {\n\t\tm_bAddExtraHeaders = b;\n\t}","mark":9.0}
{"file_name":"LocalSettings_function_17.cpp","line_count":3,"code":"void SetDisableFormatting(bool b) {\n\t\tm_bDisableFormatting = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_18.cpp","line_count":3,"code":"void SetShowScrollBarOnGuildList(bool b) {\n\t\tm_bShowScrollBarOnGuildList = b;\n\t}","mark":10.0}
{"file_name":"LocalSettings_function_19.cpp","line_count":3,"code":"void SetImageBackgroundFileName(const std::string& fn) {\n\t\tm_imageBackgroundFileName = fn;\n\t}","mark":9.0}
{"file_name":"LocalSettings_function_2.cpp","line_count":3,"code":"void SetMessageStyle(eMessageStyle ms) {\n\t\tm_messageStyle = ms;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_20.cpp","line_count":3,"code":"void SetImageAlignment(eImageAlignment align) {\n\t\tm_imageAlignment = align;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_21.cpp","line_count":3,"code":"void SetUserScale(int userScale) {\n\t\tm_userScale = userScale;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_22.cpp","line_count":3,"code":"void SetCompactMemberList(bool b) {\n\t\tm_bCompactMemberList = b;\n\t}","mark":9.0}
{"file_name":"LocalSettings_function_23.cpp","line_count":3,"code":"void SetShowAttachmentImages(bool b) {\n\t\tm_bShowAttachmentImages = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_24.cpp","line_count":3,"code":"void SetShowEmbedImages(bool b) {\n\t\tm_bShowEmbedImages = b;\n\t}","mark":9.0}
{"file_name":"LocalSettings_function_25.cpp","line_count":3,"code":"void SetShowEmbedContent(bool b) {\n\t\tm_bShowEmbedContent = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_26.cpp","line_count":3,"code":"void SetEnableNotifications(bool b) {\n\t\tm_bEnableNotifications = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_27.cpp","line_count":3,"code":"void SetFlashOnNotification(bool b) {\n\t\tm_bFlashOnNotification = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_3.cpp","line_count":3,"code":"void SetReplyMentionByDefault(bool b) {\n\t\tm_bReplyMentionDefault = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_6.cpp","line_count":3,"code":"void SetSaveWindowSize(bool b) {\n\t\tm_bSaveWindowSize = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_7.cpp","line_count":3,"code":"void SetStartMaximized(bool b) {\n\t\tm_bStartMaximized = b;\n\t}","mark":8.0}
{"file_name":"LocalSettings_function_8.cpp","line_count":3,"code":"void SetOpenOnStartup(bool b) {\n\t\tm_bOpenOnStartup = b;\n\t}","mark":9.0}
{"file_name":"LocalSettings_function_9.cpp","line_count":3,"code":"void SetStartMinimized(bool b) {\n\t\tm_bStartMinimized = b;\n\t}","mark":9.0}
{"file_name":"Logger_function_1.cpp","line_count":48,"code":"bool InitializeConsole()\n{\n\t\/\/ Allocate a console for this app\n\tif (!AllocConsole()) \n\t\treturn false;\n\t\n\tFILE* pFile;\n\n\t\/\/ Redirect STDIN if the console has an input handle\n\tif (GetStdHandle(STD_INPUT_HANDLE) != INVALID_HANDLE_VALUE) \n\t{\n\t\tif (freopen_s(&pFile, \"CONIN$\", \"r\", stdin) != 0) \n\t\t\treturn false;\n\t}\n\n\t\/\/ Redirect STDOUT if the console has an output handle\n\tif (GetStdHandle(STD_OUTPUT_HANDLE) != INVALID_HANDLE_VALUE) \n\t{\n\t\tif (freopen_s(&pFile, \"CONOUT$\", \"w\", stdout) != 0) \n\t\t\treturn false;\n\t}\n\n\t\/\/ Redirect STDERR if the console has an error handle\n\tif (GetStdHandle(STD_ERROR_HANDLE) != INVALID_HANDLE_VALUE) \n\t{\n\t\tif (freopen_s(&pFile, \"CONOUT$\", \"w\", stderr) != 0) \n\t\t\treturn false;\n\t}\n\n\t\/\/ Clear the error state for each of the C++ standard streams\n\tstd::cin.clear();\n\tstd::cout.clear();\n\tstd::cerr.clear();\n\tstd::wcin.clear();\n\tstd::wcout.clear();\n\tstd::wcerr.clear();\n\n\t\/\/ Make C++ standard streams point to console as well.\n\tstd::ios::sync_with_stdio();\n\n\tif (Config::Instance()->DebugWait.value_or(false))\n\t{\n\t\tstd::cout << \"Press ENTER to continue...\" << std::endl;\n\t\tstd::cin.get();\n\t}\n\n\treturn true;\n}","mark":8.0}
{"file_name":"Logger_function_3.cpp","line_count":5,"code":"void CloseLogger()\n{\n\tspdlog::default_logger()->flush();\n\tspdlog::shutdown();\n}","mark":8.0}
{"file_name":"LogonDialog_function_3.cpp","line_count":4,"code":"bool LogonDialogShow()\n{\n\treturn DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DIALOG_LOGON), g_Hwnd, DialogProc) != IDCANCEL;\n}","mark":8.0}
{"file_name":"Main_function_1.cpp","line_count":4,"code":"int GetProfilePictureSize()\n{\n\treturn g_ProfilePictureSize;\n}","mark":8.0}
{"file_name":"Main_function_15.cpp","line_count":7,"code":"void CloseCleanup(HWND hWnd)\n{\n\tKillImageViewer();\n\tProfilePopout::Dismiss();\n\tAutoComplete::DismissAutoCompleteWindowsIfNeeded(hWnd);\n\tg_pLoadingMessage->Hide();\n}","mark":8.0}
{"file_name":"Main_function_19.cpp","line_count":3,"code":"void ResetTryAgainInTime() {\n\tg_tryAgainTimerElapse = 500;\n}","mark":8.0}
{"file_name":"Main_function_28.cpp","line_count":5,"code":"CALLBACK OnHeartbeatTimer(HWND hWnd, UINT uInt, UINT_PTR uIntPtr, DWORD dWord)\n{\n\t\/\/ Don't care about the parameters, tell discord instance to send a heartbeat\n\tGetDiscordInstance()->SendHeartbeat();\n}","mark":8.0}
{"file_name":"Main_function_29.cpp","line_count":18,"code":"void SetHeartbeatInterval(int timeMs)\n{\n\tif (g_HeartbeatTimerInterval == timeMs)\n\t\treturn;\n\n\tassert(timeMs > 100 || timeMs == 0);\n\n\tif (g_HeartbeatTimer != 0)\n\t{\n\t\tKillTimer(g_Hwnd, g_HeartbeatTimer);\n\t\tg_HeartbeatTimer = 0;\n\t}\n\n\tif (timeMs != 0)\n\t{\n\t\tg_HeartbeatTimer = SetTimer(g_Hwnd, 0, timeMs, OnHeartbeatTimer);\n\t}\n}","mark":8.0}
{"file_name":"Main_function_4.cpp","line_count":4,"code":"string GetDiscordToken()\n{\n\treturn g_pDiscordInstance->GetToken();\n}","mark":8.0}
{"file_name":"Main_function_5.cpp","line_count":3,"code":"HBITMAP GetDefaultBitmap() {\n\treturn g_DefaultProfilePicture;\n}","mark":8.0}
{"file_name":"Manipulator_function_1.cpp","line_count":5,"code":"void init() {\n *         manip = CameraManipulator::Builder()\n *             .viewport(1024, 768)\n *             .build(camutils::Mode::ORBIT);\n *     }","mark":8.0}
{"file_name":"match_results_function_10.cpp","line_count":4,"code":"void  set_named_subs(std::shared_ptr<named_sub_type> subs)\n   {\n      m_named_subs = subs;\n   }","mark":8.0}
{"file_name":"match_results_function_11.cpp","line_count":9,"code":"void raise_logic_error()\n   {\n      std::logic_error e(\"Attempt to access an uninitialized boost::match_results<> class.\");\n#ifndef BOOST_REGEX_STANDALONE\n      boost::throw_exception(e);\n#else\n      throw e;\n#endif\n   }","mark":8.0}
{"file_name":"match_results_function_13.cpp","line_count":4,"code":"void swap(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b)\n{\n   a.swap(b);\n}","mark":8.0}
{"file_name":"match_results_function_7.cpp","line_count":4,"code":"void  set_base(BidiIterator pos)\n   {\n      m_base = pos;\n   }","mark":8.0}
{"file_name":"MaterialInstance_function_1.cpp","line_count":3,"code":"void setParameter(StringLiteral name, T const& value) {\n        setParameter<T>(name.data, name.size, value);\n    }","mark":8.0}
{"file_name":"MaterialInstance_function_10.cpp","line_count":3,"code":"void setParameter(const char* UTILS_NONNULL name, RgbaType type, math::float4 color) {\n        setParameter(name, strlen(name), type, color);\n    }","mark":8.0}
{"file_name":"MaterialInstance_function_2.cpp","line_count":3,"code":"void setParameter(const char* UTILS_NONNULL name, T const& value) {\n        setParameter<T>(name, strlen(name), value);\n    }","mark":8.0}
{"file_name":"MaterialInstance_function_3.cpp","line_count":3,"code":"void setParameter(StringLiteral name, const T* UTILS_NONNULL values, size_t count) {\n        setParameter<T>(name.data, name.size, values, count);\n    }","mark":8.0}
{"file_name":"MaterialInstance_function_7.cpp","line_count":3,"code":"void setParameter(StringLiteral name, RgbType type, math::float3 color) {\n        setParameter(name.data, name.size, type, color);\n    }","mark":8.0}
{"file_name":"MaterialInstance_function_8.cpp","line_count":3,"code":"void setParameter(const char* UTILS_NONNULL name, RgbType type, math::float3 color) {\n        setParameter(name, strlen(name), type, color);\n    }","mark":8.0}
{"file_name":"MaterialInstance_function_9.cpp","line_count":3,"code":"void setParameter(StringLiteral name, RgbaType type, math::float4 color) {\n        setParameter(name.data, name.size, type, color);\n    }","mark":8.0}
{"file_name":"MemberList_function_1.cpp","line_count":4,"code":"int GetProfileBorderSize()\n{\n\treturn ScaleByDPI(Supports32BitIcons() ? (PROFILE_PICTURE_SIZE_DEF + 12) : 64);\n}","mark":8.0}
{"file_name":"mem_block_cache_function_5.cpp","line_count":4,"code":"void  put_mem_block(void* p)\n{\n   ::operator delete(p);\n}","mark":8.0}
{"file_name":"mem_block_cache_function_6.cpp","line_count":4,"code":"void  put_mem_block(void* p)\n{\n   mem_block_cache::instance().put(p);\n}","mark":8.0}
{"file_name":"mem_block_cache_function_7.cpp","line_count":4,"code":"BOOST_REGEX_CALL get_mem_block()\n{\n   return mem_block_cache::instance().get();\n}","mark":8.0}
{"file_name":"mem_block_cache_function_8.cpp","line_count":4,"code":"BOOST_REGEX_CALL put_mem_block(void* p)\n{\n   mem_block_cache::instance().put(p);\n}","mark":8.0}
{"file_name":"MessageList_function_1.cpp","line_count":5,"code":"void Clear() {\n\t\tfree(m_nameText);\n\t\tfree(m_sizeText);\n\t\tm_nameText = m_sizeText = NULL;\n\t}","mark":8.0}
{"file_name":"MessageList_function_11.cpp","line_count":3,"code":"void SetManagedByOwner(bool bNew) {\n\t\tm_bManagedByOwner = bNew;\n\t}","mark":9.0}
{"file_name":"MessageList_function_12.cpp","line_count":3,"code":"void SetTopDown (bool bNew) {\n\t\tm_bIsTopDown = bNew;\n\t}","mark":10.0}
{"file_name":"MessageList_function_4.cpp","line_count":6,"code":"void ClearAttachmentDataRects() {\n\t\tfor (auto& att : m_attachmentData) {\n\t\t\tSetRectEmpty(&att.m_boxRect);\n\t\t\tSetRectEmpty(&att.m_textRect);\n\t\t}\n\t}","mark":8.0}
{"file_name":"MessageList_function_5.cpp","line_count":5,"code":"void ClearInteractableDataRects() {\n\t\tfor (auto& inte : m_interactableData) {\n\t\t\tSetRectEmpty(&inte.m_rect);\n\t\t}\n\t}","mark":8.0}
{"file_name":"MessageList_function_7.cpp","line_count":3,"code":"void AddMessageStart(const Message& msg) {\n\t\tAddMessageInternal(msg, true, false);\n\t}","mark":8.0}
{"file_name":"MessageList_function_8.cpp","line_count":3,"code":"void AddMessage(const Message& msg, bool updateLastViewedMessage = false) {\n\t\tAddMessageInternal(msg, false, updateLastViewedMessage);\n\t}","mark":8.0}
{"file_name":"MessageList_function_9.cpp","line_count":3,"code":"void SetGuild(Snowflake sf) {\n\t\tm_guildID = sf;\n\t}","mark":8.0}
{"file_name":"message_function_1.cpp","line_count":3,"code":"void set_prepared(bool value) {\n        m_prepared = value;\n    }","mark":8.0}
{"file_name":"message_function_10.cpp","line_count":4,"code":"void append_payload(void const * payload, size_t len) {\n        m_payload.reserve(m_payload.size()+len);\n        m_payload.append(static_cast<char const *>(payload),len);\n    }","mark":8.0}
{"file_name":"message_function_2.cpp","line_count":3,"code":"void set_compressed(bool value) {\n        m_compressed = value;\n    }","mark":9.0}
{"file_name":"message_function_3.cpp","line_count":3,"code":"void set_terminal(bool value) {\n        m_terminal = value;\n    }","mark":8.0}
{"file_name":"message_function_4.cpp","line_count":3,"code":"void set_fin(bool value) {\n        m_fin = value;\n    }","mark":8.0}
{"file_name":"message_function_5.cpp","line_count":3,"code":"void set_opcode(frame::opcode::value op) {\n        m_opcode = op;\n    }","mark":8.0}
{"file_name":"message_function_6.cpp","line_count":3,"code":"void set_header(std::string const & header) {\n        m_header = header;\n    }","mark":8.0}
{"file_name":"message_function_7.cpp","line_count":3,"code":"void set_payload(std::string const & payload) {\n        m_payload = payload;\n    }","mark":8.0}
{"file_name":"message_function_8.cpp","line_count":5,"code":"void set_payload(void const * payload, size_t len) {\n        m_payload.reserve(len);\n        char const * pl = static_cast<char const *>(payload);\n        m_payload.assign(pl, pl + len);\n    }","mark":8.0}
{"file_name":"message_function_9.cpp","line_count":3,"code":"void append_payload(std::string const & payload) {\n        m_payload.append(payload);\n    }","mark":9.0}
{"file_name":"misc_function_37.cpp","line_count":5,"code":"optimizations\n    if (wlan_handle != nullptr) {\n      fn_WlanCloseHandle(wlan_handle, nullptr);\n      wlan_handle = nullptr;\n    }","mark":8.0}
{"file_name":"misc_function_60.cpp","line_count":13,"code":"string ensureCrLf(const std::string& utf8Str) {\n    std::string result;\n    result.reserve(utf8Str.size() + utf8Str.size() \/ 2); \/\/ Reserve extra space\n\n    for (size_t i = 0; i < utf8Str.size(); ++i) {\n        if (utf8Str[i] == '\\n' && (i == 0 || utf8Str[i - 1] != '\\r')) {\n            result += '\\r'; \/\/ Add \\r before \\n if not present\n        }\n        result += utf8Str[i]; \/\/ Always add the current character\n    }\n\n    return result;\n}","mark":8.0}
{"file_name":"misc_function_61.cpp","line_count":27,"code":"wstring getClipboardData() {\n  if (!OpenClipboard(nullptr)) {\n    BOOST_LOG(warning) << \"Failed to open clipboard.\";\n    return L\"\";\n  }\n\n  HANDLE hData = GetClipboardData(CF_UNICODETEXT);\n  if (hData == nullptr) {\n    BOOST_LOG(warning) << \"No text data in clipboard or failed to get data.\";\n    CloseClipboard();\n    return L\"\";\n  }\n\n  wchar_t* pszText = static_cast<wchar_t*>(GlobalLock(hData));\n  if (pszText == nullptr) {\n    BOOST_LOG(warning) << \"Failed to lock clipboard data.\";\n    CloseClipboard();\n    return L\"\";\n  }\n\n  std::wstring ret = pszText;\n\n  GlobalUnlock(hData);\n  CloseClipboard();\n\n  return ret;\n}","mark":8.0}
{"file_name":"mux_types_function_1.cpp","line_count":5,"code":"void WebPDataInit(WebPData* webp_data) {\n  if (webp_data != NULL) {\n    memset(webp_data, 0, sizeof(*webp_data));\n  }\n}","mark":8.0}
{"file_name":"mux_types_function_2.cpp","line_count":6,"code":"void WebPDataClear(WebPData* webp_data) {\n  if (webp_data != NULL) {\n    WebPFree((void*)webp_data->bytes);\n    WebPDataInit(webp_data);\n  }\n}","mark":8.0}
{"file_name":"mux_types_function_3.cpp","line_count":11,"code":"int WebPDataCopy(const WebPData* src, WebPData* dst) {\n  if (src == NULL || dst == NULL) return 0;\n  WebPDataInit(dst);\n  if (src->bytes != NULL && src->size != 0) {\n    dst->bytes = (uint8_t*)WebPMalloc(src->size);\n    if (dst->bytes == NULL) return 0;\n    memcpy((void*)dst->bytes, src->bytes, src->size);\n    dst->size = src->size;\n  }\n  return 1;\n}","mark":8.0}
{"file_name":"NetworkerThread_function_2.cpp","line_count":4,"code":"bool AddExtraHeaders()\n{\n\treturn GetLocalSettings()->AddExtraHeaders();\n}","mark":8.0}
{"file_name":"network_function_1.cpp","line_count":5,"code":"bool is_little_endian() {\n    short int val = 0x1;\n    char *ptr = reinterpret_cast<char *>(&val);\n    return (ptr[0] == 1);\n}","mark":8.0}
{"file_name":"network_function_7.cpp","line_count":4,"code":"string\n  addr_to_normalized_string(boost::asio::ip::address address) {\n    return normalize_address(address).to_string();\n  }","mark":8.0}
{"file_name":"NitroHash_function_1.cpp","line_count":11,"code":"uint64_t hashString(const char* str, size_t length) {\n  uint64_t hash = 14695981039346656037ull; \/\/ FNV offset basis\n  const uint64_t fnv_prime = 1099511628211ull;\n\n  for (size_t i = 0; i < length; ++i) {\n    hash ^= static_cast<uint64_t>(str[i]);\n    hash *= fnv_prime;\n  }\n\n  return hash;\n}","mark":8.0}
{"file_name":"NitroLogger_function_4.cpp","line_count":3,"code":"bool all_are_trivially_copyable() {\n    return (is_trivially_copyable<Args>() && ...);\n  }","mark":8.0}
{"file_name":"none_function_11.cpp","line_count":6,"code":"error_code translate_ec(lib::error_code ec) {\n        \/\/ We don't know any more information about this error, but the error is\n        \/\/ the same type as the one we are translating to, so pass through\n        \/\/ untranslated.\n        return ec;\n    }","mark":8.0}
{"file_name":"none_function_13.cpp","line_count":3,"code":"void set_socket_init_handler(socket_init_handler h) {\n        m_socket_init_handler = h;\n    }","mark":8.0}
{"file_name":"none_function_2.cpp","line_count":3,"code":"void set_socket_init_handler(socket_init_handler h) {\n        m_socket_init_handler = h;\n    }","mark":8.0}
{"file_name":"none_function_5.cpp","line_count":10,"code":"void pre_init(init_handler callback) {\n        if (m_state != READY) {\n            callback(socket::make_error_code(socket::error::invalid_state));\n            return;\n        }\n\n        m_state = READING;\n\n        callback(lib::error_code());\n    }","mark":8.0}
{"file_name":"none_function_7.cpp","line_count":3,"code":"void set_handle(connection_hdl hdl) {\n        m_hdl = hdl;\n    }","mark":8.0}
{"file_name":"none_function_8.cpp","line_count":5,"code":"error_code cancel_socket() {\n        lib::asio::error_code ec;\n        m_socket->cancel(ec);\n        return ec;\n    }","mark":8.0}
{"file_name":"none_function_9.cpp","line_count":5,"code":"void async_shutdown(socket::shutdown_handler h) {\n        lib::asio::error_code ec;\n        m_socket->shutdown(lib::asio::ip::tcp::socket::shutdown_both, ec);\n        h(ec);\n    }","mark":8.0}
{"file_name":"nvapi_function_2.cpp","line_count":34,"code":"NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_VER1\n\n    DECLARE_INTERFACE(ID3DNvVRSHelper_V1)\n    {\n        BEGIN_INTERFACE\n\n        STDMETHOD_(ULONG, AddRef)\n        (THIS) PURE;\n        STDMETHOD_(ULONG, Release)\n        (THIS) PURE;\n\n        \/\/ Latches the latest gaze which will be used for subsequent foveated rendering. Recommended to be called once per frame before scene drawing begins.\n        STDMETHOD_(NvAPI_Status, LatchGaze)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_LATCH_GAZE_PARAMS * pLatchGazeParams) PURE;\n\n        \/\/ Enables VRS with sepcified content type and preset. This can be called per draw call.\n        STDMETHOD_(NvAPI_Status, Enable)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_ENABLE_PARAMS * pEnableParams) PURE;\n\n        \/\/ Disables VRS till re-enabled.\n        STDMETHOD_(NvAPI_Status, Disable)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_DISABLE_PARAMS * pDisableParams) PURE;\n\n        \/\/ Creates a 2D texture, copies the current shading rate pattern on it and returns the pointer to this texture.\n        \/\/ It also returns an array that conveys which value in the shading rate resource corresponds to which exact pixel shading rate.\n        STDMETHOD_(NvAPI_Status, GetShadingRateResource)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS * pGetShadingRateResourceParams) PURE;\n\n        \/\/ Destroys all internally created shading rate resources and views.\n        STDMETHOD_(NvAPI_Status, PurgeInternalShadingRateResources)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS * pPurgeParams) PURE;\n\n        END_INTERFACE\n    }","mark":8.0}
{"file_name":"nvenc_utils_function_2.cpp","line_count":19,"code":"NV_ENC_BUFFER_FORMAT\n  nvenc_format_from_sunshine_format(platf::pix_fmt_e format) {\n    switch (format) {\n      case platf::pix_fmt_e::nv12:\n        return NV_ENC_BUFFER_FORMAT_NV12;\n\n      case platf::pix_fmt_e::p010:\n        return NV_ENC_BUFFER_FORMAT_YUV420_10BIT;\n\n      case platf::pix_fmt_e::ayuv:\n        return NV_ENC_BUFFER_FORMAT_AYUV;\n\n      case platf::pix_fmt_e::yuv444p16:\n        return NV_ENC_BUFFER_FORMAT_YUV444_10BIT;\n\n      default:\n        return NV_ENC_BUFFER_FORMAT_UNDEFINED;\n    }\n  }","mark":8.0}
{"file_name":"NVNGX_DLSS_Dx11_function_10.cpp","line_count":11,"code":"NVSDK_NGX_Result NVSDK_NGX_D3D11_PopulateParameters_Impl(NVSDK_NGX_Parameter* InParameters)\n{\n    LOG_FUNC();\n\n    if (InParameters == nullptr)\n        return NVSDK_NGX_Result_Fail;\n\n    InitNGXParameters(InParameters);\n\n    return NVSDK_NGX_Result_Success;\n}","mark":8.0}
{"file_name":"NVNGX_DLSS_Dx12_function_1.cpp","line_count":9,"code":"int64_t GetTicks()\n{\n    LARGE_INTEGER ticks;\n\n    if (!QueryPerformanceCounter(&ticks))\n        return 0;\n\n    return ticks.QuadPart;\n}","mark":8.0}
{"file_name":"NVNGX_DLSS_Dx12_function_16.cpp","line_count":11,"code":"NVSDK_NGX_Result NVSDK_NGX_D3D12_PopulateParameters_Impl(NVSDK_NGX_Parameter* InParameters)\n{\n    LOG_FUNC();\n\n    if (InParameters == nullptr)\n        return NVSDK_NGX_Result_Fail;\n\n    InitNGXParameters(InParameters);\n\n    return NVSDK_NGX_Result_Success;\n}","mark":8.0}
{"file_name":"NVNGX_DLSS_Vk_function_13.cpp","line_count":11,"code":"NVSDK_NGX_Result NVSDK_NGX_VULKAN_PopulateParameters_Impl(NVSDK_NGX_Parameter* InParameters)\n{\n    LOG_FUNC();\n\n    if (InParameters == nullptr)\n        return NVSDK_NGX_Result_Fail;\n\n    InitNGXParameters(InParameters);\n\n    return NVSDK_NGX_Result_Success;\n}","mark":8.0}
{"file_name":"NVNGX_Proxy_function_13.cpp","line_count":4,"code":"bool IsNVNGXInited()\n    {\n        return _dll != nullptr && (_dx11Inited || _dx12Inited || _vulkanInited) && Config::Instance()->DLSSEnabled.value_or(true);\n    }","mark":8.0}
{"file_name":"NVNGX_Proxy_function_16.cpp","line_count":4,"code":"void SetDx11Inited(bool value)\n    {\n        _dx11Inited = value;\n    }","mark":8.0}
{"file_name":"NVNGX_Proxy_function_17.cpp","line_count":4,"code":"bool IsDx11Inited()\n    {\n        return _dx11Inited;\n    }","mark":8.0}
{"file_name":"NVNGX_Proxy_function_33.cpp","line_count":4,"code":"void SetDx12Inited(bool value)\n    {\n        _dx12Inited = value;\n    }","mark":10.0}
{"file_name":"NVNGX_Proxy_function_34.cpp","line_count":4,"code":"bool IsDx12Inited()\n    {\n        return _dx12Inited;\n    }","mark":8.0}
{"file_name":"NVNGX_Proxy_function_50.cpp","line_count":4,"code":"void SetVulkanInited(bool value)\n    {\n        _vulkanInited = value;\n    }","mark":8.0}
{"file_name":"NVNGX_Proxy_function_51.cpp","line_count":4,"code":"bool IsVulkanInited()\n    {\n        return _vulkanInited;\n    }","mark":8.0}
{"file_name":"OldEnum_function_1.cpp","line_count":4,"code":"OldEnum fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {\n      int enumValue = JSIConverter<int>::fromJSI(runtime, arg);\n      return static_cast<OldEnum>(enumValue);\n    }","mark":8.0}
{"file_name":"OldEnum_function_2.cpp","line_count":4,"code":"Value toJSI(jsi::Runtime& runtime, OldEnum arg) {\n      int enumValue = static_cast<int>(arg);\n      return JSIConverter<int>::toJSI(runtime, enumValue);\n    }","mark":8.0}
{"file_name":"OldEnum_function_3.cpp","line_count":13,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isNumber()) {\n        return false;\n      }\n      double integer;\n      double fraction = modf(value.getNumber(), &integer);\n      if (fraction != 0.0) {\n        \/\/ It is some kind of floating point number - our enums are ints.\n        return false;\n      }\n      \/\/ Check if we are within the bounds of the enum.\n      return integer >= 0 && integer <= 2;\n    }","mark":8.0}
{"file_name":"OptionsDialog_function_9.cpp","line_count":4,"code":"int ShowOptionsDialog()\n{\n\treturn DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DIALOG_OPTIONS), g_Hwnd, DialogProc);\n}","mark":8.0}
{"file_name":"OS_Common_function_8.cpp","line_count":8,"code":"float3x4 LoadSamples(uint idx, uint Stride)\n{\n\tuint i0 = idx, i1 = idx+Stride, i2 = idx+2*Stride, i3=idx+3*Stride;\n\treturn float3x4(\n\t\tg_R[i0], g_R[i1], g_R[i2], g_R[i3],\n\t\tg_G[i0], g_G[i1], g_G[i2], g_G[i3],\n\t\tg_B[i0], g_B[i1], g_B[i2], g_B[i3]);\n}","mark":8.5}
{"file_name":"OS_Dx11_function_1.cpp","line_count":1,"code":"bool IsUpsampling() { return _upsample; }","mark":9.0}
{"file_name":"OS_Dx12_function_1.cpp","line_count":1,"code":"bool IsUpsampling() { return _upsample; }","mark":8.0}
{"file_name":"PAG_Dx12_function_4.cpp","line_count":13,"code":"void SetResourceState(ID3D12GraphicsCommandList* InCommandList, ID3D12Resource* InResource, D3D12_RESOURCE_STATES InCurrentState, D3D12_RESOURCE_STATES InNewState)\n{\n    if (InCurrentState == InNewState)\n        return;\n\n    D3D12_RESOURCE_BARRIER barrier = {};\n    barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;\n    barrier.Transition.pResource = InResource;\n    barrier.Transition.StateBefore = InCurrentState;\n    barrier.Transition.StateAfter = InNewState;\n    barrier.Transition.Subresource = 0;\n    InCommandList->ResourceBarrier(1, &barrier);\n}","mark":8.0}
{"file_name":"Panic_function_1.cpp","line_count":5,"code":"int main(int argc, char** argv) {\n *     ::testing::InitGoogleTest(&argc, argv);\n *     Panic::setMode(Panic::Mode::THROW);\n *     return RUN_ALL_TESTS();\n * }","mark":8.0}
{"file_name":"Path_function_1.cpp","line_count":3,"code":"void setPath(const std::string& pathname) {\n        m_path = getCanonicalPath(pathname);\n    }","mark":8.0}
{"file_name":"Person_function_2.cpp","line_count":6,"code":"Value toJSI(jsi::Runtime& runtime, const Person& arg) {\n      jsi::Object obj(runtime);\n      obj.setProperty(runtime, \"name\", JSIConverter<std::string>::toJSI(runtime, arg.name));\n      obj.setProperty(runtime, \"age\", JSIConverter<double>::toJSI(runtime, arg.age));\n      return obj;\n    }","mark":8.0}
{"file_name":"Person_function_3.cpp","line_count":9,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isObject()) {\n        return false;\n      }\n      jsi::Object obj = value.getObject(runtime);\n      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, \"name\"))) return false;\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"age\"))) return false;\n      return true;\n    }","mark":8.0}
{"file_name":"PixelFormat_function_3.cpp","line_count":14,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isString()) {\n        return false;\n      }\n      std::string unionValue = JSIConverter<std::string>::fromJSI(runtime, value);\n      switch (hashString(unionValue.c_str(), unionValue.size())) {\n        case hashString(\"rgb\"):\n        case hashString(\"yuv-8bit\"):\n        case hashString(\"yuv-10bit\"):\n          return true;\n        default:\n          return false;\n      }\n    }","mark":8.0}
{"file_name":"PluginTest_function_1.cpp","line_count":1,"code":"bool isPluginOriginal() { return true; }","mark":8.0}
{"file_name":"Powertrain_function_3.cpp","line_count":14,"code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isString()) {\n        return false;\n      }\n      std::string unionValue = JSIConverter<std::string>::fromJSI(runtime, value);\n      switch (hashString(unionValue.c_str(), unionValue.size())) {\n        case hashString(\"electric\"):\n        case hashString(\"gas\"):\n        case hashString(\"hybrid\"):\n          return true;\n        default:\n          return false;\n      }\n    }","mark":8.0}
{"file_name":"Process_function_9.cpp","line_count":1,"code":"void inheritParentEnvironmentVariables(bool inherit) { inheritEnv = inherit; }","mark":8.0}
{"file_name":"ProfileView_function_1.cpp","line_count":4,"code":"int GetProfileBorderSize()\n{\n\treturn ScaleByDPI(Supports32BitIcons() ? (PROFILE_PICTURE_SIZE_DEF + 12) : 64);\n}","mark":8.0}
{"file_name":"Protobuf_function_1.cpp","line_count":4,"code":"uint64_t CombineFieldNumberAndTag(FieldNumber fieldNumber, int tag)\n\t{\n\t\treturn (fieldNumber << 3) | tag;\n\t}","mark":8.0}
{"file_name":"Protobuf_function_4.cpp","line_count":1,"code":"bool IsEmpty() { return true; }","mark":8.0}
{"file_name":"Protobuf_function_6.cpp","line_count":3,"code":"void MarkClean() {\n\t\t\tm_bIsDirty = false;\n\t\t}","mark":8.0}
{"file_name":"Protobuf_function_7.cpp","line_count":5,"code":"void MarkDirty() {\n\t\t\tm_bIsDirty = true;\n\t\t\tif (m_pParent)\n\t\t\t\tm_pParent->MarkDirty();\n\t\t}","mark":8.0}
{"file_name":"Protobuf_function_8.cpp","line_count":3,"code":"void SetParent(ObjectBase* pMsg) {\n\t\t\tm_pParent = pMsg;\n\t\t}","mark":8.0}
{"file_name":"QuickSwitcher_function_1.cpp","line_count":10,"code":"int GetIconFromChannel(Channel* pChan)\n{\n\tswitch (pChan->m_channelType)\n\t{\n\t\tcase Channel::DM:      return ICN_DM;\n\t\tcase Channel::GROUPDM: return ICN_GROUPDM;\n\t\tcase Channel::VOICE:   return ICN_VOICE;\n\t\tdefault:               return ICN_CHANNEL;\n\t}\n}","mark":8.0}
{"file_name":"RCAS_Dx11_function_1.cpp","line_count":23,"code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n{\n    switch (format) {\n        case DXGI_FORMAT_R32G32B32A32_TYPELESS:\n            return DXGI_FORMAT_R32G32B32A32_FLOAT;\n        case DXGI_FORMAT_R32G32B32_TYPELESS:\n            return DXGI_FORMAT_R32G32B32_FLOAT;\n        case DXGI_FORMAT_R16G16B16A16_TYPELESS:\n            return DXGI_FORMAT_R16G16B16A16_FLOAT;\n        case DXGI_FORMAT_R10G10B10A2_TYPELESS:\n            return DXGI_FORMAT_R10G10B10A2_UINT;\n        case DXGI_FORMAT_R8G8B8A8_TYPELESS:\n            return DXGI_FORMAT_R8G8B8A8_UNORM;\n        case DXGI_FORMAT_B8G8R8A8_TYPELESS:\n            return DXGI_FORMAT_B8G8R8A8_UNORM;\n        case DXGI_FORMAT_R16G16_TYPELESS:\n            return DXGI_FORMAT_R16G16_FLOAT;\n        case DXGI_FORMAT_R32G32_TYPELESS:\n            return DXGI_FORMAT_R32G32_FLOAT;\n        default:\n            return format;\n    }\n}","mark":8.0}
{"file_name":"RCAS_Dx12_function_1.cpp","line_count":23,"code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n{\n\tswitch (format) {\n\t\tcase DXGI_FORMAT_R32G32B32A32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32B32A32_FLOAT;\n\t\tcase DXGI_FORMAT_R32G32B32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32B32_FLOAT;\n\t\tcase DXGI_FORMAT_R16G16B16A16_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R16G16B16A16_FLOAT;\n\t\tcase DXGI_FORMAT_R10G10B10A2_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R10G10B10A2_UINT;\n\t\tcase DXGI_FORMAT_R8G8B8A8_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R8G8B8A8_UNORM;\n\t\tcase DXGI_FORMAT_B8G8R8A8_TYPELESS:\n\t\t\treturn DXGI_FORMAT_B8G8R8A8_UNORM;\n\t\tcase DXGI_FORMAT_R16G16_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R16G16_FLOAT;\n\t\tcase DXGI_FORMAT_R32G32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32_FLOAT;\n\t\tdefault:\n\t\t\treturn format;\n\t}\n}","mark":8.0}
{"file_name":"ReflectionAutoAggregates_function_3.cpp","line_count":1,"code":"TypeCategory getCategory() { return TypeCategory::TypeStruct; }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_10.cpp","line_count":5,"code":"if constexpr (NumMembers == 9)\n    {\n        auto& [a, b, c, d, e, f, g, h, i] = obj;\n        return func(a, b, c, d, e, f, g, h, i);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_11.cpp","line_count":5,"code":"if constexpr (NumMembers == 10)\n    {\n        auto& [a, b, c, d, e, f, g, h, i, j] = obj;\n        return func(a, b, c, d, e, f, g, h, i, j);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_17.cpp","line_count":5,"code":"if constexpr (NumMembers == 3)\n    {\n        auto& [a, b, c] = obj;\n        return ArgumentGet<N>(&a, &b, &c);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_20.cpp","line_count":5,"code":"if constexpr (NumMembers == 6)\n    {\n        auto& [a, b, c, d, e, f] = obj;\n        return ArgumentGet<N>(&a, &b, &c, &d, &e, &f);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_21.cpp","line_count":5,"code":"if constexpr (NumMembers == 7)\n    {\n        auto& [a, b, c, d, e, f, g] = obj;\n        return ArgumentGet<N>(&a, &b, &c, &d, &e, &f, &g);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_22.cpp","line_count":5,"code":"if constexpr (NumMembers == 8)\n    {\n        auto& [a, b, c, d, e, f, g, h] = obj;\n        return ArgumentGet<N>(&a, &b, &c, &d, &e, &f, &g, &h);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_24.cpp","line_count":5,"code":"if constexpr (NumMembers == 10)\n    {\n        auto& [a, b, c, d, e, f, g, h, i, j] = obj;\n        return ArgumentGet<N>(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_33.cpp","line_count":1,"code":"TypeCategory getCategory() { return TypeCategory::TypeStruct; }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_4.cpp","line_count":5,"code":"if constexpr (NumMembers == 3)\n    {\n        auto& [a, b, c] = obj;\n        return func(a, b, c);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_6.cpp","line_count":5,"code":"if constexpr (NumMembers == 5)\n    {\n        auto& [a, b, c, d, e] = obj;\n        return func(a, b, c, d, e);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_7.cpp","line_count":5,"code":"if constexpr (NumMembers == 6)\n    {\n        auto& [a, b, c, d, e, f] = obj;\n        return func(a, b, c, d, e, f);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_8.cpp","line_count":5,"code":"if constexpr (NumMembers == 7)\n    {\n        auto& [a, b, c, d, e, f, g] = obj;\n        return func(a, b, c, d, e, f, g);\n    }","mark":8.0}
{"file_name":"ReflectionAutoStructured_function_9.cpp","line_count":5,"code":"if constexpr (NumMembers == 8)\n    {\n        auto& [a, b, c, d, e, f, g, h] = obj;\n        return func(a, b, c, d, e, f, g, h);\n    }","mark":8.0}
{"file_name":"ReflectionFoundation_function_1.cpp","line_count":10,"code":"bool append(const ArrayWithSize<T, N2>& other)\n    {\n        if (size + other.size >= N)\n            return false;\n        for (uint32_t i = 0; i < other.size; ++i)\n        {\n            values[size++] = other.values[i];\n        }\n        return true;\n    }","mark":8.0}
{"file_name":"ReflectionFoundation_function_2.cpp","line_count":9,"code":"bool push_back(const T& value)\n    {\n        if (size < N)\n        {\n            values[size++] = value;\n            return true;\n        }\n        return false;\n    }","mark":8.0}
{"file_name":"ReflectionFoundation_function_3.cpp","line_count":10,"code":"bool writeAndAdvance(const Type& value)\n    {\n        if (iterator < iteratorEnd)\n        {\n            *iterator = value;\n            iterator++;\n            return true;\n        }\n        return false;\n    }","mark":8.0}
{"file_name":"ReflectionFoundation_function_6.cpp","line_count":1,"code":"TypeStringView get() { return TypeStringView(value.values, value.size); }","mark":8.0}
{"file_name":"ReflectionSC_function_1.cpp","line_count":1,"code":"bool build(MemberVisitor&) { return true; }","mark":8.0}
{"file_name":"ReflectionSC_function_10.cpp","line_count":1,"code":"auto size(const SC::Vector<T>& object) { return object.size(); }","mark":8.0}
{"file_name":"ReflectionSC_function_12.cpp","line_count":4,"code":"bool resizeWithoutInitializing(SC::Vector<T>& object, size_t newSize)\n    {\n        return object.resizeWithoutInitializing(newSize);\n    }","mark":8.0}
{"file_name":"ReflectionSC_function_13.cpp","line_count":1,"code":"bool resize(SC::Vector<T>& object, size_t newSize) { return object.resize(newSize); }","mark":8.0}
{"file_name":"ReflectionSC_function_2.cpp","line_count":1,"code":"auto size(const SC::Array<T, N>& object) { return object.size(); }","mark":8.0}
{"file_name":"ReflectionSC_function_4.cpp","line_count":4,"code":"bool resizeWithoutInitializing(SC::Array<T, N>& object, size_t newSize)\n    {\n        return object.resizeWithoutInitializing(min(newSize, static_cast<size_t>(N)));\n    }","mark":8.0}
{"file_name":"ReflectionSC_function_5.cpp","line_count":4,"code":"bool resize(SC::Array<T, N>& object, size_t newSize)\n    {\n        return object.resize(min(newSize, static_cast<size_t>(N)));\n    }","mark":8.0}
{"file_name":"ReflectionSC_function_6.cpp","line_count":1,"code":"TypeCategory getCategory() { return TypeCategory::TypeVector; }","mark":8.0}
{"file_name":"ReflectionSC_function_8.cpp","line_count":1,"code":"TypeCategory getCategory() { return TypeCategory::TypeVector; }","mark":8.0}
{"file_name":"ReflectionTestPrint_function_1.cpp","line_count":22,"code":"StringView typeCategoryToStringView(Reflection::TypeCategory type)\n{\n    switch (type)\n    {\n    case Reflection::TypeCategory::TypeInvalid: return \"TypeInvalid \";\n    case Reflection::TypeCategory::TypeBOOL: return \"TypeBOOL   \";\n    case Reflection::TypeCategory::TypeUINT8: return \"TypeUINT8   \";\n    case Reflection::TypeCategory::TypeUINT16: return \"TypeUINT16  \";\n    case Reflection::TypeCategory::TypeUINT32: return \"TypeUINT32  \";\n    case Reflection::TypeCategory::TypeUINT64: return \"TypeUINT64  \";\n    case Reflection::TypeCategory::TypeINT8: return \"TypeINT8    \";\n    case Reflection::TypeCategory::TypeINT16: return \"TypeINT16   \";\n    case Reflection::TypeCategory::TypeINT32: return \"TypeINT32   \";\n    case Reflection::TypeCategory::TypeINT64: return \"TypeINT64   \";\n    case Reflection::TypeCategory::TypeFLOAT32: return \"TypeFLOAT32 \";\n    case Reflection::TypeCategory::TypeDOUBLE64: return \"TypeDOUBLE64\";\n    case Reflection::TypeCategory::TypeStruct: return \"TypeStruct  \";\n    case Reflection::TypeCategory::TypeArray: return \"TypeArray   \";\n    case Reflection::TypeCategory::TypeVector: return \"TypeVector  \";\n    }\n    Assert::unreachable();\n}","mark":8.0}
{"file_name":"Reflection_function_17.cpp","line_count":1,"code":"TypeCategory getCategory() { return TypeCategory::TypeArray; }","mark":8.0}
{"file_name":"Reflection_function_19.cpp","line_count":1,"code":"TypeCategory getCategory() { return TypeCategory::TypeStruct; }","mark":8.0}
{"file_name":"Reflection_function_2.cpp","line_count":7,"code":"bool setLinkIndex(ssize_t newLinkIndex)\n    {\n        if (newLinkIndex > static_cast<decltype(linkIndex)>(MaxValue()))\n            return false;\n        linkIndex = static_cast<decltype(linkIndex)>(newLinkIndex);\n        return true;\n    }","mark":8.0}
{"file_name":"Reflection_function_3.cpp","line_count":4,"code":"bool isPrimitiveCategory(TypeCategory category)\n    {\n        return category >= TypeCategory::TypeBOOL and category <= TypeCategory::TypeDOUBLE64;\n    }","mark":8.0}
{"file_name":"Reflection_function_4.cpp","line_count":4,"code":"bool build(TypeVisitor&)\n    {\n        return true;\n    }","mark":8.0}
{"file_name":"Reflection_function_7.cpp","line_count":1,"code":"auto getCategory(){return TypeCategory::TypeUINT16;}","mark":8.0}
{"file_name":"Reflection_function_8.cpp","line_count":1,"code":"auto getCategory(){return TypeCategory::TypeUINT32;}","mark":8.0}
{"file_name":"Reflection_function_9.cpp","line_count":1,"code":"auto getCategory(){return TypeCategory::TypeUINT64;}","mark":8.0}
{"file_name":"Renderer_function_1.cpp","line_count":9,"code":"void renderLoop(Renderer* renderer, SwapChain* swapChain) {\n     *     do {\n     *         \/\/ typically we wait for VSYNC and user input events\n     *         if (renderer->beginFrame(swapChain)) {\n     *             renderer->render(mView);\n     *             renderer->endFrame();\n     *         }\n     *     } while (!quit());\n     * }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_10.cpp","line_count":3,"code":"void setIntensity(float intensity) {\n    this->intensity = intensity;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_12.cpp","line_count":3,"code":"void setBilateralThreshold(float bilateralThreshold) {\n    this->bilateralThreshold = bilateralThreshold;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_19.cpp","line_count":3,"code":"bool getEnabled() {\n    return enabled;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_2.cpp","line_count":3,"code":"void setRadius(float radius) {\n    this->radius = radius;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_20.cpp","line_count":3,"code":"void setEnabled(bool enabled) {\n    this->enabled = enabled;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_21.cpp","line_count":3,"code":"bool getBentNormals() {\n    return bentNormals;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_22.cpp","line_count":3,"code":"void setBentNormals(bool bentNormals) {\n    this->bentNormals = bentNormals;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_23.cpp","line_count":3,"code":"float getMinHorizonAngleRad() {\n    return minHorizonAngleRad;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_24.cpp","line_count":3,"code":"void setMinHorizonAngleRad(float minHorizonAngleRad) {\n    this->minHorizonAngleRad = minHorizonAngleRad;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_4.cpp","line_count":3,"code":"void setPower(float power) {\n    this->power = power;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_6.cpp","line_count":3,"code":"void setBias(float bias) {\n    this->bias = bias;\n  }","mark":8.0}
{"file_name":"RNFAmbientOcclusionOptionsWrapper_function_8.cpp","line_count":3,"code":"void setResolution(float resolution) {\n    this->resolution = resolution;\n  }","mark":8.0}
{"file_name":"RNFAnimatorWrapper_function_1.cpp","line_count":7,"code":"void assertAnimationIndexSmallerThan(int animationIndex, int max) {\n  if (animationIndex >= max || animationIndex < 0) {\n    [[unlikely]];\n    throw std::invalid_argument(\"Animation index out of range! Expected <\" + std::to_string(max) + \", received \" +\n                                std::to_string(animationIndex));\n  }\n}","mark":8.0}
{"file_name":"RNFAnimatorWrapper_function_2.cpp","line_count":7,"code":"void assertAnimatorNotNull(Animator* animator) {\n  if (animator == nullptr) {\n    [[unlikely]];\n    throw std::runtime_error(\"Failed to call animator method, as the internal animator was null. You probably tried to access the animator \"\n                             \"after calling .release()\");\n  }\n}","mark":8.0}
{"file_name":"RNFAnimatorWrapper_function_3.cpp","line_count":7,"code":"void assertInstanceNotNull(FilamentInstance* instance) {\n  if (instance == nullptr) {\n    [[unlikely]];\n    throw std::runtime_error(\"Failed to call animator method, as the internal instance was null. You probably tried to access the animator \"\n                             \"after calling .release()\");\n  }\n}","mark":8.0}
{"file_name":"RNFCameraFovEnum_function_1.cpp","line_count":8,"code":"void convertJSUnionToEnum(const std::string& inUnion, Camera::Fov* outEnum) {\n    if (inUnion == \"horizontal\")\n      *outEnum = Camera::Fov::HORIZONTAL;\n    else if (inUnion == \"vertical\")\n      *outEnum = Camera::Fov::VERTICAL;\n    else\n      throw invalidUnion(inUnion);\n  }","mark":8.0}
{"file_name":"RNFConverter_function_1.cpp","line_count":7,"code":"float3 VecToFloat3(std::vector<double> vec) {\n    if (vec.size() != 3) {\n      throw std::invalid_argument(\"Point must have 3 elements\");\n    }\n\n    return math::float3(vec[0], vec[1], vec[2]);\n  }","mark":8.0}
{"file_name":"RNFCullingModeEnum_function_2.cpp","line_count":18,"code":"void convertEnumToJSUnion(backend::CullingMode inEnum, std::string* outUnion) {\n    switch (inEnum) {\n      case backend::CullingMode::NONE:\n        *outUnion = \"none\";\n        break;\n      case backend::CullingMode::BACK:\n        *outUnion = \"back\";\n        break;\n      case backend::CullingMode::FRONT:\n        *outUnion = \"front\";\n        break;\n      case backend::CullingMode::FRONT_AND_BACK:\n        *outUnion = \"frontAndBack\";\n        break;\n      default:\n        throw invalidEnum(inEnum);\n    }\n  }","mark":8.0}
{"file_name":"RNFDynamicResolutionOptions_function_1.cpp","line_count":14,"code":"void loadHybridMethods() {\n    registerHybridGetter(\"minScale\", &DynamicResolutionOptionsWrapper::getMinScale, this);\n    registerHybridSetter(\"minScale\", &DynamicResolutionOptionsWrapper::setMinScale, this);\n    registerHybridGetter(\"maxScale\", &DynamicResolutionOptionsWrapper::getMaxScale, this);\n    registerHybridSetter(\"maxScale\", &DynamicResolutionOptionsWrapper::setMaxScale, this);\n    registerHybridGetter(\"sharpness\", &DynamicResolutionOptionsWrapper::getSharpness, this);\n    registerHybridSetter(\"sharpness\", &DynamicResolutionOptionsWrapper::setSharpness, this);\n    registerHybridGetter(\"enabled\", &DynamicResolutionOptionsWrapper::getEnabled, this);\n    registerHybridSetter(\"enabled\", &DynamicResolutionOptionsWrapper::setEnabled, this);\n    registerHybridGetter(\"homogeneousScaling\", &DynamicResolutionOptionsWrapper::getHomogeneousScaling, this);\n    registerHybridSetter(\"homogeneousScaling\", &DynamicResolutionOptionsWrapper::setHomogeneousScaling, this);\n    registerHybridGetter(\"quality\", &DynamicResolutionOptionsWrapper::getQuality, this);\n    registerHybridSetter(\"quality\", &DynamicResolutionOptionsWrapper::setQuality, this);\n  }","mark":8.0}
{"file_name":"RNFDynamicResolutionOptions_function_2.cpp","line_count":5,"code":"void setMinScale(const std::vector<float>& scale) {\n    if (scale.size() != 2)\n      throw std::invalid_argument(\"Expected exactly two values for scale.\");\n    minScale = {scale[0], scale[1]};\n  }","mark":8.0}
{"file_name":"RNFDynamicResolutionOptions_function_3.cpp","line_count":5,"code":"void setMaxScale(const std::vector<float>& scale) {\n    if (scale.size() != 2)\n      throw std::invalid_argument(\"Expected exactly two values for scale.\");\n    maxScale = {scale[0], scale[1]};\n  }","mark":8.0}
{"file_name":"RNFDynamicResolutionOptions_function_5.cpp","line_count":3,"code":"void setSharpness(float sharpnessValue) {\n    sharpness = sharpnessValue;\n  }","mark":8.0}
{"file_name":"RNFDynamicResolutionOptions_function_6.cpp","line_count":3,"code":"bool getEnabled() {\n    return enabled;\n  }","mark":8.0}
{"file_name":"RNFDynamicResolutionOptions_function_7.cpp","line_count":3,"code":"void setEnabled(bool enable) {\n    enabled = enable;\n  }","mark":8.0}
{"file_name":"RNFDynamicResolutionOptions_function_8.cpp","line_count":3,"code":"bool getHomogeneousScaling() {\n    return homogeneousScaling;\n  }","mark":8.0}
{"file_name":"RNFDynamicResolutionOptions_function_9.cpp","line_count":3,"code":"void setHomogeneousScaling(bool homogeneous) {\n    homogeneousScaling = homogeneous;\n  }","mark":8.0}
{"file_name":"RNFEngineBackendEnum_function_1.cpp","line_count":12,"code":"void convertJSUnionToEnum(const std::string& inUnion, Engine::Backend* outEnum) {\n    if (inUnion == \"default\")\n      *outEnum = Engine::Backend::DEFAULT;\n    else if (inUnion == \"metal\")\n      *outEnum = Engine::Backend::METAL;\n    else if (inUnion == \"opengl\")\n      *outEnum = Engine::Backend::OPENGL;\n    else if (inUnion == \"vulkan\")\n      *outEnum = Engine::Backend::VULKAN;\n    else\n      throw invalidUnion(inUnion);\n  }","mark":8.0}
{"file_name":"RNFEngineBackendEnum_function_2.cpp","line_count":18,"code":"void convertEnumToJSUnion(Engine::Backend inEnum, std::string* outUnion) {\n    switch (inEnum) {\n      case Engine::Backend::DEFAULT:\n        *outUnion = \"default\";\n        break;\n      case Engine::Backend::METAL:\n        *outUnion = \"metal\";\n        break;\n      case Engine::Backend::OPENGL:\n        *outUnion = \"opengl\";\n        break;\n      case Engine::Backend::VULKAN:\n        *outUnion = \"vulkan\";\n        break;\n      default:\n        throw invalidEnum(inEnum);\n    }\n  }","mark":8.0}
{"file_name":"RNFFilamentAssetWrapper_function_1.cpp","line_count":3,"code":"int getEntityCount() {\n    return pointee()->getEntityCount();\n  }","mark":8.0}
{"file_name":"RNFFilamentAssetWrapper_function_2.cpp","line_count":3,"code":"int getRenderableEntityCount() {\n    return pointee()->getRenderableEntityCount();\n  }","mark":8.0}
{"file_name":"RNFFilamentRecorder_function_1.cpp","line_count":3,"code":"int getWidth() {\n    return _width;\n  }","mark":8.0}
{"file_name":"RNFFilamentRecorder_function_2.cpp","line_count":3,"code":"int getHeight() {\n    return _height;\n  }","mark":8.0}
{"file_name":"RNFFilamentRecorder_function_3.cpp","line_count":3,"code":"int getFps() {\n    return _fps;\n  }","mark":8.0}
{"file_name":"RNFHybridObject_function_2.cpp","line_count":5,"code":"if constexpr (std::is_same_v<ReturnType, jsi::Value>) {\n        \/\/ If the return type is a jsi::Value, we assume the user wants full JSI code control.\n        \/\/ The signature must be identical to jsi::HostFunction (jsi::Runtime&, jsi::Value& this, ...)\n        return (derivedInstance->*method)(runtime, thisVal, args, count);\n      }","mark":8.0}
{"file_name":"RNFJSIConverter_function_10.cpp","line_count":3,"code":"Value toJSI(jsi::Runtime& runtime, int64_t arg) {\n    return jsi::BigInt::fromInt64(runtime, arg);\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_12.cpp","line_count":3,"code":"Value toJSI(jsi::Runtime& runtime, uint64_t arg) {\n    return jsi::BigInt::fromUint64(runtime, arg);\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_13.cpp","line_count":3,"code":"bool fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return arg.asBool();\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_15.cpp","line_count":3,"code":"string fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {\n    return arg.asString(runtime).utf8(runtime);\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_16.cpp","line_count":3,"code":"Value toJSI(jsi::Runtime& runtime, const std::string& arg) {\n    return jsi::String::createFromUtf8(runtime, arg);\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_17.cpp","line_count":7,"code":"Value toJSI(jsi::Runtime& runtime, const std::optional<TInner>& arg) {\n    if (arg == std::nullopt) {\n      return jsi::Value::undefined();\n    } else {\n      return JSIConverter<TInner>::toJSI(runtime, arg.value());\n    }\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_21.cpp","line_count":5,"code":"if constexpr (std::is_same_v<TResult, void>) {\n              \/\/ it's returning void, just return undefined to JS\n              sharedFuture->get();\n              promise->resolve(jsi::Value::undefined());\n            }","mark":8.0}
{"file_name":"RNFJSIConverter_function_22.cpp","line_count":4,"code":"if constexpr (std::is_same_v<ReturnType, void>) {\n        \/\/ it is a void function (returns undefined)\n        return;\n      }","mark":8.0}
{"file_name":"RNFJSIConverter_function_25.cpp","line_count":9,"code":"Value toJSI(jsi::Runtime& runtime, const std::unordered_map<std::string, ValueType>& map) {\n    jsi::Object object(runtime);\n    for (const auto& pair : map) {\n      jsi::Value value = JSIConverter<ValueType>::toJSI(runtime, pair.second);\n      jsi::String key = jsi::String::createFromUtf8(runtime, pair.first);\n      object.setProperty(runtime, key, std::move(value));\n    }\n    return object;\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_27.cpp","line_count":3,"code":"string invalidTypeErrorMessage(const std::string& typeDescription, const std::string& reason) {\n    return \"Cannot convert \\\"\" + typeDescription + \"\\\" to HostObject<\" + getFriendlyTypename() + \">! \" + reason;\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_3.cpp","line_count":3,"code":"int fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return static_cast<int>(arg.asNumber());\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_32.cpp","line_count":3,"code":"string invalidTypeErrorMessage(const std::string& typeDescription, const std::string& reason) {\n    return \"Cannot convert \\\"\" + typeDescription + \"\\\" to NativeState<\" + getFriendlyTypename() + \">! \" + reason;\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_5.cpp","line_count":3,"code":"double fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return arg.asNumber();\n  }","mark":8.0}
{"file_name":"RNFJSIConverter_function_7.cpp","line_count":3,"code":"float fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return static_cast<float>(arg.asNumber());\n  }","mark":8.0}
{"file_name":"RNFLightEnum_function_1.cpp","line_count":14,"code":"void convertJSUnionToEnum(const std::string& inUnion, LightManager::Type* outEnum) {\n    if (inUnion == \"directional\")\n      *outEnum = LightManager::Type::DIRECTIONAL;\n    else if (inUnion == \"spot\")\n      *outEnum = LightManager::Type::SPOT;\n    else if (inUnion == \"point\")\n      *outEnum = LightManager::Type::POINT;\n    else if (inUnion == \"focused_sport\")\n      *outEnum = LightManager::Type::FOCUSED_SPOT;\n    else if (inUnion == \"sun\")\n      *outEnum = LightManager::Type::SUN;\n    else\n      throw invalidUnion(inUnion);\n  }","mark":8.0}
{"file_name":"RNFListenerManager_function_2.cpp","line_count":5,"code":"bool getHasListeners() {\n    std::unique_lock lock(_mutex);\n\n    return _listeners.size() > 0;\n  }","mark":8.0}
{"file_name":"RNFPointerHolder_function_1.cpp","line_count":9,"code":"void release() {\n    std::unique_lock lock(_mutex);\n\n    if (_pointer == nullptr) {\n      throw std::runtime_error(\"Pointer \" + _name + \" has already been manually released!\");\n    }\n    Logger::log(TAG, \"Manually releasing %s... (PointerHolder::release())\", _name.c_str());\n    _pointer = nullptr;\n  }","mark":8.0}
{"file_name":"RNFPointerHolder_function_2.cpp","line_count":5,"code":"bool getIsValid() {\n    std::unique_lock lock(_mutex);\n\n    return _pointer != nullptr;\n  }","mark":8.0}
{"file_name":"RNFQualityLevel_function_1.cpp","line_count":12,"code":"void convertJSUnionToEnum(const std::string& inUnion, QualityLevel* outEnum) {\n    if (inUnion == \"low\")\n      *outEnum = QualityLevel::LOW;\n    else if (inUnion == \"medium\")\n      *outEnum = QualityLevel::MEDIUM;\n    else if (inUnion == \"high\")\n      *outEnum = QualityLevel::HIGH;\n    else if (inUnion == \"ultra\")\n      *outEnum = QualityLevel::ULTRA;\n    else\n      throw invalidUnion(inUnion);\n  }","mark":8.0}
{"file_name":"RNFQualityLevel_function_2.cpp","line_count":18,"code":"void convertEnumToJSUnion(QualityLevel inEnum, std::string* outUnion) {\n    switch (inEnum) {\n      case QualityLevel::LOW:\n        *outUnion = \"low\";\n        break;\n      case QualityLevel::MEDIUM:\n        *outUnion = \"medium\";\n        break;\n      case QualityLevel::HIGH:\n        *outUnion = \"high\";\n        break;\n      case QualityLevel::ULTRA:\n        *outUnion = \"ultra\";\n        break;\n      default:\n        throw invalidEnum(inEnum);\n    }\n  }","mark":8.25}
{"file_name":"RNFTestEnum_function_2.cpp","line_count":15,"code":"void convertEnumToJSUnion(TestEnum inEnum, std::string* outUnion) {\n    switch (inEnum) {\n      case TestEnum::FIRST:\n        *outUnion = \"first\";\n        break;\n      case TestEnum::SECOND:\n        *outUnion = \"second\";\n        break;\n      case TestEnum::THIRD:\n        *outUnion = \"third\";\n        break;\n      default:\n        throw invalidEnum(inEnum);\n    }\n  }","mark":8.0}
{"file_name":"RNFTestHybridObject_function_2.cpp","line_count":3,"code":"void setInt(int newValue) {\n    _int = newValue;\n  }","mark":8.0}
{"file_name":"RNFTestHybridObject_function_4.cpp","line_count":3,"code":"void setString(const std::string& newValue) {\n    _string = newValue;\n  }","mark":9.0}
{"file_name":"RNFTestHybridObject_function_5.cpp","line_count":3,"code":"void setEnum(TestEnum testEnum) {\n    _enum = testEnum;\n  }","mark":8.0}
{"file_name":"RNFTestHybridObject_function_7.cpp","line_count":3,"code":"void setNullableString(std::optional<std::string> string) {\n    _nullableString = string;\n  }","mark":8.0}
{"file_name":"RNFTestHybridObject_function_8.cpp","line_count":20,"code":"uint64_t calculateFibonacci(int count) {\n    if (count < 0)\n      throw std::invalid_argument(\"Cannot calculate fibonacci for \" + std::to_string(count) + \" - it needs to be at least 0!\");\n    if (count == 0)\n      return 0;\n    if (count == 1)\n      return 1;\n    if (count >= 94)\n      throw std::invalid_argument(\"Cannot calculate fibonacci for \" + std::to_string(count) +\n                                  \" - it needs to be 94 at max, the number will overflow!\");\n\n    uint64_t prev = 0;\n    uint64_t current = 1;\n    for (unsigned int i = 2; i <= count; ++i) {\n      uint64_t next = prev + current;\n      prev = current;\n      current = next;\n    }\n    return current;\n  }","mark":8.25}
{"file_name":"RNFTMat44Wrapper_function_1.cpp","line_count":3,"code":"mat4f getMat() {\n    return _matrix;\n  }","mark":8.0}
{"file_name":"RNFTransparencyModeEnum_function_1.cpp","line_count":10,"code":"void convertJSUnionToEnum(const std::string& inUnion, TransparencyMode* outEnum) {\n    if (inUnion == \"default\")\n      *outEnum = TransparencyMode::DEFAULT;\n    else if (inUnion == \"twoPassesOneSide\")\n      *outEnum = TransparencyMode::TWO_PASSES_ONE_SIDE;\n    else if (inUnion == \"twoPassesTwoSides\")\n      *outEnum = TransparencyMode::TWO_PASSES_TWO_SIDES;\n    else\n      throw invalidUnion(inUnion);\n  }","mark":8.0}
{"file_name":"RNFWorkletRuntimeCollector_function_1.cpp","line_count":5,"code":"void install(jsi::Runtime& rt) {\n    auto collector = std::make_shared<WorkletRuntimeCollector>(rt);\n    auto object = jsi::Object::createFromHostObject(rt, collector);\n    rt.global().setProperty(rt, \"__workletRuntimeCollector\", object);\n  }","mark":8.0}
{"file_name":"RNFWorkletRuntimeRegistry_function_1.cpp","line_count":4,"code":"void registerRuntime(jsi::Runtime& runtime) {\n    std::lock_guard<std::mutex> lock(mutex_);\n    registry_.insert(&runtime);\n  }","mark":8.0}
{"file_name":"RNFWorkletRuntimeRegistry_function_2.cpp","line_count":4,"code":"void unregisterRuntime(jsi::Runtime& runtime) {\n    std::lock_guard<std::mutex> lock(mutex_);\n    registry_.erase(&runtime);\n  }","mark":8.0}
{"file_name":"RNFWorkletRuntimeRegistry_function_3.cpp","line_count":5,"code":"bool isRuntimeAlive(jsi::Runtime* runtime) {\n    assert(runtime != nullptr);\n    std::lock_guard<std::mutex> lock(mutex_);\n    return registry_.find(runtime) != registry_.end();\n  }","mark":8.0}
{"file_name":"RoleList_function_1.cpp","line_count":5,"code":"LPTSTR GetText() {\n\t\tif (!m_text)\n\t\t\tm_text = ConvertCppStringToTString(m_role.m_name);\n\t\treturn m_text;\n\t}","mark":8.0}
{"file_name":"SC-package_function_4.cpp","line_count":13,"code":"Result downloadFileMD5(StringView remoteURL, StringView localFile, StringView localFileMD5)\n{\n    FileSystem fs;\n    SC_TRY(fs.init(\".\"));\n    if (not fs.existsAndIsFile(localFile) or not checkFileMD5(localFile, localFileMD5))\n    {\n        Process process;\n        SC_TRY(process.exec({\"curl\", \"-L\", \"-o\", localFile, remoteURL}));\n        SC_TRY_MSG(process.getExitStatus() == 0, \"Cannot download file\");\n        SC_TRY(checkFileMD5(localFile, localFileMD5));\n    }\n    return Result(true);\n}","mark":8.0}
{"file_name":"SCExample_function_8.cpp","line_count":20,"code":"void drawToolbar()\n    {\n        ImGui::SetNextWindowPos(ImVec2(0, 0));\n        ImGui::SetNextWindowSize(ImVec2(ImGui::GetIO().DisplaySize.x, ToolbarHeight));\n        constexpr auto flags = ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar |\n                               ImGuiWindowFlags_NoScrollbar;\n        if (ImGui::Begin(\"Toolbar\", nullptr, flags))\n        {\n            if (ImGui::Button(\"Settings...\"))\n            {\n                viewState.page = ApplicationPage::Settings;\n            }\n            HotReloadView view{system.hotReloadSystem, system.hotReloadSystem.state, viewState.exampleViewState};\n            if (view.drawToolbar())\n            {\n                viewState.page = ApplicationPage::Examples;\n            }\n        }\n        ImGui::End();\n    }","mark":8.0}
{"file_name":"SCExample_function_9.cpp","line_count":12,"code":"void drawSettings()\n    {\n        if (ImGui::CollapsingHeader(\"SC::Async\", ImGuiTreeNodeFlags_DefaultOpen))\n        {\n            drawSettingsAsync();\n        }\n        if (ImGui::CollapsingHeader(\"SC::Plugin\", ImGuiTreeNodeFlags_DefaultOpen))\n        {\n            HotReloadView view{system.hotReloadSystem, system.hotReloadSystem.state, viewState.exampleViewState};\n            view.drawSettings();\n        }\n    }","mark":8.0}
{"file_name":"Segment_function_3.cpp","line_count":1,"code":"void setSize(size_t newSize) { sizeBytes = static_cast<SizeType>(newSize * sizeof(T)); }","mark":8.0}
{"file_name":"SerializationBinaryBuffer_function_5.cpp","line_count":7,"code":"bool advanceBytes(size_t numBytes)\n    {\n        if (readPosition + numBytes > memory.sizeInBytes())\n            return false;\n        readPosition += numBytes;\n        return true;\n    }","mark":8.0}
{"file_name":"SerializationBinaryTypeErasedTest_function_1.cpp","line_count":1,"code":"void runSerializationBinaryTypeErasedTest(SC::TestReport& report) { SerializationBinaryTypeErasedTest test(report); }","mark":8.0}
{"file_name":"SerializationBinaryTypeErased_function_1.cpp","line_count":10,"code":"bool write(const T& object, Vector<uint8_t>& buffer, size_t* numberOfWrites = nullptr)\n    {\n        SerializationBinaryBufferWriter         binaryBuffer(buffer);\n        SerializationBinaryTypeErasedWriteExact writer;\n        if (not writer.write(object, binaryBuffer))\n            return false;\n        if (numberOfWrites)\n            *numberOfWrites = binaryBuffer.numberOfOperations;\n        return true;\n    }","mark":8.0}
{"file_name":"SerializationBinaryTypeErased_function_2.cpp","line_count":10,"code":"bool loadExact(T& object, Span<const uint8_t> buffer, size_t* numberOfReads = nullptr)\n    {\n        SerializationBinaryBufferReader        bufferReader(buffer);\n        SerializationBinaryTypeErasedReadExact reader;\n        if (not reader.loadExact(object, bufferReader))\n            return false;\n        if (numberOfReads)\n            *numberOfReads = bufferReader.numberOfOperations;\n        return bufferReader.positionIsAtEnd();\n    }","mark":8.0}
{"file_name":"SerializationBinaryTypeErased_function_7.cpp","line_count":9,"code":"bool copySourceSink(Span<const uint8_t> source, Span<uint8_t> other)\n{\n    if (other.sizeInBytes() >= source.sizeInBytes())\n    {\n        memcpy(other.data(), source.data(), source.sizeInBytes());\n        return true;\n    }\n    return false;\n}","mark":8.0}
{"file_name":"SerializationBinary_function_1.cpp","line_count":10,"code":"bool write(T& value, Vector<uint8_t>& buffer, size_t* numberOfWrites = nullptr)\n    {\n        SerializationBinaryBufferWriter writer(buffer);\n        using Writer = Serialization::SerializerBinaryReadWriteExact<SerializationBinaryBufferWriter, T>;\n        if (not Writer::serialize(value, writer))\n            return false;\n        if (numberOfWrites)\n            *numberOfWrites = writer.numberOfOperations;\n        return true;\n    }","mark":8.0}
{"file_name":"SerializationBinary_function_2.cpp","line_count":10,"code":"bool loadExact(T& value, Span<const uint8_t> buffer, size_t* numberOfReads = nullptr)\n    {\n        SerializationBinaryBufferReader bufferReader(buffer);\n        using Reader = Serialization::SerializerBinaryReadWriteExact<SerializationBinaryBufferReader, T>;\n        if (not Reader::serialize(value, bufferReader))\n            return false;\n        if (numberOfReads)\n            *numberOfReads = bufferReader.numberOfOperations;\n        return bufferReader.positionIsAtEnd();\n    }","mark":8.0}
{"file_name":"SerializationExample_function_1.cpp","line_count":1,"code":"TypeCategory getCategory() { return TypeCategory::TypeVector; }","mark":8.0}
{"file_name":"SerializationExample_function_18.cpp","line_count":1,"code":"bool init() { return view.init(); }","mark":8.0}
{"file_name":"SerializationExample_function_20.cpp","line_count":1,"code":"void draw() { view.draw(model); }","mark":8.0}
{"file_name":"SerializationExample_function_3.cpp","line_count":1,"code":"int  size(const ImVector<T>& object) { return object.size(); }","mark":8.0}
{"file_name":"SerializationExample_function_9.cpp","line_count":6,"code":"Result loadFromBinaryFile(const StringView fileName)\n    {\n        Vector<uint8_t> buffer;\n        SC_TRY(FileSystem().read(fileName, buffer));\n        return loadFromBinary(buffer.toSpanConst());\n    }","mark":8.0}
{"file_name":"SerializationJson_function_2.cpp","line_count":5,"code":"bool loadExact(T& object, StringView text)\n    {\n        Reader stream(text);\n        return Serialization::SerializationTextReadWriteExact<Reader, T>::serialize(0, object, stream);\n    }","mark":8.0}
{"file_name":"SerializationJson_function_3.cpp","line_count":5,"code":"bool loadVersioned(T& object, StringView text)\n    {\n        Reader stream(text);\n        return Serialization::SerializationTextReadVersioned<Reader, T>::loadVersioned(0, object, stream);\n    }","mark":8.0}
{"file_name":"SerializationJson_function_7.cpp","line_count":1,"code":"bool onSerializationStart() { return true; }","mark":8.0}
{"file_name":"SerializationJson_function_8.cpp","line_count":1,"code":"bool onSerializationEnd() { return true; }","mark":8.0}
{"file_name":"SerializationSuiteTest_function_2.cpp","line_count":108,"code":"void runSameVersionTests()\n    {\n        size_t numWriteOperations = 0;\n        size_t numReadOperations  = 0;\n        if (test_section(\"Primitive Structure Write\"))\n        {\n            PrimitiveStruct objectToSerialize;\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n\n            \/\/ Verification\n            SC_TEST_EXPECT(numWriteOperations == 1);\n            uint32_t index = 0;\n            for (uint32_t i = 0; i < 4; ++i)\n            {\n                SC_TEST_EXPECT(readPrimitive<uint8_t>(buffer, index) == objectToSerialize.arrayValue[i]);\n            }\n            SC_TEST_EXPECT(readPrimitive<float>(buffer, index) == objectToSerialize.floatValue);\n            SC_TEST_EXPECT(readPrimitive<int64_t>(buffer, index) == objectToSerialize.int64Value);\n        }\n        if (test_section(\"PrimitiveStruct\"))\n        {\n            PrimitiveStruct objectToSerialize;\n            PrimitiveStruct deserializedObject;\n            memset(&deserializedObject, 0, sizeof(deserializedObject));\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n            SC_TEST_EXPECT(numWriteOperations == 1);\n\n            \/\/ Deserialization\n            SC_TEST_EXPECT(SerializerReader::loadExact(deserializedObject, buffer.toSpanConst(), &numReadOperations));\n            SC_TEST_EXPECT(numReadOperations == numWriteOperations);\n\n            \/\/ Verification\n            SC_TEST_EXPECT(not(objectToSerialize != deserializedObject));\n        }\n        if (test_section(\"TopLevelStruct\"))\n        {\n            TopLevelStruct objectToSerialize;\n            TopLevelStruct deserializedObject;\n            memset(&deserializedObject, 0, sizeof(deserializedObject));\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n            SC_TEST_EXPECT(numWriteOperations == 3);\n\n            \/\/ Deserialization\n            SC_TEST_EXPECT(SerializerReader::loadExact(deserializedObject, buffer.toSpanConst(), &numReadOperations));\n            SC_TEST_EXPECT(numReadOperations == numWriteOperations);\n\n            \/\/ Verification\n            SC_TEST_EXPECT(not(objectToSerialize != deserializedObject));\n        }\n        if (test_section(\"VectorStructSimple\"))\n        {\n            VectorStructSimple objectToSerialize;\n            SC_TRUST_RESULT(objectToSerialize.vectorOfInts.push_back(1));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfInts.push_back(2));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfInts.push_back(3));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfInts.push_back(4));\n            VectorStructSimple deserializedObject;\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n            SC_TEST_EXPECT(numWriteOperations == 4);\n\n            \/\/ Deserialization\n            SC_TEST_EXPECT(SerializerReader::loadExact(deserializedObject, buffer.toSpanConst(), &numReadOperations));\n            SC_TEST_EXPECT(numReadOperations == numWriteOperations);\n\n            \/\/ Verification\n            SC_TEST_EXPECT(deserializedObject.emptyVector.size() == 0);\n            SC_TEST_EXPECT(deserializedObject.vectorOfInts.size() == 4);\n            for (size_t idx = 0; idx < objectToSerialize.vectorOfInts.size(); ++idx)\n            {\n                SC_TEST_EXPECT(objectToSerialize.vectorOfInts[idx] == deserializedObject.vectorOfInts[idx]);\n            }\n        }\n        if (test_section(\"VectorStructComplex\"))\n        {\n            VectorStructComplex objectToSerialize;\n            SC_TRUST_RESULT(objectToSerialize.vectorOfStrings.push_back(\"asdasdasd1\"));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfStrings.push_back(\"asdasdasd2\"));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfStrings.push_back(\"asdasdasd3\"));\n            VectorStructComplex deserializedObject;\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n            SC_TEST_EXPECT(numWriteOperations == 10);\n\n            \/\/ Deserialization\n            SC_TEST_EXPECT(SerializerReader::loadExact(deserializedObject, buffer.toSpanConst(), &numReadOperations));\n            SC_TEST_EXPECT(numReadOperations == numWriteOperations);\n\n            \/\/ Verification\n            SC_TEST_EXPECT(deserializedObject.vectorOfStrings.size() == 3);\n            SC_TEST_EXPECT(deserializedObject.vectorOfStrings[0] == \"asdasdasd1\");\n            SC_TEST_EXPECT(deserializedObject.vectorOfStrings[1] == \"asdasdasd2\");\n            SC_TEST_EXPECT(deserializedObject.vectorOfStrings[2] == \"asdasdasd3\");\n        }\n    }","mark":8.0}
{"file_name":"SerializationTextReadVersioned_function_3.cpp","line_count":4,"code":"bool loadVersioned(uint32_t index, T& object, SerializerStream& stream)\n    {\n        return stream.serialize(index, object);\n    }","mark":8.0}
{"file_name":"SerializationTextReadVersioned_function_5.cpp","line_count":4,"code":"bool loadVersioned(uint32_t index, String& object, SerializerStream& stream)\n    {\n        return stream.serialize(index, object);\n    }","mark":8.0}
{"file_name":"SerializationTextReadWriteExact_function_1.cpp","line_count":8,"code":"bool serialize(uint32_t index, T& object, TextStream& stream)\n    {\n        if (not stream.startObject(index))\n            return false;\n        if (not Reflection::Reflect<T>::visit(MemberIterator{stream, object}))\n            return false;\n        return stream.endObject();\n    }","mark":8.0}
{"file_name":"SerializationTextReadWriteExact_function_2.cpp","line_count":4,"code":"bool serialize(uint32_t index, T& object, TextStream& stream)\n    {\n        return stream.serialize(index, object);\n    }","mark":8.0}
{"file_name":"SerializationTextReadWriteExact_function_4.cpp","line_count":4,"code":"bool serialize(uint32_t index, String& object, TextStream& stream)\n    {\n        return stream.serialize(index, object);\n    }","mark":8.0}
{"file_name":"Shared_function_6.cpp","line_count":1,"code":"void _DebugSetMute() { shared.DebugSetMute(); }","mark":8.0}
{"file_name":"SmallVectorTest_function_1.cpp","line_count":7,"code":"void checkItems(Container& container, size_t numItems)\n    {\n        for (size_t idx = 0; idx < numItems; ++idx)\n        {\n            SC_TEST_EXPECT(container[idx] == static_cast<int>(idx));\n        }\n    }","mark":8.0}
{"file_name":"SocketDescriptor_function_1.cpp","line_count":1,"code":"AddressFamily getAddressFamily() { return addressFamily; }","mark":8.0}
{"file_name":"StringIterator_function_6.cpp","line_count":1,"code":"StringEncoding getEncoding() { return StringEncoding::Ascii; }","mark":8.0}
{"file_name":"StringIterator_function_8.cpp","line_count":1,"code":"StringEncoding getEncoding() { return StringEncoding::Utf16; }","mark":8.0}
{"file_name":"StringIterator_function_9.cpp","line_count":1,"code":"StringEncoding getEncoding() { return StringEncoding::Utf8; }","mark":8.0}
{"file_name":"StringView_function_1.cpp","line_count":1,"code":"bool tokenizeNextLine() { return tokenizeNext({'\\n'}); }","mark":8.0}
{"file_name":"StructureOfArrays_function_11.cpp","line_count":5,"code":"void forEach(F&& f, ARGS&& ... args) {\n        for_each(mArrays, [&](size_t, auto* p) {\n            f(p, std::forward<ARGS>(args)...);\n        });\n    }","mark":8.0}
{"file_name":"TaggedUnionTest_function_1.cpp","line_count":24,"code":"void taggedUnionUsageSnippet(Console& console)\n{\n    \/\/ Create the tagged union on the TestUnion definition\n    TaggedUnion<TestUnion> test; \/\/ default initialized to first type (String)\n\n    \/\/ Access \/ Change type\n    String* ptr = test.field<TypeString>();\n    if (ptr) \/\/ If TypeString is not active type, ptr will be == nullptr\n    {\n        *ptr = \"SomeValue\";\n    }\n    test.changeTo<TypeInt>() = 2; \/\/ Change active type to TypeInt (compile time known)\n\n    \/\/ Switch on currently active type (TypeInt)\n    switch (test.getType())\n    {\n    case TypeString: console.print(\"String = {}\", *test.field<TypeString>()); break;\n    case TypeInt: console.print(\"Int = {}\", *test.field<TypeInt>()); break;\n    }\n\n    \/\/ Set current active type at runtime back to TypeString\n    test.setType(TypeString);\n    *test.field<TypeString>() = \"Some new string\";\n}","mark":8.0}
{"file_name":"TaggedUnion_function_6.cpp","line_count":4,"code":"auto visit(Visitor&& visitor, Arguments&&... args)\n    {\n        return RuntimeEnumVisit<Visitor>::visit(forward<Visitor>(visitor), type, *this, forward<Arguments>(args)...);\n    }","mark":8.0}
{"file_name":"TestPluginChild_function_1.cpp","line_count":1,"code":"int multiply(int value) { return value * 2; }","mark":8.0}
{"file_name":"TestPluginChild_function_2.cpp","line_count":1,"code":"float divide(float value) { return value \/ 2; }","mark":8.0}
{"file_name":"TestPluginChild_function_4.cpp","line_count":1,"code":"bool close() { return true; }","mark":8.0}
{"file_name":"TestPluginChild_function_5.cpp","line_count":1,"code":"bool isPluginOriginal() { return true; }","mark":8.0}
{"file_name":"TextInterface_function_1.cpp","line_count":6,"code":"void Clear() {\n\t\tif (m_content)\n\t\t\tdelete[] m_content;\n\n\t\tm_content = NULL;\n\t}","mark":8.0}
{"file_name":"TextInterface_function_3.cpp","line_count":3,"code":"void Clear() {\n\t\tm_content = \"\";\n\t}","mark":8.0}
{"file_name":"TextInterface_function_4.cpp","line_count":3,"code":"void Set(const std::string& text) {\n\t\tm_content = text;\n\t}","mark":8.0}
{"file_name":"TextInterface_Win32_function_1.cpp","line_count":3,"code":"void SetBackgroundColor(COLORREF cr) {\n\t\tm_bkColor = cr;\n\t}","mark":8.0}
{"file_name":"TextInterface_Win32_function_2.cpp","line_count":3,"code":"void SetInvertTextColor(bool invert) {\n\t\tm_bInvertTextColor = invert;\n\t}","mark":8.0}
{"file_name":"TextInterface_Win32_function_3.cpp","line_count":5,"code":"COLORREF InvertIfNeeded(COLORREF cr) {\n\t\tif (m_bInvertTextColor)\n\t\t\tcr ^= 0xffffff;\n\t\treturn cr;\n\t}","mark":8.0}
{"file_name":"TextInterface_Win32_function_4.cpp","line_count":4,"code":"RECT RectToNative(const Rect& rc) {\n\tRECT rcNative{ rc.left, rc.top, rc.right, rc.bottom };\n\treturn rcNative;\n}","mark":8.0}
{"file_name":"TextInterface_Win32_function_9.cpp","line_count":4,"code":"int MdGetQuoteIndentSize()\n{\n\treturn ScaleByDPI(SIZE_QUOTE_INDENT);\n}","mark":8.0}
{"file_name":"ThreadPool_function_1_1.cpp","line_count":5,"code":"task\n            if (task != nullptr)\n            {\n                task->function();\n            }","mark":8.0}
{"file_name":"TMatHelpers_function_26.cpp","line_count":3,"code":"constexpr TMatTransform() {\n        static_assert(BASE<T>::NUM_ROWS == 3 || BASE<T>::NUM_ROWS == 4, \"3x3 or 4x4 matrices only\");\n    }","mark":8.0}
{"file_name":"TMatHelpers_function_6.cpp","line_count":9,"code":"T determinant(Matrix<T, 3> in) {\n        return\n            in[0][0] * in[1][1] * in[2][2] +\n            in[1][0] * in[2][1] * in[0][2] +\n            in[2][0] * in[0][1] * in[1][2] -\n            in[2][0] * in[1][1] * in[0][2] -\n            in[1][0] * in[0][1] * in[2][2] -\n            in[0][0] * in[2][1] * in[1][2];\n    }","mark":8.0}
{"file_name":"TMatHelpers_function_7.cpp","line_count":3,"code":"T determinant(Matrix<T, 2> in) {\n        return in[0][0] * in[1][1] - in[0][1] * in[1][0];\n    }","mark":8.0}
{"file_name":"TQuatHelpers_function_16.cpp","line_count":3,"code":"MATH_PURE lerp(const QUATERNION<T>& p, const QUATERNION<T>& q, T t) {\n        return ((1 - t) * p) + (t * q);\n    }","mark":8.0}
{"file_name":"TQuatHelpers_function_17.cpp","line_count":3,"code":"MATH_PURE nlerp(const QUATERNION<T>& p, const QUATERNION<T>& q, T t) {\n        return normalize(lerp(p, q, t));\n    }","mark":8.0}
{"file_name":"TQuatHelpers_function_18.cpp","line_count":3,"code":"MATH_PURE positive(const QUATERNION<T>& q) {\n        return q.w < 0 ? -q : q;\n    }","mark":8.0}
{"file_name":"TQuatHelpers_function_2.cpp","line_count":3,"code":"MATH_PURE norm(const QUATERNION<T>& q) {\n        return std::sqrt(dot(q, q));\n    }","mark":8.0}
{"file_name":"TQuatHelpers_function_3.cpp","line_count":3,"code":"MATH_PURE length(const QUATERNION<T>& q) {\n        return norm(q);\n    }","mark":8.0}
{"file_name":"TQuatHelpers_function_4.cpp","line_count":3,"code":"MATH_PURE length2(const QUATERNION<T>& q) {\n        return dot(q, q);\n    }","mark":8.0}
{"file_name":"TQuatHelpers_function_6.cpp","line_count":3,"code":"MATH_PURE conj(const QUATERNION<T>& q) {\n        return QUATERNION<T>(q.w, -q.x, -q.y, -q.z);\n    }","mark":8.0}
{"file_name":"TQuatHelpers_function_7.cpp","line_count":3,"code":"MATH_PURE inverse(const QUATERNION<T>& q) {\n        return conj(q) * (T(1) \/ dot(q, q));\n    }","mark":8.0}
{"file_name":"TQuatHelpers_function_8.cpp","line_count":3,"code":"MATH_PURE real(const QUATERNION<T>& q) {\n        return q.w;\n    }","mark":8.0}
{"file_name":"TVecHelpers_function_10.cpp","line_count":3,"code":"MATH_PURE norm2(const VECTOR<T>& lv) {\n        return dot(lv, lv);\n    }","mark":8.0}
{"file_name":"TVecHelpers_function_11.cpp","line_count":3,"code":"MATH_PURE length2(const VECTOR<T>& lv) {\n        return norm2(lv);\n    }","mark":8.0}
{"file_name":"TVecHelpers_function_34.cpp","line_count":3,"code":"MATH_PURE saturate(const VECTOR<T>& lv) {\n        return clamp(lv, T(0), T(1));\n    }","mark":8.0}
{"file_name":"TVecHelpers_function_43.cpp","line_count":4,"code":"MATH_PURE smoothstep(T edge0, T edge1, VECTOR<T> v) {\n        VECTOR<T> t = saturate((v - edge0) \/ (edge1 - edge0));\n        return t * t * (T(3) - T(2) * t);\n    }","mark":8.0}
{"file_name":"TVecHelpers_function_8.cpp","line_count":3,"code":"MATH_PURE norm(const VECTOR<T>& lv) {\n        return std::sqrt(dot(lv, lv));\n    }","mark":8.0}
{"file_name":"TypeInfo_function_1.cpp","line_count":4,"code":"string replaceRegex(const std::string& original, const std::string& pattern, const std::string& replacement) {\n    std::regex re(pattern);\n    return std::regex_replace(original, re, replacement);\n  }","mark":8.0}
{"file_name":"TypeInfo_function_3.cpp","line_count":4,"code":"string getFriendlyTypename(const std::type_info& type, bool removeNamespace = false) {\n    std::string typeName = type.name();\n    return demangleName(typeName, removeNamespace);\n  }","mark":8.0}
{"file_name":"TypeInfo_function_4.cpp","line_count":4,"code":"string getFriendlyTypename(const std::type_index& typeIndex, bool removeNamespace = false) {\n    std::string typeName = typeIndex.name();\n    return demangleName(typeName, removeNamespace);\n  }","mark":8.0}
{"file_name":"UniqueHandle_function_3.cpp","line_count":1,"code":"void detach() { handle = Invalid; }","mark":8.0}
{"file_name":"UploadDialog_function_12.cpp","line_count":12,"code":"bool UploadDialogCheckHasUploadRights()\n{\n\tChannel* pChan = GetDiscordInstance()->GetCurrentChannel();\n\tif (!pChan)\n\t\treturn false;\n\t\n\tif (!pChan->HasPermission(PERM_SEND_MESSAGES) ||\n\t\t!pChan->HasPermission(PERM_ATTACH_FILES))\n\t\treturn false;\n\n\treturn true;\n}","mark":8.0}
{"file_name":"UploadDialog_function_16.cpp","line_count":7,"code":"void UploadDialogShow()\n{\n\tif (!UploadDialogCheckHasUploadRights())\n\t\treturn;\n\n\tPostMessage(g_Hwnd, WM_SHOWUPLOADDIALOG, 0, 0);\n}","mark":8.0}
{"file_name":"UploadDialog_function_2.cpp","line_count":4,"code":"void UploadDialogOnFileTooBig(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_TOO_BIG), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}","mark":8.0}
{"file_name":"UploadDialog_function_3.cpp","line_count":4,"code":"void UploadDialogOnEmptyFile(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_EMPTY), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}","mark":8.0}
{"file_name":"UploadDialog_function_4.cpp","line_count":4,"code":"void UploadDialogOutOfMemory(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_OUT_OF_MEMORY), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}","mark":8.0}
{"file_name":"UploadDialog_function_5.cpp","line_count":4,"code":"void UploadDialogCantReadFile(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_NO_READ), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}","mark":8.0}
{"file_name":"UploadDialog_function_6.cpp","line_count":4,"code":"void UploadDialogCantOpenFile(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_NO_OPEN), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}","mark":8.0}
{"file_name":"UploadDialog_function_7.cpp","line_count":4,"code":"int FailAndClose(HANDLE hFile, int errorCode) {\n\tCloseHandle(hFile);\n\treturn errorCode;\n}","mark":8.0}
{"file_name":"UploadDialog_function_8.cpp","line_count":5,"code":"int FailDeallocAndClose(HANDLE hFile, BYTE*& pbFileData, int errorCode) {\n\tdelete[] pbFileData;\n\tpbFileData = NULL;\n\treturn FailAndClose(hFile, errorCode);\n}","mark":8.0}
{"file_name":"Util_function_11.cpp","line_count":9,"code":"int StringCompareCaseInsens(const char* s1, const char* s2)\n{\n\twhile (tolower(*s1) == tolower(*s2)) {\n\t\tif (*s1 == '\\0') break;\n\t\ts1++, s2++;\n\t}\n\n\treturn tolower(*s1) - tolower(*s2);\n}","mark":8.0}
{"file_name":"Util_function_14.cpp","line_count":7,"code":"bool BeginsWithCaseInsens(const std::string& what, const std::string& with)\n{\n\tif (what.size() < with.size())\n\t\treturn false;\n\n\treturn StringCompareCaseInsensLimited(what.c_str(), with.c_str(), with.size()) == 0;\n}","mark":8.0}
{"file_name":"Util_function_17.cpp","line_count":10,"code":"bool IsPotentiallyDangerousDownload(const std::string& filename)\n{\n\treturn\n\t\tEndsWithCaseInsens(filename, \".exe\") ||\n\t\tEndsWithCaseInsens(filename, \".bat\") ||\n\t\tEndsWithCaseInsens(filename, \".com\") ||\n\t\tEndsWithCaseInsens(filename, \".vbs\") ||\n\t\tEndsWithCaseInsens(filename, \".cmd\") ||\n\t\tEndsWithCaseInsens(filename, \".scr\");\n}","mark":8.0}
{"file_name":"Util_function_18.cpp","line_count":4,"code":"int64_t ExtractTimestamp(Snowflake sf)\n{\n\treturn (sf >> 22) + 1420070400000;\n}","mark":8.0}
{"file_name":"Util_function_2.cpp","line_count":4,"code":"string GetBasePath()\n{\n\treturn g_BasePath;\n}","mark":8.0}
{"file_name":"Util_function_22.cpp","line_count":7,"code":"string GetGlobalName(const nlohmann::json& j)\n{\n\tif (j.contains(\"global_name\") && !j[\"global_name\"].is_null())\n\t\treturn GetFieldSafe(j, \"global_name\");\n\telse\n\t\treturn GetFieldSafe(j, \"username\");\n}","mark":8.0}
{"file_name":"Util_function_23.cpp","line_count":10,"code":"string GetUsername(const nlohmann::json& j)\n{\n\tstd::string username = GetFieldSafe(j, \"username\");\n\tint discrim = int(GetIntFromString(GetFieldSafe(j, \"discriminator\")));\n\n\tif (discrim > 0)\n\t\tusername += \"#\" + FormatDiscrim(discrim);\n\n\treturn username;\n}","mark":8.0}
{"file_name":"Util_function_3.cpp","line_count":4,"code":"string GetCachePath()\n{\n\treturn g_BasePath + \"\\\\cache\";\n}","mark":8.0}
{"file_name":"Util_function_37.cpp","line_count":4,"code":"float GetAppVersion()\n{\n\treturn 1.07f;\n}","mark":8.0}
{"file_name":"Util_function_38.cpp","line_count":4,"code":"string GetAppVersionString()\n{\n\treturn \"V1.07\";\n}","mark":8.0}
{"file_name":"Util_function_39.cpp","line_count":39,"code":"string FormatDuration(int seconds)\n{\n\tint minutes = seconds \/ 60;\n\tseconds %= 60;\n\tint hours   = minutes \/ 60;\n\tminutes %= 60;\n\tint days    = hours \/ 24;\n\thours %= 24;\n\n\tstd::string result;\n\tif (days) {\n\t\tresult += std::to_string(days);\n\t\tif (days == 1) result += \" day\";\n\t\telse           result += \" days\";\n\t}\n\tif (hours) {\n\t\tif (!result.empty()) result += \", \";\n\t\tresult += std::to_string(hours);\n\t\tif (hours == 1) result += \" hr\";\n\t\telse            result += \" hrs\";\n\t}\n\tif (minutes) {\n\t\tif (!result.empty()) result += \", \";\n\t\tresult += std::to_string(minutes);\n\t\tif (minutes == 1) result += \" min\";\n\t\telse              result += \" mins\";\n\t}\n\tif (seconds) {\n\t\tif (!result.empty()) result += \", \";\n\t\tresult += std::to_string(seconds);\n\t\tif (seconds == 1) result += \" sec\";\n\t\telse              result += \" secs\";\n\t}\n\tif (result.empty()) {\n\t\tresult = \"0 secs\";\n\t}\n\n\treturn result;\n}","mark":8.0}
{"file_name":"Util_function_4.cpp","line_count":9,"code":"long BitMix(uint64_t lol)\n{\n\tlol ^= lol >> 33;\n\tlol *= 0xff51afd7ed558ccdLL;\n\tlol ^= lol >> 33;\n\tlol *= 0xc4ceb9fe1a85ec53LL;\n\tlol ^= lol >> 33;\n\treturn lol;\n}","mark":8.0}
{"file_name":"VectorMap_function_2.cpp","line_count":8,"code":"bool insertIfNotExists(Item&& item)\n    {\n        if (not contains(item.key))\n        {\n            return items.push_back(forward<Item>(item));\n        }\n        return false;\n    }","mark":8.0}
{"file_name":"VectorMap_function_3.cpp","line_count":12,"code":"bool contains(const ComparableToKey& key, Value*& outValue)\n    {\n        for (auto& item : items)\n        {\n            if (item.key == key)\n            {\n                outValue = &item.value;\n                return true;\n            }\n        }\n        return false;\n    }","mark":8.0}
{"file_name":"VectorSet_function_1.cpp","line_count":4,"code":"bool contains(const ComparableToValue& value)\n    {\n        return items.contains(value);\n    }","mark":8.0}
{"file_name":"VectorSet_function_3.cpp","line_count":4,"code":"bool remove(const ComparableToValue& value)\n    {\n        return items.remove(value);\n    }","mark":8.0}
{"file_name":"VectorTest_function_1.cpp","line_count":5,"code":"void push(Operation operation)\n    {\n        SC_ASSERT_DEBUG(numSequences < MAX_SEQUENCES);\n        sequence[numSequences++] = operation;\n    }","mark":8.0}
{"file_name":"VectorTest_function_2.cpp","line_count":5,"code":"void reset()\n    {\n        numSequences     = 0;\n        numNextSequences = 0;\n    }","mark":8.0}
{"file_name":"VectorTest_function_4.cpp","line_count":9,"code":"size_t dataLength(const char* str)\n    {\n        size_t idx = 0;\n        while (str[idx] != 0)\n        {\n            ++idx;\n        }\n        return idx;\n    }","mark":8.0}
{"file_name":"Vector_function_3.cpp","line_count":1,"code":"bool push_back(const T& element) { return Operations::push_back(items, element); }","mark":8.0}
{"file_name":"Vector_function_4.cpp","line_count":1,"code":"bool push_back(T&& element) { return Operations::push_back(items, move(element)); }","mark":8.0}
{"file_name":"Vector_function_5.cpp","line_count":1,"code":"bool pop_back() { return Operations::pop_back(items); }","mark":8.0}
{"file_name":"Vector_function_6.cpp","line_count":1,"code":"bool pop_front() { return Operations::pop_front(items); }","mark":8.0}
{"file_name":"Vector_function_7.cpp","line_count":1,"code":"void clearWithoutInitializing() { (void)resizeWithoutInitializing(0); }","mark":8.0}
{"file_name":"Vector_function_8.cpp","line_count":1,"code":"bool shrink_to_fit() { return Operations::shrink_to_fit(items); }","mark":8.0}
{"file_name":"Vector_function_9.cpp","line_count":1,"code":"bool removeAt(size_t index) { return Operations::removeAt(items, index); }","mark":8.0}
{"file_name":"ViewerGui_function_1.cpp","line_count":1,"code":"void enableWireframe(bool b) { mEnableWireframe = b; }","mark":9.0}
{"file_name":"ViewerGui_function_2.cpp","line_count":1,"code":"void enableSunlight(bool b) { mSettings.lighting.enableSunlight = b; }","mark":9.0}
{"file_name":"ViewerGui_function_3.cpp","line_count":3,"code":"void enableDithering(bool b) {\n        mSettings.view.dithering = b ? Dithering::TEMPORAL : Dithering::NONE;\n    }","mark":8.0}
{"file_name":"ViewerGui_function_4.cpp","line_count":3,"code":"void enableFxaa(bool b) {\n        mSettings.view.antiAliasing = b ? AntiAliasing::FXAA : AntiAliasing::NONE;\n    }","mark":8.0}
{"file_name":"ViewerGui_function_5.cpp","line_count":4,"code":"void enableMsaa(bool b) {\n        mSettings.view.msaa.sampleCount = 4;\n        mSettings.view.msaa.enabled = b;\n    }","mark":8.0}
{"file_name":"ViewerGui_function_6.cpp","line_count":1,"code":"void enableSSAO(bool b) { mSettings.view.ssao.enabled = b; }","mark":8.0}
{"file_name":"ViewerGui_function_7.cpp","line_count":1,"code":"void enableBloom(bool bloom) { mSettings.view.bloom.enabled = bloom; }","mark":8.0}
{"file_name":"ViewerGui_function_8.cpp","line_count":1,"code":"void setIBLIntensity(float brightness) { mSettings.lighting.iblIntensity = brightness; }","mark":9.0}
{"file_name":"ViewerGui_function_9.cpp","line_count":1,"code":"void stopAnimation() { mCurrentAnimation = -1; }","mark":8.0}
{"file_name":"WebServerExample_function_10.cpp","line_count":1,"code":"bool close() { return true; }","mark":8.0}
{"file_name":"WebServerExample_function_11.cpp","line_count":5,"code":"Result initAsync(SC::AsyncEventLoop& eventLoop)\n    {\n        model.eventLoop = &eventLoop;\n        return SC::Result(true);\n    }","mark":8.0}
{"file_name":"WebServerExample_function_9.cpp","line_count":1,"code":"bool init() { return view.init(); }","mark":8.0}
{"file_name":"Wininet_function_250.cpp","line_count":1,"code":"void _ResumeSuspendedDownload() { wininet.ResumeSuspendedDownload(); }","mark":8.0}
{"file_name":"Wininet_function_267.cpp","line_count":1,"code":"void _ShowClientAuthCerts() { wininet.ShowClientAuthCerts(); }","mark":8.0}
{"file_name":"Winmm_function_167.cpp","line_count":1,"code":"void _waveInStop() { winmm.waveInStop(); }","mark":8.0}
{"file_name":"Winmm_function_185.cpp","line_count":1,"code":"void _waveOutReset() { winmm.waveOutReset(); }","mark":8.0}
{"file_name":"Winmm_function_186.cpp","line_count":1,"code":"void _waveOutRestart() { winmm.waveOutRestart(); }","mark":8.0}
{"file_name":"Winmm_function_24.cpp","line_count":1,"code":"void _joyConfigChanged() { winmm.joyConfigChanged(); }","mark":8.0}
{"file_name":"Winmm_function_36.cpp","line_count":1,"code":"void _mciDriverYield() { winmm.mciDriverYield(); }","mark":8.0}
{"file_name":"Winmm_function_59.cpp","line_count":1,"code":"void _midiInClose() { winmm.midiInClose(); }","mark":8.0}
{"file_name":"Winmm_function_69.cpp","line_count":1,"code":"void _midiInReset() { winmm.midiInReset(); }","mark":8.0}
{"file_name":"Winmm_function_70.cpp","line_count":1,"code":"void _midiInStart() { winmm.midiInStart(); }","mark":8.0}
{"file_name":"Winmm_function_71.cpp","line_count":1,"code":"void _midiInStop() { winmm.midiInStop(); }","mark":8.0}
{"file_name":"Winmm_function_87.cpp","line_count":1,"code":"void _midiOutReset() { winmm.midiOutReset(); }","mark":8.0}
{"file_name":"Winmm_function_94.cpp","line_count":1,"code":"void _midiStreamPause() { winmm.midiStreamPause(); }","mark":8.0}
{"file_name":"Winmm_function_97.cpp","line_count":1,"code":"void _midiStreamRestart() { winmm.midiStreamRestart(); }","mark":8.0}
{"file_name":"Winmm_function_98.cpp","line_count":1,"code":"void _midiStreamStop() { winmm.midiStreamStop(); }","mark":8.0}
{"file_name":"Winmm_function_99.cpp","line_count":1,"code":"void _mixerClose() { winmm.mixerClose(); }","mark":8.0}
{"file_name":"WinUtils_function_12.cpp","line_count":12,"code":"void ResizeWindow(HWND hWnd, int diffX, int diffY, bool byLeft, bool byTop, bool bRepaint)\n{\n\tHWND hParWnd = GetParent(hWnd);\n\tRECT rc{};\n\n\tGetChildRect(hParWnd, hWnd, &rc);\n\tif (byLeft) rc.left   += diffX;\n\telse        rc.right  += diffX;\n\tif (byTop)  rc.top    += diffY;\n\telse        rc.bottom += diffY;\n\tMoveWindow(hWnd, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, bRepaint);\n}","mark":8.0}
{"file_name":"WinUtils_function_13.cpp","line_count":5,"code":"void WindowScroll(HWND hWnd, int diffUpDown)\n{\n\tScrollWindowEx(hWnd, 0, -diffUpDown, NULL, NULL, NULL, NULL, SW_INVALIDATE);\n\tUpdateWindow(hWnd);\n}","mark":8.0}
{"file_name":"WinUtils_function_14.cpp","line_count":5,"code":"void WindowScrollXY(HWND hWnd, int diffLeftRight, int diffUpDown)\n{\n\tScrollWindowEx(hWnd, -diffLeftRight, -diffUpDown, NULL, NULL, NULL, NULL, SW_INVALIDATE);\n\tUpdateWindow(hWnd);\n}","mark":8.0}
{"file_name":"WinUtils_function_15.cpp","line_count":4,"code":"bool IsWindowActive(HWND hWnd)\n{\n\treturn IsWindowVisible(hWnd) && GetForegroundWindow() == hWnd;\n}","mark":8.0}
{"file_name":"WinUtils_function_18.cpp","line_count":7,"code":"string GetStringFromHResult(HRESULT hr)\n{\n\tLPTSTR tstr = GetTStringFromHResult(hr);\n\tstd::string str = MakeStringFromTString(tstr);\n\tLocalFree(tstr);\n\treturn str;\n}","mark":8.0}
{"file_name":"WinUtils_function_36.cpp","line_count":12,"code":"bool IsChildOf(HWND child, HWND of)\n{\n\twhile (child)\n\t{\n\t\tif (child == of)\n\t\t\treturn true;\n\n\t\tchild = GetParent(child);\n\t}\n\n\treturn false;\n}","mark":8.0}
{"file_name":"WinUtils_function_4.cpp","line_count":4,"code":"void ForgetSystemDPI()\n{\n\tg_systemDPICache = 0;\n}","mark":8.0}
{"file_name":"WinUtils_function_43.cpp","line_count":40,"code":"int MapIconToOldIfNeeded(int iconID)\n{\n\t\/\/ No mapping if icon ID is supported.\n\tif (Supports32BitIcons())\n\t\treturn iconID;\n\n\tswitch (iconID)\n\t{\n\t\tcase IDI_PROFILE_BORDER_GOLD: return IDI_PROFILE_BORDER_GOLD_2K;\n\t\tcase IDI_CHANNEL_MENTIONED: return IDI_CHANNEL_MENTIONED_2K;\n\t\tcase IDI_CHANNEL_UNREAD: return IDI_CHANNEL_UNREAD_2K;\n\t\tcase IDI_PROFILE_BORDER: return IDI_PROFILE_BORDER_2K;\n\t\tcase IDI_TYPING_FRAME1: return IDI_TYPING_FRAME1_2K;\n\t\tcase IDI_TYPING_FRAME2: return IDI_TYPING_FRAME2_2K;\n\t\tcase IDI_TYPING_FRAME3: return IDI_TYPING_FRAME3_2K;\n\t\tcase IDI_NOTIFICATION: return IDI_NOTIFICATION_2K;\n\t\tcase IDI_REPLY_PIECE: return IDI_REPLY_PIECE_2K;\n\t\tcase IDI_SHIFT_RIGHT: return IDI_SHIFT_RIGHT_2K;\n\t\tcase IDI_NEW_INLINE: return IDI_NEW_INLINE_2K;\n\t\tcase IDI_SHIFT_LEFT: return IDI_SHIFT_LEFT_2K;\n\t\tcase IDI_CATEGORY: return IDI_CATEGORY_2K;\n\t\tcase IDI_CHANNEL: return IDI_CHANNEL_2K;\n\t\tcase IDI_MEMBERS: return IDI_MEMBERS_2K;\n\t\tcase IDI_GROUPDM: return IDI_GROUPDM_2K;\n\t\tcase IDI_SERVER: return IDI_SERVER_2K;\n\t\tcase IDI_BOOST: return IDI_BOOST_2K;\n\t\tcase IDI_VOICE: return IDI_VOICE_2K;\n\t\tcase IDI_FILE: return IDI_FILE_2K;\n\t\tcase IDI_JUMP: return IDI_JUMP_2K;\n\t\tcase IDI_SEND: return IDI_SEND_2K;\n\t\tcase IDI_ICON: return IDI_ICON_2K;\n\t\tcase IDI_BOT: return IDI_BOT_2K;\n\t\tcase IDI_NEW: return IDI_NEW_2K;\n\t\tcase IDI_PIN: return IDI_PIN_2K;\n\t\tcase IDI_DM: return IDI_DM_2K;\n\n\t\tdefault: \/\/ No mapping\n\t\t\treturn iconID;\n\t}\n}","mark":8.0}
{"file_name":"WinUtils_function_45.cpp","line_count":10,"code":"void DrawIconInsideProfilePicture(HDC hdc, int xp, int yp, HICON icon)\n{\n\tint pfpSize = ScaleByDPI(PROFILE_PICTURE_SIZE_DEF);\n\tint iconSize = ScaleByDPI(16);\n\n\tint xb = xp + pfpSize - iconSize;\n\tint yb = yp + pfpSize - iconSize;\n\n\tDrawIconEx(hdc, xb, yb, icon, iconSize, iconSize, 0, NULL, DI_COMPAT | DI_NORMAL);\n}","mark":8.0}
{"file_name":"WinUtils_function_46.cpp","line_count":7,"code":"void DrawMentionStatus(HDC hdc, int x, int y, int mentionCount)\n{\n\tif (mentionCount < 1) return;\n\tmentionCount--;\n\tif (mentionCount > 9) mentionCount = 9;\n\tDrawIconInsideProfilePicture(hdc, x, y, g_MentionMarkerIcons[mentionCount]);\n}","mark":8.0}
{"file_name":"WinUtils_function_47.cpp","line_count":4,"code":"void DrawActivityStatus(HDC hdc, int x, int y, eActiveStatus status)\n{\n\tDrawIconInsideProfilePicture(hdc, x, y, g_ProfileStatusIcons[int(status)]);\n}","mark":8.0}
{"file_name":"WinUtils_function_5.cpp","line_count":4,"code":"void SetUserScale(int scale)\n{\n\tg_Scale = scale;\n}","mark":8.0}
{"file_name":"WinUtils_function_57.cpp","line_count":8,"code":"bool IsColorDark(COLORREF cr)\n{\n\tuint8_t c1 = cr & 0xFF; cr >>= 8;\n\tuint8_t c2 = cr & 0xFF; cr >>= 8;\n\tuint8_t c3 = cr & 0xFF;\n\tint avg = (c1 + c2 + c3) \/ 3;\n\treturn avg <= 128;\n}","mark":8.0}
{"file_name":"XeSSFeature_function_1.cpp","line_count":22,"code":"string ResultToString(xess_result_t result)\n{\n\tswitch (result)\n\t{\n\tcase XESS_RESULT_WARNING_NONEXISTING_FOLDER: return \"Warning Nonexistent Folder\";\n\tcase XESS_RESULT_WARNING_OLD_DRIVER: return \"Warning Old Driver\";\n\tcase XESS_RESULT_SUCCESS: return \"Success\";\n\tcase XESS_RESULT_ERROR_UNSUPPORTED_DEVICE: return \"Unsupported Device\";\n\tcase XESS_RESULT_ERROR_UNSUPPORTED_DRIVER: return \"Unsupported Driver\";\n\tcase XESS_RESULT_ERROR_UNINITIALIZED: return \"Uninitialized\";\n\tcase XESS_RESULT_ERROR_INVALID_ARGUMENT: return \"Invalid Argument\";\n\tcase XESS_RESULT_ERROR_DEVICE_OUT_OF_MEMORY: return \"Device Out of Memory\";\n\tcase XESS_RESULT_ERROR_DEVICE: return \"Device Error\";\n\tcase XESS_RESULT_ERROR_NOT_IMPLEMENTED: return \"Not Implemented\";\n\tcase XESS_RESULT_ERROR_INVALID_CONTEXT: return \"Invalid Context\";\n\tcase XESS_RESULT_ERROR_OPERATION_IN_PROGRESS: return \"Operation in Progress\";\n\tcase XESS_RESULT_ERROR_UNSUPPORTED: return \"Unsupported\";\n\tcase XESS_RESULT_ERROR_CANT_LOAD_LIBRARY: return \"Cannot Load Library\";\n\tcase XESS_RESULT_ERROR_UNKNOWN:\n\tdefault: return \"Unknown\";\n\t}\n}","mark":8.0}
{"file_name":"XeSS_Dx12_function_11.cpp","line_count":15,"code":"xess_result_t xessDestroyContext(xess_context_handle_t hContext)\n{\n    LOG_DEBUG(\"\");\n\n    if (!_contexts.contains(hContext))\n        return XESS_RESULT_ERROR_INVALID_CONTEXT;\n\n    NVSDK_NGX_D3D12_ReleaseFeature(_contexts[hContext]);\n\n    _contexts.erase(hContext);\n    _nvParams.erase(hContext);\n    _initParams.erase(hContext);\n\n    return XESS_RESULT_SUCCESS;\n}","mark":8.0}
{"file_name":"XeSS_Dx12_function_13.cpp","line_count":22,"code":"xess_result_t xessD3D12GetInitParams(xess_context_handle_t hContext, xess_d3d12_init_params_t* pInitParams)\n{\n    LOG_DEBUG(\"\");\n\n    if (!_initParams.contains(hContext))\n        return XESS_RESULT_ERROR_INVALID_CONTEXT;\n\n    auto ip = &_initParams[hContext];\n\n    pInitParams->bufferHeapOffset = ip->bufferHeapOffset;\n    pInitParams->creationNodeMask = ip->creationNodeMask;\n    pInitParams->initFlags = ip->initFlags;\n    pInitParams->outputResolution = ip->outputResolution;\n    pInitParams->pPipelineLibrary = ip->pPipelineLibrary;\n    pInitParams->pTempBufferHeap = ip->pTempBufferHeap;\n    pInitParams->pTempTextureHeap = ip->pTempTextureHeap;\n    pInitParams->qualitySetting = ip->qualitySetting;\n    pInitParams->textureHeapOffset = ip->textureHeapOffset;\n    pInitParams->visibleNodeMask = ip->visibleNodeMask;\n\n    return XESS_RESULT_SUCCESS;\n}","mark":8.0}
{"file_name":"XeSS_Dx12_function_15.cpp","line_count":12,"code":"xess_result_t xessGetExposureMultiplier(xess_context_handle_t hContext, float* pScale)\n{\n    LOG_DEBUG(\"\");\n\n    if (!_nvParams.contains(hContext))\n        return XESS_RESULT_ERROR_INVALID_CONTEXT;\n\n    if (_nvParams[hContext]->Get(NVSDK_NGX_Parameter_DLSS_Exposure_Scale, pScale) == NVSDK_NGX_Result_Success)\n        return XESS_RESULT_SUCCESS;\n\n    return XESS_RESULT_ERROR_UNKNOWN;\n}","mark":8.0}
{"file_name":"XeSS_Dx12_function_17.cpp","line_count":11,"code":"xess_result_t xessGetIntelXeFXVersion(xess_context_handle_t hContext, xess_version_t* pVersion)\n{\n    LOG_DEBUG(\"\");\n\n    pVersion->major = XeSSProxy::Version().major;\n    pVersion->minor = XeSSProxy::Version().minor;\n    pVersion->patch = XeSSProxy::Version().patch;\n    pVersion->reserved = XeSSProxy::Version().reserved;\n\n    return XESS_RESULT_SUCCESS;\n}","mark":8.0}
{"file_name":"XeSS_Dx12_function_18.cpp","line_count":9,"code":"xess_result_t xessGetJitterScale(xess_context_handle_t hContext, float* pX, float* pY)\n{\n    LOG_DEBUG(\"\");\n\n    *pX = 1.0f;\n    *pY = 1.0f;\n\n    return XESS_RESULT_SUCCESS;\n}","mark":8.0}
{"file_name":"XeSS_Dx12_function_21.cpp","line_count":5,"code":"xess_result_t xessSetJitterScale(xess_context_handle_t hContext, float x, float y)\n{\n    LOG_DEBUG(\"x: {}, y: {}\", x, y);\n    return XESS_RESULT_SUCCESS;\n}","mark":8.0}
{"file_name":"XeSS_Dx12_function_22.cpp","line_count":11,"code":"xess_result_t xessSetExposureMultiplier(xess_context_handle_t hContext, float scale)\n{\n    LOG_DEBUG(\"\");\n\n    if (!_nvParams.contains(hContext))\n        return XESS_RESULT_ERROR_INVALID_CONTEXT;\n\n    _nvParams[hContext]->Set(NVSDK_NGX_Parameter_DLSS_Exposure_Scale, scale);\n\n    return XESS_RESULT_SUCCESS;\n}","mark":8.0}
{"file_name":"XeSS_Dx12_function_7.cpp","line_count":11,"code":"xess_result_t xessGetVersion(xess_version_t* pVersion)\n{\n    LOG_DEBUG(\"\");\n\n    pVersion->major = XeSSProxy::Version().major;\n    pVersion->minor = XeSSProxy::Version().minor;\n    pVersion->patch = XeSSProxy::Version().patch;\n    pVersion->reserved = XeSSProxy::Version().reserved;\n\n    return XESS_RESULT_SUCCESS;\n}","mark":8.0}
{"file_name":"XeSS_Proxy_function_11.cpp","line_count":1,"code":"PFN_xessSelectNetworkModel SelectNetworkModel() { return _xessSelectNetworkModel; }","mark":8.0}
{"file_name":"XeSS_Proxy_function_14.cpp","line_count":1,"code":"PFN_xessIsOptimalDriver IsOptimalDriver() { return _xessIsOptimalDriver; }","mark":8.0}
{"file_name":"XeSS_Proxy_function_16.cpp","line_count":1,"code":"PFN_xessGetProperties GetProperties() { return _xessGetProperties; }","mark":8.0}
{"file_name":"XeSS_Proxy_function_20.cpp","line_count":1,"code":"PFN_xessForceLegacyScaleFactors ForceLegacyScaleFactors() { return _xessForceLegacyScaleFactors; }","mark":8.0}
{"file_name":"Zydis_function_1.cpp","line_count":13,"code":"int ZYAN_MEMCMP(const void* s1, const void* s2, ZyanUSize n)\n{\n    const ZyanU8* p1 = s1, *p2 = s2;\n    while (n--)\n    {\n        if (*p1 != *p2)\n        {\n            return *p1 - *p2;\n        }\n        p1++, p2++;\n    }\n    return 0;\n}","mark":8.0}
{"file_name":"Zydis_function_102.cpp","line_count":17,"code":"ZyanU8 ZydisGetUnsignedImmSize(ZyanU64 imm)\n{\n    if (imm <= ZYAN_UINT8_MAX)\n    {\n        return 8;\n    }\n    if (imm <= ZYAN_UINT16_MAX)\n    {\n        return 16;\n    }\n    if (imm <= ZYAN_UINT32_MAX)\n    {\n        return 32;\n    }\n\n    return 64;\n}","mark":8.0}
{"file_name":"Zydis_function_108.cpp","line_count":14,"code":"ZyanBool ZydisIsScaleValid(ZyanU8 scale)\n{\n    switch (scale)\n    {\n    case 0:\n    case 1:\n    case 2:\n    case 4:\n    case 8:\n        return ZYAN_TRUE;\n    default:\n        return ZYAN_FALSE;\n    }\n}","mark":8.0}
{"file_name":"Zydis_function_11.cpp","line_count":10,"code":"void ZydisInputSkip(ZydisDecoderState* state, ZydisDecodedInstruction* instruction)\n{\n    ZYAN_ASSERT(state);\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(instruction->length < ZYDIS_MAX_INSTRUCTION_LENGTH);\n\n    ++instruction->length;\n    ++state->buffer;\n    --state->buffer_len;\n}","mark":8.0}
{"file_name":"Zydis_function_115.cpp","line_count":16,"code":"ZyanU8 ZydisEncodeMvexBroadcastMode(ZydisBroadcastMode broadcast)\n{\n    switch (broadcast)\n    {\n    case ZYDIS_BROADCAST_MODE_INVALID:\n        return 0;\n    case ZYDIS_BROADCAST_MODE_1_TO_16:\n    case ZYDIS_BROADCAST_MODE_1_TO_8:\n        return 1;\n    case ZYDIS_BROADCAST_MODE_4_TO_16:\n    case ZYDIS_BROADCAST_MODE_4_TO_8:\n        return 2;\n    default:\n        ZYAN_UNREACHABLE;\n    }\n}","mark":8.0}
{"file_name":"Zydis_function_149.cpp","line_count":4,"code":"ZyanStatus ZydisEmitByte(ZyanU8 byte, ZydisEncoderBuffer *buffer)\n{\n    return ZydisEmitUInt(byte, 1, buffer);\n}","mark":8.0}
{"file_name":"Zydis_function_172.cpp","line_count":32,"code":"ZyanStatus ZydisEncoderNopFill(void *buffer, ZyanUSize length)\n{\n    if (!buffer)\n    {\n        return ZYAN_STATUS_INVALID_ARGUMENT;\n    }\n\n    \/\/ Intel SDM Vol. 2B \"Recommended Multi-Byte Sequence of NOP Instruction\"\n    static const ZyanU8 nops[9][9] =\n    {\n        { 0x90 },\n        { 0x66, 0x90 },\n        { 0x0F, 0x1F, 0x00 },\n        { 0x0F, 0x1F, 0x40, 0x00 },\n        { 0x0F, 0x1F, 0x44, 0x00, 0x00 },\n        { 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00 },\n        { 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00 },\n        { 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        { 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 },\n    };\n\n    ZyanU8 *output = (ZyanU8 *)buffer;\n    while (length)\n    {\n        ZyanUSize nop_size = (length > 9) ? 9 : length;\n        ZYAN_MEMCPY(output, nops[nop_size - 1], nop_size);\n        output += nop_size;\n        length -= nop_size;\n    }\n\n    return ZYAN_STATUS_SUCCESS;\n}","mark":8.0}
{"file_name":"Zydis_function_184.cpp","line_count":11,"code":"ZyanStatus ZydisFormatterInit(ZydisFormatter* formatter, ZydisFormatterStyle style)\n{\n    if (!formatter || ((ZyanUSize)style > ZYDIS_FORMATTER_STYLE_MAX_VALUE))\n    {\n        return ZYAN_STATUS_INVALID_ARGUMENT;\n    }\n\n    ZYAN_MEMCPY(formatter, FORMATTER_PRESETS[style], sizeof(*formatter));\n\n    return ZYAN_STATUS_SUCCESS;\n}","mark":8.0}
{"file_name":"Zydis_function_19.cpp","line_count":11,"code":"void ZydisDecodeModRM(ZydisDecodedInstruction* instruction, ZyanU8 data)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(!(instruction->attributes & ZYDIS_ATTRIB_HAS_MODRM));\n    ZYAN_ASSERT(instruction->raw.modrm.offset == instruction->length - 1);\n\n    instruction->attributes   |= ZYDIS_ATTRIB_HAS_MODRM;\n    instruction->raw.modrm.mod = (data >> 6) & 0x03;\n    instruction->raw.modrm.reg = (data >> 3) & 0x07;\n    instruction->raw.modrm.rm  = (data >> 0) & 0x07;\n}","mark":8.0}
{"file_name":"Zydis_function_236.cpp","line_count":11,"code":"ZydisRegisterWidth ZydisRegisterGetWidth(ZydisMachineMode mode, ZydisRegister reg)\n{\n    if ((ZyanUSize)reg >= ZYAN_ARRAY_LENGTH(REG_LOOKUP))\n    {\n        return 0;\n    }\n\n    return (mode == ZYDIS_MACHINE_MODE_LONG_64)\n        ? REG_LOOKUP[reg].width64\n        : REG_LOOKUP[reg].width;\n}","mark":8.0}
{"file_name":"Zydis_function_260.cpp","line_count":4,"code":"ZyanU64 ZydisGetVersion(void)\n{\n    return ZYDIS_VERSION;\n}","mark":8.0}
{"file_name":"Zydis_function_59.cpp","line_count":19,"code":"ZyanStatus ZydisNodeHandlerVEX(const ZydisDecodedInstruction* instruction, ZyanU16* index)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(index);\n\n    switch (instruction->encoding)\n    {\n    case ZYDIS_INSTRUCTION_ENCODING_LEGACY:\n        *index = 0;\n        break;\n    case ZYDIS_INSTRUCTION_ENCODING_VEX:\n        ZYAN_ASSERT(instruction->attributes & ZYDIS_ATTRIB_HAS_VEX);\n        *index = instruction->raw.vex.m_mmmm + (instruction->raw.vex.pp << 2) + 1;\n        break;\n    default:\n        ZYAN_UNREACHABLE;\n    }\n    return ZYAN_STATUS_SUCCESS;\n}","mark":8.0}
{"file_name":"Zydis_function_63.cpp","line_count":24,"code":"ZyanStatus ZydisNodeHandlerMode(const ZydisDecodedInstruction* instruction, ZyanU16* index)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(index);\n\n    switch (instruction->machine_mode)\n    {\n    case ZYDIS_MACHINE_MODE_LONG_COMPAT_16:\n    case ZYDIS_MACHINE_MODE_LEGACY_16:\n    case ZYDIS_MACHINE_MODE_REAL_16:\n        *index = 0;\n        break;\n    case ZYDIS_MACHINE_MODE_LONG_COMPAT_32:\n    case ZYDIS_MACHINE_MODE_LEGACY_32:\n        *index = 1;\n        break;\n    case ZYDIS_MACHINE_MODE_LONG_64:\n        *index = 2;\n        break;\n    default:\n        ZYAN_UNREACHABLE;\n    }\n    return ZYAN_STATUS_SUCCESS;\n}","mark":8.0}
{"file_name":"Zydis_function_7.cpp","line_count":9,"code":"ZyanUSize ZYAN_STRSPN(const char* s1, const char* s2)\n{\n    ZyanUSize ret = 0;\n    while (*s1 && ZYAN_STRCHR(s2, *s1++))\n    {\n        ret++;\n    }\n    return ret;\n}","mark":8.0}
{"file_name":"Zydis_function_75.cpp","line_count":10,"code":"ZyanStatus ZydisNodeHandlerEvexB(const ZydisDecodedInstruction* instruction, ZyanU16* index)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(index);\n\n    ZYAN_ASSERT(instruction->encoding == ZYDIS_INSTRUCTION_ENCODING_EVEX);\n    ZYAN_ASSERT(instruction->attributes & ZYDIS_ATTRIB_HAS_EVEX);\n    *index = instruction->raw.evex.b;\n    return ZYAN_STATUS_SUCCESS;\n}","mark":8.5}
{"file_name":"Zydis_function_76.cpp","line_count":10,"code":"ZyanStatus ZydisNodeHandlerMvexE(const ZydisDecodedInstruction* instruction, ZyanU16* index)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(index);\n\n    ZYAN_ASSERT(instruction->encoding == ZYDIS_INSTRUCTION_ENCODING_MVEX);\n    ZYAN_ASSERT(instruction->attributes & ZYDIS_ATTRIB_HAS_MVEX);\n    *index = instruction->raw.mvex.E;\n    return ZYAN_STATUS_SUCCESS;\n}","mark":8.0}
{"file_name":"Zydis_function_89.cpp","line_count":18,"code":"ZyanStatus ZydisDecoderEnableMode(ZydisDecoder* decoder, ZydisDecoderMode mode, ZyanBool enabled)\n{\n    if (!decoder || ((ZyanUSize)mode > ZYDIS_DECODER_MODE_MAX_VALUE))\n    {\n        return ZYAN_STATUS_INVALID_ARGUMENT;\n    }\n\n#ifdef ZYDIS_MINIMAL_MODE\n    if ((mode == ZYDIS_DECODER_MODE_MINIMAL) && !enabled)\n    {\n        return ZYAN_STATUS_INVALID_OPERATION;\n    }\n#endif\n\n    decoder->decoder_mode[mode] = enabled;\n\n    return ZYAN_STATUS_SUCCESS;\n}","mark":8.0}
{"file_name":"Zydis_function_94.cpp","line_count":14,"code":"ZydisEncodableEncoding ZydisGetEncodableEncoding(ZydisInstructionEncoding encoding)\n{\n    static const ZydisEncodableEncoding encoding_lookup[6] =\n    {\n        ZYDIS_ENCODABLE_ENCODING_LEGACY,\n        ZYDIS_ENCODABLE_ENCODING_3DNOW,\n        ZYDIS_ENCODABLE_ENCODING_XOP,\n        ZYDIS_ENCODABLE_ENCODING_VEX,\n        ZYDIS_ENCODABLE_ENCODING_EVEX,\n        ZYDIS_ENCODABLE_ENCODING_MVEX,\n    };\n    ZYAN_ASSERT((ZyanUSize)encoding <= ZYDIS_INSTRUCTION_ENCODING_MAX_VALUE);\n    return encoding_lookup[encoding];\n}","mark":8.0}
{"file_name":"Zydis_function_95.cpp","line_count":17,"code":"ZyanU8 ZydisGetMachineModeWidth(ZydisMachineMode machine_mode)\n{\n    switch (machine_mode)\n    {\n    case ZYDIS_MACHINE_MODE_REAL_16:\n    case ZYDIS_MACHINE_MODE_LEGACY_16:\n    case ZYDIS_MACHINE_MODE_LONG_COMPAT_16:\n        return 16;\n    case ZYDIS_MACHINE_MODE_LEGACY_32:\n    case ZYDIS_MACHINE_MODE_LONG_COMPAT_32:\n        return 32;\n    case ZYDIS_MACHINE_MODE_LONG_64:\n        return 64;\n    default:\n        ZYAN_UNREACHABLE;\n    }\n}","mark":8.0}
{"file_name":"Zydis_function_96.cpp","line_count":6,"code":"ZyanU8 ZydisGetAszFromHint(ZydisAddressSizeHint hint)\n{\n    ZYAN_ASSERT((ZyanUSize)hint <= ZYDIS_ADDRESS_SIZE_HINT_MAX_VALUE);\n    static const ZyanU8 lookup[ZYDIS_ADDRESS_SIZE_HINT_MAX_VALUE + 1] = { 0, 16, 32, 64 };\n    return lookup[hint];\n}","mark":8.0}
{"file_name":"Zydis_function_97.cpp","line_count":6,"code":"ZyanU8 ZydisGetOszFromHint(ZydisOperandSizeHint hint)\n{\n    ZYAN_ASSERT((ZyanUSize)hint <= ZYDIS_OPERAND_SIZE_HINT_MAX_VALUE);\n    static const ZyanU8 lookup[ZYDIS_OPERAND_SIZE_HINT_MAX_VALUE + 1] = { 0, 8, 16, 32, 64 };\n    return lookup[hint];\n}","mark":8.0}
{"file_name":"nvhttp_function_32.cpp","line_count":7,"code":"void stop_session(stream::session_t& session, bool graceful) {\n    if (graceful) {\n      stream::session::graceful_stop(session);\n    } else {\n      stream::session::stop(session);\n    }\n  }","mark":8.0}
{"file_name":"nvhttp_function_33.cpp","line_count":8,"code":"bool find_and_stop_session(const std::string& uuid, bool graceful) {\n    auto session = rtsp_stream::find_session(uuid);\n    if (session) {\n      stop_session(*session, graceful);\n      return true;\n    }\n    return false;\n  }","mark":8.0}
{"file_name":"nvhttp_function_35.cpp","line_count":8,"code":"bool find_and_udpate_session_info(const std::string& uuid, const std::string& name, const crypto::PERM newPerm) {\n    auto session = rtsp_stream::find_session(uuid);\n    if (session) {\n      update_session_info(*session, name, newPerm);\n      return true;\n    }\n    return false;\n  }","mark":8.0}
{"file_name":"nvsdk_ngx_helpers_vk_function_1.cpp","line_count":13,"code":"NVSDK_NGX_Resource_VK NVSDK_NGX_Create_ImageView_Resource_VK(VkImageView imageView, VkImage image, VkImageSubresourceRange subresourceRange, VkFormat format, unsigned int width, unsigned int height, bool readWrite)\n{\n    NVSDK_NGX_Resource_VK resourceVK = {0};\n    resourceVK.Type = NVSDK_NGX_RESOURCE_VK_TYPE_VK_IMAGEVIEW;\n    resourceVK.Resource.ImageViewInfo.ImageView = imageView;\n    resourceVK.Resource.ImageViewInfo.Image = image;\n    resourceVK.Resource.ImageViewInfo.SubresourceRange = subresourceRange;\n    resourceVK.Resource.ImageViewInfo.Height = height;\n    resourceVK.Resource.ImageViewInfo.Width = width;\n    resourceVK.Resource.ImageViewInfo.Format = format;\n    resourceVK.ReadWrite = readWrite;\n    return resourceVK;\n}","mark":8.0}
{"file_name":"nvsdk_ngx_helpers_vk_function_2.cpp","line_count":9,"code":"NVSDK_NGX_Resource_VK NVSDK_NGX_Create_Buffer_Resource_VK(VkBuffer buffer, unsigned int sizeInBytes, bool readWrite)\n{\n    NVSDK_NGX_Resource_VK resourceVK = {0};\n    resourceVK.Type = NVSDK_NGX_RESOURCE_VK_TYPE_VK_BUFFER;\n    resourceVK.Resource.BufferInfo.Buffer = buffer;\n    resourceVK.Resource.BufferInfo.SizeInBytes = sizeInBytes;\n    resourceVK.ReadWrite = readWrite;\n    return resourceVK;\n}","mark":8.0}
{"file_name":"object_pool_function_1.cpp","line_count":4,"code":"void destroy(Object* o)\n  {\n    delete o;\n  }","mark":8.0}
{"file_name":"object_pool_function_3.cpp","line_count":9,"code":"void destroy_list(Object* list)\n  {\n    while (list)\n    {\n      Object* o = list;\n      list = object_pool_access::next(o);\n      object_pool_access::destroy(o);\n    }\n  }","mark":8.0}
{"file_name":"overlapped_ptr_function_1.cpp","line_count":4,"code":"void reset()\n  {\n    impl_.reset();\n  }","mark":8.0}
{"file_name":"parser_function_8.cpp","line_count":3,"code":"void set_max_body_size(size_t value) {\n        m_body_bytes_max = value;\n    }","mark":9.0}
{"file_name":"partial_promise_function_3.cpp","line_count":1,"code":"void return_void() {}","mark":8.0}
{"file_name":"pattern_except_function_1.cpp","line_count":8,"code":"void raise_runtime_error(const E& ex)\n{\n#ifndef BOOST_REGEX_STANDALONE\n   ::boost::throw_exception(ex);\n#else\n   throw ex;\n#endif\n}","mark":8.0}
{"file_name":"perl_matcher_function_14.cpp","line_count":1,"code":"size_t get_count() { return count; }","mark":8.0}
{"file_name":"perl_matcher_function_17.cpp","line_count":2,"code":"void setf(match_flag_type f)\n   { m_match_flags |= f; }","mark":8.0}
{"file_name":"perl_matcher_function_20.cpp","line_count":2,"code":"void setf(match_flag_type f)\n   { m_match_flags |= f; }","mark":8.0}
{"file_name":"perl_matcher_function_21.cpp","line_count":2,"code":"void unsetf(match_flag_type f)\n   { m_match_flags &= ~f; }","mark":8.0}
{"file_name":"perl_matcher_function_3.cpp","line_count":4,"code":"bool can_start(char c, const unsigned char* map, unsigned char mask)\n{\n   return map[(unsigned char)c] & mask;\n}","mark":8.0}
{"file_name":"perl_matcher_function_5.cpp","line_count":4,"code":"bool can_start(unsigned char c, const unsigned char* map, unsigned char mask)\n{\n   return map[c] & mask;\n}","mark":8.0}
{"file_name":"posix_serial_port_service_function_4.cpp","line_count":4,"code":"void destroy(implementation_type& impl)\n  {\n    descriptor_service_.destroy(impl);\n  }","mark":8.0}
{"file_name":"posix_serial_port_service_function_7.cpp","line_count":4,"code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    return descriptor_service_.native_handle(impl);\n  }","mark":8.0}
{"file_name":"primary_transform_function_1.cpp","line_count":15,"code":"unsigned count_chars(const S& s, charT c)\n{\n   \/\/\n   \/\/ Count how many occurrences of character c occur\n   \/\/ in string s: if c is a delimeter between collation\n   \/\/ fields, then this should be the same value for all\n   \/\/ sort keys:\n   \/\/\n   unsigned int count = 0;\n   for(unsigned pos = 0; pos < s.size(); ++pos)\n   {\n      if(s[pos] == c) ++count;\n   }\n   return count;\n}","mark":8.0}
{"file_name":"processor_function_4.cpp","line_count":3,"code":"void set_max_message_size(size_t new_value) {\n        m_max_message_size = new_value;\n    }","mark":9.0}
{"file_name":"process_function_15.cpp","line_count":6,"code":"uint32_t\n  calculate_crc32(const std::string &input) {\n    boost::crc_32_type result;\n    result.process_bytes(input.data(), input.length());\n    return result.checksum();\n  }","mark":8.0}
{"file_name":"process_function_1_1.cpp","line_count":4,"code":"void onVDisplayWatchdogFailed() {\n    vDisplayDriverStatus = VDISPLAY::DRIVER_STATUS::WATCHDOG_FAILED;\n    VDISPLAY::closeVDisplayDevice();\n  }","mark":8.0}
{"file_name":"promise_function_2.cpp","line_count":1,"code":"allocator_type get_allocator() {return allocator;}","mark":8.0}
{"file_name":"quat_function_1.cpp","line_count":1,"code":"size_type size() { return SIZE; }","mark":8.0}
{"file_name":"reactive_socket_service_base_function_1.cpp","line_count":4,"code":"native_handle_type native_handle(base_implementation_type& impl)\n  {\n    return impl.socket_;\n  }","mark":8.0}
{"file_name":"reactive_socket_service_function_6.cpp","line_count":4,"code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    return impl.socket_;\n  }","mark":8.0}
{"file_name":"reactor_op_queue_function_1.cpp","line_count":1,"code":"iterator begin() { return operations_.begin(); }","mark":8.0}
{"file_name":"reactor_op_queue_function_2.cpp","line_count":1,"code":"iterator end() { return operations_.end(); }","mark":8.0}
{"file_name":"regex_format_function_14.cpp","line_count":4,"code":"OutputIter do_format_string(const S& s, OutputIter i)\n   {\n      return std::copy(s.begin(), s.end(), i);\n   }","mark":8.0}
{"file_name":"regex_format_function_15.cpp","line_count":10,"code":"OutputIter do_format_string(const S* s, OutputIter i)\n   {\n      while(s && *s)\n      {\n         *i = *s;\n         ++i;\n         ++s;\n      }\n      return i;\n   }","mark":8.0}
{"file_name":"regex_raw_buffer_function_7.cpp","line_count":6,"code":"void swap(raw_storage& that)\n   {\n      std::swap(start, that.start);\n      std::swap(end, that.end);\n      std::swap(last, that.last);\n  }","mark":8.0}
{"file_name":"regex_raw_buffer_function_9.cpp","line_count":6,"code":"void swap(raw_storage& that)\n   {\n      std::swap(start, that.start);\n      std::swap(end, that.end);\n      std::swap(last, that.last);\n  }","mark":8.0}
{"file_name":"regex_traits_defaults_function_10.cpp","line_count":10,"code":"ptrdiff_t global_length(const charT* p)\n{\n   std::ptrdiff_t n = 0;\n   while(*p)\n   {\n      ++p;\n      ++n;\n   }\n   return n;\n}","mark":8.0}
{"file_name":"regex_traits_defaults_function_15.cpp","line_count":4,"code":"wchar_t  do_global_lower(wchar_t c)\n{\n   return (std::towlower)(c);\n}","mark":8.0}
{"file_name":"regex_workaround_function_2.cpp","line_count":2,"code":"void pointer_construct(T* p, const T& t)\n{ new (p) T(t); }","mark":8.0}
{"file_name":"robin_growth_policy_function_2.cpp","line_count":3,"code":"bool is_power_of_two(std::size_t value) {\n        return value != 0 && (value & (value - 1)) == 0;\n    }","mark":9.0}
{"file_name":"robin_hash_function_13.cpp","line_count":3,"code":"size_type erase(const K& key) {\n        return erase(key, hash_key(key));\n    }","mark":8.0}
{"file_name":"robin_hash_function_15.cpp","line_count":13,"code":"void swap(robin_hash& other) {\n        using std::swap;\n        \n        swap(static_cast<Hash&>(*this), static_cast<Hash&>(other));\n        swap(static_cast<KeyEqual&>(*this), static_cast<KeyEqual&>(other));\n        swap(static_cast<GrowthPolicy&>(*this), static_cast<GrowthPolicy&>(other));\n        swap(m_buckets, other.m_buckets);\n        swap(m_bucket_count, other.m_bucket_count);\n        swap(m_nb_elements, other.m_nb_elements);\n        swap(m_load_threshold, other.m_load_threshold);\n        swap(m_max_load_factor, other.m_max_load_factor);\n        swap(m_grow_on_next_insert, other.m_grow_on_next_insert);\n    }","mark":8.0}
{"file_name":"robin_hash_function_16.cpp","line_count":3,"code":"iterator find(const K& key) {\n        return find_impl(key, hash_key(key));\n    }","mark":8.0}
{"file_name":"robin_hash_function_17.cpp","line_count":3,"code":"iterator find(const K& key, std::size_t hash) {\n        return find_impl(key, hash);\n    }","mark":8.0}
{"file_name":"robin_hash_function_18.cpp","line_count":4,"code":"void max_load_factor(float ml) {\n        m_max_load_factor = std::max(0.1f, std::min(ml, 0.95f));\n        m_load_threshold = size_type(float(bucket_count())*m_max_load_factor);\n    }","mark":8.0}
{"file_name":"robin_hash_function_19.cpp","line_count":4,"code":"void rehash(size_type count) {\n        count = std::max(count, size_type(std::ceil(float(size())\/max_load_factor())));\n        rehash_impl(count);\n    }","mark":8.0}
{"file_name":"robin_hash_function_21.cpp","line_count":3,"code":"iterator mutable_iterator(const_iterator pos) {\n        return iterator(m_buckets.begin() + std::distance(m_buckets.cbegin(), pos.m_iterator));\n    }","mark":8.0}
{"file_name":"robin_hash_function_22.cpp","line_count":3,"code":"iterator find_impl(const K& key, std::size_t hash) {\n        return mutable_iterator(static_cast<const robin_hash*>(this)->find(key, hash));\n    }","mark":8.0}
{"file_name":"robin_hash_function_29.cpp","line_count":10,"code":"bool grow_on_high_load() {\n        if(m_grow_on_next_insert || size() >= m_load_threshold) {\n            rehash_impl(GrowthPolicy::next_bucket_count());\n            m_grow_on_next_insert = false;\n            \n            return true;\n        }\n        \n        return false;\n    }","mark":8.0}
{"file_name":"robin_hash_function_8.cpp","line_count":3,"code":"iterator emplace_hint(const_iterator hint, Args&&... args) {\n        return insert(hint, value_type(std::forward<Args>(args)...));        \n    }","mark":8.0}
{"file_name":"robin_map_function_1.cpp","line_count":3,"code":"iterator insert(const_iterator hint, const value_type& value) { \n        return m_ht.insert(hint, value); \n    }","mark":8.0}
{"file_name":"robin_map_function_10.cpp","line_count":3,"code":"iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args) {\n        return m_ht.try_emplace(hint, std::move(k), std::forward<Args>(args)...);\n    }","mark":8.0}
{"file_name":"robin_map_function_13.cpp","line_count":1,"code":"iterator erase(const_iterator first, const_iterator last) { return m_ht.erase(first, last); }","mark":8.0}
{"file_name":"robin_map_function_14.cpp","line_count":1,"code":"size_type erase(const key_type& key) { return m_ht.erase(key); }","mark":8.0}
{"file_name":"robin_map_function_15.cpp","line_count":3,"code":"size_type erase(const key_type& key, std::size_t precalculated_hash) { \n        return m_ht.erase(key, precalculated_hash); \n    }","mark":8.0}
{"file_name":"robin_map_function_16.cpp","line_count":1,"code":"size_type erase(const K& key) { return m_ht.erase(key); }","mark":8.0}
{"file_name":"robin_map_function_17.cpp","line_count":3,"code":"size_type erase(const K& key, std::size_t precalculated_hash) { \n        return m_ht.erase(key, precalculated_hash); \n    }","mark":8.0}
{"file_name":"robin_map_function_18.cpp","line_count":1,"code":"void swap(robin_map& other) { other.m_ht.swap(m_ht); }","mark":8.0}
{"file_name":"robin_map_function_19.cpp","line_count":1,"code":"iterator find(const Key& key) { return m_ht.find(key); }","mark":8.0}
{"file_name":"robin_map_function_2.cpp","line_count":3,"code":"iterator insert(const_iterator hint, P&& value) { \n        return m_ht.emplace_hint(hint, std::forward<P>(value));\n    }","mark":8.0}
{"file_name":"robin_map_function_20.cpp","line_count":1,"code":"iterator find(const Key& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }","mark":8.0}
{"file_name":"robin_map_function_21.cpp","line_count":1,"code":"iterator find(const K& key) { return m_ht.find(key); }","mark":8.0}
{"file_name":"robin_map_function_22.cpp","line_count":1,"code":"iterator find(const K& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }","mark":8.0}
{"file_name":"robin_map_function_23.cpp","line_count":1,"code":"void max_load_factor(float ml) { m_ht.max_load_factor(ml); }","mark":8.0}
{"file_name":"robin_map_function_24.cpp","line_count":1,"code":"void rehash(size_type count) { m_ht.rehash(count); }","mark":8.0}
{"file_name":"robin_map_function_25.cpp","line_count":1,"code":"void reserve(size_type count) { m_ht.reserve(count); }","mark":8.0}
{"file_name":"robin_map_function_26.cpp","line_count":3,"code":"iterator mutable_iterator(const_iterator pos) {\n        return m_ht.mutable_iterator(pos);\n    }","mark":8.0}
{"file_name":"robin_map_function_27.cpp","line_count":3,"code":"void swap(robin_map& lhs, robin_map& rhs) {\n        lhs.swap(rhs);\n    }","mark":8.0}
{"file_name":"robin_map_function_3.cpp","line_count":3,"code":"iterator insert(const_iterator hint, value_type&& value) { \n        return m_ht.insert(hint, std::move(value)); \n    }","mark":8.0}
{"file_name":"robin_map_function_4.cpp","line_count":3,"code":"void insert(InputIt first, InputIt last) { \n        m_ht.insert(first, last); \n    }","mark":8.0}
{"file_name":"robin_map_function_5.cpp","line_count":3,"code":"void insert(std::initializer_list<value_type> ilist) { \n        m_ht.insert(ilist.begin(), ilist.end()); \n    }","mark":8.0}
{"file_name":"robin_map_function_6.cpp","line_count":3,"code":"iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj) {\n        return m_ht.insert_or_assign(hint, k, std::forward<M>(obj));\n    }","mark":8.0}
{"file_name":"robin_map_function_7.cpp","line_count":3,"code":"iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj) {\n        return m_ht.insert_or_assign(hint, std::move(k), std::forward<M>(obj));\n    }","mark":8.0}
{"file_name":"robin_map_function_8.cpp","line_count":3,"code":"iterator emplace_hint(const_iterator hint, Args&&... args) {\n        return m_ht.emplace_hint(hint, std::forward<Args>(args)...);\n    }","mark":8.0}
{"file_name":"robin_map_function_9.cpp","line_count":3,"code":"iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args) {\n        return m_ht.try_emplace(hint, k, std::forward<Args>(args)...);\n    }","mark":8.0}
{"file_name":"robin_set_function_1.cpp","line_count":3,"code":"iterator insert(const_iterator hint, const value_type& value) { \n        return m_ht.insert(hint, value); \n    }","mark":8.0}
{"file_name":"robin_set_function_10.cpp","line_count":3,"code":"size_type erase(const key_type& key, std::size_t precalculated_hash) { \n        return m_ht.erase(key, precalculated_hash); \n    }","mark":8.0}
{"file_name":"robin_set_function_11.cpp","line_count":1,"code":"size_type erase(const K& key) { return m_ht.erase(key); }","mark":8.0}
{"file_name":"robin_set_function_12.cpp","line_count":3,"code":"size_type erase(const K& key, std::size_t precalculated_hash) { \n        return m_ht.erase(key, precalculated_hash); \n    }","mark":8.0}
{"file_name":"robin_set_function_13.cpp","line_count":1,"code":"void swap(robin_set& other) { other.m_ht.swap(m_ht); }","mark":8.0}
{"file_name":"robin_set_function_14.cpp","line_count":1,"code":"iterator find(const Key& key) { return m_ht.find(key); }","mark":8.0}
{"file_name":"robin_set_function_15.cpp","line_count":1,"code":"iterator find(const Key& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }","mark":8.0}
{"file_name":"robin_set_function_16.cpp","line_count":1,"code":"iterator find(const K& key) { return m_ht.find(key); }","mark":8.0}
{"file_name":"robin_set_function_17.cpp","line_count":1,"code":"iterator find(const K& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }","mark":8.0}
{"file_name":"robin_set_function_18.cpp","line_count":1,"code":"void max_load_factor(float ml) { m_ht.max_load_factor(ml); }","mark":8.0}
{"file_name":"robin_set_function_19.cpp","line_count":1,"code":"void rehash(size_type count) { m_ht.rehash(count); }","mark":8.0}
{"file_name":"robin_set_function_2.cpp","line_count":3,"code":"iterator insert(const_iterator hint, value_type&& value) { \n        return m_ht.insert(hint, std::move(value)); \n    }","mark":8.0}
{"file_name":"robin_set_function_20.cpp","line_count":1,"code":"void reserve(size_type count) { m_ht.reserve(count); }","mark":8.0}
{"file_name":"robin_set_function_21.cpp","line_count":3,"code":"iterator mutable_iterator(const_iterator pos) {\n        return m_ht.mutable_iterator(pos);\n    }","mark":8.0}
{"file_name":"robin_set_function_22.cpp","line_count":3,"code":"void swap(robin_set& lhs, robin_set& rhs) {\n        lhs.swap(rhs);\n    }","mark":8.0}
{"file_name":"robin_set_function_3.cpp","line_count":3,"code":"void insert(InputIt first, InputIt last) { \n        m_ht.insert(first, last);\n    }","mark":8.0}
{"file_name":"robin_set_function_4.cpp","line_count":3,"code":"void insert(std::initializer_list<value_type> ilist) { \n        m_ht.insert(ilist.begin(), ilist.end()); \n    }","mark":8.0}
{"file_name":"robin_set_function_5.cpp","line_count":3,"code":"iterator emplace_hint(const_iterator hint, Args&&... args) {\n        return m_ht.emplace_hint(hint, std::forward<Args>(args)...);\n    }","mark":8.0}
{"file_name":"robin_set_function_8.cpp","line_count":1,"code":"iterator erase(const_iterator first, const_iterator last) { return m_ht.erase(first, last); }","mark":8.0}
{"file_name":"robin_set_function_9.cpp","line_count":1,"code":"size_type erase(const key_type& key) { return m_ht.erase(key); }","mark":8.0}
{"file_name":"rswrapper_function_1.cpp","line_count":34,"code":"void\nreed_solomon_init(void) {\n#if defined(__x86_64__) || defined(__i386__)\n  if (__builtin_cpu_supports(\"avx512f\") && __builtin_cpu_supports(\"avx512bw\")) {\n    reed_solomon_new_fn = reed_solomon_new_avx512;\n    reed_solomon_release_fn = reed_solomon_release_avx512;\n    reed_solomon_encode_fn = reed_solomon_encode_avx512;\n    reed_solomon_decode_fn = reed_solomon_decode_avx512;\n    reed_solomon_init_avx512();\n  }\n  else if (__builtin_cpu_supports(\"avx2\")) {\n    reed_solomon_new_fn = reed_solomon_new_avx2;\n    reed_solomon_release_fn = reed_solomon_release_avx2;\n    reed_solomon_encode_fn = reed_solomon_encode_avx2;\n    reed_solomon_decode_fn = reed_solomon_decode_avx2;\n    reed_solomon_init_avx2();\n  }\n  else if (__builtin_cpu_supports(\"ssse3\")) {\n    reed_solomon_new_fn = reed_solomon_new_ssse3;\n    reed_solomon_release_fn = reed_solomon_release_ssse3;\n    reed_solomon_encode_fn = reed_solomon_encode_ssse3;\n    reed_solomon_decode_fn = reed_solomon_decode_ssse3;\n    reed_solomon_init_ssse3();\n  }\n  else\n#endif\n  {\n    reed_solomon_new_fn = reed_solomon_new_def;\n    reed_solomon_release_fn = reed_solomon_release_def;\n    reed_solomon_encode_fn = reed_solomon_encode_def;\n    reed_solomon_decode_fn = reed_solomon_decode_def;\n    reed_solomon_init_def();\n  }\n}","mark":8.0}
{"file_name":"safetyhook_function_21.cpp","line_count":3,"code":"Error bad_allocation(Allocator::Error err) {\n            return {.type = BAD_ALLOCATION, .allocator_error = err};\n        }","mark":8.0}
{"file_name":"safetyhook_function_22.cpp","line_count":3,"code":"Error bad_inline_hook(InlineHook::Error err) {\n            return {.type = BAD_INLINE_HOOK, .inline_hook_error = err};\n        }","mark":8.0}
{"file_name":"safetyhook_function_28.cpp","line_count":3,"code":"Error bad_allocation(Allocator::Error err) {\n            return {.type = BAD_ALLOCATION, .allocator_error = err};\n        }","mark":8.0}
{"file_name":"safetyhook_function_35.cpp","line_count":13,"code":"SystemInfo system_info() {\n    SystemInfo info{};\n\n    SYSTEM_INFO si{};\n    GetSystemInfo(&si);\n\n    info.page_size = si.dwPageSize;\n    info.allocation_granularity = si.dwAllocationGranularity;\n    info.min_address = static_cast<uint8_t*>(si.lpMinimumApplicationAddress);\n    info.max_address = static_cast<uint8_t*>(si.lpMaximumApplicationAddress);\n\n    return info;\n}","mark":8.0}
{"file_name":"safetyhook_function_37.cpp","line_count":3,"code":"bool is_executable(uint8_t* address) {\n    return vm_is_executable(address);\n}","mark":8.0}
{"file_name":"safetyhook_function_4.cpp","line_count":3,"code":"Error bad_allocation(Allocator::Error err) {\n            return {.type = BAD_ALLOCATION, .allocator_error = err};\n        }","mark":8.0}
{"file_name":"scheduler_function_1.cpp","line_count":4,"code":"void work_started()\n  {\n    ++outstanding_work_;\n  }","mark":8.0}
{"file_name":"scheduler_function_2.cpp","line_count":5,"code":"void work_finished()\n  {\n    if (--outstanding_work_ == 0)\n      stop();\n  }","mark":8.0}
{"file_name":"server_endpoint_function_1.cpp","line_count":3,"code":"connection_ptr get_connection() {\n        return endpoint_type::create_connection();\n    }","mark":8.0}
{"file_name":"sha1_function_1.cpp","line_count":3,"code":"int rol(unsigned int value, unsigned int steps) {\n    return ((value << steps) | (value >> (32 - steps)));\n}","mark":8.0}
{"file_name":"socket_holder_function_1.cpp","line_count":10,"code":"void reset()\n  {\n    if (socket_ != invalid_socket)\n    {\n      asio::error_code ec;\n      socket_ops::state_type state = 0;\n      socket_ops::close(socket_, state, true, ec);\n      socket_ = invalid_socket;\n    }\n  }","mark":8.0}
{"file_name":"std_mutex_function_1.cpp","line_count":4,"code":"void lock()\n  {\n    mutex_.lock();\n  }","mark":8.0}
{"file_name":"std_mutex_function_2.cpp","line_count":4,"code":"void unlock()\n  {\n    mutex_.unlock();\n  }","mark":8.0}
{"file_name":"std_static_mutex_function_2.cpp","line_count":4,"code":"void lock()\n  {\n    mutex_.lock();\n  }","mark":8.0}
{"file_name":"std_static_mutex_function_3.cpp","line_count":4,"code":"void unlock()\n  {\n    mutex_.unlock();\n  }","mark":8.0}
{"file_name":"std_thread_function_1.cpp","line_count":5,"code":"void join()\n  {\n    if (thread_.joinable())\n      thread_.join();\n  }","mark":8.0}
{"file_name":"std_thread_function_2.cpp","line_count":4,"code":"size_t hardware_concurrency()\n  {\n    return std::thread::hardware_concurrency();\n  }","mark":8.0}
{"file_name":"stream_core_function_2.cpp","line_count":4,"code":"time_type pos_infin()\n  {\n    return boost::posix_time::pos_infin;\n  }","mark":8.0}
{"file_name":"stream_core_function_5.cpp","line_count":4,"code":"time_point pos_infin()\n  {\n    return (asio::steady_timer::time_point::max)();\n  }","mark":8.0}
{"file_name":"stream_function_1.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return core_.engine_.native_handle();\n  }","mark":8.0}
{"file_name":"stream_function_28.cpp","line_count":11,"code":"blocks\n      for (int x = 0; x < fec_blocks_needed; ++x) {\n        if (x == fec_blocks_needed - 1) {\n          \/\/ The last block must extend to the end of the payload\n          fec_blocks[x] = payload.substr(x * aligned_size);\n        }\n        else {\n          \/\/ Earlier blocks just extend to the next block offset\n          fec_blocks[x] = payload.substr(x * aligned_size, aligned_size);\n        }\n      }","mark":8.0}
{"file_name":"stream_function_36.cpp","line_count":4,"code":"state_e\n    state(session_t &session) {\n      return session.state.load(std::memory_order_relaxed);\n    }","mark":8.0}
{"file_name":"stream_function_38.cpp","line_count":4,"code":"string\n    uuid(const session_t& session) {\n      return session.device_uuid;\n    }","mark":8.0}
{"file_name":"stream_function_39.cpp","line_count":4,"code":"bool\n    uuid_match(const session_t &session, const std::string& uuid) {\n      return session.device_uuid == uuid;\n    }","mark":8.0}
{"file_name":"sudovda_function_11.cpp","line_count":19,"code":"bool PingDriver(HANDLE hDevice) {\n\tDWORD bytesReturned;\n\tBOOL success = DeviceIoControl(\n\t\thDevice,\n\t\tIOCTL_DRIVER_PING,\n\t\tnullptr,\n\t\t0,\n\t\tnullptr,\n\t\t0,\n\t\t&bytesReturned,\n\t\tnullptr\n\t);\n\n\tif (!success) {\n\t\tstd::cerr << \"[SUVDA] PingDriver failed: \" << GetLastError() << std::endl;\n\t}\n\n\treturn success;\n}","mark":8.0}
{"file_name":"sudovda_function_3.cpp","line_count":20,"code":"bool RemoveVirtualDisplay(HANDLE hDevice, const GUID& MonitorGuid) {\n\tVIRTUAL_DISPLAY_REMOVE_PARAMS params{MonitorGuid};\n\tDWORD bytesReturned;\n\tBOOL success = DeviceIoControl(\n\t\thDevice,\n\t\tIOCTL_REMOVE_VIRTUAL_DISPLAY,\n\t\t(LPVOID)&params,\n\t\tsizeof(params),\n\t\tnullptr,\n\t\t0,\n\t\t&bytesReturned,\n\t\tnullptr\n\t);\n\n\tif (!success) {\n\t\tstd::cerr << \"[SUVDA] RemoveVirtualDisplay failed: \" << GetLastError() << std::endl;\n\t}\n\n\treturn success;\n}","mark":8.0}
{"file_name":"sudovda_function_4.cpp","line_count":20,"code":"bool SetRenderAdapter(HANDLE hDevice, const LUID& AdapterLuid) {\n\tVIRTUAL_DISPLAY_SET_RENDER_ADAPTER_PARAMS params{AdapterLuid};\n\tDWORD bytesReturned;\n\tBOOL success = DeviceIoControl(\n\t\thDevice,\n\t\tIOCTL_SET_RENDER_ADAPTER,\n\t\t(LPVOID)&params,\n\t\tsizeof(params),\n\t\tnullptr,\n\t\t0,\n\t\t&bytesReturned,\n\t\tnullptr\n\t);\n\n\tif (!success) {\n\t\tstd::cerr << \"[SUVDA] SetRenderAdapter failed: \" << GetLastError() << std::endl;\n\t}\n\n\treturn success;\n}","mark":8.0}
{"file_name":"sudovda_function_6.cpp","line_count":19,"code":"bool GetProtocolVersion(HANDLE hDevice, VIRTUAL_DISPLAY_GET_PROTOCOL_VERSION_OUT& output) {\n\tDWORD bytesReturned;\n\tBOOL success = DeviceIoControl(\n\t\thDevice,\n\t\tIOCTL_GET_PROTOCOL_VERSION,\n\t\tnullptr,\n\t\t0,\n\t\t(LPVOID)&output,\n\t\tsizeof(output),\n\t\t&bytesReturned,\n\t\tnullptr\n\t);\n\n\tif (!success) {\n\t\tstd::cerr << \"[SUVDA] GetProtocolVersion failed: \" << GetLastError() << std::endl;\n\t}\n\n\treturn success;\n}","mark":8.0}
{"file_name":"system_tray_function_1.cpp","line_count":5,"code":"void\n  tray_open_ui_cb(struct tray_menu *item) {\n    BOOST_LOG(info) << \"Opening UI from system tray\"sv;\n    launch_ui();\n  }","mark":8.0}
{"file_name":"tests_log_checker_function_1.cpp","line_count":5,"code":"string\n  remove_timestamp_prefix(const std::string &line) {\n    static const std::regex timestamp_regex(R\"(\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\]: )\");\n    return std::regex_replace(line, timestamp_regex, \"\");\n  }","mark":8.0}
{"file_name":"test_mouse_function_1.cpp","line_count":37,"code":"edges\n\nTEST_P(MouseHIDTest, MoveInputTest) {\n  util::point_t mouse_delta = GetParam();\n\n  BOOST_LOG(tests) << \"MoveInputTest:: got param: \" << mouse_delta;\n  platf::input_t input = platf::input();\n  BOOST_LOG(tests) << \"MoveInputTest:: init input\";\n\n  BOOST_LOG(tests) << \"MoveInputTest:: get current mouse loc\";\n  auto old_loc = platf::get_mouse_loc(input);\n  BOOST_LOG(tests) << \"MoveInputTest:: got current mouse loc: \" << old_loc;\n\n  BOOST_LOG(tests) << \"MoveInputTest:: move: \" << mouse_delta;\n  platf::move_mouse(input, mouse_delta.x, mouse_delta.y);\n  std::this_thread::sleep_for(std::chrono::milliseconds(200));\n  BOOST_LOG(tests) << \"MoveInputTest:: moved: \" << mouse_delta;\n\n  BOOST_LOG(tests) << \"MoveInputTest:: get updated mouse loc\";\n  auto new_loc = platf::get_mouse_loc(input);\n  BOOST_LOG(tests) << \"MoveInputTest:: got updated mouse loc: \" << new_loc;\n\n  bool has_input_moved = old_loc.x != new_loc.x && old_loc.y != new_loc.y;\n\n  if (!has_input_moved) {\n    BOOST_LOG(tests) << \"MoveInputTest:: haven't moved\";\n  }\n  else {\n    BOOST_LOG(tests) << \"MoveInputTest:: moved\";\n  }\n\n  EXPECT_TRUE(has_input_moved);\n\n  \/\/ Verify we moved as much as we requested\n  EXPECT_EQ(new_loc.x - old_loc.x, mouse_delta.x);\n  EXPECT_EQ(new_loc.y - old_loc.y, mouse_delta.y);\n}","mark":8.0}
{"file_name":"thread_function_1.cpp","line_count":4,"code":"void join()\n  {\n    impl_.join();\n  }","mark":8.0}
{"file_name":"timer_queue_function_6.cpp","line_count":11,"code":"void up_heap(std::size_t index)\n  {\n    while (index > 0)\n    {\n      std::size_t parent = (index - 1) \/ 2;\n      if (!Time_Traits::less_than(heap_[index].time_, heap_[parent].time_))\n        break;\n      swap_heap(index, parent);\n      index = parent;\n    }\n  }","mark":8.0}
{"file_name":"time_traits_function_4.cpp","line_count":4,"code":"bool less_than(const time_type& t1, const time_type& t2)\n  {\n    return t1 < t2;\n  }","mark":8.0}
{"file_name":"tls_function_10.cpp","line_count":3,"code":"void set_handle(connection_hdl hdl) {\n        m_hdl = hdl;\n    }","mark":8.0}
{"file_name":"tls_function_12.cpp","line_count":5,"code":"error_code cancel_socket() {\n        lib::asio::error_code ec;\n        get_raw_socket().cancel(ec);\n        return ec;\n    }","mark":8.0}
{"file_name":"tls_function_13.cpp","line_count":7,"code":"void async_shutdown(socket::shutdown_handler callback) {\n        if (m_strand) {\n            m_socket->async_shutdown(m_strand->wrap(callback));\n        } else {\n            m_socket->async_shutdown(callback);\n        }\n    }","mark":8.0}
{"file_name":"tls_function_14.cpp","line_count":11,"code":"error_code translate_ec(ErrorCodeType ec) {\n        if (ec.category() == lib::asio::error::get_ssl_category()) {\n            \/\/ We know it is a TLS related error, but otherwise don't know more.\n            \/\/ Pass through as TLS generic.\n            return make_error_code(transport::error::tls_error);\n        } else {\n            \/\/ We don't know any more information about this error so pass\n            \/\/ through\n            return make_error_code(transport::error::pass_through);\n        }\n    }","mark":8.0}
{"file_name":"tls_function_16.cpp","line_count":7,"code":"handshake_type get_handshake_type() {\n        if (m_is_server) {\n            return lib::asio::ssl::stream_base::server;\n        } else {\n            return lib::asio::ssl::stream_base::client;\n        }\n    }","mark":8.0}
{"file_name":"tls_function_18.cpp","line_count":3,"code":"void set_socket_init_handler(socket_init_handler h) {\n        m_socket_init_handler = h;\n    }","mark":8.0}
{"file_name":"tls_function_19.cpp","line_count":3,"code":"void set_tls_init_handler(tls_init_handler h) {\n        m_tls_init_handler = h;\n    }","mark":8.0}
{"file_name":"tls_function_3.cpp","line_count":3,"code":"void set_socket_init_handler(socket_init_handler h) {\n        m_socket_init_handler = h;\n    }","mark":8.0}
{"file_name":"tls_function_4.cpp","line_count":3,"code":"void set_tls_init_handler(tls_init_handler h) {\n        m_tls_init_handler = h;\n    }","mark":8.0}
{"file_name":"tls_function_6.cpp","line_count":3,"code":"void set_uri(uri_ptr u) {\n        m_uri = u;\n    }","mark":8.0}
{"file_name":"unicode_iterator_function_10.cpp","line_count":9,"code":"void invalid_sequence()\n   {\n      std::out_of_range e(\"Invalid UTF-8 sequence encountered while trying to encode UTF-32 character\");\n#ifndef BOOST_REGEX_STANDALONE\n      boost::throw_exception(e);\n#else\n      throw e;\n#endif\n   }","mark":8.0}
{"file_name":"upnp_function_1.cpp","line_count":15,"code":"string_view\n  status_string(int status) {\n    switch (status) {\n      case 0:\n        return \"No IGD device found\"sv;\n      case 1:\n        return \"Valid IGD device found\"sv;\n      case 2:\n        return \"Valid IGD device found,  but it isn't connected\"sv;\n      case 3:\n        return \"A UPnP device has been found,  but it wasn't recognized as an IGD\"sv;\n    }\n\n    return \"Unknown status\"sv;\n  }","mark":8.0}
{"file_name":"use_future_function_4.cpp","line_count":4,"code":"future_type get_future()\n  {\n    return p_->get_future();\n  }","mark":8.0}
{"file_name":"utf8_validator_function_3.cpp","line_count":14,"code":"bool decode (iterator_type begin, iterator_type end) {\n        for (iterator_type it = begin; it != end; ++it) {\n            unsigned int result = utf8_validator::decode(\n                &m_state,\n                &m_codepoint,\n                static_cast<uint8_t>(*it)\n            );\n\n            if (result == utf8_reject) {\n                return false;\n            }\n        }\n        return true;\n    }","mark":8.0}
{"file_name":"utf8_validator_function_4.cpp","line_count":3,"code":"bool complete() {\n        return m_state == utf8_accept;\n    }","mark":8.0}
{"file_name":"utf8_validator_function_5.cpp","line_count":4,"code":"void reset() {\n        m_state = utf8_accept;\n        m_codepoint = 0;\n    }","mark":8.0}
{"file_name":"utf8_validator_function_6.cpp","line_count":7,"code":"bool validate(std::string const & s) {\n    validator v;\n    if (!v.decode(s.begin(),s.end())) {\n        return false;\n    }\n    return v.complete();\n}","mark":8.0}
{"file_name":"utilities_function_3.cpp","line_count":3,"code":"bool isPOT(size_t x) {\n    return !(x & (x - 1));\n}","mark":8.0}
{"file_name":"utilities_impl_function_1.cpp","line_count":5,"code":"string to_lower(std::string const & in) {\n    std::string out = in;\n    std::transform(out.begin(),out.end(),out.begin(),::tolower);\n    return out;\n}","mark":8.0}
{"file_name":"utils_function_1.cpp","line_count":13,"code":"wstring acpToUtf16(const std::string& origStr) {\n\tauto acp = GetACP();\n\n\tint utf16Len = MultiByteToWideChar(acp, 0, origStr.c_str(), origStr.size(), NULL, 0);\n\tif (utf16Len == 0) {\n\t\treturn L\"\";\n\t}\n\n\tstd::wstring utf16Str(utf16Len, L'\\0');\n\tMultiByteToWideChar(acp, 0, origStr.c_str(), origStr.size(), &utf16Str[0], utf16Len);\n\n\treturn utf16Str;\n}","mark":8.0}
{"file_name":"utils_function_2.cpp","line_count":13,"code":"string utf16ToAcp(const std::wstring& utf16Str) {\n\tauto acp = GetACP();\n\n\tint codepageLen = WideCharToMultiByte(acp, 0, utf16Str.c_str(), utf16Str.size(), NULL, 0, NULL, NULL);\n\tif (codepageLen == 0) {\n\t\treturn \"\";\n\t}\n\n\tstd::string codepageStr(codepageLen, '\\0');\n\tWideCharToMultiByte(acp, 0, utf16Str.c_str(), utf16Str.size(), &codepageStr[0], codepageLen, NULL, NULL);\n\n\treturn codepageStr;\n}","mark":8.0}
{"file_name":"verify_callback_function_1.cpp","line_count":4,"code":"bool call(bool preverified, verify_context& ctx)\n  {\n    return callback_(preverified, ctx);\n  }","mark":8.0}
{"file_name":"verify_context_function_1.cpp","line_count":4,"code":"native_handle_type native_handle()\n  {\n    return handle_;\n  }","mark":8.0}
{"file_name":"video_function_46.cpp","line_count":2,"code":"void\ndo_nothing(void *) {}","mark":8.0}
{"file_name":"virtual_display_function_1.cpp","line_count":4,"code":"LONG getDeviceSettings(const wchar_t* deviceName, DEVMODEW& devMode) {\n\tdevMode.dmSize = sizeof(DEVMODEW);\n\treturn EnumDisplaySettingsW(deviceName, ENUM_CURRENT_SETTINGS, &devMode);\n}","mark":8.0}
{"file_name":"virtual_display_function_10.cpp","line_count":9,"code":"void closeVDisplayDevice() {\n\tif (SUDOVDA_DRIVER_HANDLE == INVALID_HANDLE_VALUE) {\n\t\treturn;\n\t}\n\n\tCloseHandle(SUDOVDA_DRIVER_HANDLE);\n\n\tSUDOVDA_DRIVER_HANDLE = INVALID_HANDLE_VALUE;\n}","mark":8.0}
{"file_name":"virtual_display_function_3.cpp","line_count":17,"code":"wstring getPrimaryDisplay() {\n\tDISPLAY_DEVICEW displayDevice;\n\tdisplayDevice.cb = sizeof(DISPLAY_DEVICE);\n\n\tstd::wstring primaryDeviceName;\n\n\tint deviceIndex = 0;\n\twhile (EnumDisplayDevicesW(NULL, deviceIndex, &displayDevice, 0)) {\n\t\tif (displayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) {\n\t\t\tprimaryDeviceName = displayDevice.DeviceName;\n\t\t\tbreak;\n\t\t}\n\t\tdeviceIndex++;\n\t}\n\n\treturn primaryDeviceName;\n}","mark":8.0}
{"file_name":"virtual_display_function_6.cpp","line_count":13,"code":"bool getDisplayHDR(const LUID& adapterId, const uint32_t& targetId) {\n\tDISPLAYCONFIG_GET_ADVANCED_COLOR_INFO hdrInfo = {};\n\thdrInfo.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO;\n\thdrInfo.header.size = sizeof(hdrInfo);\n\thdrInfo.header.adapterId = adapterId;\n\thdrInfo.header.id = targetId;\n\n\tif (DisplayConfigGetDeviceInfo(&hdrInfo.header) != ERROR_SUCCESS) {\n\t\treturn false;\n\t}\n\n\treturn hdrInfo.advancedColorSupported && hdrInfo.advancedColorEnabled;\n}","mark":8.0}
{"file_name":"virtual_display_function_7.cpp","line_count":10,"code":"bool setDisplayHDR(const LUID& adapterId, const uint32_t& targetId, bool enableAdvancedColor) {\n\tDISPLAYCONFIG_SET_ADVANCED_COLOR_STATE setHdrInfo = {};\n\tsetHdrInfo.header.type = DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE;\n\tsetHdrInfo.header.size = sizeof(setHdrInfo);\n\tsetHdrInfo.header.adapterId = adapterId;\n\tsetHdrInfo.header.id = targetId;\n\tsetHdrInfo.enableAdvancedColor = enableAdvancedColor;\n\n\treturn DisplayConfigSetDeviceInfo(&setHdrInfo.header) == ERROR_SUCCESS;\n}","mark":8.0}
{"file_name":"virtual_display_function_8.cpp","line_count":10,"code":"bool getDisplayHDRByName(const wchar_t* displayName) {\n\tLUID adapterId;\n\tuint32_t targetId;\n\n\tif (!findDisplayIds(displayName, adapterId, targetId)) {\n\t\treturn false;\n\t}\n\n\treturn getDisplayHDR(adapterId, targetId);\n}","mark":8.0}
{"file_name":"virtual_display_function_9.cpp","line_count":10,"code":"bool setDisplayHDRByName(const wchar_t* displayName, bool enableAdvancedColor) {\n\tLUID adapterId;\n\tuint32_t targetId;\n\n\tif (!findDisplayIds(displayName, adapterId, targetId)) {\n\t\treturn false;\n\t}\n\n\treturn setDisplayHDR(adapterId, targetId, enableAdvancedColor);\n}","mark":8.0}
{"file_name":"winapp_thread_function_2.cpp","line_count":6,"code":"size_t hardware_concurrency()\n  {\n    SYSTEM_INFO system_info;\n    ::GetNativeSystemInfo(&system_info);\n    return system_info.dwNumberOfProcessors;\n  }","mark":8.0}
{"file_name":"wince_thread_function_2.cpp","line_count":6,"code":"size_t hardware_concurrency()\n  {\n    SYSTEM_INFO system_info;\n    ::GetSystemInfo(&system_info);\n    return system_info.dwNumberOfProcessors;\n  }","mark":8.0}
{"file_name":"winrt_ssocket_service_base_function_1.cpp","line_count":4,"code":"native_handle_type native_handle(base_implementation_type& impl)\n  {\n    return impl.socket_;\n  }","mark":8.0}
{"file_name":"winrt_ssocket_service_function_1.cpp","line_count":4,"code":"void shutdown()\n  {\n    this->base_shutdown();\n  }","mark":8.0}
{"file_name":"win_iocp_file_service_function_1.cpp","line_count":6,"code":"void construct(implementation_type& impl)\n  {\n    handle_service_.construct(impl);\n    impl.offset_ = 0;\n    impl.is_stream_ = false;\n  }","mark":8.0}
{"file_name":"win_iocp_file_service_function_4.cpp","line_count":4,"code":"void destroy(implementation_type& impl)\n  {\n    handle_service_.destroy(impl);\n  }","mark":8.0}
{"file_name":"win_iocp_file_service_function_5.cpp","line_count":4,"code":"void set_is_stream(implementation_type& impl, bool is_stream)\n  {\n    impl.is_stream_ = is_stream;\n  }","mark":8.0}
{"file_name":"win_iocp_io_context_function_3.cpp","line_count":4,"code":"void work_started()\n  {\n    ::InterlockedIncrement(&outstanding_work_);\n  }","mark":8.0}
{"file_name":"win_iocp_io_context_function_6.cpp","line_count":4,"code":"void post_private_immediate_completion(win_iocp_operation* op)\n  {\n    post_immediate_completion(op, false);\n  }","mark":8.0}
{"file_name":"win_iocp_serial_port_service_function_1.cpp","line_count":4,"code":"void construct(implementation_type& impl)\n  {\n    handle_service_.construct(impl);\n  }","mark":8.0}
{"file_name":"win_iocp_serial_port_service_function_4.cpp","line_count":4,"code":"void destroy(implementation_type& impl)\n  {\n    handle_service_.destroy(impl);\n  }","mark":8.0}
{"file_name":"win_iocp_serial_port_service_function_7.cpp","line_count":4,"code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    return handle_service_.native_handle(impl);\n  }","mark":8.0}
{"file_name":"win_iocp_socket_service_function_6.cpp","line_count":6,"code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    if (impl.have_remote_endpoint_)\n      return native_handle_type(impl.socket_, impl.remote_endpoint_);\n    return native_handle_type(impl.socket_);\n  }","mark":8.0}
{"file_name":"win_static_mutex_function_2.cpp","line_count":4,"code":"void unlock()\n  {\n    ::LeaveCriticalSection(&crit_section_);\n  }","mark":8.0}
{"file_name":"win_thread_function_2.cpp","line_count":4,"code":"void set_terminate_threads(bool b)\n  {\n    ::InterlockedExchange(&terminate_threads_, b ? 1 : 0);\n  }","mark":8.0}
{"file_name":"wrapped_swapchain_function_10.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetLastPresentCount(UINT* pLastPresentCount)\n    {\n        return m_pReal->GetLastPresentCount(pLastPresentCount);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_11.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetDesc1(DXGI_SWAP_CHAIN_DESC1* pDesc)\n    {\n        return m_pReal1->GetDesc1(pDesc);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_15.cpp","line_count":4,"code":"STDMETHODCALLTYPE IsTemporaryMonoSupported(void)\n    {\n        return m_pReal1->IsTemporaryMonoSupported();\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_16.cpp","line_count":4,"code":"STDMETHODCALLTYPE SetBackgroundColor(const DXGI_RGBA* pColor)\n    {\n        return m_pReal1->SetBackgroundColor(pColor);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_21.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetSourceSize(UINT* pWidth, UINT* pHeight)\n    {\n        return m_pReal2->GetSourceSize(pWidth, pHeight);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_23.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetMaximumFrameLatency(UINT* pMaxLatency)\n    {\n        return m_pReal2->GetMaximumFrameLatency(pMaxLatency);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_24.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetFrameLatencyWaitableObject(void)\n    {\n        return m_pReal2->GetFrameLatencyWaitableObject();\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_25.cpp","line_count":4,"code":"STDMETHODCALLTYPE SetMatrixTransform(const DXGI_MATRIX_3X2_F* pMatrix)\n    {\n        return m_pReal2->SetMatrixTransform(pMatrix);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_27.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetCurrentBackBufferIndex(void)\n    {\n        return m_pReal3->GetCurrentBackBufferIndex();\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_28.cpp","line_count":4,"code":"STDMETHODCALLTYPE CheckColorSpaceSupport(DXGI_COLOR_SPACE_TYPE ColorSpace, UINT* pColorSpaceSupport)\n    {\n        return m_pReal3->CheckColorSpaceSupport(ColorSpace, pColorSpaceSupport);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_29.cpp","line_count":4,"code":"STDMETHODCALLTYPE SetColorSpace1(DXGI_COLOR_SPACE_TYPE ColorSpace)\n    {\n        return m_pReal3->SetColorSpace1(ColorSpace);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_3.cpp","line_count":4,"code":"STDMETHODCALLTYPE SetPrivateData(REFGUID Name, UINT DataSize, const void* pData)\n    {\n        return m_pReal->SetPrivateData(Name, DataSize, pData);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_30.cpp","line_count":4,"code":"STDMETHODCALLTYPE SetHDRMetaData(DXGI_HDR_METADATA_TYPE Type, UINT Size, void* pMetaData)\n    {\n        return m_pReal4->SetHDRMetaData(Type, Size, pMetaData);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_4.cpp","line_count":4,"code":"STDMETHODCALLTYPE SetPrivateDataInterface(REFGUID Name, const IUnknown* pUnknown)\n    {\n        return m_pReal->SetPrivateDataInterface(Name, pUnknown);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_5.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetPrivateData(REFGUID Name, UINT* pDataSize, void* pData)\n    {\n        return m_pReal->GetPrivateData(Name, pDataSize, pData);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_6.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetParent(REFIID riid, void** ppParent)\n    {\n        return m_pReal->GetParent(riid, ppParent);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_7.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetDesc(DXGI_SWAP_CHAIN_DESC* pDesc)\n    {\n        return m_pReal->GetDesc(pDesc);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_8.cpp","line_count":4,"code":"STDMETHODCALLTYPE ResizeTarget(const DXGI_MODE_DESC* pNewTargetParameters)\n    {\n        return m_pReal->ResizeTarget(pNewTargetParameters);\n    }","mark":8.0}
{"file_name":"wrapped_swapchain_function_9.cpp","line_count":4,"code":"STDMETHODCALLTYPE GetFrameStatistics(DXGI_FRAME_STATISTICS* pStats)\n    {\n        return m_pReal->GetFrameStatistics(pStats);\n    }","mark":8.0}
