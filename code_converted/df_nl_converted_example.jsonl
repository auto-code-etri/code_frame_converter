
    {
        "file_name":"address_v4_function_1.cpp",
        "line_count":4,
        "code":"address_v4 make_address_v4(const address_v4::bytes_type& bytes)\n{\n  return address_v4(bytes);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an IPv4 address using the provided byte array.\n>>> address_v4 make_address_v4(const address_v4::bytes_type& bytes) *\/",
        "query_nlx":"\/* Create a function called make_address_v4 that takes a sequence of bytes as input and returns an IPv4 address object initialized with the provided bytes.\n>>> make_address_v4({192, 168, 1, 1}) returns an IPv4 address object with the bytes {192, 168, 1, 1} *\/ \naddress_v4 make_address_v4(const address_v4::bytes_type& bytes) { "
    }

    {
        "file_name":"address_v6_function_2.cpp",
        "line_count":9,
        "code":"void combine_4_bytes(std::size_t& seed, const unsigned char* bytes)\n  {\n    const std::size_t bytes_hash =\n      (static_cast<std::size_t>(bytes[0]) << 24) |\n      (static_cast<std::size_t>(bytes[1]) << 16) |\n      (static_cast<std::size_t>(bytes[2]) << 8) |\n      (static_cast<std::size_t>(bytes[3]));\n    seed ^= bytes_hash + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Combine 4 bytes into a seed value using a specific hashing algorithm.\n   >>> void combine_4_bytes(std::size_t& seed, const unsigned char* bytes) { *\/",
        "query_nlx":"\/* Function named combine_4_bytes takes a seed value and an array of 4 unsigned characters as input, combines the 4 bytes into a hash value, and updates the seed value using a specific formula.\n>>> combine_4_bytes(seed, bytes) *\/ \nvoid combine_4_bytes(std::size_t& seed, const unsigned char* bytes) { "
    }

    {
        "file_name":"AlgorithmFind_function_1.cpp",
        "line_count":12,
        "code":"ForwardIterator findIf(ForwardIterator first, ForwardIterator last, UnaryPredicate&& predicate)\n{\n    SC_ASSERT_DEBUG(first <= last);\n    for (auto it = first; it != last; ++it)\n    {\n        if (predicate(*it))\n        {\n            return it;\n        }\n    }\n    return last;\n}",
        "mark":8.0,
        "query_nsx":"\/* Find the first element in a sequence that satisfies a given condition.\n>>> ForwardIterator findIf(ForwardIterator first, ForwardIterator last, UnaryPredicate&& predicate) *\/",
        "query_nlx":"\/* Find the first element in a range defined by two iterators that satisfies a given condition provided by a unary predicate function.\n   >>> findIf(Iterator first, Iterator last, UnaryPredicate predicate) Iterator *\/\n*\/"
    }

    {
        "file_name":"Allocator_function_3.cpp",
        "line_count":3,
        "code":"void deallocate(TYPE* p, std::size_t n) {\n        mArena.free(p, n * sizeof(TYPE));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Deallocate memory for an array of elements of a specific type.\n   >>> void deallocate(TYPE* p, std::size_t n) { *\/",
        "query_nlx":"\/* Function named deallocate deallocates a block of memory pointed to by a given pointer and size. \n>>> deallocate(pointer, size) *\/ \nvoid deallocate(TYPE* p, std::size_t n) { "
    }

    {
        "file_name":"AnyMapHolder_function_1.cpp",
        "line_count":3,
        "code":"AnyValue create_AnyValue() {\n  return AnyValue{std::monostate{}};\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a new AnyValue object with a default state.\n   >>> create_AnyValue() AnyValue *\/",
        "query_nlx":"\/* Create a function that returns a value of a generic type that can hold any value, initialized with an empty state.\n>>> create_AnyValue() returns an AnyValue object with an empty state *\/ \nAnyValue create_AnyValue() {"
    }

    {
        "file_name":"AnyMapHolder_function_10.cpp",
        "line_count":3,
        "code":"bool is_AnyValue_number(const AnyValue& value) {\n  return std::holds_alternative<double>(value);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the provided value is a number of any kind.\n   >>> bool is_AnyValue_number(const AnyValue& value) { *\/",
        "query_nlx":"\/* Function named is_AnyValue_number determines if a given value is of type double.\n>>> is_AnyValue_number(value: AnyValue) -> bool *\/"
    }

    {
        "file_name":"AnyMapHolder_function_12.cpp",
        "line_count":3,
        "code":"bool is_AnyValue_string(const AnyValue& value) {\n  return std::holds_alternative<std::string>(value);\n}",
        "mark":9.0,
        "query_nsx":"\/* Check if the given value is of type string.\n>>> bool is_AnyValue_string(const AnyValue& value); *\/",
        "query_nlx":"\/* Function named is_AnyValue_string determines if a given value is of type string or not.\n>>> is_AnyValue_string(AnyValue value) *\/\nbool is_AnyValue_string(const AnyValue& value) {"
    }

    {
        "file_name":"AnyMapHolder_function_13.cpp",
        "line_count":3,
        "code":"bool is_AnyValue_AnyArray(const AnyValue& value) {\n  return std::holds_alternative<AnyArray>(value);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given value is of type AnyArray.\n>>> bool is_AnyValue_AnyArray(const AnyValue& value) { *\/",
        "query_nlx":"\/* Function named is_AnyValue_AnyArray checks if a given value is of type AnyArray. \n>>> is_AnyValue_AnyArray(AnyValue(value)) true \n>>> is_AnyValue_AnyArray(AnyValue(value)) false *\/ \nbool is_AnyValue_AnyArray(const AnyValue& value) { "
    }

    {
        "file_name":"AnyMapHolder_function_14.cpp",
        "line_count":3,
        "code":"bool is_AnyValue_AnyObject(const AnyValue& value) {\n  return std::holds_alternative<AnyObject>(value);\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the provided value is of type AnyObject.\n>>> bool is_AnyValue_AnyObject(const AnyValue& value) { *\/",
        "query_nlx":"\/* Function determines if the provided value is of type AnyObject.\n   >>> is_AnyValue_AnyObject(value: AnyValue) \n   - Returns true if the value is of type AnyObject, false otherwise. *\/ \nbool is_AnyValue_AnyObject(const AnyValue& value) {"
    }

    {
        "file_name":"AnyMapHolder_function_16.cpp",
        "line_count":3,
        "code":"bool get_AnyValue_bool(const AnyValue& value) {\n  return std::get<bool>(value);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the provided value contains a boolean value.\n>>> bool get_AnyValue_bool(const AnyValue& value) { *\/",
        "query_nlx":"\/* Function named get_AnyValue_bool retrieves a boolean value from a given AnyValue object.\n>>> get_AnyValue_bool(AnyValue) bool *\/"
    }

    {
        "file_name":"AnyMapHolder_function_17.cpp",
        "line_count":3,
        "code":"double get_AnyValue_number(const AnyValue& value) {\n  return std::get<double>(value);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a double value from a given AnyValue object.\n>>> double get_AnyValue_number(const AnyValue& value) { *\/",
        "query_nlx":"\/* Function named get_AnyValue_number retrieves a double value from a given AnyValue object.\n>>> get_AnyValue_number(AnyValue value) double { *\/"
    }

    {
        "file_name":"AnyMapHolder_function_18.cpp",
        "line_count":3,
        "code":"int64_t get_AnyValue_bigint(const AnyValue& value) {\n  return std::get<int64_t>(value);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a large integer value from a generic data container.\n   >>> get_AnyValue_bigint(AnyValue value) int64_t { *\/",
        "query_nlx":"\/* Function named get_AnyValue_bigint extracts a 64-bit integer value from a given AnyValue object.\n>>> get_AnyValue_bigint(AnyValue) int64_t *\/"
    }

    {
        "file_name":"AnyMapHolder_function_2.cpp",
        "line_count":3,
        "code":"AnyValue create_AnyValue(bool boolValue) {\n  return AnyValue{boolValue};\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an AnyValue object with a boolean value.\n>>> AnyValue create_AnyValue(bool boolValue) { *\/",
        "query_nlx":"\/* Create a function that generates an AnyValue object with a boolean value.\n   >>> create_AnyValue(true) returns AnyValue object with true boolean value\n   >>> create_AnyValue(false) returns AnyValue object with false boolean value *\/ \nAnyValue create_AnyValue(bool boolValue) {"
    }

    {
        "file_name":"AnyMapHolder_function_22.cpp",
        "line_count":7,
        "code":"AnyValue getAnyObjectValue(const AnyObject& object, const std::string& key) {\n  auto item = object.find(key);\n  if (item == object.end()) {\n    throw std::runtime_error(\"Couldn't find \" + key + \" in AnyObject!\");\n  }\n  return item->second;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the value associated with a specific key from a given object.\n>>> AnyValue getAnyObjectValue(const AnyObject& object, const std::string& key) { *\/",
        "query_nlx":"\/* Function named getAnyObjectValue retrieves the value associated with a given key from a provided object. If the key is not found in the object, a runtime error is thrown.\n>>> getAnyObjectValue({object}, \"key\") { *\/ \n#include <stdexcept>\n#include <string>\n#include <unordered_map>\nusing namespace std;\nAnyValue getAnyObjectValue(const AnyObject& object, const std::string& key) {"
    }

    {
        "file_name":"AnyMapHolder_function_4.cpp",
        "line_count":3,
        "code":"AnyValue create_AnyValue(int64_t bigintValue) {\n  return AnyValue{bigintValue};\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an AnyValue object with a large integer value.\n   >>> create_AnyValue(1000000) \n*\/ \nAnyValue create_AnyValue(int64_t bigintValue) {",
        "query_nlx":"\/* Create a function that takes a big integer value as input and returns an AnyValue containing that value. \n>>> create_AnyValue(1000000) returns AnyValue{1000000} \n>>> create_AnyValue(-500) returns AnyValue{-500} *\/ \nAnyValue create_AnyValue(int64_t bigintValue) {"
    }

    {
        "file_name":"AnyMapHolder_function_5.cpp",
        "line_count":3,
        "code":"AnyValue create_AnyValue(const std::string& stringValue) {\n  return AnyValue{stringValue};\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an AnyValue object with the given string value.\n   >>> create_AnyValue(\"example\") \n*\/ \nAnyValue create_AnyValue(const std::string& stringValue) {",
        "query_nlx":"\/* Create a function that takes a string as input and returns an AnyValue object containing that string.\n   >>> create_AnyValue(\"example\") returns an AnyValue object containing the string \"example\" *\/ \nAnyValue create_AnyValue(const std::string& stringValue) {"
    }

    {
        "file_name":"AnyMapHolder_function_6.cpp",
        "line_count":3,
        "code":"AnyValue create_AnyValue(const AnyArray& arrayValue) {\n  return AnyValue{arrayValue};\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an AnyValue object using the provided AnyArray parameter.\n   >>> create_AnyValue({1, 2, 3}) {1, 2, 3}\n   >>> create_AnyValue({\"hello\", \"world\"}) {\"hello\", \"world\"} *\/ \nAnyValue create_AnyValue(const AnyArray& arrayValue) {",
        "query_nlx":"\/* Create a function named create_AnyValue that takes an array of values and returns an AnyValue object containing the array.\n   >>> create_AnyValue({1, 2, 3, 4}) returns AnyValue object containing {1, 2, 3, 4}\n   >>> create_AnyValue({\"hello\", \"world\"}) returns AnyValue object containing {\"hello\", \"world\"} *\/ \nAnyValue create_AnyValue(const AnyArray& arrayValue) {"
    }

    {
        "file_name":"AnyMapHolder_function_7.cpp",
        "line_count":3,
        "code":"AnyValue create_AnyValue(const AnyObject& objectValue) {\n  return AnyValue{objectValue};\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an AnyValue object using the provided AnyObject object value.\n>>> AnyValue create_AnyValue(const AnyObject& objectValue) { *\/",
        "query_nlx":"\/* Create a function named create_AnyValue that takes an objectValue of any type and returns an AnyValue object containing the value of the input object.\n>>> create_AnyValue(5) returns AnyValue{5}\n>>> create_AnyValue(\"hello\") returns AnyValue{\"hello\"} *\/ \nAnyValue create_AnyValue(const AnyObject& objectValue) {"
    }

    {
        "file_name":"AnyMapHolder_function_8.cpp",
        "line_count":3,
        "code":"bool is_AnyValue_null(const AnyValue& value) {\n  return std::holds_alternative<std::monostate>(value);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the provided value is null or empty.\n>>> bool is_AnyValue_null(const AnyValue& value) { *\/",
        "query_nlx":"\/* Function named is_AnyValue_null determines if the given value is of null type.\n>>> is_AnyValue_null(AnyValue) returns true if the value is of null type, otherwise false. *\/ \nbool is_AnyValue_null(const AnyValue& value) {"
    }

    {
        "file_name":"AnyMapHolder_function_9.cpp",
        "line_count":3,
        "code":"bool is_AnyValue_bool(const AnyValue& value) {\n  return std::holds_alternative<bool>(value);\n}",
        "mark":9.0,
        "query_nsx":"\/* Check if the given value is of type bool.\n>>> bool is_AnyValue_bool(const AnyValue& value); *\/",
        "query_nlx":"\/* Function named is_AnyValue_bool checks if a given value is of type bool.\n>>> is_AnyValue_bool(value) returns true if the value is of type bool, otherwise false. *\/\nbool is_AnyValue_bool(const AnyValue& value) {"
    }

    {
        "file_name":"Array_function_3.cpp",
        "line_count":1,
        "code":"bool reserve(size_t newCapacity) { return newCapacity <= capacity(); }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the requested capacity is less than or equal to the current capacity of the system.\n>>> reserve(size_t newCapacity) *\/",
        "query_nlx":"\/* Function named reserve determines if the given new capacity is less than or equal to the current capacity of the data structure.\n>>> reserve(10) true\n>>> reserve(5) false *\/ \nbool reserve(size_t newCapacity) { "
    }

    {
        "file_name":"Array_function_6.cpp",
        "line_count":1,
        "code":"bool shrink_to_fit() { return true; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the container can be reduced in size to fit its contents more efficiently. \n>>> shrink_to_fit() true *\/",
        "query_nlx":"\/* Function named shrink_to_fit checks if a container can be reduced in size to fit its current elements without affecting its functionality. \n>>> shrink_to_fit() true *\/ \nbool shrink_to_fit() {"
    }

    {
        "file_name":"asio_function_1.cpp",
        "line_count":3,
        "code":"bool is_neg(T duration) {\n            return duration.count() < 0;\n        }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given duration is negative or not.\n   >>> bool is_neg(T duration); *\/",
        "query_nlx":"\/* Function named is_neg determines if the given duration is negative based on its count value. \n>>> is_neg(5) false \n>>> is_neg(-10) true *\/ \nbool is_neg(T duration) {"
    }

    {
        "file_name":"asio_function_3.cpp",
        "line_count":3,
        "code":"bool is_neg(T duration) {\n                return duration.count() < 0;\n            }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given duration is negative or not.\n   >>> bool is_neg(T duration); *\/",
        "query_nlx":"\/* Function named is_neg determines if the given duration is negative based on its count value.\n>>> is_neg(5) false\n>>> is_neg(-3) true *\/ \nbool is_neg(T duration) {"
    }

    {
        "file_name":"asio_function_6.cpp",
        "line_count":3,
        "code":"bool is_neg(T duration) {\n                return duration.is_negative();\n            }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given duration is negative or not.\n>>> bool is_neg(T duration) { *\/",
        "query_nlx":"\/* Function named is_neg determines if a given duration is negative or not.\n>>> is_neg(-5) true\n>>> is_neg(10) false *\/ \nbool is_neg(T duration) {"
    }

    {
        "file_name":"AsyncLinuxAPI_function_15.cpp",
        "line_count":5,
        "code":"void io_uring_prep_send(struct io_uring_sqe* sqe, int sockfd, const void* buf, size_t len, int flags)\n    {\n        io_uring_prep_rw(IORING_OP_SEND, sqe, sockfd, buf, (__u32)len, 0);\n        sqe->msg_flags = (__u32)flags;\n    }",
        "mark":8.0,
        "query_nsx":"            \/* Prepare for sending data over a network socket with specified flags.\n            >>> io_uring_prep_send(struct io_uring_sqe* sqe, int sockfd, const void* buf, size_t len, int flags) *\/",
        "query_nlx":"        \/* Function named io_uring_prep_send prepares a send operation for an I\/O ring submission queue entry with the given socket file descriptor, buffer, length, and flags.\n        >>> io_uring_prep_send(sqe, sockfd, buf, len, flags) *\/ \n        void io_uring_prep_send(struct io_uring_sqe* sqe, int sockfd, const void* buf, size_t len, int flags) {"
    }

    {
        "file_name":"AsyncLinuxAPI_function_16.cpp",
        "line_count":5,
        "code":"void io_uring_prep_recv(struct io_uring_sqe* sqe, int sockfd, void* buf, size_t len, int flags)\n    {\n        io_uring_prep_rw(IORING_OP_RECV, sqe, sockfd, buf, (__u32)len, 0);\n        sqe->msg_flags = (__u32)flags;\n    }",
        "mark":8.0,
        "query_nsx":"            \/* Prepare for receiving data from a socket using I\/O operations.\n            >>> io_uring_prep_recv(struct io_uring_sqe* sqe, int sockfd, void* buf, size_t len, int flags) { *\/",
        "query_nlx":"        \/* Function named io_uring_prep_recv prepares a receive operation for input\/output operations on a socket using the io_uring library.\n        >>> io_uring_prep_recv(sqe, sockfd, buf, len, flags) *\/ \n        void io_uring_prep_recv(struct io_uring_sqe* sqe, int sockfd, void* buf, size_t len, int flags) {"
    }

    {
        "file_name":"AsyncLinuxAPI_function_17.cpp",
        "line_count":4,
        "code":"void io_uring_prep_close(struct io_uring_sqe* sqe, int fd)\n    {\n        io_uring_prep_rw(IORING_OP_CLOSE, sqe, fd, NULL, 0, 0);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Prepare an input\/output operation to close a file descriptor.\n        >>> void io_uring_prep_close(struct io_uring_sqe* sqe, int fd) { *\/",
        "query_nlx":"\/* Prepare an input\/output operation for closing a file descriptor using the io_uring interface.\n   >>> io_uring_prep_close(sqe, fd) *\/\nvoid io_uring_prep_close(struct io_uring_sqe* sqe, int fd) { "
    }

    {
        "file_name":"AsyncLinuxAPI_function_18.cpp",
        "line_count":4,
        "code":"void io_uring_prep_read(struct io_uring_sqe* sqe, int fd, void* buf, unsigned nbytes, __u64 offset)\n    {\n        io_uring_prep_rw(IORING_OP_READ, sqe, fd, buf, nbytes, offset);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Prepare an input\/output operation request to read data from a file descriptor into a buffer with a specified size and offset.\n        >>> void io_uring_prep_read(struct io_uring_sqe* sqe, int fd, void* buf, unsigned nbytes, __u64 offset) { *\/",
        "query_nlx":"\/* Function io_uring_prep_read prepares a read operation for input\/output operations by setting up the necessary parameters such as file descriptor, buffer, number of bytes to read, and offset.\n>>> io_uring_prep_read(sqe, fd, buf, nbytes, offset) void *\/"
    }

    {
        "file_name":"AsyncRequestStreams_function_1.cpp",
        "line_count":1,
        "code":"bool isEnded(AsyncFileRead::Result& result) { return result.completionData.endOfFile; }",
        "mark":8.0,
        "query_nsx":"\/* Check if the asynchronous file read operation has reached the end of the file.\n>>> bool isEnded(AsyncFileRead::Result& result) { *\/",
        "query_nlx":"\/* Function named isEnded checks if the given AsyncFileRead result indicates that the end of the file has been reached.\n>>> isEnded(result) true\n>>> isEnded(result) false *\/ \nbool isEnded(AsyncFileRead::Result& result) { "
    }

    {
        "file_name":"AsyncRequestStreams_function_2.cpp",
        "line_count":1,
        "code":"bool isEnded(AsyncSocketReceive::Result& result) { return result.completionData.disconnected; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the asynchronous socket receive operation has ended based on the provided result.\n>>> bool isEnded(AsyncSocketReceive::Result& result) { *\/",
        "query_nlx":"\/* Function named isEnded checks if the completion data of an asynchronous socket receive operation indicates that the connection has been disconnected.\n>>> isEnded(AsyncSocketReceive::Result& result) { return result.completionData.disconnected; } *\/"
    }

    {
        "file_name":"AsyncTest_function_9.cpp",
        "line_count":35,
        "code":"Result snippetForSocketAccept(AsyncEventLoop& eventLoop, Console& console)\n{\n\/\/! [AsyncSocketAcceptSnippet]\n\/\/ Assuming an already created (and running) AsyncEventLoop named eventLoop\n\/\/ ...\n\/\/ Create a listening socket\nconstexpr uint32_t numWaitingConnections = 2;\nSocketDescriptor   serverSocket;\nuint16_t           tcpPort = 5050;\nSocketIPAddress    nativeAddress;\nSC_TRY(nativeAddress.fromAddressPort(\"127.0.0.1\", tcpPort));\nSC_TRY(eventLoop.createAsyncTCPSocket(nativeAddress.getAddressFamily(), serverSocket));\nSocketServer server(serverSocket);\nSC_TRY(server.bind(nativeAddress));\nSC_TRY(server.listen(numWaitingConnections));\n\/\/ Accept connect for new clients\nAsyncSocketAccept accept;\naccept.callback = [&](AsyncSocketAccept::Result& res)\n{\n    SocketDescriptor client;\n    if(res.moveTo(client))\n    {\n        \/\/ ...do something with new client\n        console.printLine(\"New client connected!\");\n        res.reactivateRequest(true); \/\/ We want to receive more clients\n    }\n};\nSC_TRY(accept.start(eventLoop, serverSocket));\n\/\/ ... at some later point\n\/\/ Stop accepting new clients\nSC_TRY(accept.stop());\n\/\/! [AsyncSocketAcceptSnippet]\nSC_TRY(eventLoop.run());\nreturn Result(true);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a function that sets up a server to accept new client connections asynchronously.\n>>> Result snippetForSocketAccept(AsyncEventLoop& eventLoop, Console& console) *\/",
        "query_nlx":"\/* Create a listening socket, accept connections from new clients, and stop accepting new clients when needed.\n>>> Result snippetForSocketAccept(AsyncEventLoop& eventLoop, Console& console) *\/"
    }

    {
        "file_name":"Async_function_1.cpp",
        "line_count":1,
        "code":"void cacheInternalEventLoop(AsyncEventLoop& loop) { eventLoop = &loop; }",
        "mark":8.0,
        "query_nsx":"\/* Cache the internal event loop for future reference.\n   >>> cacheInternalEventLoop(AsyncEventLoop& loop) *\/ \nvoid cacheInternalEventLoop(AsyncEventLoop& loop) { ",
        "query_nlx":"\/* Define a function that caches an internal event loop by taking a reference to an asynchronous event loop as input.\n   >>> cacheInternalEventLoop(AsyncEventLoop& loop) *\/ \nvoid cacheInternalEventLoop(AsyncEventLoop& loop) { "
    }

    {
        "file_name":"Async_function_10.cpp",
        "line_count":5,
        "code":"void setOffset(uint64_t fileOffset)\n    {\n        useOffset = true;\n        offset    = fileOffset;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the offset value to be used in file operations.\n   >>> void setOffset(uint64_t fileOffset); *\/",
        "query_nlx":"\/* Define a function that sets a file offset value to be used, given a 64-bit unsigned integer file offset input.\n   >>> setOffset(uint64_t fileOffset) *\/"
    }

    {
        "file_name":"Async_function_2.cpp",
        "line_count":1,
        "code":"void reactivateRequest(bool value) { shouldBeReactivated = value; }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to indicate whether a request should be reactivated or not.\n   >>> reactivateRequest(true) *\/ \nvoid reactivateRequest(bool value) { ",
        "query_nlx":"\/* Define a function called reactivateRequest that takes a boolean value as input and sets the internal variable shouldBeReactivated to that value. \n   >>> reactivateRequest(true) \n   >>> reactivateRequest(false) *\/ \nvoid reactivateRequest(bool value) {"
    }

    {
        "file_name":"Async_function_8.cpp",
        "line_count":5,
        "code":"void setOffset(uint64_t fileOffset)\n    {\n        useOffset = true;\n        offset    = fileOffset;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the offset value to be used in the file operations.\n   >>> void setOffset(uint64_t fileOffset); *\/",
        "query_nlx":"\/* Function named setOffset sets a file offset value to be used for future operations.\n   >>> setOffset(100) \n   This function sets the file offset to 100. *\/ \nvoid setOffset(uint64_t fileOffset) { "
    }

    {
        "file_name":"atomic_count_function_11.cpp",
        "line_count":1,
        "code":"void ref_count_up(atomic_count& a) { ++a; }",
        "mark":8.0,
        "query_nsx":"\/* Increment the reference count of an atomic variable. \n>>> void ref_count_up(atomic_count& a) { *\/",
        "query_nlx":"\/* Define a function that increments the reference count of an atomic counter by one.\n   >>> ref_count_up(atomic_count&) *\/ \nvoid ref_count_up(atomic_count& a) { "
    }

    {
        "file_name":"atomic_count_function_3.cpp",
        "line_count":1,
        "code":"void ref_count_up(atomic_count& a) { ++a; }",
        "mark":8.0,
        "query_nsx":"\/* Increment the reference count of an atomic variable.\n>>> void ref_count_up(atomic_count& a); *\/",
        "query_nlx":"\/* Define a function that increments the reference count of an atomic counter by one.\n   >>> ref_count_up(atomic_count&) *\/\nvoid ref_count_up(atomic_count& a) { \/* Function body omitted *\/ }"
    }

    {
        "file_name":"atomic_count_function_7.cpp",
        "line_count":4,
        "code":"void ref_count_up(atomic_count& a)\n{\n  a.fetch_add(1, std::memory_order_relaxed);\n}",
        "mark":8.0,
        "query_nsx":"\/* Increment the reference count atomically by one.\n>>> void ref_count_up(atomic_count& a) *\/",
        "query_nlx":"\/* Define a function that increments the value of an atomic counter by 1 using a relaxed memory order.\n>>> ref_count_up(atomic_count&) *\/ \nvoid ref_count_up(atomic_count& a) { "
    }

    {
        "file_name":"atomic_count_function_8.cpp",
        "line_count":9,
        "code":"bool ref_count_down(atomic_count& a)\n{\n  if (a.fetch_sub(1, std::memory_order_release) == 1)\n  {\n    std::atomic_thread_fence(std::memory_order_acquire);\n    return true;\n  }\n  return false;\n}",
        "mark":8.0,
        "query_nsx":"\/* Decrement an atomic count and return true if the count reaches 0, otherwise return false.\n>>> bool ref_count_down(atomic_count& a) *\/",
        "query_nlx":"\/* Function named ref_count_down updates the atomic count by subtracting 1 and returns true if the updated count is 1, otherwise false.\n>>> ref_count_down(atomic_count) bool *\/"
    }

    {
        "file_name":"AutomationEngine_function_1.cpp",
        "line_count":1,
        "code":"void signalBatchMode() { mBatchModeAllowed = true; }",
        "mark":8.0,
        "query_nsx":"\/* Set the system to allow batch processing mode.\n   >>> void signalBatchMode() { *\/",
        "query_nlx":"\/* Define a function that sets a flag to allow batch mode processing.\n   >>> signalBatchMode() *\/ \nvoid signalBatchMode() { "
    }

    {
        "file_name":"AutomationEngine_function_2.cpp",
        "line_count":1,
        "code":"void stopRunning() { mIsRunning = false; }",
        "mark":8.0,
        "query_nsx":"\/* Stop the running process. \n>>> void stopRunning() { *\/",
        "query_nlx":"\/* Define a function that stops the current running process by setting a boolean variable to false.\n>>> stopRunning() *\/ \nvoid stopRunning() { "
    }

    {
        "file_name":"AutomationEngine_function_3.cpp",
        "line_count":1,
        "code":"void setOptions(Options options) { mOptions = options; }",
        "mark":8.0,
        "query_nsx":"\/* Set the options for a specific functionality.\n   >>> setOptions(Options options) *\/",
        "query_nlx":"\/* Function named setOptions assigns the provided options to the internal options variable of the object.\n>>> setOptions(options) void { *\/"
    }

    {
        "file_name":"AutomationEngine_function_4.cpp",
        "line_count":1,
        "code":"void requestClose() { mShouldClose = true; }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to indicate that a request for closure has been made.\n   >>> requestClose() *\/ \nvoid requestClose() { ",
        "query_nlx":"\/* Define a function called requestClose that sets a boolean variable mShouldClose to true. *\/\nvoid requestClose() { "
    }

    {
        "file_name":"AvatarCache_function_1.cpp",
        "line_count":1,
        "code":"void SetSizeOverride(int so) { sizeOverride = so; }",
        "mark":8.0,
        "query_nsx":"\/* Set a custom size override value for the object. \n>>> SetSizeOverride(int so) *\/",
        "query_nlx":"\/* Define a function named SetSizeOverride that takes an integer parameter and assigns it to a variable named sizeOverride. \n   >>> SetSizeOverride(10) *\/ \nvoid SetSizeOverride(int so) { "
    }

    {
        "file_name":"awaitable_function_12.cpp",
        "line_count":4,
        "code":"void destroy()\n  {\n    coro_.destroy();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Destroy the coroutine associated with this function.\n   >>> destroy() *\/ \nvoid destroy() { \n    \/\/ function body omitted\n}",
        "query_nlx":"\/* Function named destroy calls the destroy method on an object named coro_ to perform cleanup operations.\n>>> destroy() *\/ \nvoid destroy() { \/\/ Function declaration."
    }

    {
        "file_name":"awaitable_function_3.cpp",
        "line_count":4,
        "code":"void set_error(const asio::error_code& ec)\n  {\n    this->set_except(std::make_exception_ptr(asio::system_error(ec)));\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set an error using the provided error code.\n   >>> void set_error(const error_code& ec) *\/",
        "query_nlx":"\/* Define a function that sets an error by creating an exception pointer from a system error code.\n   >>> set_error(ec) void set_error(const asio::error_code& ec) { *\/"
    }

    {
        "file_name":"awaitable_function_5.cpp",
        "line_count":8,
        "code":"void rethrow_exception()\n  {\n    if (pending_exception_)\n    {\n      std::exception_ptr ex = std::exchange(pending_exception_, nullptr);\n      std::rethrow_exception(ex);\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Rethrow any pending exception that was caught previously.\n   >>> void rethrow_exception() { *\/",
        "query_nlx":"\/* Function named rethrow_exception checks if there is a pending exception, and if so, rethrows it.\n   >>> rethrow_exception() void *\/"
    }

    {
        "file_name":"base_from_cancellation_state_function_1.cpp",
        "line_count":5,
        "code":"void reset_cancellation_state(const Handler& handler)\n  {\n    cancellation_state_ = cancellation_state(\n        asio::get_associated_cancellation_slot(handler));\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the cancellation state based on the associated cancellation slot from the provided handler.\n   >>> reset_cancellation_state(const Handler& handler) *\/",
        "query_nlx":"\/* Reset the cancellation state based on the associated cancellation slot of a given handler.\n   >>> reset_cancellation_state(const Handler& handler) *\/"
    }

    {
        "file_name":"base_function_1.cpp",
        "line_count":3,
        "code":"error_code make_error_code(error::value e) {\n    return lib::error_code(static_cast<int>(e), get_category());\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an error code based on the provided error value. \n>>> error_code make_error_code(error::value e) { *\/",
        "query_nlx":"\/* Create an error code based on a given error value by converting it to an integer and associating it with a specific error category. \n>>> make_error_code(error::value e) error_code *\/"
    }

    {
        "file_name":"base_function_3.cpp",
        "line_count":3,
        "code":"error_code make_error_code(error::value e) {\n    return lib::error_code(static_cast<int>(e), get_category());\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an error code based on the provided error value. \n>>> error_code make_error_code(error::value e) { *\/",
        "query_nlx":"\/* Create an error code based on a given error value by converting it to an integer and associating it with a specific error category. \n>>> make_error_code(error::value e) error_code *\/"
    }

    {
        "file_name":"basic_channel_function_1.cpp",
        "line_count":4,
        "code":"void reset()\n  {\n    service_->reset(impl_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the service by calling the reset function with the implementation parameter. \n   >>> reset() *\/ \nvoid reset();",
        "query_nlx":"\/* Reset function calls the reset method of a service using the provided implementation object.\n   >>> reset() *\/ \nvoid reset() { \n    service_->reset(impl_); \n}"
    }

    {
        "file_name":"basic_channel_function_2.cpp",
        "line_count":4,
        "code":"void close()\n  {\n    service_->close(impl_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the service connection.\n   >>> void close() *\/",
        "query_nlx":"\/* Function named close closes a service using the provided implementation.\n   >>> close()\n*\/ \nvoid close() {"
    }

    {
        "file_name":"basic_channel_function_3.cpp",
        "line_count":4,
        "code":"void cancel()\n  {\n    service_->cancel(impl_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel the current operation or task.\n   >>> cancel() *\/",
        "query_nlx":"        \/* Function named cancel calls the cancel function of a service using the provided implementation object.\n        >>> cancel() *\/ \n        void cancel() { \n            service_->cancel(impl_); \n        }"
    }

    {
        "file_name":"basic_concurrent_channel_function_1.cpp",
        "line_count":4,
        "code":"void reset()\n  {\n    service_->reset(impl_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the service by calling the reset function with the implementation parameter. \n>>> reset() *\/",
        "query_nlx":"\/* Function named reset calls a service function to reset the implementation. \n>>> reset() *\/ \nvoid reset() { \n    service_->reset(impl_); \n}"
    }

    {
        "file_name":"basic_concurrent_channel_function_2.cpp",
        "line_count":4,
        "code":"void close()\n  {\n    service_->close(impl_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the service connection.\n   >>> void close() *\/",
        "query_nlx":"\/* Function named close closes the current service using the provided implementation.\n   >>> close() *\/ \nvoid close() { \n    service_->close(impl_); \n}"
    }

    {
        "file_name":"basic_concurrent_channel_function_3.cpp",
        "line_count":4,
        "code":"void cancel()\n  {\n    service_->cancel(impl_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel the current operation or task.\n   >>> cancel() *\/",
        "query_nlx":"\/* Function named cancel calls the cancel function of a service using the provided implementation. \n>>> cancel() *\/ \nvoid cancel() { \n    service_->cancel(impl_); \n}"
    }

    {
        "file_name":"basic_datagram_socket_function_1.cpp",
        "line_count":8,
        "code":"size_t send(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().send(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"send\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Send a sequence of constant buffers and return the size of the sent data.\n   >>> size_t send(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function named send that takes a constant buffer sequence as input and returns a size_t value.\n   >>> send(const ConstBufferSequence& buffers) *\/"
    }

    {
        "file_name":"basic_datagram_socket_function_7.cpp",
        "line_count":8,
        "code":"size_t receive(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().receive(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"receive\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve data from a buffer and return the size of the received data.\n   >>> size_t receive(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function named receive that takes a sequence of mutable buffers as input and returns the size of data received after performing a receive operation. \n   >>> receive(buffers) returns the size of data received from the service implementation after calling the receive function with the provided buffers. *\/ \nsize_t receive(const MutableBufferSequence& buffers) { "
    }

    {
        "file_name":"basic_deadline_timer_function_1.cpp",
        "line_count":7,
        "code":"size_t cancel()\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the size of the cancelled operation after attempting to cancel it.\n   >>> size_t cancel() *\/",
        "query_nlx":"\/* Define a function that cancels an operation and returns the size of the operation that was canceled.\n   >>> cancel() size_t *\/"
    }

    {
        "file_name":"basic_deadline_timer_function_10.cpp",
        "line_count":4,
        "code":"void wait(asio::error_code& ec)\n  {\n    impl_.get_service().wait(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that waits for an event to occur and handles any errors that may arise during the process.\n   >>> void wait(asio::error_code& ec) *\/",
        "query_nlx":"\/* Define a function called wait that takes an error code as a parameter and calls a service function to wait for an implementation to complete, storing any errors in the provided error code. *\/\nvoid wait(asio::error_code& ec) { "
    }

    {
        "file_name":"basic_deadline_timer_function_2.cpp",
        "line_count":4,
        "code":"size_t cancel(asio::error_code& ec)\n  {\n    return impl_.get_service().cancel(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the result of canceling an operation with a potential error code.\n   >>> size_t cancel(asio::error_code& ec); *\/",
        "query_nlx":"\/* Define a function named cancel that takes an error code as a parameter and returns a size_t value. \n   >>> cancel(error_code) size_t *\/"
    }

    {
        "file_name":"basic_deadline_timer_function_3.cpp",
        "line_count":8,
        "code":"size_t cancel_one()\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().cancel_one(\n        impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel_one\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve and cancel one operation from the service implementation.\n   >>> cancel_one() returns the size of the canceled operation. *\/ \n   size_t cancel_one();",
        "query_nlx":"\/* Define a function named cancel_one that cancels one operation in a service implementation and returns the size of the operation canceled. \n   >>> cancel_one() returns the size of the canceled operation *\/ \nsize_t cancel_one() { "
    }

    {
        "file_name":"basic_deadline_timer_function_4.cpp",
        "line_count":4,
        "code":"size_t cancel_one(asio::error_code& ec)\n  {\n    return impl_.get_service().cancel_one(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel one operation using the provided error code.\n   >>> size_t cancel_one(asio::error_code& ec); *\/",
        "query_nlx":"\/* Define a function named cancel_one that takes an error code as a parameter and returns a size_t value. \n   >>> cancel_one(asio::error_code& ec) *\/"
    }

    {
        "file_name":"basic_deadline_timer_function_5.cpp",
        "line_count":8,
        "code":"size_t expires_at(const time_type& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_at(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_at\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the expiration time of a resource based on the provided expiry time.\n   >>> size_t expires_at(const time_type& expiry_time) *\/",
        "query_nlx":"\/* Function named expires_at calculates the expiration time based on the given expiry time and returns it. \n>>> expires_at(10:30:00) 1630453800 \n>>> expires_at(15:45:00) 1630475100 *\/ \nsize_t expires_at(const time_type& expiry_time) { "
    }

    {
        "file_name":"basic_deadline_timer_function_7.cpp",
        "line_count":8,
        "code":"size_t expires_from_now(const duration_type& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_from_now(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_from_now\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the expiration time relative to the current time for a specific operation.\n   >>> size_t expires_from_now(const duration_type& expiry_time) *\/",
        "query_nlx":"\/* Function named expires_from_now calculates the time remaining until a specified expiry time based on the current time.\n>>> expires_from_now(5 seconds) 10\n>>> expires_from_now(2 minutes) 120 *\/ \nsize_t expires_from_now(const duration_type& expiry_time) { "
    }

    {
        "file_name":"basic_descriptor_function_1.cpp",
        "line_count":7,
        "code":"void assign(const native_handle_type& native_descriptor)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(),\n        native_descriptor, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Assign a native descriptor to the implementation and handle any errors that occur during the assignment process.\n   >>> assign(const native_handle_type& native_descriptor) *\/",
        "query_nlx":"\/* Function named assign takes a native handle type as input and assigns it to the implementation using the service. It then checks for any errors and throws an error message if needed.\n>>> assign(const native_handle_type& native_descriptor) *\/"
    }

    {
        "file_name":"basic_descriptor_function_11.cpp",
        "line_count":6,
        "code":"void non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().non_blocking(impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"non_blocking\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Execute a function to set the non-blocking mode for a service implementation.\n   >>> void non_blocking(bool mode) *\/",
        "query_nlx":"\/* Define a function that sets a non-blocking mode for a service implementation. \n   The function takes a boolean parameter to specify the mode.\n   It internally calls a service function to set the non-blocking mode and handles any errors that may occur. *\/\nvoid non_blocking(bool mode) { *\/"
    }

    {
        "file_name":"basic_descriptor_function_13.cpp",
        "line_count":7,
        "code":"void native_non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().native_non_blocking(\n        impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"native_non_blocking\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the native non-blocking mode for a service implementation.\n   >>> void native_non_blocking(bool mode); *\/",
        "query_nlx":"\/* Function named native_non_blocking sets the native non-blocking mode for a service implementation.\n   >>> native_non_blocking(true) \n   >>> native_non_blocking(false) *\/\nvoid native_non_blocking(bool mode) { "
    }

    {
        "file_name":"basic_descriptor_function_15.cpp",
        "line_count":6,
        "code":"void wait(wait_type w)\n  {\n    asio::error_code ec;\n    impl_.get_service().wait(impl_.get_implementation(), w, ec);\n    asio::detail::throw_error(ec, \"wait\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that waits for a specified type of event to occur.\n   >>> void wait(wait_type w) *\/",
        "query_nlx":"\/* Define a function called wait that takes a parameter of type wait_type and performs a waiting operation using an internal implementation. \n   >>> wait(wait_type w) *\/"
    }

    {
        "file_name":"basic_descriptor_function_3.cpp",
        "line_count":6,
        "code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the underlying resource associated with the current object.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a service implementation by invoking the close method with the implementation and an error code. If an error occurs during the operation, it throws an error with the message \"close\". *\/\nvoid close() {  *\/"
    }

    {
        "file_name":"basic_descriptor_function_5.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the current implementation.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Define a function that returns the native handle of the service implementation.\n   >>> native_handle_type native_handle() { *\/"
    }

    {
        "file_name":"basic_descriptor_function_6.cpp",
        "line_count":4,
        "code":"native_handle_type release()\n  {\n    return impl_.get_service().release(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Release the native handle type by calling the corresponding service implementation.\n   >>> native_handle_type release() *\/",
        "query_nlx":"\/* Function named release returns the native handle type by calling the release function of the service associated with the implementation.\n>>> release() native_handle_type *\/"
    }

    {
        "file_name":"basic_descriptor_function_7.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel any ongoing operation and throw an error if necessary.\n   >>> cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by invoking the cancel method of the service implementation with an error code and throws an error if necessary. \n   >>> cancel() *\/ \nvoid cancel() {"
    }

    {
        "file_name":"basic_descriptor_function_9.cpp",
        "line_count":6,
        "code":"void io_control(IoControlCommand& command)\n  {\n    asio::error_code ec;\n    impl_.get_service().io_control(impl_.get_implementation(), command, ec);\n    asio::detail::throw_error(ec, \"io_control\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Perform input\/output control operation based on the given command.\n   >>> io_control(IoControlCommand& command) *\/",
        "query_nlx":"\/* Define a function called io_control that takes an IoControlCommand reference as a parameter and performs input\/output control operations using an internal implementation. \n   >>> io_control(IoControlCommand& command) *\/"
    }

    {
        "file_name":"basic_endpoint_function_1.cpp",
        "line_count":4,
        "code":"void resize(std::size_t new_size)\n  {\n    impl_.resize(new_size);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Resize the internal data structure to accommodate the specified new size.\n   >>> resize(std::size_t new_size) *\/",
        "query_nlx":"\/* Define a function that resizes a container to a new specified size.\n   >>> resize(new_size) *\/ \nvoid resize(std::size_t new_size) {"
    }

    {
        "file_name":"basic_file_function_1.cpp",
        "line_count":6,
        "code":"void open(const char* path, file_base::flags open_flags)\n  {\n    asio::error_code ec;\n    impl_.get_service().open(impl_.get_implementation(), path, open_flags, ec);\n    asio::detail::throw_error(ec, \"open\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Open a file with the specified path and open flags.\n   >>> void open(const char* path, file_base::flags open_flags) { *\/",
        "query_nlx":"\/* Define a function named open that takes a path as a constant character pointer and open_flags as file_base flags. This function opens a file using the given path and flags, throwing an error if unsuccessful. *\/\nvoid open(const char* path, file_base::flags open_flags) {"
    }

    {
        "file_name":"basic_file_function_10.cpp",
        "line_count":4,
        "code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the native handle type after releasing it with a possible error code.\n   >>> native_handle_type release(asio::error_code& ec) *\/",
        "query_nlx":"\/* Define a function named release that takes an error code as a parameter and returns a native handle type. The function should call the release method on the service associated with the implementation stored in the impl_ member variable, passing the implementation and the error code as arguments. \n>>> release(asio::error_code& ec) native_handle_type *\/"
    }

    {
        "file_name":"basic_file_function_11.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the current implementation.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Define a function that returns the native handle of the service implementation.\n   >>> native_handle_type native_handle() { *\/"
    }

    {
        "file_name":"basic_file_function_12.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel the current operation by invoking the cancel function of the service implementation. \n   >>> void cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by invoking the cancel method with the implementation and an error code. If an error occurs during the cancellation process, throw an error with the message \"cancel\". \n>>> cancel() *\/ \nvoid cancel() { "
    }

    {
        "file_name":"basic_file_function_14.cpp",
        "line_count":6,
        "code":"void resize(uint64_t n)\n  {\n    asio::error_code ec;\n    impl_.get_service().resize(impl_.get_implementation(), n, ec);\n    asio::detail::throw_error(ec, \"resize\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Resize the internal data structure to accommodate a specified number of elements.\n   >>> resize(uint64_t n) *\/",
        "query_nlx":"\/* Function named resize resizes a service implementation by a given number of units.\n   >>> resize(10) *\/ \nvoid resize(uint64_t n) { "
    }

    {
        "file_name":"basic_file_function_16.cpp",
        "line_count":6,
        "code":"void sync_all()\n  {\n    asio::error_code ec;\n    impl_.get_service().sync_all(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"sync_all\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Synchronize all pending operations and handle any errors that may occur during the process.\n   >>> sync_all() *\/",
        "query_nlx":"\/* Define a function named sync_all that synchronizes all operations in the current service implementation and throws an error if any occurs.\n   >>> sync_all() *\/"
    }

    {
        "file_name":"basic_file_function_18.cpp",
        "line_count":6,
        "code":"void sync_data()\n  {\n    asio::error_code ec;\n    impl_.get_service().sync_data(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"sync_data\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Synchronize data with the service implementation.\n   >>> sync_data() *\/",
        "query_nlx":"\/* Function named sync_data synchronizes data using an internal implementation and throws an error if unsuccessful.\n   >>> sync_data() *\/ \nvoid sync_data() {"
    }

    {
        "file_name":"basic_file_function_5.cpp",
        "line_count":7,
        "code":"void assign(const native_handle_type& native_file)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(\n        impl_.get_implementation(), native_file, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Assign a native file handle to the current implementation.\n   >>> assign(const native_handle_type& native_file) *\/",
        "query_nlx":"\/* Function named assign takes a native file handle as input and assigns it to the implementation using a service. It then checks for any errors and throws an error message if needed.\n>>> assign(const native_handle_type& native_file) *\/"
    }

    {
        "file_name":"basic_file_function_7.cpp",
        "line_count":6,
        "code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the underlying service connection.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a service implementation by invoking the close method with the implementation and an error code. If an error occurs during the operation, it throws an error with the message \"close\". *\/\nvoid close() { "
    }

    {
        "file_name":"basic_function_1.cpp",
        "line_count":3,
        "code":"void set_ostream(std::ostream * out = &std::cout) {\n        m_out = out;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the output stream for the program to the specified ostream object or default to standard output stream.\n   >>> set_ostream(std::ofstream* out = &std::cout) *\/ \nvoid set_ostream(std::ostream * out = &std::cout) {",
        "query_nlx":"\/* Define a function called set_ostream that takes a pointer to an output stream as an argument, with a default value of the standard output stream. This function assigns the provided output stream pointer to a class member variable. *\/\nvoid set_ostream(std::ostream * out = &std::cout) {"
    }

    {
        "file_name":"basic_function_3.cpp",
        "line_count":4,
        "code":"void clear_channels(level channels) {\n        scoped_lock_type lock(m_lock);\n        m_dynamic_channels &= ~channels;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Clear specified channels from the dynamic channels list.\n   >>> void clear_channels(level channels) { *\/",
        "query_nlx":"\/* Function named clear_channels updates the dynamic channels by removing the specified level from them.\n>>> clear_channels(level channels) *\/"
    }

    {
        "file_name":"basic_object_handle_function_1.cpp",
        "line_count":6,
        "code":"void assign(const native_handle_type& handle)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(), handle, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Assign a native handle to the implementation and handle any errors that occur during the assignment process.\n   >>> assign(const native_handle_type& handle) *\/",
        "query_nlx":"\/* Define a function called assign that takes a constant reference to a native handle type as input. This function assigns the implementation of a service to the handle provided, and throws an error if any, with the message \"assign\". *\/\nvoid assign(const native_handle_type& handle) { "
    }

    {
        "file_name":"basic_object_handle_function_3.cpp",
        "line_count":6,
        "code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the underlying resource associated with the current object.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a service implementation by invoking the close method with the implementation and an error code. \n   >>> close() *\/ \nvoid close() {"
    }

    {
        "file_name":"basic_object_handle_function_5.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the current implementation.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Function named native_handle retrieves the native handle from the service implementation. \n>>> native_handle_type native_handle() { *\/"
    }

    {
        "file_name":"basic_object_handle_function_6.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel the current operation by invoking the cancel function of the service implementation. \n   >>> void cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by invoking the cancel method with the implementation and an error code, then throws an error if needed.\n   >>> cancel() *\/ \nvoid cancel() {"
    }

    {
        "file_name":"basic_object_handle_function_9.cpp",
        "line_count":4,
        "code":"void wait(asio::error_code& ec)\n  {\n    impl_.get_service().wait(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that waits for an event to occur and handles any errors that may arise.\n   >>> void wait(asio::error_code& ec) { *\/",
        "query_nlx":"\/* Define a function called wait that takes an error code as a parameter and calls a service function to wait for an implementation to complete, storing any error in the provided error code.\n   >>> wait(error_code) *\/"
    }

    {
        "file_name":"basic_overlapped_handle_function_1.cpp",
        "line_count":6,
        "code":"void assign(const native_handle_type& handle)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(), handle, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Assign a native handle to the implementation and handle any errors that occur during the assignment process.\n   >>> assign(const native_handle_type& handle) *\/",
        "query_nlx":"\/* Define a function named assign that takes a constant reference to a native handle type as input, assigns the handle to the implementation, and throws an error code if necessary. \n   >>> assign(const native_handle_type& handle) *\/"
    }

    {
        "file_name":"basic_overlapped_handle_function_3.cpp",
        "line_count":6,
        "code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the underlying service connection.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a service implementation by invoking the close method with the implementation and an error code. If an error occurs during the operation, it throws an error with the message \"close\". *\/\nvoid close() { "
    }

    {
        "file_name":"basic_overlapped_handle_function_6.cpp",
        "line_count":4,
        "code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Release the native handle type associated with the current implementation.\n   >>> native_handle_type release(asio::error_code& ec) *\/",
        "query_nlx":"\/* Function named release takes an error code as a parameter and returns a native handle type by calling the release function of the service associated with the implementation.\n   >>> release(error_code) native_handle_type *\/"
    }

    {
        "file_name":"basic_overlapped_handle_function_7.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the current implementation.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Function named native_handle retrieves the native handle from the service implementation. \n>>> native_handle_type native_handle() { *\/"
    }

    {
        "file_name":"basic_overlapped_handle_function_8.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel the current operation by invoking the cancel function of the service implementation. \n   >>> cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by calling the cancel method of the service implementation with an error code and throws an error if necessary. \n   >>> cancel() *\/ \nvoid cancel() {"
    }

    {
        "file_name":"basic_raw_socket_function_1.cpp",
        "line_count":8,
        "code":"size_t send(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().send(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"send\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Send a sequence of constant buffers and return the size of the sent data.\n   >>> size_t send(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function named send that takes a constant buffer sequence as input and returns the size of the sent data.\n   >>> send(const ConstBufferSequence& buffers) size_t *\/"
    }

    {
        "file_name":"basic_raw_socket_function_7.cpp",
        "line_count":8,
        "code":"size_t receive(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().receive(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"receive\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Define a function that receives data into a buffer and returns the size of the received data.\n   >>> size_t receive(const MutableBufferSequence& buffers); *\/",
        "query_nlx":"\/* Define a function named receive that takes a sequence of mutable buffers as input and returns the size of data received after performing a receive operation. \n   >>> receive(buffers) size_t *\/"
    }

    {
        "file_name":"basic_readable_pipe_function_1.cpp",
        "line_count":6,
        "code":"void assign(const native_handle_type& native_pipe)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(), native_pipe, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Assign a native pipe to the implementation for handling asynchronous operations.\n   >>> assign(const native_handle_type& native_pipe) *\/",
        "query_nlx":"\/* Define a function named assign that takes a constant reference to a native_handle_type parameter and assigns the native pipe to the implementation service. \n   >>> assign(const native_handle_type& native_pipe) *\/"
    }

    {
        "file_name":"basic_readable_pipe_function_10.cpp",
        "line_count":8,
        "code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().read_some(\n        impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Read some data from a buffer and return the size of the data read.\n   >>> size_t read_some(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Function named read_some reads data into a buffer sequence from an implementation, throwing an error if any, and returning the size of the data read.\n   >>> read_some(buffers) size_t *\/"
    }

    {
        "file_name":"basic_readable_pipe_function_3.cpp",
        "line_count":6,
        "code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the underlying service connection.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a service implementation by invoking the close method with the implementation and an error code. If an error occurs during the operation, it throws an error with the message \"close\". *\/\nvoid close() {  *\/"
    }

    {
        "file_name":"basic_readable_pipe_function_6.cpp",
        "line_count":4,
        "code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the native handle type after releasing it with a possible error code.\n   >>> native_handle_type release(asio::error_code& ec) *\/",
        "query_nlx":"\/* Function named release takes an error code as input and returns a native handle type by calling the release function of the service associated with the implementation.\n   >>> release(error_code) native_handle_type *\/"
    }

    {
        "file_name":"basic_readable_pipe_function_7.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the current implementation.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Define a function that returns the native handle of the service implementation.\n   >>> native_handle_type native_handle() { *\/"
    }

    {
        "file_name":"basic_readable_pipe_function_8.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel the current operation by invoking the cancel function of the service implementation. \n   >>> void cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by calling the cancel method of the service implementation with an error code and throws an error if necessary. \n   >>> cancel() *\/ \nvoid cancel() { "
    }

    {
        "file_name":"basic_regex_creator_function_1.cpp",
        "line_count":7,
        "code":"void add_single(const digraph_type& s)\n   {\n      m_singles.insert(s);\n      if(s.second)\n         m_has_digraphs = true;\n      m_empty = false;\n   }",
        "mark":8.0,
        "query_nsx":"\/* Add a single element to a collection, updating flags accordingly.\n   >>> void add_single(const digraph_type& s) *\/",
        "query_nlx":"\/* Function named add_single inserts a single element into a data structure and updates flags based on the inserted element.\n>>> add_single({1, true}) \n>>> add_single({0, false}) *\/ \nvoid add_single(const digraph_type& s) { "
    }

    {
        "file_name":"basic_regex_creator_function_10.cpp",
        "line_count":4,
        "code":"flag_type flags()\n   {\n      return m_pdata->m_flags;\n   }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the flags associated with a specific data object.\n   >>> flags() flag_type *\/",
        "query_nlx":"\/* Function named flags retrieves the type of flags stored in the data structure pointed to by m_pdata.\n   >>> flags() returns the flag_type stored in the data structure pointed to by m_pdata. *\/ \nflag_type flags() { "
    }

    {
        "file_name":"basic_regex_creator_function_14.cpp",
        "line_count":4,
        "code":"bool char_less(char t1, char t2)\n{\n   return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the first character is less than the second character based on their ASCII values.\n>>> bool char_less(char t1, char t2) { *\/",
        "query_nlx":"\/* Function named char_less compares two characters based on their ASCII values.\n   >>> char_less('a', 'b') true\n   >>> char_less('z', 'a') false *\/ \nbool char_less(char t1, char t2) { "
    }

    {
        "file_name":"basic_regex_creator_function_15.cpp",
        "line_count":4,
        "code":"bool char_less(signed char t1, signed char t2)\n{\n   return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the first input character is less than the second input character in terms of their ASCII values.\n>>> char_less(signed char t1, signed char t2){ *\/",
        "query_nlx":"\/* Function named char_less compares two signed char values by converting them to unsigned char and checking if the first value is less than the second value.\n>>> char_less(-5, 10) true\n>>> char_less(127, -128) false *\/ \nbool char_less(signed char t1, signed char t2) { "
    }

    {
        "file_name":"basic_regex_creator_function_5.cpp",
        "line_count":10,
        "code":"void add_equivalent(const digraph_type& s)\n   {\n      m_equivalents.insert(s);\n      if(s.second)\n      {\n         m_has_digraphs = true;\n         add_single(s);\n      }\n      m_empty = false;\n   }",
        "mark":8.0,
        "query_nsx":"\/* Add an equivalent digraph to the collection and update the state accordingly.\n   >>> void add_equivalent(const digraph_type& s) { *\/",
        "query_nlx":"\/* Define a function that adds a given digraph to a collection of equivalents and updates internal flags accordingly.\n   >>> add_equivalent(const digraph_type& s) *\/"
    }

    {
        "file_name":"basic_regex_creator_function_8.cpp",
        "line_count":4,
        "code":"ptrdiff_t getoffset(const void* addr, const void* base)\n   {\n      return static_cast<const char*>(addr) - static_cast<const char*>(base);\n   }",
        "mark":9.0,
        "query_nsx":"\/* Calculate the offset between two memory addresses.\n   >>> ptrdiff_t getoffset(const void* addr, const void* base) { *\/",
        "query_nlx":"\/* Function named getoffset calculates the offset between two memory addresses represented by void pointers. \n   >>> getoffset(address1, address2) returns the offset between the two memory addresses *\/ \nptrdiff_t getoffset(const void* addr, const void* base) { "
    }

    {
        "file_name":"basic_regex_creator_function_9.cpp",
        "line_count":5,
        "code":"void init(unsigned l_flags)\n   {\n      m_pdata->m_flags = l_flags;\n      m_icase = l_flags & regex_constants::icase;\n   }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the flags and case sensitivity for a specific operation.\n   >>> void init(unsigned l_flags) *\/",
        "query_nlx":"\/* Initialize the flags of a data structure with the given input flags and set a case-insensitive flag based on the input flags.\n   >>> init(5) *\/ \nvoid init(unsigned l_flags) {"
    }

    {
        "file_name":"basic_regex_function_3.cpp",
        "line_count":5,
        "code":"void swap(name& other)\n      {\n         std::swap(index, other.index);\n         std::swap(hash, other.hash);\n      }",
        "mark":8.0,
        "query_nsx":"\/* Swap the values of two objects of the same type.\n   >>> void swap(name& other) *\/",
        "query_nlx":"\/* Function named swap exchanges the values of two objects by swapping their index and hash values.\n>>> swap(obj1, obj2) swaps the index and hash values between obj1 and obj2. *\/ \nvoid swap(name& other) {"
    }

    {
        "file_name":"basic_resolver_function_1.cpp",
        "line_count":4,
        "code":"void cancel()\n  {\n    return impl_.get_service().cancel(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel the current operation.\n    >>> void cancel() *\/",
        "query_nlx":"\/* Define a function called cancel that calls the cancel method on the service object obtained from the implementation object.\n   >>> cancel() void *\/"
    }

    {
        "file_name":"basic_resolver_function_12.cpp",
        "line_count":8,
        "code":"results_type resolve(const endpoint_type& e)\n  {\n    asio::error_code ec;\n    results_type i = impl_.get_service().resolve(\n        impl_.get_implementation(), e, ec);\n    asio::detail::throw_error(ec, \"resolve\");\n    return i;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Resolve the endpoint using the provided implementation and return the results.\n   >>> results_type resolve(const endpoint_type& e) *\/",
        "query_nlx":"\/* Function named resolve takes an endpoint as input and resolves it to obtain results. \n>>> resolve(const endpoint_type& e) *\/"
    }

    {
        "file_name":"basic_resolver_function_2.cpp",
        "line_count":8,
        "code":"results_type resolve(const query& q)\n  {\n    asio::error_code ec;\n    results_type r = impl_.get_service().resolve(\n        impl_.get_implementation(), q, ec);\n    asio::detail::throw_error(ec, \"resolve\");\n    return r;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Resolve a query using a service implementation and return the results.\n   >>> results_type resolve(const query& q) *\/",
        "query_nlx":"\/* Function named resolve takes a query object and resolves it using an implementation to obtain results. \n>>> resolve(query_object) results \n>>> resolve(another_query_object) more_results *\/ \nresults_type resolve(const query& q) {"
    }

    {
        "file_name":"basic_resolver_function_3.cpp",
        "line_count":4,
        "code":"results_type resolve(const query& q, asio::error_code& ec)\n  {\n    return impl_.get_service().resolve(impl_.get_implementation(), q, ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Resolve a query using the provided parameters and return the result type.\n   >>> resolve(const query& q, asio::error_code& ec) *\/",
        "query_nlx":"\/* Function resolve takes a query and an error code, then returns the resolved results using the implementation's service and implementation details.\n>>> resolve(query q, asio::error_code& ec) results_type { *\/"
    }

    {
        "file_name":"basic_serial_port_function_1.cpp",
        "line_count":6,
        "code":"void open(const std::string& device)\n  {\n    asio::error_code ec;\n    impl_.get_service().open(impl_.get_implementation(), device, ec);\n    asio::detail::throw_error(ec, \"open\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Open a device using the provided device identifier.\n   >>> open(device) *\/ \nvoid open(const std::string& device) {",
        "query_nlx":"\/* Define a function named open that takes a constant reference to a string device as input. This function opens a device using an implementation, and throws an error if unsuccessful. *\/\nvoid open(const std::string& device) { "
    }

    {
        "file_name":"basic_serial_port_function_10.cpp",
        "line_count":6,
        "code":"void send_break()\n  {\n    asio::error_code ec;\n    impl_.get_service().send_break(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"send_break\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Send a break signal using the underlying service implementation.\n   >>> void send_break() *\/",
        "query_nlx":"\/* Define a function that sends a break signal using the underlying service implementation. \n   The function should handle any errors that occur during the operation. \n   >>> send_break() *\/ \nvoid send_break() {"
    }

    {
        "file_name":"basic_serial_port_function_12.cpp",
        "line_count":6,
        "code":"void set_option(const SettableSerialPortOption& option)\n  {\n    asio::error_code ec;\n    impl_.get_service().set_option(impl_.get_implementation(), option, ec);\n    asio::detail::throw_error(ec, \"set_option\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a specific option for a serial port.\n   >>> void set_option(const SettableSerialPortOption& option) *\/",
        "query_nlx":"\/* Function named set_option sets a specific option for a serial port communication.\n>>> set_option(option) void *\/\n"
    }

    {
        "file_name":"basic_serial_port_function_14.cpp",
        "line_count":8,
        "code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().write_some(\n        impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Write some data from a buffer sequence using the service implementation.\n   >>> size_t write_some(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Function named write_some takes a sequence of constant buffers and writes some data from the implementation's service. \n>>> write_some({buffers}) returns the size of the data written *\/ \nsize_t write_some(const ConstBufferSequence& buffers) {"
    }

    {
        "file_name":"basic_serial_port_function_16.cpp",
        "line_count":8,
        "code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().read_some(\n        impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Read some data from a buffer and return the size of the data read.\n   >>> size_t read_some(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function called read_some that reads data into a buffer sequence and returns the size of the data read.\n   >>> read_some(buffers: MutableBufferSequence) -> size_t *\/"
    }

    {
        "file_name":"basic_serial_port_function_3.cpp",
        "line_count":7,
        "code":"void assign(const native_handle_type& native_serial_port)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(),\n        native_serial_port, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Assign a native serial port to the implementation and handle any errors that may occur during the process.\n   >>> void assign(const native_handle_type& native_serial_port) *\/",
        "query_nlx":"\/* Function named assign takes a native handle type representing a serial port and assigns it to the implementation. It then throws an error if any, with the message \"assign\".\n   >>> assign(const native_handle_type& native_serial_port) *\/"
    }

    {
        "file_name":"basic_serial_port_function_5.cpp",
        "line_count":6,
        "code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the underlying service connection.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a service implementation by invoking the close method with the implementation and an error code. If an error occurs during the operation, it throws an error with the message \"close\". *\/\nvoid close() { "
    }

    {
        "file_name":"basic_serial_port_function_7.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the current implementation.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Function named native_handle retrieves the native handle from the service implementation.\n   >>> native_handle() returns the native handle type\n*\/ \nnative_handle_type native_handle() { "
    }

    {
        "file_name":"basic_serial_port_function_8.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function to cancel a specific operation.\n   >>> void cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by invoking the cancel method with the implementation and an error code. If an error occurs during the cancellation process, throw an error with the message \"cancel\". \n>>> cancel() *\/ \nvoid cancel() { "
    }

    {
        "file_name":"basic_signal_set_function_3.cpp",
        "line_count":6,
        "code":"void add(int signal_number, flags_t f)\n  {\n    asio::error_code ec;\n    impl_.get_service().add(impl_.get_implementation(), signal_number, f, ec);\n    asio::detail::throw_error(ec, \"add\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Add a signal with specified flags to the service implementation.\n   >>> void add(int signal_number, flags_t f) { *\/",
        "query_nlx":"\/* Function named add adds a signal with a specified signal number and flags to the service implementation. \n>>> add(5, FLAG_READ) *\/ \nvoid add(int signal_number, flags_t f) { "
    }

    {
        "file_name":"basic_signal_set_function_9.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel any ongoing operation and throw an error if necessary.\n   >>> void cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by calling the cancel method of the service implementation with an error code and throws an error if necessary. \n   >>> cancel() *\/ \nvoid cancel() {"
    }

    {
        "file_name":"basic_socket_acceptor_function_11.cpp",
        "line_count":4,
        "code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Release the native handle type associated with the current implementation, handling any errors using the provided error code.\n   >>> native_handle_type release(asio::error_code& ec) *\/",
        "query_nlx":"\/* Define a function named release that takes an error code as a parameter and returns a native handle type. \n   >>> release(asio::error_code& ec) { *\/"
    }

    {
        "file_name":"basic_socket_acceptor_function_12.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the current implementation.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Define a function that returns the native handle of the service implementation.\n   >>> native_handle_type native_handle() { *\/"
    }

    {
        "file_name":"basic_socket_acceptor_function_13.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel any ongoing operation and throw an error if necessary.\n   >>> cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by calling the cancel method of the service implementation with an error code and throws an error if necessary. \n   >>> cancel() *\/ \nvoid cancel() {"
    }

    {
        "file_name":"basic_socket_acceptor_function_15.cpp",
        "line_count":6,
        "code":"void set_option(const SettableSocketOption& option)\n  {\n    asio::error_code ec;\n    impl_.get_service().set_option(impl_.get_implementation(), option, ec);\n    asio::detail::throw_error(ec, \"set_option\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a specific option for a socket using the provided configuration.\n   >>> void set_option(const SettableSocketOption& option) *\/",
        "query_nlx":"\/* Define a function named set_option that takes a constant reference to a SettableSocketOption object as a parameter and sets this option for a socket. \n   >>> set_option(const SettableSocketOption& option) *\/"
    }

    {
        "file_name":"basic_socket_acceptor_function_17.cpp",
        "line_count":6,
        "code":"void io_control(IoControlCommand& command)\n  {\n    asio::error_code ec;\n    impl_.get_service().io_control(impl_.get_implementation(), command, ec);\n    asio::detail::throw_error(ec, \"io_control\");\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Perform input\/output control operation based on the given command.\n        >>> io_control(IoControlCommand& command) *\/",
        "query_nlx":"\/* Define a function called io_control that takes an IoControlCommand reference as a parameter and performs input\/output control operations using an internal implementation. \n   >>> io_control(IoControlCommand& command) *\/"
    }

    {
        "file_name":"basic_socket_acceptor_function_19.cpp",
        "line_count":6,
        "code":"void non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().non_blocking(impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"non_blocking\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Execute a function to set the non-blocking mode for a service implementation.\n   >>> void non_blocking(bool mode) *\/",
        "query_nlx":"\/* Define a function that sets a non-blocking mode for a service implementation. \n   The function takes a boolean parameter 'mode' to specify the non-blocking mode.\n   It internally calls a service function to set the non-blocking mode and handles any errors that may occur.\n   >>> non_blocking(true) \n   >>> non_blocking(false) *\/\nvoid non_blocking(bool mode) { "
    }

    {
        "file_name":"basic_socket_acceptor_function_21.cpp",
        "line_count":7,
        "code":"void native_non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().native_non_blocking(\n        impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"native_non_blocking\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the native non-blocking mode for a service implementation.\n   >>> native_non_blocking(true) \n   >>> native_non_blocking(false) *\/\n   void native_non_blocking(bool mode) {",
        "query_nlx":"\/* Function named native_non_blocking sets the native non-blocking mode for a service implementation.\n>>> native_non_blocking(true) \n>>> native_non_blocking(false) *\/\nvoid native_non_blocking(bool mode) { "
    }

    {
        "file_name":"basic_socket_acceptor_function_4.cpp",
        "line_count":6,
        "code":"void bind(const endpoint_type& endpoint)\n  {\n    asio::error_code ec;\n    impl_.get_service().bind(impl_.get_implementation(), endpoint, ec);\n    asio::detail::throw_error(ec, \"bind\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Bind a specified endpoint to the implementation service.\n   >>> void bind(const endpoint_type& endpoint) *\/",
        "query_nlx":"\/* Define a function named bind that takes an endpoint_type parameter and binds the implementation to the specified endpoint. \n   The function should handle any errors that occur during the binding process and throw an error if necessary. \n   >>> bind(const endpoint_type& endpoint) *\/"
    }

    {
        "file_name":"basic_socket_acceptor_function_6.cpp",
        "line_count":6,
        "code":"void listen(int backlog = socket_base::max_listen_connections)\n  {\n    asio::error_code ec;\n    impl_.get_service().listen(impl_.get_implementation(), backlog, ec);\n    asio::detail::throw_error(ec, \"listen\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Define a function that sets up a listening socket with an optional backlog parameter.\n   >>> void listen(int backlog = socket_base::max_listen_connections) { *\/",
        "query_nlx":"\/* Define a function called listen that takes an optional parameter backlog with a default value of the maximum number of listen connections. This function listens for incoming connections and throws an error if any occur.\n>>> listen() *\/ \nvoid listen(int backlog = socket_base::max_listen_connections) {"
    }

    {
        "file_name":"basic_socket_acceptor_function_8.cpp",
        "line_count":6,
        "code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the underlying resource associated with the current object.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a service implementation by invoking the close method with the implementation and an error code. If an error occurs during the operation, it throws an error with the message \"close\". *\/\nvoid close() { "
    }

    {
        "file_name":"basic_socket_function_11.cpp",
        "line_count":6,
        "code":"void bind(const endpoint_type& endpoint)\n  {\n    asio::error_code ec;\n    impl_.get_service().bind(impl_.get_implementation(), endpoint, ec);\n    asio::detail::throw_error(ec, \"bind\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Bind the specified endpoint to the implementation service.\n   >>> void bind(const endpoint_type& endpoint) { *\/",
        "query_nlx":"\/* Define a function named bind that takes an endpoint_type parameter and binds it to the implementation. \n   The function should handle any errors that occur during the binding process and throw an error if needed. \n   >>> bind(endpoint_type endpoint) *\/"
    }

    {
        "file_name":"basic_socket_function_15.cpp",
        "line_count":6,
        "code":"void set_option(const SettableSocketOption& option)\n  {\n    asio::error_code ec;\n    impl_.get_service().set_option(impl_.get_implementation(), option, ec);\n    asio::detail::throw_error(ec, \"set_option\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a specific option for a socket using the provided configuration.\n   >>> void set_option(const SettableSocketOption& option) *\/",
        "query_nlx":"\/* Define a function named set_option that takes a constant reference to a SettableSocketOption object as a parameter and sets this option for a socket.\n   >>> set_option(const SettableSocketOption& option) *\/"
    }

    {
        "file_name":"basic_socket_function_17.cpp",
        "line_count":6,
        "code":"void io_control(IoControlCommand& command)\n  {\n    asio::error_code ec;\n    impl_.get_service().io_control(impl_.get_implementation(), command, ec);\n    asio::detail::throw_error(ec, \"io_control\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Perform input\/output control operation based on the given command.\n   >>> io_control(IoControlCommand& command) *\/",
        "query_nlx":"\/* Define a function called io_control that takes an IoControlCommand reference as a parameter and performs input\/output control operations using an internal implementation. \n   >>> io_control(IoControlCommand& command) *\/"
    }

    {
        "file_name":"basic_socket_function_19.cpp",
        "line_count":6,
        "code":"void non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().non_blocking(impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"non_blocking\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the non-blocking mode for a service implementation.\n   >>> non_blocking(true) \n   >>> non_blocking(false) *\/\n   void non_blocking(bool mode) {",
        "query_nlx":"\/* Define a function that sets a non-blocking mode for a service implementation. \n   The function takes a boolean parameter to specify the mode.\n   It internally calls a service function to set the non-blocking mode and handles any errors that may occur. *\/ \nvoid non_blocking(bool mode) { "
    }

    {
        "file_name":"basic_socket_function_21.cpp",
        "line_count":7,
        "code":"void native_non_blocking(bool mode)\n  {\n    asio::error_code ec;\n    impl_.get_service().native_non_blocking(\n        impl_.get_implementation(), mode, ec);\n    asio::detail::throw_error(ec, \"native_non_blocking\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the native non-blocking mode for a service implementation.\n   >>> native_non_blocking(true) \n   >>> native_non_blocking(false) *\/\n   void native_non_blocking(bool mode) { ",
        "query_nlx":"\/* Function named native_non_blocking sets the native non-blocking mode for a service implementation.\n>>> native_non_blocking(true) \n>>> native_non_blocking(false) *\/\nvoid native_non_blocking(bool mode) { "
    }

    {
        "file_name":"basic_socket_function_23.cpp",
        "line_count":6,
        "code":"void shutdown(shutdown_type what)\n  {\n    asio::error_code ec;\n    impl_.get_service().shutdown(impl_.get_implementation(), what, ec);\n    asio::detail::throw_error(ec, \"shutdown\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Perform a shutdown operation based on the specified type.\n   >>> void shutdown(shutdown_type what) *\/",
        "query_nlx":"\/* Define a function named shutdown that takes a shutdown_type parameter and shuts down a service based on the specified type.\n   >>> shutdown(SHUTDOWN_IMMEDIATE) shuts down the service immediately\n   >>> shutdown(SHUTDOWN_GRACEFUL) shuts down the service gracefully *\/ \nvoid shutdown(shutdown_type what) { "
    }

    {
        "file_name":"basic_socket_function_4.cpp",
        "line_count":6,
        "code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the underlying service connection.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a service implementation by invoking the close method with the implementation and an error code. If an error occurs during the operation, it throws an error with the message \"close\". *\/\nvoid close() { "
    }

    {
        "file_name":"basic_socket_function_7.cpp",
        "line_count":4,
        "code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Release the native handle type associated with the current implementation.\n   >>> native_handle_type release(asio::error_code& ec) *\/",
        "query_nlx":"\/* Function named release takes an error code as input and returns a native handle type by calling the release function of the service associated with the implementation.\n   >>> release(error_code) native_handle_type *\/"
    }

    {
        "file_name":"basic_socket_function_8.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the current implementation.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Function named native_handle retrieves the native handle from the service implementation. \n>>> native_handle() returns the native handle type obtained by calling the native_handle function on the service implementation. *\/ \nnative_handle_type native_handle();"
    }

    {
        "file_name":"basic_socket_function_9.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel any ongoing operation and throw an error if necessary.\n   >>> cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by calling the cancel method of the service implementation with an error code and throws an error if necessary. \n   >>> cancel() *\/ \nvoid cancel() {"
    }

    {
        "file_name":"basic_socket_iostream_function_4.cpp",
        "line_count":4,
        "code":"void expires_after(const duration& expiry_time)\n  {\n    rdbuf()->expires_after(expiry_time);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set an expiration time for a resource. \n   >>> void expires_after(const duration& expiry_time){ *\/",
        "query_nlx":"\/* Define a function called expires_after that sets the expiration time for a resource to the specified duration.\n   >>> expires_after(expiry_time) *\/ \nvoid expires_after(const duration& expiry_time) { \n    \/\/ Function body omitted\n}"
    }

    {
        "file_name":"basic_streambuf_function_10.cpp",
        "line_count":4,
        "code":"void consume(std::size_t n)\n  {\n    return sb_.consume(n);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Consume a specified number of elements from a container.\n   >>> consume(std::size_t n) *\/",
        "query_nlx":"\/* Define a function called consume that takes a single parameter of type size_t and calls the consume function of the sb_ object with that parameter. \n   >>> consume(10) *\/ \nvoid consume(std::size_t n) { "
    }

    {
        "file_name":"basic_streambuf_function_2.cpp",
        "line_count":6,
        "code":"void commit(std::size_t n)\n  {\n    n = std::min<std::size_t>(n, epptr() - pptr());\n    pbump(static_cast<int>(n));\n    setg(eback(), gptr(), pptr());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Update the internal pointers and adjust the buffer size based on the specified value.\n   >>> commit(size_t n) *\/",
        "query_nlx":"\/* Define a function named commit that takes a non-negative integer as input and performs the following operations:\n- Limit the input value to be within the range of the difference between two internal pointers.\n- Increment the internal pointer by the limited input value.\n- Update the internal pointers to specific positions.\n>>> commit(10) *\/ \nvoid commit(std::size_t n) { "
    }

    {
        "file_name":"basic_streambuf_function_8.cpp",
        "line_count":4,
        "code":"mutable_buffers_type prepare(std::size_t n)\n  {\n    return sb_.prepare(n);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Prepare a buffer with a specified size for future operations.\n   >>> mutable_buffers_type prepare(std::size_t n) *\/",
        "query_nlx":"\/* Function named prepare generates a mutable buffer of a specified size by calling the prepare function of an internal object sb_. \n>>> prepare(10) returns a mutable buffer of size 10 *\/ \nmutable_buffers_type prepare(std::size_t n) {"
    }

    {
        "file_name":"basic_streambuf_function_9.cpp",
        "line_count":4,
        "code":"void commit(std::size_t n)\n  {\n    return sb_.commit(n);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Commit a specified number of changes to the system. \n>>> void commit(std::size_t n) *\/",
        "query_nlx":"\/* Define a function named commit that takes a single parameter of type size_t and calls the commit function of an object sb_ with that parameter. *\/\nvoid commit(std::size_t n) { "
    }

    {
        "file_name":"basic_stream_descriptor_function_1.cpp",
        "line_count":8,
        "code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().write_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Write some data from a buffer to a destination.\n   >>> size_t write_some(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function called write_some that takes a constant buffer sequence as input and returns a size_t value.\n   >>> write_some(const ConstBufferSequence& buffers) size_t *\/"
    }

    {
        "file_name":"basic_stream_descriptor_function_3.cpp",
        "line_count":8,
        "code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().read_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Read some data from a buffer and return the size of the data read.\n   >>> size_t read_some(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function called read_some that reads data into a buffer sequence and returns the size of the data read. \n   >>> read_some(buffers) returns the size of the data read from the buffer sequence *\/ \nsize_t read_some(const MutableBufferSequence& buffers) { "
    }

    {
        "file_name":"basic_stream_file_function_1.cpp",
        "line_count":8,
        "code":"uint64_t seek(int64_t offset, file_base::seek_basis whence)\n  {\n    asio::error_code ec;\n    uint64_t n = this->impl_.get_service().seek(\n        this->impl_.get_implementation(), offset, whence, ec);\n    asio::detail::throw_error(ec, \"seek\");\n    return n;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the position within a file based on the specified offset and seek basis.\n   >>> uint64_t seek(int64_t offset, file_base::seek_basis whence); *\/",
        "query_nlx":"\/* Function named seek performs a seek operation on a file based on the given offset and seek basis.\n   >>> seek(100, file_base::seek_basis::current) returns the new position after seeking 100 bytes from the current position.\n   >>> seek(-50, file_base::seek_basis::end) returns the new position after seeking 50 bytes backwards from the end of the file. *\/\nuint64_t seek(int64_t offset, file_base::seek_basis whence) { *\/"
    }

    {
        "file_name":"basic_stream_file_function_3.cpp",
        "line_count":8,
        "code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().write_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Write some data from a buffer to a destination with error handling.\n   >>> size_t write_some(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Function named write_some takes a sequence of constant buffers and writes some data from these buffers using an internal implementation. \n>>> write_some(const ConstBufferSequence& buffers) returns the size of data successfully written after invoking the internal write operation. *\/"
    }

    {
        "file_name":"basic_stream_file_function_5.cpp",
        "line_count":8,
        "code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().read_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Read some data from a buffer and return the size of the data read.\n   >>> size_t read_some(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function called read_some that reads data into a buffer sequence and returns the size of the data read.\n   >>> read_some(buffers) size_t *\/"
    }

    {
        "file_name":"basic_stream_handle_function_1.cpp",
        "line_count":8,
        "code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().write_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Write some data from a buffer to a destination.\n   >>> size_t write_some(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Function named write_some takes a sequence of constant buffers and writes some data from these buffers using an internal implementation. \n>>> write_some(const ConstBufferSequence& buffers) size_t { *\/"
    }

    {
        "file_name":"basic_stream_handle_function_3.cpp",
        "line_count":8,
        "code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().read_some(\n        this->impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Read some data from a buffer and return the size of the data read.\n   >>> size_t read_some(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Function named read_some reads data into a buffer sequence from an implementation, throwing an error if any, and returning the size of the data read.\n   >>> read_some(buffers) size_t *\/"
    }

    {
        "file_name":"basic_stream_socket_function_1.cpp",
        "line_count":8,
        "code":"size_t send(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().send(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"send\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Send a sequence of constant buffers and return the size of the sent data.\n   >>> size_t send(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function named send that takes a constant buffer sequence as input and returns a size_t value.\n   >>> send(const ConstBufferSequence& buffers) size_t *\/"
    }

    {
        "file_name":"basic_stream_socket_function_4.cpp",
        "line_count":8,
        "code":"size_t receive(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().receive(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"receive\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve data from a buffer and return the size of the received data.\n   >>> size_t receive(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function named receive that takes a sequence of mutable buffers as input and returns the size of the received data.\n   >>> receive(buffers) returns the size of the received data\n   >>> receive({buffer1, buffer2, buffer3}) returns the total size of the data received from the mutable buffers *\/ \nsize_t receive(const MutableBufferSequence& buffers) { "
    }

    {
        "file_name":"basic_stream_socket_function_7.cpp",
        "line_count":8,
        "code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().send(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Write a function that sends a buffer of data and returns the number of bytes written.\n   >>> size_t write_some(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Function named write_some sends a sequence of constant buffers using the service implementation and returns the size of the sent data.\n>>> write_some({buffers}) returns the size of the sent data *\/ \nsize_t write_some(const ConstBufferSequence& buffers) { "
    }

    {
        "file_name":"basic_stream_socket_function_9.cpp",
        "line_count":8,
        "code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = this->impl_.get_service().receive(\n        this->impl_.get_implementation(), buffers, 0, ec);\n    asio::detail::throw_error(ec, \"read_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Read data from a buffer and return the number of bytes read.\n   >>> size_t read_some(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Function named read_some reads data into a buffer sequence from an implementation, throwing an error if any, and returning the size of the data read.\n   >>> read_some(buffers) size_t *\/"
    }

    {
        "file_name":"basic_waitable_timer_function_1.cpp",
        "line_count":7,
        "code":"size_t cancel()\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the size of the cancelled operation after attempting to cancel it.\n   >>> size_t cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that returns the size of the result of canceling an operation. \n   >>> cancel() size_t *\/"
    }

    {
        "file_name":"basic_waitable_timer_function_11.cpp",
        "line_count":4,
        "code":"void wait(asio::error_code& ec)\n  {\n    impl_.get_service().wait(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that waits for an event to occur and handles any errors that may arise during the process.\n   >>> void wait(asio::error_code& ec) *\/",
        "query_nlx":"\/* Define a function that waits for an asynchronous operation to complete and handles any errors that may occur during the process. \n>>> wait(error_code&) *\/"
    }

    {
        "file_name":"basic_waitable_timer_function_2.cpp",
        "line_count":4,
        "code":"size_t cancel(asio::error_code& ec)\n  {\n    return impl_.get_service().cancel(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the result of canceling an operation with a potential error code.\n   >>> size_t cancel(asio::error_code& ec); *\/",
        "query_nlx":"\/* Define a function named cancel that takes an error code by reference and returns a size_t value. This function calls the cancel method of the service associated with the implementation stored in the impl_ object, passing the implementation and the error code as arguments. *\/\n>>> cancel(asio::error_code& ec) {  *\/"
    }

    {
        "file_name":"basic_waitable_timer_function_3.cpp",
        "line_count":8,
        "code":"size_t cancel_one()\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().cancel_one(\n        impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel_one\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve and cancel one operation from the service implementation.\n   >>> size_t cancel_one() *\/",
        "query_nlx":"\/* Define a function that cancels one operation within a service implementation and returns the size of the operation canceled. \n   >>> cancel_one() size_t *\/"
    }

    {
        "file_name":"basic_waitable_timer_function_4.cpp",
        "line_count":4,
        "code":"size_t cancel_one(asio::error_code& ec)\n  {\n    return impl_.get_service().cancel_one(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel one operation using the provided error code.\n   >>> size_t cancel_one(asio::error_code& ec); *\/",
        "query_nlx":"\/* Define a function named cancel_one that takes an error code as a parameter and returns a size_t value. This function calls the cancel_one method of the service associated with the implementation stored in the impl_ object, passing the implementation and the error code as arguments. \n   >>> cancel_one(asio::error_code& ec) *\/ \nsize_t cancel_one(asio::error_code& ec) { "
    }

    {
        "file_name":"basic_waitable_timer_function_5.cpp",
        "line_count":8,
        "code":"size_t expires_at(const time_point& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_at(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_at\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine the expiration time of a resource based on the provided expiry time.\n   >>> size_t expires_at(const time_point& expiry_time) *\/",
        "query_nlx":"\/* Function named expires_at calculates the expiration time based on the given expiry time and returns it. \n>>> expires_at({expiry_time}) returns size_t *\/ \nsize_t expires_at(const time_point& expiry_time) {"
    }

    {
        "file_name":"basic_waitable_timer_function_7.cpp",
        "line_count":8,
        "code":"size_t expires_after(const duration& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_after(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_after\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the expiration time after a specified duration.\n   >>> size_t expires_after(const duration& expiry_time) *\/",
        "query_nlx":"\/* Function named expires_after calculates the size of an expiration time after a given duration.\n   >>> expires_after(5 seconds) 10\n   >>> expires_after(2 minutes) 20\n   >>> expires_after(1 hour) 60\n   >>> expires_after(1 day) 1440\n   >>> expires_after(30 seconds) 60\n   >>> expires_after(1 minute) 120\n   >>> expires_after(1 week) 10080\n   >>> expires_after(1 month) 43800\n   >>> expires_after(1 year) 525600 *\/ \nsize_t expires_after(const duration& expiry_time) { "
    }

    {
        "file_name":"basic_waitable_timer_function_8.cpp",
        "line_count":8,
        "code":"size_t expires_from_now(const duration& expiry_time)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().expires_from_now(\n        impl_.get_implementation(), expiry_time, ec);\n    asio::detail::throw_error(ec, \"expires_from_now\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the expiration time relative to the current time for a specific operation.\n   >>> size_t expires_from_now(const duration& expiry_time) *\/",
        "query_nlx":"\/* Function named expires_from_now calculates the expiration time from the current time based on a given duration and returns the result. \n>>> expires_from_now(5 seconds) 10 \n>>> expires_from_now(2 minutes) 120 *\/ \nsize_t expires_from_now(const duration& expiry_time) { "
    }

    {
        "file_name":"basic_writable_pipe_function_1.cpp",
        "line_count":6,
        "code":"void assign(const native_handle_type& native_pipe)\n  {\n    asio::error_code ec;\n    impl_.get_service().assign(impl_.get_implementation(), native_pipe, ec);\n    asio::detail::throw_error(ec, \"assign\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Assign a native pipe to the implementation for handling asynchronous operations.\n   >>> assign(const native_handle_type& native_pipe) *\/",
        "query_nlx":"\/* Define a function called assign that takes a constant reference to a native_handle_type parameter and assigns the native pipe to the implementation service. \n   >>> assign(const native_handle_type& native_pipe) *\/"
    }

    {
        "file_name":"basic_writable_pipe_function_10.cpp",
        "line_count":8,
        "code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    asio::error_code ec;\n    std::size_t s = impl_.get_service().write_some(\n        impl_.get_implementation(), buffers, ec);\n    asio::detail::throw_error(ec, \"write_some\");\n    return s;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Write some data from a buffer sequence using the service implementation.\n   >>> size_t write_some(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Function named write_some takes a sequence of constant buffers and writes some data from the implementation's service. It then returns the size of the data written.\n>>> write_some(const ConstBufferSequence& buffers) size_t { *\/"
    }

    {
        "file_name":"basic_writable_pipe_function_3.cpp",
        "line_count":6,
        "code":"void close()\n  {\n    asio::error_code ec;\n    impl_.get_service().close(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"close\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the connection using the underlying service implementation.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a service implementation by invoking the close method with the implementation and an error code. If an error occurs during the operation, it throws an error with the message \"close\". *\/\nvoid close() { "
    }

    {
        "file_name":"basic_writable_pipe_function_6.cpp",
        "line_count":4,
        "code":"native_handle_type release(asio::error_code& ec)\n  {\n    return impl_.get_service().release(impl_.get_implementation(), ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Release the native handle type associated with the current implementation, handling any errors using the provided error code.\n   >>> native_handle_type release(asio::error_code& ec) *\/",
        "query_nlx":"\/* Function named release returns the native handle type by calling the release function of the service associated with the implementation, passing an error code by reference.\n>>> native_handle_type release(asio::error_code& ec) { *\/"
    }

    {
        "file_name":"basic_writable_pipe_function_7.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return impl_.get_service().native_handle(impl_.get_implementation());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the current implementation.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Function named native_handle retrieves the native handle from the service implementation. \n>>> native_handle() returns the native handle type *\/ \nnative_handle_type native_handle() {"
    }

    {
        "file_name":"basic_writable_pipe_function_8.cpp",
        "line_count":6,
        "code":"void cancel()\n  {\n    asio::error_code ec;\n    impl_.get_service().cancel(impl_.get_implementation(), ec);\n    asio::detail::throw_error(ec, \"cancel\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Cancel the current operation by invoking the cancel function of the service implementation. \n   >>> void cancel() *\/",
        "query_nlx":"\/* Define a function named cancel that cancels a service operation by invoking the cancel method with the implementation and an error code, then throws an error if needed.\n   >>> cancel() *\/ \nvoid cancel() {"
    }

    {
        "file_name":"Bias_Dx11_function_1.cpp",
        "line_count":23,
        "code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n{\n    switch (format) {\n        case DXGI_FORMAT_R32G32B32A32_TYPELESS:\n            return DXGI_FORMAT_R32G32B32A32_FLOAT;\n        case DXGI_FORMAT_R32G32B32_TYPELESS:\n            return DXGI_FORMAT_R32G32B32_FLOAT;\n        case DXGI_FORMAT_R16G16B16A16_TYPELESS:\n            return DXGI_FORMAT_R16G16B16A16_FLOAT;\n        case DXGI_FORMAT_R10G10B10A2_TYPELESS:\n            return DXGI_FORMAT_R10G10B10A2_UINT;\n        case DXGI_FORMAT_R8G8B8A8_TYPELESS:\n            return DXGI_FORMAT_R8G8B8A8_UNORM;\n        case DXGI_FORMAT_B8G8R8A8_TYPELESS:\n            return DXGI_FORMAT_B8G8R8A8_UNORM;\n        case DXGI_FORMAT_R16G16_TYPELESS:\n            return DXGI_FORMAT_R16G16_FLOAT;\n        case DXGI_FORMAT_R32G32_TYPELESS:\n            return DXGI_FORMAT_R32G32_FLOAT;\n        default:\n            return format;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Translate typeless DXGI formats to their corresponding typed formats.\n   >>> DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format); *\/",
        "query_nlx":"\/* TranslateTypelessFormats function translates typeless DXGI formats to their corresponding non-typeless formats.\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R32G32B32A32_TYPELESS) returns DXGI_FORMAT_R32G32B32A32_FLOAT\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R10G10B10A2_TYPELESS) returns DXGI_FORMAT_R10G10B10A2_UINT\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R16G16_TYPELESS) returns DXGI_FORMAT_R16G16_FLOAT *\/ \nDXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format) {"
    }

    {
        "file_name":"Bias_Dx12_function_1.cpp",
        "line_count":23,
        "code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n{\n\tswitch (format) {\n\t\tcase DXGI_FORMAT_R32G32B32A32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32B32A32_FLOAT;\n\t\tcase DXGI_FORMAT_R32G32B32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32B32_FLOAT;\n\t\tcase DXGI_FORMAT_R16G16B16A16_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R16G16B16A16_FLOAT;\n\t\tcase DXGI_FORMAT_R10G10B10A2_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R10G10B10A2_UINT;\n\t\tcase DXGI_FORMAT_R8G8B8A8_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R8G8B8A8_UNORM;\n\t\tcase DXGI_FORMAT_B8G8R8A8_TYPELESS:\n\t\t\treturn DXGI_FORMAT_B8G8R8A8_UNORM;\n\t\tcase DXGI_FORMAT_R16G16_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R16G16_FLOAT;\n\t\tcase DXGI_FORMAT_R32G32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32_FLOAT;\n\t\tdefault:\n\t\t\treturn format;\n\t}\n}",
        "mark":8.0,
        "query_nsx":"\/* Translate typeless DXGI formats to their corresponding non-typeless formats.\n   >>> TranslateTypelessFormats(DXGI_FORMAT format) DXGI_FORMAT { *\/",
        "query_nlx":"        \/* Translate typeless DXGI formats to their corresponding non-typeless formats.\n        >>> TranslateTypelessFormats(DXGI_FORMAT_R32G32B32A32_TYPELESS) returns DXGI_FORMAT_R32G32B32A32_FLOAT\n        >>> TranslateTypelessFormats(DXGI_FORMAT_R16G16B16A16_TYPELESS) returns DXGI_FORMAT_R16G16B16A16_FLOAT\n        >>> TranslateTypelessFormats(DXGI_FORMAT_R8G8B8A8_TYPELESS) returns DXGI_FORMAT_R8G8B8A8_UNORM\n        >>> TranslateTypelessFormats(DXGI_FORMAT_R32G32_TYPELESS) returns DXGI_FORMAT_R32G32_FLOAT\n        *\/ \n        DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format) {"
    }

    {
        "file_name":"buffered_stream_function_1.cpp",
        "line_count":4,
        "code":"void close()\n  {\n    stream_impl_.close();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Close the stream.\n   >>> void close() *\/",
        "query_nlx":"\/* Define a function named close that closes a stream implementation.\n   >>> close() *\/ \nvoid close() {"
    }

    {
        "file_name":"buffered_stream_function_11.cpp",
        "line_count":4,
        "code":"size_t peek(const MutableBufferSequence& buffers)\n  {\n    return stream_impl_.peek(buffers);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the data from the buffer without modifying its contents.\n   >>> peek(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function named peek that takes a sequence of mutable buffers as input and returns the size of the peeked data.\n   >>> peek(buffers) returns the size of the data peeked from the stream_impl_ object *\/ \nsize_t peek(const MutableBufferSequence& buffers) { "
    }

    {
        "file_name":"buffered_stream_function_13.cpp",
        "line_count":4,
        "code":"size_t in_avail()\n  {\n    return stream_impl_.in_avail();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine the available number of characters to read from the input stream.\n>>> size_t in_avail() *\/",
        "query_nlx":"\/* Define a function that returns the number of available characters in a stream by calling a method from the stream implementation.\n   >>> in_avail() returns the number of characters available in the stream. *\/ \nsize_t in_avail() { "
    }

    {
        "file_name":"buffered_stream_function_14.cpp",
        "line_count":4,
        "code":"size_t in_avail(asio::error_code& ec)\n  {\n    return stream_impl_.in_avail(ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the available number of bytes to read from the input stream.\n   >>> size_t in_avail(asio::error_code& ec) *\/",
        "query_nlx":"\/* Define a function that returns the number of available bytes to read from a stream, given an error code parameter.\n   >>> in_avail(error_code) returns the number of available bytes to read from the stream. *\/ \nsize_t in_avail(asio::error_code& ec) { "
    }

    {
        "file_name":"buffered_stream_function_3.cpp",
        "line_count":4,
        "code":"size_t flush()\n  {\n    return stream_impl_.next_layer().flush();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the size of the data stream after flushing it.\n   >>> size_t flush() *\/",
        "query_nlx":"\/* Define a function named flush that returns the size of the flushed data from the underlying stream implementation.\n   >>> flush() returns the size of the flushed data from the stream implementation. *\/ \nsize_t flush() {  \/\/ Function declaration."
    }

    {
        "file_name":"buffered_stream_function_4.cpp",
        "line_count":4,
        "code":"size_t flush(asio::error_code& ec)\n  {\n    return stream_impl_.next_layer().flush(ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the size of the data that has been flushed from the stream.\n   >>> size_t flush(asio::error_code& ec) *\/",
        "query_nlx":"\/* Define a function named flush that takes an error code as a parameter and returns the size of the flushed data from the next layer of a stream implementation.\n   >>> flush(error_code) returns the size of the flushed data from the next layer of the stream implementation *\/ \nsize_t flush(asio::error_code& ec) { "
    }

    {
        "file_name":"buffered_stream_function_5.cpp",
        "line_count":4,
        "code":"size_t write_some(const ConstBufferSequence& buffers)\n  {\n    return stream_impl_.write_some(buffers);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Write some data from a buffer sequence to a stream implementation.\n   >>> write_some(const ConstBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function called write_some that takes a constant buffer sequence as input and returns the size of the data written to a stream implementation.\n   >>> write_some(const ConstBufferSequence& buffers) *\/"
    }

    {
        "file_name":"buffered_stream_function_7.cpp",
        "line_count":4,
        "code":"size_t fill()\n  {\n    return stream_impl_.fill();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the size of the stream after filling it.\n   >>> fill()  *\/ \nsize_t fill();",
        "query_nlx":"\/* Define a function that returns the size of a stream by calling a method from an internal stream implementation.\n   >>> fill() returns the size of the stream.\n*\/ \nsize_t fill() {"
    }

    {
        "file_name":"buffered_stream_function_8.cpp",
        "line_count":4,
        "code":"size_t fill(asio::error_code& ec)\n  {\n    return stream_impl_.fill(ec);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the amount of data filled into a stream implementation while handling any errors that may occur.\n   >>> size_t fill(asio::error_code& ec) *\/",
        "query_nlx":"\/* Define a function that fills a stream implementation with error handling support.\n   >>> fill() returns the size of the filled stream implementation with the provided error code. *\/ \nsize_t fill(asio::error_code& ec) { "
    }

    {
        "file_name":"buffered_stream_function_9.cpp",
        "line_count":4,
        "code":"size_t read_some(const MutableBufferSequence& buffers)\n  {\n    return stream_impl_.read_some(buffers);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Read some data from a stream and store it in the provided buffer sequence. \n   >>> size_t read_some(const MutableBufferSequence& buffers) *\/",
        "query_nlx":"\/* Define a function called read_some that takes a sequence of mutable buffers as input and returns the size read from the stream implementation.\n   >>> read_some(buffers) size_t *\/"
    }

    {
        "file_name":"buffered_stream_storage_function_1.cpp",
        "line_count":5,
        "code":"void clear()\n  {\n    begin_offset_ = 0;\n    end_offset_ = 0;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the begin and end offsets to zero.\n   >>> clear() *\/ \nvoid clear() { \n    \/\/ function body omitted\n}",
        "query_nlx":"\/* Function named clear sets the begin and end offsets to zero.\n>>> clear()\n*\/ \nvoid clear() {"
    }

    {
        "file_name":"buffered_stream_storage_function_4.cpp",
        "line_count":7,
        "code":"void consume(size_type count)\n  {\n    ASIO_ASSERT(begin_offset_ + count <= end_offset_);\n    begin_offset_ += count;\n    if (empty())\n      clear();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Consume a specified number of items from a collection, adjusting the beginning offset accordingly.\n   >>> consume(size_type count) *\/",
        "query_nlx":"\/* Function named consume updates the begin_offset_ value by adding the input count, ensuring it does not exceed the end_offset_ value. If the container is empty after the update, it is cleared.\n   >>> consume(5)\n   >>> consume(10) *\/ \nvoid consume(size_type count) { "
    }

    {
        "file_name":"buffer_sequence_adapter_function_3.cpp",
        "line_count":4,
        "code":"void init_iov_base(void*& base, void* addr)\n  {\n    base = addr;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the base pointer to the provided address.\n   >>> init_iov_base(void*& base, void* addr){ *\/",
        "query_nlx":"\/* Define a function called init_iov_base that takes in a reference to a void pointer base and a void pointer addr as parameters. This function initializes the base pointer to point to the memory address specified by addr.\n>>> init_iov_base(void*& base, void* addr) *\/"
    }

    {
        "file_name":"buffer_sequence_adapter_function_47.cpp",
        "line_count":4,
        "code":"bool all_empty(const boost::array<Elem, 2>& buffer_sequence)\n  {\n    return buffer_sequence[0].size() == 0 && buffer_sequence[1].size() == 0;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if both elements in a sequence are empty.\n>>> bool all_empty(const boost::array<Elem, 2>& buffer_sequence) *\/",
        "query_nlx":"\/* Function named all_empty checks if both elements in a given buffer sequence have a size of 0.\n   >>> all_empty({{elem1, elem2}}) true\n   >>> all_empty({{elem1, elem2}}) false *\/ \nbool all_empty(const boost::array<Elem, 2>& buffer_sequence) { "
    }

    {
        "file_name":"buffer_sequence_adapter_function_52.cpp",
        "line_count":4,
        "code":"bool all_empty(const std::array<Elem, 2>& buffer_sequence)\n  {\n    return buffer_sequence[0].size() == 0 && buffer_sequence[1].size() == 0;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if both elements in a sequence are empty.\n>>> bool all_empty(const std::array<Elem, 2>& buffer_sequence) *\/",
        "query_nlx":"\/* Function named all_empty checks if both elements in a given array of elements have a size of 0.\n   >>> all_empty({elem1, elem2}) true\n   >>> all_empty({elem1, elem2}) false *\/ \nbool all_empty(const std::array<Elem, 2>& buffer_sequence) { "
    }

    {
        "file_name":"buffer_sequence_adapter_function_7.cpp",
        "line_count":6,
        "code":"bool all_empty(const Buffers& buffer_sequence)\n  {\n    return buffer_sequence_adapter::all_empty(\n        asio::buffer_sequence_begin(buffer_sequence),\n        asio::buffer_sequence_end(buffer_sequence));\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if all buffers in the buffer sequence are empty.\n   >>> bool all_empty(const Buffers& buffer_sequence) *\/",
        "query_nlx":"\/* Function named all_empty checks if all buffers in a given buffer sequence are empty.\n   >>> all_empty({buffer1, buffer2, buffer3}) true\n   >>> all_empty({buffer1, buffer2, buffer3}) false *\/\nbool all_empty(const Buffers& buffer_sequence) { "
    }

    {
        "file_name":"buffer_sequence_adapter_function_8.cpp",
        "line_count":6,
        "code":"void validate(const Buffers& buffer_sequence)\n  {\n    buffer_sequence_adapter::validate(\n        asio::buffer_sequence_begin(buffer_sequence),\n        asio::buffer_sequence_end(buffer_sequence));\n  }",
        "mark":8.0,
        "query_nsx":"\/* Validate a sequence of buffers by passing it to a buffer sequence adapter function. \n   >>> validate(const Buffers& buffer_sequence) *\/",
        "query_nlx":"\/* Function named validate takes a sequence of buffers and validates them using a buffer sequence adapter. \n>>> validate({buffer1, buffer2, buffer3}) *\/ \nvoid validate(const Buffers& buffer_sequence) { "
    }

    {
        "file_name":"buffer_sequence_adapter_function_9.cpp",
        "line_count":6,
        "code":"Buffer first(const Buffers& buffer_sequence)\n  {\n    return buffer_sequence_adapter::first(\n        asio::buffer_sequence_begin(buffer_sequence),\n        asio::buffer_sequence_end(buffer_sequence));\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the first element of a buffer sequence.\n   >>> first(const Buffers& buffer_sequence) *\/",
        "query_nlx":"\/* Function named first retrieves the first buffer from a sequence of buffers provided in a buffer_sequence container.\n>>> first({buffer1, buffer2, buffer3}) buffer1\n>>> first({bufferA, bufferB, bufferC, bufferD}) bufferA *\/ \nBuffer first(const Buffers& buffer_sequence) { "
    }

    {
        "file_name":"BuildWriter_function_2.cpp",
        "line_count":19,
        "code":"StringView getExtension(RenderItem::Type type)\n        {\n            switch (type)\n            {\n            case RenderItem::CppFile: {\n                return \".cpp\";\n            }\n            case RenderItem::CFile: {\n                return \".c\";\n            }\n            case RenderItem::ObjCFile: {\n                return \".m\";\n            }\n            case RenderItem::ObjCppFile: {\n                return \".mm\";\n            }\n            default: return StringView();\n            }\n        }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the file extension based on the type of render item.\n   >>> StringView getExtension(RenderItem::Type type) { *\/",
        "query_nlx":"        \/* Function named getExtension takes a RenderItem type and returns the corresponding file extension.\n        >>> getExtension(RenderItem::CppFile) returns \".cpp\"\n        >>> getExtension(RenderItem::CFile) returns \".c\"\n        >>> getExtension(RenderItem::ObjCFile) returns \".m\"\n        >>> getExtension(RenderItem::ObjCppFile) returns \".mm\"\n        >>> getExtension(RenderItem::UnknownType) returns an empty string *\/ \n        StringView getExtension(RenderItem::Type type) {"
    }

    {
        "file_name":"Build_function_1.cpp",
        "line_count":12,
        "code":"StringView toString(Type type)\n    {\n        switch (type)\n        {\n        case Unknown: return \"unknown\";\n        case Windows: return \"windows\";\n        case Apple: return \"apple\";\n        case Linux: return \"linux\";\n        case Wasm: return \"wasm\";\n        }\n        Assert::unreachable();\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Convert a given type to a corresponding string representation.\n        >>> StringView toString(Type type) { *\/",
        "query_nlx":"\/* Function named toString converts a given type into a corresponding string representation based on the type.\n>>> toString(Unknown) returns \"unknown\"\n>>> toString(Windows) returns \"windows\"\n>>> toString(Apple) returns \"apple\"\n>>> toString(Linux) returns \"linux\"\n>>> toString(Wasm) returns \"wasm\" *\/ \nStringView toString(Type type) {"
    }

    {
        "file_name":"Build_function_10.cpp",
        "line_count":9,
        "code":"bool addFrameworks(Span<const StringView> frameworks, PlatformApple appleOS = PlatformApple::Any)\n    {\n        switch (appleOS)\n        {\n        case PlatformApple::macOS: return getOrCreate<Link::linkFrameworksMacOS>()->append(frameworks);\n        case PlatformApple::iOS: return getOrCreate<Link::linkFrameworksIOS>()->append(frameworks);\n        default: return getOrCreate<Link::linkFrameworksAny>()->append(frameworks);\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Append a list of frameworks to the appropriate platform-specific framework list based on the specified Apple operating system.\n   >>> bool addFrameworks(Span<const StringView> frameworks, PlatformApple appleOS = PlatformApple::Any) { *\/",
        "query_nlx":"        \/* Function addFrameworks appends a list of frameworks to the corresponding platform-specific framework list based on the specified Apple operating system.\n        >>> addFrameworks({\"Framework1\", \"Framework2\"}, PlatformApple::macOS)\n        >>> addFrameworks({\"Framework3\", \"Framework4\"}, PlatformApple::iOS)\n        >>> addFrameworks({\"Framework5\", \"Framework6\"})\n        *\/ \n        bool addFrameworks(Span<const StringView> frameworks, PlatformApple appleOS = PlatformApple::Any) { "
    }

    {
        "file_name":"Build_function_11.cpp",
        "line_count":4,
        "code":"bool addLibraries(Span<const StringView> libraries)\n    {\n        return getOrCreate<Link::linkLibraries>()->append(libraries);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Add libraries to the existing list of libraries for linking.\n   >>> addLibraries({\"lib1\", \"lib2\", \"lib3\"}) true\n   >>> addLibraries({\"lib4\"}) true *\/ \nbool addLibraries(Span<const StringView> libraries) { ",
        "query_nlx":"        \/* Function named addLibraries takes a list of library names and adds them to the existing list of libraries for linking. \n        >>> addLibraries({\"lib1\", \"lib2\", \"lib3\"}) true \n        >>> addLibraries({\"lib4\", \"lib5\"}) true *\/ \n        bool addLibraries(Span<const StringView> libraries) { "
    }

    {
        "file_name":"Build_function_12.cpp",
        "line_count":11,
        "code":"StringView PresetToString(Preset preset)\n    {\n        switch (preset)\n        {\n        case Configuration::Preset::Debug: return \"Debug\";\n        case Configuration::Preset::DebugCoverage: return \"DebugCoverage\";\n        case Configuration::Preset::Release: return \"Release\";\n        case Configuration::Preset::None: return \"None\";\n        }\n        Assert::unreachable();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given preset configuration to a corresponding string representation.\n   >>> StringView PresetToString(Preset preset); *\/",
        "query_nlx":"\/* Function named PresetToString converts a given preset configuration into a corresponding string representation. The function handles different preset cases such as Debug, DebugCoverage, Release, and None, returning the respective string representation for each case. \n>>> PresetToString(Configuration::Preset::Debug) \"Debug\" \n>>> PresetToString(Configuration::Preset::Release) \"Release\" \n>>> PresetToString(Configuration::Preset::None) \"None\" *\/ \nStringView PresetToString(Preset preset) {"
    }

    {
        "file_name":"Build_function_2.cpp",
        "line_count":12,
        "code":"StringView toString(Type type)\n    {\n        switch (type)\n        {\n        case Any: return \"Any\";\n        case Intel32: return \"Intel32\";\n        case Intel64: return \"Intel64\";\n        case Arm64: return \"Arm64\";\n        case Wasm: return \"Wasm\";\n        }\n        Assert::unreachable();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given type to a corresponding string representation.\n   >>> StringView toString(Type type) { *\/",
        "query_nlx":"\/* Function named toString converts a given type into a corresponding string representation. The types include Any, Intel32, Intel64, Arm64, and Wasm.\n>>> toString(Any) returns \"Any\"\n>>> toString(Intel32) returns \"Intel32\"\n>>> toString(Intel64) returns \"Intel64\"\n>>> toString(Arm64) returns \"Arm64\"\n>>> toString(Wasm) returns \"Wasm\" *\/ \nStringView toString(Type type) {"
    }

    {
        "file_name":"Build_function_6.cpp",
        "line_count":4,
        "code":"bool addIncludes(Span<const StringView> includes)\n    {\n        return getOrCreate<Compile::includePaths>()->append(includes);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Append a list of file paths to the existing include paths for compilation.\n   >>> addIncludes(Span<const StringView> includes) bool *\/",
        "query_nlx":"\/* Function named addIncludes appends a list of string views to a collection of include paths and returns a boolean value.\n   >>> addIncludes({\"path1\", \"path2\", \"path3\"}) true\n   >>> addIncludes({\"header1\", \"header2\"}) false *\/ \nbool addIncludes(Span<const StringView> includes) { "
    }

    {
        "file_name":"Build_function_7.cpp",
        "line_count":4,
        "code":"bool addDefines(Span<const StringView> defines)\n    {\n        return getOrCreate<Compile::preprocessorDefines>()->append(defines);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Add the provided string defines to the list of preprocessor defines if they do not already exist.\n   >>> addDefines({\"DEBUG\", \"ENABLE_LOGGING\"}) true\n   >>> addDefines({\"ENABLE_LOGGING\"}) false *\/ \nbool addDefines(Span<const StringView> defines);",
        "query_nlx":"\/* Function named addDefines appends a list of string defines to a preprocessor defines container if it exists, otherwise creates a new one and appends the defines to it.\n>>> addDefines({\"DEFINE1\", \"DEFINE2\", \"DEFINE3\"}) true\n>>> addDefines({\"DEFINE4\"}) false *\/ \nbool addDefines(Span<const StringView> defines) { *\/"
    }

    {
        "file_name":"Build_function_8.cpp",
        "line_count":16,
        "code":"StringView typeToString(Type type)\n    {\n        switch (type)\n        {\n        case libraryPaths: return \"libraryPaths\";\n        case linkFrameworksAny: return \"linkFrameworksAny\";\n        case linkFrameworksMacOS: return \"linkFrameworksMacOS\";\n        case linkFrameworksIOS: return \"linkFrameworksIOS\";\n        case linkLibraries: return \"linkLibraries\";\n        case guiApplication: return \"guiApplication\";\n        case enableLTO: return \"enableLTO\";\n        case enableASAN: return \"enableASAN\";\n        case enableStdCpp: return \"enableStdCpp\";\n        }\n        Assert::unreachable();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given type to a corresponding string representation.\n   >>> StringView typeToString(Type type); *\/",
        "query_nlx":"\/* Define a function that converts a given type to a corresponding string representation based on predefined cases.\n   >>> typeToString(libraryPaths) returns \"libraryPaths\"\n   >>> typeToString(linkFrameworksAny) returns \"linkFrameworksAny\"\n   >>> typeToString(enableStdCpp) returns \"enableStdCpp\" *\/ \nStringView typeToString(Type type) {"
    }

    {
        "file_name":"Build_function_9.cpp",
        "line_count":4,
        "code":"bool addSearchPath(Span<const StringView> libraries)\n    {\n        return getOrCreate<Link::libraryPaths>()->append(libraries);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Add search paths for libraries to the existing list of library paths.\n   >>> addSearchPath(libraries: Span<const StringView>) -> bool *\/",
        "query_nlx":"\/* Function named addSearchPath takes a list of library names and adds them to the existing library paths for linking.\n>>> addSearchPath({\"lib1\", \"lib2\", \"lib3\"}) true\n>>> addSearchPath({\"lib4\", \"lib5\"}) true *\/ \nbool addSearchPath(Span<const StringView> libraries) { *\/"
    }

    {
        "file_name":"cancellation_signal_function_2.cpp",
        "line_count":5,
        "code":"void emit(cancellation_type_t type)\n  {\n    if (handler_)\n      handler_->call(type);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Emit a cancellation signal of a specific type if a handler is available.\n   >>> void emit(cancellation_type_t type) *\/",
        "query_nlx":"\/* Define a function called emit that takes a cancellation type as input and calls a handler function if it exists.\n   >>> emit(CANCELLATION_TYPE_SOFT) calls the handler function if it is set.\n   >>> emit(CANCELLATION_TYPE_HARD) does nothing if the handler function is not set. *\/\nvoid emit(cancellation_type_t type) { *\/"
    }

    {
        "file_name":"Car_function_2.cpp",
        "line_count":11,
        "code":"Value toJSI(jsi::Runtime& runtime, const Car& arg) {\n      jsi::Object obj(runtime);\n      obj.setProperty(runtime, \"year\", JSIConverter<double>::toJSI(runtime, arg.year));\n      obj.setProperty(runtime, \"make\", JSIConverter<std::string>::toJSI(runtime, arg.make));\n      obj.setProperty(runtime, \"model\", JSIConverter<std::string>::toJSI(runtime, arg.model));\n      obj.setProperty(runtime, \"power\", JSIConverter<double>::toJSI(runtime, arg.power));\n      obj.setProperty(runtime, \"powertrain\", JSIConverter<Powertrain>::toJSI(runtime, arg.powertrain));\n      obj.setProperty(runtime, \"driver\", JSIConverter<std::optional<Person>>::toJSI(runtime, arg.driver));\n      obj.setProperty(runtime, \"isFast\", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.isFast));\n      return obj;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert a Car object into a JavaScript object with specific properties.\n   >>> Value toJSI(jsi::Runtime& runtime, const Car& arg) { *\/",
        "query_nlx":"\/* Function to convert a Car object into a JavaScript object with specific properties such as year, make, model, power, powertrain, driver, and isFast.\n>>> toJSI(runtime, arg) returns a JavaScript object with properties year, make, model, power, powertrain, driver, and isFast based on the input Car object arg *\/"
    }

    {
        "file_name":"Car_function_3.cpp",
        "line_count":14,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isObject()) {\n        return false;\n      }\n      jsi::Object obj = value.getObject(runtime);\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"year\"))) return false;\n      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, \"make\"))) return false;\n      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, \"model\"))) return false;\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"power\"))) return false;\n      if (!JSIConverter<Powertrain>::canConvert(runtime, obj.getProperty(runtime, \"powertrain\"))) return false;\n      if (!JSIConverter<std::optional<Person>>::canConvert(runtime, obj.getProperty(runtime, \"driver\"))) return false;\n      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, \"isFast\"))) return false;\n      return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the provided object contains all necessary properties for converting to specific data types.\n   >>> bool canConvert(Runtime& runtime, const Value& value) { *\/",
        "query_nlx":"        \/* Function named canConvert checks if the provided object contains specific properties that can be converted to certain data types. \n        >>> canConvert({object}, \"year\", \"make\", \"model\", \"power\", \"powertrain\", \"driver\", \"isFast\") true *\/ \n        bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {"
    }

    {
        "file_name":"ChannelView_function_1.cpp",
        "line_count":4,
        "code":"int GetProfileBorderSize()\n{\n\treturn ScaleByDPI(Supports32BitIcons() ? (PROFILE_PICTURE_SIZE_DEF + 12) : 64);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of the profile border based on the support for 32-bit icons and a default profile picture size.\n>>> int GetProfileBorderSize() *\/",
        "query_nlx":"\/* Determine the size of the profile border based on whether the system supports 32-bit icons. If it does, calculate the size as the default profile picture size plus 12; otherwise, set it to 64.\n   >>> GetProfileBorderSize() returns an integer value representing the profile border size. *\/ \nint GetProfileBorderSize() { "
    }

    {
        "file_name":"ChannelView_function_4.cpp",
        "line_count":4,
        "code":"bool IsChannelASubThread(Channel::eChannelType x)\n{\n\treturn x >= Channel::NEWSTHREAD && x < Channel::FORUM;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given channel type falls within the range of new threads but not including forums.\n>>> bool IsChannelASubThread(Channel::eChannelType x) *\/",
        "query_nlx":"\/* Function named IsChannelASubThread determines if a given channel type is within the range of new threads and forums.\n>>> IsChannelASubThread(Channel::NEWSTHREAD) true\n>>> IsChannelASubThread(Channel::FORUM) false *\/ \nbool IsChannelASubThread(Channel::eChannelType x) { "
    }

    {
        "file_name":"channel_error_function_1.cpp",
        "line_count":5,
        "code":"error_code make_error_code(channel_errors e)\n{\n  return asio::error_code(\n      static_cast<int>(e), get_channel_category());\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an error code based on the specified channel error.\n>>> error_code make_error_code(channel_errors e) { *\/",
        "query_nlx":"\/* Create an error code based on the given channel_errors enumeration value by converting it to an integer and associating it with the channel category.\n>>> make_error_code(channel_errors e) error_code *\/"
    }

    {
        "file_name":"channel_payload_function_2.cpp",
        "line_count":4,
        "code":"void receive(Handler& handler)\n  {\n    message_.receive(handler);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Receive a message using the provided handler.\n   >>> void receive(Handler& handler) *\/",
        "query_nlx":"\/* Function named receive calls the receive function of a handler object to process a message.\n   >>> receive(handler) *\/ \nvoid receive(Handler& handler) {"
    }

    {
        "file_name":"channel_payload_function_3.cpp",
        "line_count":8,
        "code":"void receive(Handler& handler)\n  {\n    std::visit(\n        [&](auto& message)\n        {\n          message.receive(handler);\n        }, message_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Receive a message and pass it to a handler for processing.\n   >>> void receive(Handler& handler) *\/",
        "query_nlx":"\/* Implement a function that receives a handler and uses std::visit to call the receive function on the message stored in the message_ variant.\n   >>> receive(handler) *\/ \nvoid receive(Handler& handler) {"
    }

    {
        "file_name":"channel_service_function_17.cpp",
        "line_count":4,
        "code":"payload_type buffer_front()\n  {\n    return payload_type({0, first_.value_});\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the front element of a buffer as a payload type.\n   >>> payload_type buffer_front() { *\/",
        "query_nlx":"\/* Define a function named buffer_front that returns a payload_type containing a pair of values, where the first value is 0 and the second value is the value of the first element in the buffer.\n   >>> buffer_front() returns a payload_type with values {0, first_.value_} *\/ \npayload_type buffer_front() {"
    }

    {
        "file_name":"channel_service_function_4.cpp",
        "line_count":7,
        "code":"size_t buffer_push_n(std::size_t count, payload_type payload)\n  {\n    std::size_t i = 0;\n    for (; i < count && buffer_.size() < this->max_buffer_size_; ++i)\n      buffer_.push_back(payload);\n    return i;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Push a specified number of elements into a buffer until the buffer reaches its maximum size.\n   >>> size_t buffer_push_n(std::size_t count, payload_type payload); *\/",
        "query_nlx":"\/* Function named buffer_push_n adds a specified payload to a buffer a certain number of times, up to a maximum buffer size. \n>>> buffer_push_n(count: size_t, payload: payload_type) -> size_t *\/"
    }

    {
        "file_name":"channel_service_function_5.cpp",
        "line_count":4,
        "code":"payload_type buffer_front()\n  {\n    return ASIO_MOVE_CAST(payload_type)(buffer_.front());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the front element of a buffer and return it.\n   >>> payload_type buffer_front() *\/",
        "query_nlx":"\/* Define a function named buffer_front that returns the front element of the buffer after applying a specific operation to it.\n>>> buffer_front() payload_type *\/"
    }

    {
        "file_name":"channel_service_function_6.cpp",
        "line_count":4,
        "code":"void buffer_pop()\n  {\n    buffer_.pop_front();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Remove the first element from a buffer.\n   >>> buffer_pop() *\/ \nvoid buffer_pop() {",
        "query_nlx":"\/* Function named buffer_pop removes the first element from a buffer.\n>>> buffer_pop()\n*\/ \nvoid buffer_pop() {  \/\/ Function declaration for removing the first element from a buffer."
    }

    {
        "file_name":"channel_service_function_7.cpp",
        "line_count":4,
        "code":"void buffer_clear()\n  {\n    buffer_.clear();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Clear the buffer by removing all its contents.\n   >>> buffer_clear() *\/ \nvoid buffer_clear() {",
        "query_nlx":"\/* Function named buffer_clear clears the contents of a buffer. \n>>> buffer_clear() *\/ \nvoid buffer_clear() { \n    buffer_.clear(); \n}"
    }

    {
        "file_name":"chrono_time_traits_function_4.cpp",
        "line_count":4,
        "code":"bool less_than(const time_type& t1, const time_type& t2)\n  {\n    return t1 < t2;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the first time is less than the second time.\n   >>> less_than(t1, t2) true\n   >>> less_than(t2, t1) false *\/ \nbool less_than(const time_type& t1, const time_type& t2) { ",
        "query_nlx":"\/* Function named less_than compares two time values to determine if the first time is less than the second time.\n   >>> less_than(10:30 AM, 2:00 PM) true\n   >>> less_than(8:00 PM, 8:00 AM) false *\/ \nbool less_than(const time_type& t1, const time_type& t2) { "
    }

    {
        "file_name":"client_endpoint_function_1.cpp",
        "line_count":18,
        "code":"connection_ptr get_connection(uri_ptr location, lib::error_code & ec) {\n        if (location->get_secure() && !transport_type::is_secure()) {\n            ec = error::make_error_code(error::endpoint_not_secure);\n            return connection_ptr();\n        }\n\n        connection_ptr con = endpoint_type::create_connection();\n\n        if (!con) {\n            ec = error::make_error_code(error::con_creation_failed);\n            return con;\n        }\n\n        con->set_uri(location);\n\n        ec = lib::error_code();\n        return con;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Create a connection based on the provided location, handling secure and non-secure endpoints appropriately.\n   >>> connection_ptr get_connection(uri_ptr location, lib::error_code & ec) { *\/",
        "query_nlx":"        \/* Function named get_connection retrieves a connection based on a given URI location, handling secure connections and potential errors. \n        >>> get_connection(uri_ptr location, lib::error_code & ec) connection_ptr *\/"
    }

    {
        "file_name":"client_endpoint_function_2.cpp",
        "line_count":10,
        "code":"connection_ptr get_connection(std::string const & u, lib::error_code & ec) {\n        uri_ptr location = lib::make_shared<uri>(u);\n\n        if (!location->get_valid()) {\n            ec = error::make_error_code(error::invalid_uri);\n            return connection_ptr();\n        }\n\n        return get_connection(location, ec);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a connection based on a provided URI after validating its correctness.\n   >>> connection_ptr get_connection(std::string const & u, lib::error_code & ec) { *\/",
        "query_nlx":"\/* Function named get_connection retrieves a connection pointer based on a given URI string and error code. If the URI is not valid, it sets the error code to indicate an invalid URI and returns a null connection pointer.\n>>> get_connection(\"example.com\/api\/data\", ec) returns a connection pointer\n>>> get_connection(\"invalid_uri\", ec) returns a null connection pointer *\/ \nconnection_ptr get_connection(std::string const & u, lib::error_code & ec) {"
    }

    {
        "file_name":"client_endpoint_function_4.cpp",
        "line_count":13,
        "code":"void handle_connect(connection_ptr con, lib::error_code const & ec) {\n        if (ec) {\n            con->terminate(ec);\n\n            endpoint_type::m_elog->write(log::elevel::rerror,\n                    \"handle_connect error: \"+ec.message());\n        } else {\n            endpoint_type::m_alog->write(log::alevel::connect,\n                \"Successful connection\");\n\n            con->start();\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Handle connection status and perform necessary actions based on success or failure.\n   >>> void handle_connect(connection_ptr con, lib::error_code const & ec) { *\/",
        "query_nlx":"\/* Function named handle_connect takes a connection pointer and an error code as input parameters. It handles the connection based on the error code received. If there is an error (ec), it terminates the connection and logs the error message. If there is no error, it logs a successful connection message and starts the connection.\n>>> handle_connect(connection_ptr con, lib::error_code const & ec) *\/"
    }

    {
        "file_name":"ColorTransform_function_13.cpp",
        "line_count":10,
        "code":"LinearImage toLinearFromRGBM( filament::math::float4 const* src, uint32_t w, uint32_t h) {\n    LinearImage result(w, h, 3);\n    auto dst = result.get< filament::math::float3>();\n    for (uint32_t row = 0; row < h; ++row) {\n        for (uint32_t col = 0; col < w; ++col, ++src, ++dst) {\n            *dst = RGBMtoLinear(*src);\n        }\n    }\n    return result;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert an array of RGBA values to linear color space and store the result in a linear image.\n>>> LinearImage toLinearFromRGBM( filament::math::float4 const* src, uint32_t w, uint32_t h) { *\/",
        "query_nlx":"        \/* Function named toLinearFromRGBM converts an array of RGBA values to linear color space using RGBM encoding.\n        >>> toLinearFromRGBM(filament::math::float4 const* src, uint32_t w, uint32_t h) LinearImage *\/"
    }

    {
        "file_name":"ColorTransform_function_14.cpp",
        "line_count":13,
        "code":"LinearImage fromLinearToRGBM(const LinearImage& image) {\n    assert(image.getChannels() == 3);\n    const uint32_t w = image.getWidth(), h = image.getHeight();\n    LinearImage result(w, h, 4);\n    auto src = image.get< filament::math::float3>();\n    auto dst = result.get< filament::math::float4>();\n    for (uint32_t row = 0; row < h; ++row) {\n        for (uint32_t col = 0; col < w; ++col, ++src, ++dst) {\n            *dst = linearToRGBM(*src);\n        }\n    }\n    return result;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a linear image with 3 channels to an RGBM image with 4 channels.\n   >>> LinearImage fromLinearToRGBM(const LinearImage& image); *\/",
        "query_nlx":"\/* Function named fromLinearToRGBM converts a linear image with 3 channels to an RGBM image with 4 channels by applying a specific transformation to each pixel.\n>>> fromLinearToRGBM(LinearImage image) LinearImage *\/"
    }

    {
        "file_name":"ColorTransform_function_4.cpp",
        "line_count":15,
        "code":"float3 linearTosRGB(const T& linear) {\n    using filament::math::float3;\n    constexpr float a = 0.055f;\n    constexpr float a1 = 1.055f;\n    constexpr float p = 1 \/ 2.4f;\n    float3 sRGB;\n    for (size_t i=0 ; i<3 ; i++) {\n        if (linear[i] <= 0.0031308f) {\n            sRGB[i] = linear[i] * 12.92f;\n        } else {\n            sRGB[i] = a1 * std::pow(linear[i], p) - a;\n        }\n    }\n    return sRGB;\n}",
        "mark":8.25,
        "query_nsx":"\/* Convert linear color values to sRGB color space values.\n>>> float3 linearTosRGB(const T& linear) { *\/",
        "query_nlx":"        \/* Function named linearTosRGB converts linear RGB values to sRGB color space using a specific formula.\n        >>> linearTosRGB({0.5, 0.3, 0.8}) { \n        float3 linearTosRGB(const T& linear) { *\/"
    }

    {
        "file_name":"ColorTransform_function_5.cpp",
        "line_count":10,
        "code":"float linearTosRGB(float linear) {\n    if (linear <= 0.0031308f) {\n        return linear * 12.92f;\n    } else {\n        constexpr float a = 0.055f;\n        constexpr float a1 = 1.055f;\n        constexpr float p = 1 \/ 2.4f;\n        return a1 * std::pow(linear, p) - a;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert linear color values to sRGB color space.\n>>> float linearTosRGB(float linear) { *\/",
        "query_nlx":"\/* Function named linearTosRGB converts a linear RGB value to sRGB color space.\n>>> linearTosRGB(0.5) returns 6.46\n>>> linearTosRGB(0.003) returns 0.0392 *\/ \nfloat linearTosRGB(float linear) { "
    }

    {
        "file_name":"ColorTransform_function_7.cpp",
        "line_count":16,
        "code":"float4 sRGBToLinear(const filament::math::float4& sRGB) {\n    using filament::math::float4;\n    constexpr float a = 0.055f;\n    constexpr float a1 = 1.055f;\n    constexpr float p = 2.4f;\n    float4 linear;\n    for (size_t i=0 ; i<3 ; i++) {\n        if (sRGB[i] <= 0.04045f) {\n            linear[i] = sRGB[i] * (1.0f \/ 12.92f);\n        } else {\n            linear[i] = std::pow((sRGB[i] + a) \/ a1, p);\n        }\n    }\n    linear[3] = sRGB[3];\n    return linear;\n}",
        "mark":8.25,
        "query_nsx":"\/* Convert sRGB color values to linear color space.\n>>> float4 sRGBToLinear(const float4& sRGB) *\/",
        "query_nlx":"        \/* Convert sRGB color values to linear color space using a specific formula for each channel.\n        >>> sRGBToLinear(filament::math::float4 sRGB) float4 { *\/"
    }

    {
        "file_name":"Compiler_function_1.cpp",
        "line_count":6,
        "code":"void swap(T& t1, T& t2)\n{\n    T temp = move(t1);\n    t1     = move(t2);\n    t2     = move(temp);\n}",
        "mark":8.0,
        "query_nsx":"\/* Swap the values of two variables of the same type.\n>>> void swap(T& t1, T& t2) *\/",
        "query_nlx":"\/* Function named swap takes two input parameters of type T and swaps their values. \n>>> swap(5, 10) \n>>> swap(\"hello\", \"world\") *\/ \nvoid swap(T& t1, T& t2) { "
    }

    {
        "file_name":"completion_condition_function_1.cpp",
        "line_count":4,
        "code":"size_t adapt_completion_condition_result(bool result)\n{\n  return result ? 0 : default_max_transfer_size;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the adaptation completion condition result based on a boolean value.\n   >>> adapt_completion_condition_result(true) 0\n   >>> adapt_completion_condition_result(false) default_max_transfer_size *\/ \nsize_t adapt_completion_condition_result(bool result) {",
        "query_nlx":"\/* Define a function that adapts the completion condition result based on a boolean input value.\n   >>> adapt_completion_condition_result(true) 0\n   >>> adapt_completion_condition_result(false) default_max_transfer_size *\/ \nsize_t adapt_completion_condition_result(bool result) {"
    }

    {
        "file_name":"completion_condition_function_2.cpp",
        "line_count":4,
        "code":"size_t adapt_completion_condition_result(std::size_t result)\n{\n  return result;\n}",
        "mark":8.0,
        "query_nsx":"\/* Return the result of adapting the completion condition.\n>>> adapt_completion_condition_result(std::size_t result) *\/",
        "query_nlx":"\/* Define a function that adapts the completion condition result by taking a single unsigned integer input and returning it as a size_t value.\n>>> adapt_completion_condition_result(10) 10\n>>> adapt_completion_condition_result(0) 0\n*\/ \nsize_t adapt_completion_condition_result(std::size_t result) {"
    }

    {
        "file_name":"completion_condition_function_3.cpp",
        "line_count":4,
        "code":"transfer_all_t transfer_all()\n{\n  return detail::transfer_all_t();\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a transfer function that transfers all elements from one location to another.\n>>> transfer_all_t transfer_all() *\/",
        "query_nlx":"\/* Define a function named transfer_all that returns an object of type transfer_all_t from the detail namespace. \n   >>> transfer_all() returns a transfer_all_t object *\/ \ntransfer_all_t transfer_all() { "
    }

    {
        "file_name":"completion_condition_function_4.cpp",
        "line_count":4,
        "code":"transfer_at_least_t transfer_at_least(std::size_t minimum)\n{\n  return detail::transfer_at_least_t(minimum);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a transfer function that ensures at least a specified minimum size is transferred.\n>>> transfer_at_least(std::size_t minimum) transfer_at_least_t(minimum) { *\/",
        "query_nlx":"\/* Define a function called transfer_at_least that returns a transfer_at_least_t object with a minimum size specified.\n   >>> transfer_at_least(10) returns a transfer_at_least_t object with a minimum size of 10. *\/ \ntransfer_at_least_t transfer_at_least(std::size_t minimum) { "
    }

    {
        "file_name":"completion_condition_function_5.cpp",
        "line_count":4,
        "code":"transfer_exactly_t transfer_exactly(std::size_t size)\n{\n  return detail::transfer_exactly_t(size);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a transfer object with a specified size.\n>>> transfer_exactly(std::size_t size) *\/",
        "query_nlx":"\/* Define a function called transfer_exactly that returns an object of type transfer_exactly_t with a given size.\n   >>> transfer_exactly(10) returns an object of type transfer_exactly_t with a size of 10. *\/ \ntransfer_exactly_t transfer_exactly(std::size_t size) { "
    }

    {
        "file_name":"composed_work_function_3.cpp",
        "line_count":5,
        "code":"void reset()\n  {\n    head_.reset();\n    tail_.reset();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the head and tail elements. \n>>> reset() *\/ \nvoid reset() {",
        "query_nlx":"\/* Reset the head and tail elements of a data structure to their initial state.\n   >>> reset()\n   void reset() { *\/"
    }

    {
        "file_name":"composed_work_function_4.cpp",
        "line_count":4,
        "code":"void reset()\n  {\n    head_.reset();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the head of a data structure to its initial state.\n   >>> reset() *\/ \nvoid reset() { \n    head_.reset(); \n}",
        "query_nlx":"\/* Reset the head of a data structure to its initial state.\n   >>> reset()\n   void reset() { *\/"
    }

    {
        "file_name":"composed_work_function_5.cpp",
        "line_count":4,
        "code":"void reset()\n  {\n    head_.reset();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the head of a data structure. \n   >>> reset() *\/ \nvoid reset() { \n    head_.reset(); \n}",
        "query_nlx":"\/* Reset the head of an object to its initial state.\n   >>> reset()\n   void reset() { *\/"
    }

    {
        "file_name":"composed_work_function_6.cpp",
        "line_count":5,
        "code":"void reset()\n  {\n    head_.reset();\n    tail_.reset();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the head and tail elements.\n   >>> reset() *\/ \nvoid reset() {",
        "query_nlx":"\/* Reset the head and tail elements to their initial state.\n   >>> reset()\n*\/ \nvoid reset() {"
    }

    {
        "file_name":"conditionally_enabled_mutex_function_2.cpp",
        "line_count":8,
        "code":"void unlock()\n    {\n      if (locked_)\n      {\n        mutex_.unlock();\n        locked_ = false;\n      }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Unlock the mutex if it is currently locked.\n   >>> void unlock() *\/",
        "query_nlx":"\/* Function named unlock unlocks a mutex if it is currently locked.\n   >>> unlock() unlocks the mutex if it is locked *\/ \nvoid unlock() {"
    }

    {
        "file_name":"conditionally_enabled_mutex_function_4.cpp",
        "line_count":5,
        "code":"void unlock()\n  {\n    if (enabled_)\n      mutex_.unlock();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if the function unlocks a mutex if it is currently enabled.\n   >>> void unlock() *\/",
        "query_nlx":"\/* Define a function that unlocks a mutex if it is currently enabled.\n   >>> unlock() *\/ \nvoid unlock() {"
    }

    {
        "file_name":"confighttp_function_10.cpp",
        "line_count":4,
        "code":"void\n  getPinPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"pin.html\", true);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a specific webpage related to 'pin' functionality from a server response using HTTPS.\n   >>> getPinPage(resp_https_t response, req_https_t request) *\/",
        "query_nlx":"\/* Define a function called getPinPage that takes in a response object and a request object. \n   This function fetches a static page named \"pin.html\" and sets a flag to true indicating success. *\/\nvoid getPinPage(resp_https_t response, req_https_t request) { *\/"
    }

    {
        "file_name":"confighttp_function_12.cpp",
        "line_count":4,
        "code":"void\n  getConfigPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"config.html\", true);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the configuration page to display to the user.\n   >>> getConfigPage(resp_https_t response, req_https_t request) *\/",
        "query_nlx":"\/* Define a function named getConfigPage that retrieves and displays the static page \"config.html\" in response to a given request.\n>>> getConfigPage(response, request) *\/ \nvoid getConfigPage(resp_https_t response, req_https_t request) {"
    }

    {
        "file_name":"confighttp_function_13.cpp",
        "line_count":4,
        "code":"void\n  getPasswordPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"password.html\", true);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the password page by fetching the static page \"password.html\" using HTTPS. \n>>> getPasswordPage(resp_https_t response, req_https_t request) *\/",
        "query_nlx":"\/* Define a function that retrieves a static password page using HTTPS, given a response and request object. \n   >>> getPasswordPage(resp_https_t response, req_https_t request) *\/ \nvoid getPasswordPage(resp_https_t response, req_https_t request) {"
    }

    {
        "file_name":"confighttp_function_16.cpp",
        "line_count":4,
        "code":"void\n  getTroubleshootingPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"troubleshooting.html\", true);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the troubleshooting page for a given HTTPS response and request.\n   >>> getTroubleshootingPage(resp_https_t response, req_https_t request) *\/",
        "query_nlx":"\/* Define a function that retrieves a troubleshooting page using a given response and request, fetching the static page named \"troubleshooting.html\".\n   >>> getTroubleshootingPage(resp_https_t response, req_https_t request) *\/"
    }

    {
        "file_name":"confighttp_function_4.cpp",
        "line_count":17,
        "code":"string getCookieValue(const std::string& cookieString, const std::string& key) {\n    std::string keyWithEqual = key + \"=\";\n    std::size_t startPos = cookieString.find(keyWithEqual);\n\n    if (startPos == std::string::npos) {\n      return \"\";\n    }\n\n    startPos += keyWithEqual.length();\n    std::size_t endPos = cookieString.find(\";\", startPos);\n\n    if (endPos == std::string::npos) {\n      return cookieString.substr(startPos);\n    }\n\n    return cookieString.substr(startPos, endPos - startPos);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the value associated with a specific key from a given cookie string.\n   >>> string getCookieValue(const string& cookieString, const string& key) { *\/",
        "query_nlx":"\/* Function named getCookieValue retrieves the value associated with a specific key from a given cookie string. \n>>> getCookieValue(\"cookieString\", \"key\") returns the value associated with the key in the cookieString. *\/ \nstring getCookieValue(const std::string& cookieString, const std::string& key) {"
    }

    {
        "file_name":"confighttp_function_9.cpp",
        "line_count":4,
        "code":"void\n  getIndexPage(resp_https_t response, req_https_t request) {\n    fetchStaticPage(response, request, \"index.html\", true);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the index page by fetching the static page \"index.html\" for a given HTTPS response and request.\n   >>> getIndexPage(resp_https_t response, req_https_t request) *\/",
        "query_nlx":"\/* Define a function called getIndexPage that takes in a response object and a request object. \n   This function fetches the static page \"index.html\" and includes it in the response object. \n   The boolean parameter indicates whether the page should be cached or not. *\/\nvoid getIndexPage(resp_https_t response, req_https_t request) {"
    }

    {
        "file_name":"Config_function_1.cpp",
        "line_count":9,
        "code":"int64_t GetTicks()\n{\n    LARGE_INTEGER ticks;\n\n    if (!QueryPerformanceCounter(&ticks))\n        return 0;\n\n    return ticks.QuadPart;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the current system time in ticks for performance measurement purposes.\n>>> GetTicks() int64_t *\/",
        "query_nlx":"\/* Function named GetTicks retrieves the current system time in ticks. \n>>> GetTicks() returns the current system time in ticks. *\/ \nint64_t GetTicks() { "
    }

    {
        "file_name":"Config_function_2.cpp",
        "line_count":4,
        "code":"bool isInteger(const std::string& str, int& value) {\n    std::istringstream iss(str);\n    return (iss >> value) && iss.eof();\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given string represents an integer value. \n>>> bool isInteger(const std::string& str, int& value) { *\/",
        "query_nlx":"\/* Function named isInteger checks if a given string can be converted to an integer value. \n>>> isInteger(\"123\", value) true \n>>> isInteger(\"abc\", value) false *\/ \nbool isInteger(const std::string& str, int& value) {"
    }

    {
        "file_name":"Config_function_3.cpp",
        "line_count":4,
        "code":"bool isUInt(const std::string& str, uint32_t& value) {\n    std::istringstream iss(str);\n    return (iss >> value) && iss.eof();\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the input string represents an unsigned integer value. \n>>> bool isUInt(const std::string& str, uint32_t& value); *\/",
        "query_nlx":"\/* Function named isUInt checks if a given string represents an unsigned integer and extracts its value if it does. \n>>> isUInt(\"123\", value) true \n>>> isUInt(\"abc\", value) false *\/ \n#include<iostream> \n#include<sstream> \nusing namespace std; \nbool isUInt(const string& str, uint32_t& value) {"
    }

    {
        "file_name":"Config_function_4.cpp",
        "line_count":4,
        "code":"bool isFloat(const std::string& str, float& value) {\n    std::istringstream iss(str);\n    return (iss >> value) && iss.eof();\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given string can be converted to a floating-point number and retrieve the value if successful.\n>>> bool isFloat(const std::string& str, float& value) { *\/",
        "query_nlx":"\/* Function named isFloat checks if a given string can be converted to a floating-point number and stores the value in the provided variable. \n>>> isFloat(\"3.14\", value) true \n>>> isFloat(\"abc\", value) false *\/ \nbool isFloat(const std::string& str, float& value) {"
    }

    {
        "file_name":"Config_function_5.cpp",
        "line_count":7,
        "code":"string GetBoolValue(std::optional<bool> value)\n{\n    if (!value.has_value())\n        return \"auto\";\n\n    return value.value() ? \"true\" : \"false\";\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the boolean value based on the optional input value, returning \"auto\" if no value is provided.\n   >>> GetBoolValue(std::optional<bool> value) *\/",
        "query_nlx":"\/* Function named GetBoolValue takes an optional boolean value and returns a string representation of it. If the optional value is not set, it returns \"auto\". If the optional value is set, it returns \"true\" if the boolean value is true, and \"false\" if the boolean value is false. \n>>> GetBoolValue(std::optional<bool> value) *\/"
    }

    {
        "file_name":"Config_function_6.cpp",
        "line_count":7,
        "code":"string GetIntValue(std::optional<int> value)\n{\n    if (!value.has_value())\n        return \"auto\";\n\n    return std::to_string(value.value());\n}",
        "mark":8.0,
        "query_nsx":"\/* Return the integer value if present, otherwise return \"auto\".\n   >>> GetIntValue(std::optional<int> value) *\/",
        "query_nlx":"\/* Function named GetIntValue takes an optional integer value and returns a string representation of the value if it exists, otherwise returns the string \"auto\". \n>>> GetIntValue(std::optional<int> value) *\/"
    }

    {
        "file_name":"Config_function_7.cpp",
        "line_count":7,
        "code":"string GetFloatValue(std::optional<float> value)\n{\n    if (!value.has_value())\n        return \"auto\";\n\n    return std::to_string(value.value());\n}",
        "mark":8.0,
        "query_nsx":"\/* Extract a float value from an optional container, returning \"auto\" if no value is present.\n   >>> GetFloatValue(std::optional<float> value) *\/",
        "query_nlx":"\/* Function named GetFloatValue takes an optional floating-point value and returns a string representation of that value. If the optional value is not set, it returns the string \"auto\". If the optional value is set, it converts the value to a string using the to_string function and returns it.\n>>> GetFloatValue(3.14) \"3.14\"\n>>> GetFloatValue(nullopt) \"auto\" *\/ \nstring GetFloatValue(std::optional<float> value) { "
    }

    {
        "file_name":"config_function_8_1.cpp",
        "line_count":4,
        "code":"bool\n  endline(char ch) {\n    return ch == '\\r' || ch == '\\n';\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given character is an endline character ('\\r' or '\\n').\n   >>> endline(char ch) *\/",
        "query_nlx":"\/* Define a function that checks if a given character is an endline character, which can be either '\\r' or '\\n'.\n   >>> endline('\\r') true\n   >>> endline('a') false *\/ \nbool endline(char ch) {"
    }

    {
        "file_name":"config_function_9_1.cpp",
        "line_count":4,
        "code":"bool\n  space_tab(char ch) {\n    return ch == ' ' || ch == '\\t';\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given character is either a space or a tab.\n   >>> space_tab(char ch) *\/",
        "query_nlx":"\/* Function named space_tab checks if a given character is either a space or a tab character.\n>>> space_tab(' ') true\n>>> space_tab('\\t') true\n>>> space_tab('a') false *\/ \nbool space_tab(char ch) {"
    }

    {
        "file_name":"connection_function_13.cpp",
        "line_count":3,
        "code":"void async_shutdown(shutdown_handler handler) {\n        handler(lib::error_code());\n    }",
        "mark":8.0,
        "query_nsx":"\/* Execute the provided handler function asynchronously to perform a shutdown operation.\n   >>> void async_shutdown(shutdown_handler handler) { *\/",
        "query_nlx":"\/* Define an asynchronous function that takes a shutdown handler as a parameter and immediately calls the handler with an empty error code.\n   >>> async_shutdown(handler) *\/ \nvoid async_shutdown(shutdown_handler handler) {"
    }

    {
        "file_name":"connection_function_14.cpp",
        "line_count":3,
        "code":"void set_vector_write_handler(vector_write_handler h) {\n        m_vector_write_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler function for writing to a vector.\n   >>> set_vector_write_handler(vector_write_handler h) *\/",
        "query_nlx":"\/* Define a function that sets a handler for writing to a vector.\n   >>> set_vector_write_handler(handler) *\/ \nvoid set_vector_write_handler(vector_write_handler h) {"
    }

    {
        "file_name":"connection_function_15.cpp",
        "line_count":3,
        "code":"void set_shutdown_handler(shutdown_handler h) {\n        m_shutdown_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the function to handle shutdown events.\n   >>> set_shutdown_handler(shutdown_handler h) *\/ \nvoid set_shutdown_handler(shutdown_handler h) {",
        "query_nlx":"\/* Define a function that sets a shutdown handler to be called when a shutdown event occurs.\n   >>> set_shutdown_handler(shutdown_handler h) *\/ \nvoid set_shutdown_handler(shutdown_handler h) {"
    }

    {
        "file_name":"connection_function_23.cpp",
        "line_count":3,
        "code":"void set_handle(connection_hdl hdl) {\n        m_connection_hdl = hdl;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handle for a connection to a specified value. \n>>> void set_handle(connection_hdl hdl) { *\/",
        "query_nlx":"\/* Define a function that sets the handle for a connection.\n   >>> set_handle(connection_hdl hdl) *\/"
    }

    {
        "file_name":"connection_function_27.cpp",
        "line_count":20,
        "code":"size_t read_some_impl(char const * buf, size_t len) {\n        m_alog->write(log::alevel::devel,\"iostream_con read_some\");\n\n        if (!m_reading) {\n            m_elog->write(log::elevel::devel,\"write while not reading\");\n            return 0;\n        }\n\n        size_t bytes_to_copy = (std::min)(len,m_len-m_cursor);\n\n        std::copy(buf,buf+bytes_to_copy,m_buf+m_cursor);\n\n        m_cursor += bytes_to_copy;\n\n        if (m_cursor >= m_bytes_needed) {\n            complete_read(lib::error_code());\n        }\n\n        return bytes_to_copy;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that reads a portion of data from a source, copying it into a buffer until a certain condition is met.\n>>> size_t read_some_impl(char const * buf, size_t len) { *\/",
        "query_nlx":"        \/* This function reads a specified length of data from a buffer and copies it to an internal buffer, updating the cursor position accordingly. If not currently reading, it logs an error message and returns 0.\n        >>> read_some_impl(\"data_buffer\", 10) 8 *\/ \n        size_t read_some_impl(char const * buf, size_t len) {"
    }

    {
        "file_name":"connection_function_28.cpp",
        "line_count":8,
        "code":"void complete_read(lib::error_code const & ec) {\n        m_reading = false;\n\n        read_handler handler = m_read_handler;\n        m_read_handler = read_handler();\n\n        handler(ec,m_cursor);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Complete the reading process and handle any errors that may occur during the operation.\n   >>> complete_read(lib::error_code const & ec) *\/\n\nvoid complete_read(lib::error_code const & ec) {",
        "query_nlx":"\/* Define a function called complete_read that marks the reading process as complete, resets the read handler, and calls the handler function with an error code and cursor position.\n>>> complete_read(lib::error_code const & ec) *\/\n\nvoid complete_read(lib::error_code const & ec) {"
    }

    {
        "file_name":"connection_function_35.cpp",
        "line_count":4,
        "code":"void set_handle(connection_hdl hdl) {\n        m_connection_hdl = hdl;\n        socket_con_type::set_handle(hdl);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handle for a connection and update the handle for the socket connection type.\n   >>> set_handle(connection_hdl hdl) *\/",
        "query_nlx":"\/* Define a function that sets the handle for a connection and updates the handle for a socket connection type.\n   >>> set_handle(connection_hdl hdl) *\/"
    }

    {
        "file_name":"connection_function_36.cpp",
        "line_count":8,
        "code":"error_code interrupt(interrupt_handler handler) {\n        if (config::enable_multithreading) {\n            m_io_service->post(m_strand->wrap(handler));\n        } else {\n            m_io_service->post(handler);\n        }\n        return lib::error_code();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Post an interrupt handler to the IO service based on the configuration for multithreading.\n   >>> error_code interrupt(interrupt_handler handler) { *\/",
        "query_nlx":"\/* Function named interrupt takes an interrupt handler function as input and posts it for execution using an IO service. If multithreading is enabled, the handler is wrapped in a strand before posting. Otherwise, the handler is directly posted. \n>>> interrupt(interrupt_handler handler) error_code *\/"
    }

    {
        "file_name":"connection_function_38.cpp",
        "line_count":3,
        "code":"void handle_interrupt(interrupt_handler handler) {\n        handler();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Execute the provided interrupt handler function. \n>>> void handle_interrupt(interrupt_handler handler) { *\/",
        "query_nlx":"\/* Define a function that takes an interrupt handler as a parameter and calls it.\n   >>> handle_interrupt(handler) *\/ \nvoid handle_interrupt(interrupt_handler handler) {"
    }

    {
        "file_name":"connection_function_43.cpp",
        "line_count":5,
        "code":"void log_err(log::level l, const char * msg, const error_type & ec) {\n        std::stringstream s;\n        s << msg << \" error: \" << ec << \" (\" << ec.message() << \")\";\n        m_elog->write(l,s.str());\n    }",
        "mark":8.0,
        "query_nsx":"\/* Log an error message with the specified level and error code details.\n   >>> log_err(log::ERROR, \"Connection failed\", error_code)\n   >>> log_err(log::WARNING, \"Invalid input\", error_code) *\/ \nvoid log_err(log::level l, const char * msg, const error_type & ec) {",
        "query_nlx":"\/* Define a function that logs an error message along with an error code and its corresponding message. \n   The function takes in a log level, a message string, and an error type as input parameters. \n   The error message is constructed by concatenating the input message, the error code, and the error message itself. \n   Finally, the error message is written to the log with the specified log level. *\/ \nvoid log_err(log::level l, const char * msg, const error_type & ec) { "
    }

    {
        "file_name":"connection_impl_function_12.cpp",
        "line_count":8,
        "code":"else if (m_state == session::state::closed) {\n            \/\/ The connection was canceled while the response was being sent,\n            \/\/ usually by the handshake timer. This is basically expected\n            \/\/ (though hopefully rare) and there is nothing we can do so ignore.\n            m_alog->write(log::alevel::devel,\n                \"handle_write_http_response invoked after connection was closed\");\n            return;\n        }",
        "mark":8.0,
        "query_nsx":"\/* Check if the function is invoked after the connection has been closed.\n   >>> handle_write_http_response invoked after connection was closed *\/ \n   void handle_write_http_response() {",
        "query_nlx":"\/* Check if the session state is closed and log a message if the connection was canceled during response sending.\n   >>> handle_write_http_response invoked after connection was closed *\/ \nelse if (m_state == session::state::closed) { "
    }

    {
        "file_name":"connection_impl_function_14.cpp",
        "line_count":8,
        "code":"else if (m_state == session::state::closed) {\n            \/\/ The connection was canceled while the response was being sent,\n            \/\/ usually by the handshake timer. This is basically expected\n            \/\/ (though hopefully rare) and there is nothing we can do so ignore.\n            m_alog->write(log::alevel::devel,\n                \"handle_send_http_request invoked after connection was closed\");\n            return;\n        }",
        "mark":8.0,
        "query_nsx":"\/* Check if the connection state is closed and handle the scenario where the response was being sent but the connection was canceled. \n>>> handle_send_http_request() *\/ \nelse if (m_state == session::state::closed) {",
        "query_nlx":"\/* Check if the session state is closed and log a message if the connection was canceled during response sending. \n>>> handle_send_http_request() *\/ \nelse if (m_state == session::state::closed) { \n    m_alog->write(log::alevel::devel, \"handle_send_http_request invoked after connection was closed\"); \n    return; \n}"
    }

    {
        "file_name":"connection_impl_function_15.cpp",
        "line_count":8,
        "code":"else if (m_state == session::state::closed) {\n            \/\/ The connection was canceled while the response was being sent,\n            \/\/ usually by the handshake timer. This is basically expected\n            \/\/ (though hopefully rare) and there is nothing we can do so ignore.\n            m_alog->write(log::alevel::devel,\n                \"handle_read_http_response invoked after connection was closed\");\n            return;\n        }",
        "mark":8.0,
        "query_nsx":"\/* Check if the connection state is closed and handle the read HTTP response accordingly. \n>>> handle_read_http_response() *\/ \nelse if (m_state == session::state::closed) {",
        "query_nlx":"\/* Check if the session state is closed and log a message if so, then return.\n   >>> handle_read_http_response() *\/ \nelse if (m_state == session::state::closed) { \n    m_alog->write(log::alevel::devel, \"handle_read_http_response invoked after connection was closed\"); \n    return; \n}"
    }

    {
        "file_name":"connection_impl_function_24.cpp",
        "line_count":8,
        "code":"else if (op == frame::opcode::PONG) {\n        if (m_pong_handler) {\n            m_pong_handler(m_connection_hdl, msg->get_payload());\n        }\n        if (m_ping_timer) {\n            m_ping_timer->cancel();\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Execute specific actions when receiving a PONG frame opcode.\n   >>> else if (op == frame::opcode::PONG) { *\/",
        "query_nlx":"\/* When the operation is a PONG frame opcode, if there is a pong handler set, call the pong handler with the connection handle and the message payload. \nIf there is a ping timer set, cancel the ping timer. *\/\nelse if (op == frame::opcode::PONG) { *\/"
    }

    {
        "file_name":"connection_impl_function_29.cpp",
        "line_count":6,
        "code":"else if (m_remote_close_code == close::status::no_status) {\n        m_alog->write(log::alevel::devel,\n            \"acknowledging a no-status close with normal code\");\n        m_local_close_code = close::status::normal;\n        m_local_close_reason.clear();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Acknowledge a no-status close with a normal code.\n   >>> acknowledge_no_status_close() *\/ \nvoid acknowledge_no_status_close() {",
        "query_nlx":"\/* When the remote close code is equal to no status, acknowledge the close with a normal code and clear the local close reason.\n   >>> else if (m_remote_close_code == close::status::no_status) {\n            m_alog->write(log::alevel::devel, \"acknowledging a no-status close with normal code\");\n            m_local_close_code = close::status::normal;\n            m_local_close_reason.clear();\n    } *\/"
    }

    {
        "file_name":"connection_impl_function_3.cpp",
        "line_count":8,
        "code":"else if (m_state == session::state::closed) {\n            \/\/ The connection was canceled while the response was being sent,\n            \/\/ usually by the handshake timer. This is basically expected\n            \/\/ (though hopefully rare) and there is nothing we can do so ignore.\n            m_alog->write(log::alevel::devel,\n                \"handle_read_handshake invoked after connection was closed\");\n            return;\n        }",
        "mark":8.0,
        "query_nsx":"\/* Check if the function is invoked after the connection has been closed.\n   >>> handle_read_handshake invoked after connection was closed *\/ \n   void handle_read_handshake() { ",
        "query_nlx":"\/* Check if the session state is closed and log a message if the connection was canceled during response sending. \n   >>> handle_read_handshake invoked after connection was closed *\/ \nelse if (m_state == session::state::closed) { "
    }

    {
        "file_name":"connection_impl_function_5.cpp",
        "line_count":7,
        "code":"else if (m_state == session::state::closing && !m_is_server) {\n                \/\/ If we are a client we expect to get eof in the closing state,\n                \/\/ this is a signal to terminate our end of the connection after\n                \/\/ the closing handshake\n                terminate(lib::error_code());\n                return;\n            }",
        "mark":8.0,
        "query_nsx":"\/* Check if the session is in the closing state and not a server, then terminate the connection after the closing handshake.\n   >>> N\/A *\/ \n   void function_name();",
        "query_nlx":"\/* Check if the current session state is closing and the connection is not a server. If these conditions are met, terminate the connection with an error code.\n        >>> terminate(lib::error_code()) *\/ \n        else if (m_state == session::state::closing && !m_is_server) {"
    }

    {
        "file_name":"constants_function_3.cpp",
        "line_count":3,
        "code":"bool is_whitespace_char(unsigned char c) {\n        return (c == 9 || c == 32);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given character is a whitespace character.\n   >>> bool is_whitespace_char(unsigned char c) { *\/",
        "query_nlx":"\/* Function named is_whitespace_char determines if a given unsigned character represents a whitespace character, which includes tab (ASCII 9) and space (ASCII 32) characters. \n>>> is_whitespace_char(9) true \n>>> is_whitespace_char(32) true \n>>> is_whitespace_char(65) false *\/ \nbool is_whitespace_char(unsigned char c) {"
    }

    {
        "file_name":"constants_function_4.cpp",
        "line_count":3,
        "code":"bool is_not_whitespace_char(unsigned char c) {\n        return (c != 9 && c != 32);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given character is not a whitespace character.\n   >>> bool is_not_whitespace_char(unsigned char c) { *\/",
        "query_nlx":"\/* Function named is_not_whitespace_char checks if a given unsigned character is not a whitespace character, where whitespace characters are defined as ASCII values 9 (tab) and 32 (space).\n>>> is_not_whitespace_char(65) true\n>>> is_not_whitespace_char(9) false\n*\/ \nbool is_not_whitespace_char(unsigned char c) {"
    }

    {
        "file_name":"consuming_buffers_function_4.cpp",
        "line_count":4,
        "code":"void consume(std::size_t size)\n  {\n    total_consumed_ += size;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Update the total amount consumed by adding the specified size.\n   >>> consume(std::size_t size) *\/",
        "query_nlx":"\/* Function named consume updates the total consumed size by adding the input size value to it. \n>>> consume(10) \n*\/ \nvoid consume(std::size_t size) { "
    }

    {
        "file_name":"consuming_buffers_function_5.cpp",
        "line_count":4,
        "code":"void consume(std::size_t size)\n  {\n    total_consumed_ += size;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Update the total amount consumed by adding the given size.\n   >>> consume(std::size_t size) *\/",
        "query_nlx":"\/* Function named consume updates the total consumed size by adding the given size parameter to it. \n>>> consume(10) \n*\/ \nvoid consume(std::size_t size) { "
    }

    {
        "file_name":"consuming_buffers_function_6.cpp",
        "line_count":4,
        "code":"void consume(std::size_t size)\n  {\n    total_consumed_ += size;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Update the total amount consumed by adding the given size.\n   >>> consume(std::size_t size) *\/",
        "query_nlx":"\/* Function named consume updates the total amount consumed by adding the given size to the current total consumed value. \n>>> consume(10) \n*\/ \nvoid consume(std::size_t size) { "
    }

    {
        "file_name":"ContentType_function_1.cpp",
        "line_count":9,
        "code":"eType GetFromString(const std::string& str) {\n\t\t\/\/OutputPrintf(\"Content type: %s\", str.c_str());\n\t\tif (str == \"image\/png\")  return PNG;\n\t\tif (str == \"image\/jpeg\") return JPEG;\n\t\tif (str == \"image\/gif\")  return GIF;\n\t\tif (str == \"image\/webp\") return WEBP;\n\n\t\treturn BLOB;\n\t}",
        "mark":8.0,
        "query_nsx":"        \/* Determine the type of content based on the input string.\n        >>> GetFromString(const string& str) *\/",
        "query_nlx":"\/* Function named GetFromString takes a string input representing a content type and returns the corresponding enum value. The function maps specific content types like image\/png, image\/jpeg, image\/gif, and image\/webp to their respective enum values PNG, JPEG, GIF, and WEBP. If the input string does not match any of these content types, the function returns the enum value BLOB. *\/\neType GetFromString(const std::string& str) {"
    }

    {
        "file_name":"coro_function_13.cpp",
        "line_count":4,
        "code":"void reset_error()\n  {\n    error_ = std::exception_ptr{};\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the error state to clear any previously stored exception pointer.\n   >>> reset_error()\n*\/ \nvoid reset_error() {",
        "query_nlx":"\/* Function named reset_error resets the error state by setting the error pointer to null. \n>>> reset_error() *\/ \nvoid reset_error() { "
    }

    {
        "file_name":"coro_function_34.cpp",
        "line_count":4,
        "code":"void return_value(Return&& r)\n  {\n    result_ = std::move(r);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Store the input value in the result variable after moving it.\n>>> return_value(Return&& r) *\/",
        "query_nlx":"\/* Define a function that takes a single argument by rvalue reference and assigns the moved value to the result_ member variable. \n>>> return_value(Return&& r) *\/"
    }

    {
        "file_name":"coro_function_35.cpp",
        "line_count":1,
        "code":"void return_void() {}",
        "mark":8.0,
        "query_nsx":"\/* Define a function that does not return any value. \n   >>> return_void() *\/ \nvoid return_void() {",
        "query_nlx":"\/* Define a function that returns void and takes no input parameters.\n   >>> return_void() *\/ \nvoid return_void() { }"
    }

    {
        "file_name":"coro_function_40.cpp",
        "line_count":4,
        "code":"auto get_handle()\n  {\n    return coroutine_handle<coro_promise>::from_promise(*this);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return a handle based on the coroutine promise associated with the current context.\n   >>> auto get_handle() { *\/",
        "query_nlx":"\/* Function named get_handle returns a handle by converting the current promise to a coroutine handle.\n   >>> get_handle() auto get_handle() { *\/"
    }

    {
        "file_name":"coro_function_5.cpp",
        "line_count":4,
        "code":"error_code interrupted()\n  {\n    return asio::error::interrupted;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if an interruption error has occurred.\n   >>> error_code interrupted() *\/",
        "query_nlx":"\/* Define a function that returns an error code representing an interruption.\n   >>> interrupted() returns an error code indicating an interruption. *\/ \nerror_code interrupted() {"
    }

    {
        "file_name":"CountTrailingOptionals_function_2.cpp",
        "line_count":4,
        "code":"if constexpr (isOptional) {\n        \/\/ last item is an optional, finally return the final number incremented by one.\n        return N + 1;\n      }",
        "mark":8.0,
        "query_nsx":"        \/* Check if the last item is optional and return the final number incremented by one if it is.\n        >>> if constexpr (isOptional) { *\/",
        "query_nlx":"\/* If the last item is optional, the function returns the final number incremented by one.\n>>> return N + 1; *\/ \nif constexpr (isOptional) {"
    }

    {
        "file_name":"crypto_function_15.cpp",
        "line_count":4,
        "code":"bool\n  verify256(const x509_t &x509, const std::string_view &data, const std::string_view &signature) {\n    return verify(x509, data, signature, EVP_sha256());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Verify the signature of a given x509 certificate using SHA-256 algorithm.\n   >>> verify256(const x509_t &x509, const std::string_view &data, const std::string_view &signature) *\/",
        "query_nlx":"\/* Function named verify256 checks if a given x509 certificate, data, and signature can be verified using the SHA-256 hashing algorithm.\n>>> verify256(const x509_t &x509, const std::string_view &data, const std::string_view &signature) *\/\n#include <openssl\/evp.h>\n#include <string>\nusing namespace std;\nbool verify256(const x509_t &x509, const std::string_view &data, const std::string_view &signature) {"
    }

    {
        "file_name":"CubemapSH_function_2.cpp",
        "line_count":3,
        "code":"size_t SHindex(ssize_t m, size_t l) {\n        return l * (l + 1) + m;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the index based on two input values, m and l, to determine a specific position in a data structure.\n   >>> SHindex(ssize_t m, size_t l) *\/",
        "query_nlx":"\/* Function named SHindex calculates an index value based on two input parameters, m and l, using a specific formula. \n>>> SHindex(2, 3) 15 \n>>> SHindex(-1, 5) 29 *\/ \nsize_t SHindex(ssize_t m, size_t l) { "
    }

    {
        "file_name":"Cubemap_function_1.cpp",
        "line_count":3,
        "code":"void writeAt(void* data, const Texel& texel) {\n        *static_cast<Texel*>(data) = texel;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Write the provided texel data at the specified memory location.\n    >>> writeAt(void* data, const Texel& texel) { *\/",
        "query_nlx":"\/* Function named writeAt takes a generic data pointer and a Texel object, then assigns the Texel object to the memory location pointed to by the data pointer. \n>>> writeAt(void* data, const Texel& texel) *\/"
    }

    {
        "file_name":"d3dx12_function_101.cpp",
        "line_count":1,
        "code":"void SetStateObjectType(D3D12_STATE_OBJECT_TYPE Type) { m_Desc.Type = Type; }",
        "mark":8.0,
        "query_nsx":"\/* Set the state object type to the specified value.\n   >>> SetStateObjectType(D3D12_STATE_OBJECT_TYPE Type) *\/",
        "query_nlx":"\/* Define a function that sets the state object type based on the input parameter.\n   >>> SetStateObjectType(D3D12_STATE_OBJECT_TYPE Type) *\/\nvoid SetStateObjectType(D3D12_STATE_OBJECT_TYPE Type) { m_Desc.Type = Type; }"
    }

    {
        "file_name":"d3dx12_function_103.cpp",
        "line_count":9,
        "code":"void Init(D3D12_STATE_OBJECT_TYPE Type)\n    {\n        SetStateObjectType(Type);\n        m_Desc.pSubobjects = nullptr;\n        m_Desc.NumSubobjects = 0;\n        m_SubobjectList.clear();\n        m_SubobjectArray.clear();\n        m_RepointedAssociations.clear();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the state object type and clear associated subobjects and lists.\n   >>> Init(D3D12_STATE_OBJECT_TYPE Type) *\/",
        "query_nlx":"        \/* Initialize the state object with the given type by setting its type, clearing subobjects, and associated lists.\n        >>> Init(D3D12_STATE_OBJECT_TYPE Type) *\/"
    }

    {
        "file_name":"d3dx12_function_105.cpp",
        "line_count":1,
        "code":"void clear() { m_Strings.clear(); }",
        "mark":9.0,
        "query_nsx":"\/* Clear all stored strings.\n>>> clear() *\/ \nvoid clear();",
        "query_nlx":"\/* Define a function that clears all elements from a collection of strings.\n   >>> clear() *\/ \nvoid clear() { m_Strings.clear(); }"
    }

    {
        "file_name":"d3dx12_function_107.cpp",
        "line_count":1,
        "code":"void Init() { m_pSubobject = nullptr; }",
        "mark":8.0,
        "query_nsx":"\/* Initialize a subobject pointer to a null value.\n>>> Init() *\/ \nvoid Init();",
        "query_nlx":"\/* Initialize a member variable named m_pSubobject to have a null pointer value.\n>>> Init() *\/ \nvoid Init() { m_pSubobject = nullptr; }"
    }

    {
        "file_name":"d3dx12_function_108.cpp",
        "line_count":5,
        "code":"void SetDXILLibrary(D3D12_SHADER_BYTECODE*pCode)\n    {\n        static const D3D12_SHADER_BYTECODE Default = {};\n        m_Desc.DXILLibrary = pCode ? *pCode : Default;\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set the DXIL library for a shader bytecode.\n        >>> void SetDXILLibrary(D3D12_SHADER_BYTECODE*pCode){ *\/",
        "query_nlx":"\/* Define a function that sets the DXIL library for a given shader bytecode. The function takes a pointer to D3D12_SHADER_BYTECODE as input.\n   >>> SetDXILLibrary(D3D12_SHADER_BYTECODE*pCode) *\/"
    }

    {
        "file_name":"d3dx12_function_110.cpp",
        "line_count":7,
        "code":"void DefineExports(LPCWSTR* Exports, UINT N)\n    {\n        for (UINT i = 0; i < N; i++)\n        {\n            DefineExport(Exports[i]);\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Define multiple exports based on an array of names.\n   >>> DefineExports(Exports, N) void *\/",
        "query_nlx":"        \/* DefineExports function takes an array of wide strings (LPCWSTR) and the number of elements in the array (N), then iterates through the array to define each element as an export.\n        >>> DefineExports({L\"Export1\", L\"Export2\", L\"Export3\"}, 3) *\/ \n        void DefineExports(LPCWSTR* Exports, UINT N) { "
    }

    {
        "file_name":"d3dx12_function_111.cpp",
        "line_count":7,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        m_Strings.clear();\n        m_Exports.clear();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the object by clearing description, strings, and exports.\n   >>> Init() *\/ \nvoid Init();",
        "query_nlx":"        \/* Initialize the object by calling the base class initialization function, setting the description to an empty value, and clearing the strings and exports lists.\n        >>> Init() *\/ \n        void Init() { "
    }

    {
        "file_name":"d3dx12_function_112.cpp",
        "line_count":5,
        "code":"void SetExistingCollection(ID3D12StateObject*pExistingCollection)\n    {\n        m_Desc.pExistingCollection = pExistingCollection;\n        m_CollectionRef = pExistingCollection;\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set an existing collection for the state object.\n        >>> SetExistingCollection(ID3D12StateObject*pExistingCollection){ *\/",
        "query_nlx":"\/* Function named SetExistingCollection assigns the input state object to two member variables within the class. \n>>> SetExistingCollection(pExistingCollection) sets the pExistingCollection pointer to the m_Desc.pExistingCollection and m_CollectionRef variables. *\/ \nvoid SetExistingCollection(ID3D12StateObject*pExistingCollection) { "
    }

    {
        "file_name":"d3dx12_function_114.cpp",
        "line_count":7,
        "code":"void DefineExports(LPCWSTR* Exports, UINT N)\n    {\n        for (UINT i = 0; i < N; i++)\n        {\n            DefineExport(Exports[i]);\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Define multiple exports based on the given array of export names.\n   >>> DefineExports(Exports, N) *\/ \nvoid DefineExports(LPCWSTR* Exports, UINT N) {",
        "query_nlx":"        \/* DefineExports function takes an array of wide strings (LPCWSTR) and the number of elements in the array (N), then iterates through the array to define each element as an export.\n        >>> DefineExports({L\"Export1\", L\"Export2\", L\"Export3\"}, 3) *\/ \n        void DefineExports(LPCWSTR* Exports, UINT N) { "
    }

    {
        "file_name":"d3dx12_function_115.cpp",
        "line_count":8,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        m_CollectionRef = nullptr;\n        m_Strings.clear();\n        m_Exports.clear();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the object by clearing internal data structures and setting references to default values.\n>>> void Init() *\/",
        "query_nlx":"\/* Initialize the object by clearing its description, setting the collection reference to null, and clearing the strings and exports lists.\n>>> Init() *\/ \nvoid Init() { "
    }

    {
        "file_name":"d3dx12_function_118.cpp",
        "line_count":7,
        "code":"void AddExports(LPCWSTR* Exports, UINT N)\n    {\n        for (UINT i = 0; i < N; i++)\n        {\n            AddExport(Exports[i]);\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Add multiple exports to a list of exports.\n    >>> void AddExports(LPCWSTR* Exports, UINT N) *\/",
        "query_nlx":"\/* Function named AddExports takes an array of wide character strings and the number of elements in the array as input, then adds each string in the array as an export.\n>>> AddExports({L\"Export1\", L\"Export2\", L\"Export3\"}, 3) *\/ \nvoid AddExports(LPCWSTR* Exports, UINT N) { "
    }

    {
        "file_name":"d3dx12_function_119.cpp",
        "line_count":7,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        m_Strings.clear();\n        m_Exports.clear();\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Initialize the object by clearing internal data structures and setting the description to an empty value.\n        >>> Init() *\/ \n        void Init();",
        "query_nlx":"\/* Initialize the object by calling the base class initialization function, setting the description to an empty value, and clearing the strings and exports lists.\n   >>> Init() *\/ \nvoid Init() { "
    }

    {
        "file_name":"d3dx12_function_120.cpp",
        "line_count":4,
        "code":"void SetSubobjectNameToAssociate(LPCWSTR SubobjectToAssociate)\n    {\n        m_Desc.SubobjectToAssociate = m_SubobjectName.LocalCopy(SubobjectToAssociate, true);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the name of a subobject to associate with the main object. \n    >>> void SetSubobjectNameToAssociate(LPCWSTR SubobjectToAssociate) { *\/",
        "query_nlx":"\/* Function named SetSubobjectNameToAssociate sets the subobject name to be associated with the given input subobject.\n>>> SetSubobjectNameToAssociate(\"NewSubobject\") *\/ \nvoid SetSubobjectNameToAssociate(LPCWSTR SubobjectToAssociate) { "
    }

    {
        "file_name":"d3dx12_function_122.cpp",
        "line_count":7,
        "code":"void AddExports(LPCWSTR* Exports, UINT N)\n    {\n        for (UINT i = 0; i < N; i++)\n        {\n            AddExport(Exports[i]);\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Add multiple exports to a list using the provided array of export names and the total number of exports.\n   >>> void AddExports(LPCWSTR* Exports, UINT N) *\/",
        "query_nlx":"        \/* Function named AddExports takes an array of wide character strings and the number of elements in the array, then adds each string as an export.\n        >>> AddExports({L\"Export1\", L\"Export2\", L\"Export3\"}, 3) *\/ \n        void AddExports(LPCWSTR* Exports, UINT N) { "
    }

    {
        "file_name":"d3dx12_function_123.cpp",
        "line_count":8,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        m_Strings.clear();\n        m_SubobjectName.clear();\n        m_Exports.clear();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the object by clearing internal data structures and setting the description to an empty value.\n   >>> Init() *\/ \nvoid Init();",
        "query_nlx":"        \/* Initialize the object by clearing its description, strings, subobject name, and exports.\n        >>> Init() *\/ \n        void Init() {"
    }

    {
        "file_name":"d3dx12_function_124.cpp",
        "line_count":4,
        "code":"void SetHitGroupExport(LPCWSTR exportName)\n    {\n        m_Desc.HitGroupExport = m_Strings[0].LocalCopy(exportName, true);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set the export name for the hit group. \n        >>> void SetHitGroupExport(LPCWSTR exportName) *\/",
        "query_nlx":"        \/* Define a function that sets the hit group export name based on the provided input string.\n        >>> SetHitGroupExport(\"ExportName\") *\/ \n        void SetHitGroupExport(LPCWSTR exportName) { "
    }

    {
        "file_name":"d3dx12_function_125.cpp",
        "line_count":1,
        "code":"void SetHitGroupType(D3D12_HIT_GROUP_TYPE Type) { m_Desc.Type = Type; }",
        "mark":8.0,
        "query_nsx":"\/* Set the type of hit group for a specified object.\n   >>> SetHitGroupType(Type) *\/ \nvoid SetHitGroupType(D3D12_HIT_GROUP_TYPE Type) { ",
        "query_nlx":"\/* Function named SetHitGroupType sets the type of a hit group to the specified value.\n   >>> SetHitGroupType(D3D12_HIT_GROUP_TYPE Type) *\/\nvoid SetHitGroupType(D3D12_HIT_GROUP_TYPE Type) { }"
    }

    {
        "file_name":"d3dx12_function_127.cpp",
        "line_count":4,
        "code":"void SetClosestHitShaderImport(LPCWSTR importName)\n    {\n        m_Desc.ClosestHitShaderImport = m_Strings[2].LocalCopy(importName, true);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set the import name for the closest hit shader. \n        >>> void SetClosestHitShaderImport(LPCWSTR importName); *\/",
        "query_nlx":"\/* Define a function that sets the closest hit shader import name by copying the provided import name to the corresponding location in the data structure.\n   >>> SetClosestHitShaderImport(\"myImportName\") *\/ \nvoid SetClosestHitShaderImport(LPCWSTR importName) { "
    }

    {
        "file_name":"d3dx12_function_129.cpp",
        "line_count":9,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n        for (UINT i = 0; i < m_NumStrings; i++)\n        {\n            m_Strings[i].clear();\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the object by clearing description and strings. \n>>> void Init() { *\/",
        "query_nlx":"\/* Initialize the object by clearing the description and clearing all strings in the array.\n   >>> Init() *\/ \nvoid Init() {"
    }

    {
        "file_name":"d3dx12_function_130.cpp",
        "line_count":5,
        "code":"void Config(UINT MaxPayloadSizeInBytes, UINT MaxAttributeSizeInBytes)\n    {\n        m_Desc.MaxPayloadSizeInBytes = MaxPayloadSizeInBytes;\n        m_Desc.MaxAttributeSizeInBytes = MaxAttributeSizeInBytes;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the maximum payload size and maximum attribute size for configuration.\n>>> Config(UINT MaxPayloadSizeInBytes, UINT MaxAttributeSizeInBytes) *\/",
        "query_nlx":"\/* Function named Config sets the maximum payload size and maximum attribute size in bytes for a configuration.\n>>> Config(1024, 256) *\/ \nvoid Config(UINT MaxPayloadSizeInBytes, UINT MaxAttributeSizeInBytes) {"
    }

    {
        "file_name":"d3dx12_function_131.cpp",
        "line_count":5,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Initialize the object by calling the base class initialization function and setting the description to an empty value.\n        >>> Init() *\/ \n        void Init() { ",
        "query_nlx":"\/* Initialize the object by calling the base class initialization function and setting the description to an empty value.\n>>> Init() *\/ \nvoid Init() { "
    }

    {
        "file_name":"d3dx12_function_132.cpp",
        "line_count":4,
        "code":"void Config(UINT MaxTraceRecursionDepth)\n    {\n        m_Desc.MaxTraceRecursionDepth = MaxTraceRecursionDepth;\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set the maximum depth for tracing recursive functions.\n        >>> Config(UINT MaxTraceRecursionDepth) *\/",
        "query_nlx":"\/* Define a function that configures a maximum trace recursion depth value.\n   >>> Config(5) sets the maximum trace recursion depth to 5\n   >>> Config(10) sets the maximum trace recursion depth to 10 *\/ \nvoid Config(UINT MaxTraceRecursionDepth) { "
    }

    {
        "file_name":"d3dx12_function_133.cpp",
        "line_count":5,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Initialize the object by calling the base class initialization function and setting the description to an empty value.\n        >>> Init() *\/ \n        void Init();",
        "query_nlx":"        \/* Initialize the object by calling the base class initialization function and setting the description to an empty value.\n        >>> Init() *\/ \n        void Init() {"
    }

    {
        "file_name":"d3dx12_function_134.cpp",
        "line_count":4,
        "code":"void SetRootSignature(ID3D12RootSignature* pRootSig)\n    {\n        m_pRootSig = pRootSig;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the root signature for the graphics pipeline.\n   >>> SetRootSignature(ID3D12RootSignature* pRootSig); *\/",
        "query_nlx":"\/* Function named SetRootSignature sets the root signature for a given object.\n   >>> SetRootSignature(ID3D12RootSignature* pRootSig) *\/"
    }

    {
        "file_name":"d3dx12_function_135.cpp",
        "line_count":5,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_pRootSig = nullptr;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the function to set the root signature to null.\n   >>> Init() *\/ \nvoid Init();",
        "query_nlx":"\/* Initialize the object by calling the base class initialization function and setting the root signature pointer to null.\n>>> Init() *\/ \nvoid Init() {"
    }

    {
        "file_name":"d3dx12_function_136.cpp",
        "line_count":4,
        "code":"void SetRootSignature(ID3D12RootSignature* pRootSig)\n    {\n        m_pRootSig = pRootSig;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the root signature for the graphics pipeline.\n   >>> SetRootSignature(ID3D12RootSignature* pRootSig) *\/",
        "query_nlx":"\/* Function named SetRootSignature sets the root signature for a given object.\n   >>> SetRootSignature(ID3D12RootSignature* pRootSig) *\/"
    }

    {
        "file_name":"d3dx12_function_137.cpp",
        "line_count":5,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_pRootSig = nullptr;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the root signature to null.\n   >>> Init() *\/ \nvoid Init();",
        "query_nlx":"\/* Initialize the object by calling the base class initialization function and setting the root signature pointer to null.\n>>> Init() *\/ \nvoid Init() {"
    }

    {
        "file_name":"d3dx12_function_138.cpp",
        "line_count":4,
        "code":"void SetFlags(D3D12_STATE_OBJECT_FLAGS Flags)\n    {\n        m_Desc.Flags = Flags;\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Update the flags of the state object with the provided input flags.\n        >>> SetFlags(Flags) *\/ \n        void SetFlags(Flags);",
        "query_nlx":"        \/* Function named SetFlags sets the flags of a state object to the provided value.\n        >>> SetFlags(D3D12_STATE_OBJECT_FLAGS Flags) *\/"
    }

    {
        "file_name":"d3dx12_function_139.cpp",
        "line_count":5,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the object by calling the base class initialization function and setting the description to an empty value.\n>>> Init() *\/ \nvoid Init();",
        "query_nlx":"        \/* Initialize the object by calling the base class initialization function and setting the description to an empty value.\n        >>> Init() *\/ \n        void Init() { \n            SUBOBJECT_HELPER_BASE::Init(); \n            m_Desc = {}; \n        }"
    }

    {
        "file_name":"d3dx12_function_140.cpp",
        "line_count":4,
        "code":"void SetNodeMask(UINT NodeMask)\n    {\n        m_Desc.NodeMask = NodeMask;\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Update the node mask value to control the visibility of nodes.\n        >>> SetNodeMask(UINT NodeMask) *\/",
        "query_nlx":"        \/* Define a function that sets the node mask value to the provided input value.\n        >>> SetNodeMask(5) *\/ \n        void SetNodeMask(UINT NodeMask) { \n            \/\/ Function body omitted \n        }"
    }

    {
        "file_name":"d3dx12_function_141.cpp",
        "line_count":5,
        "code":"void Init()\n    {\n        SUBOBJECT_HELPER_BASE::Init();\n        m_Desc = {};\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Initialize the object by calling the base class initialization function and setting the description to an empty value.\n        >>> Init() *\/ \n        void Init();",
        "query_nlx":"        \/* Initialize the object by calling the base class initialization function and setting the description to an empty value.\n        >>> Init() *\/ \n        void Init() { \n            SUBOBJECT_HELPER_BASE::Init(); \n            m_Desc = {}; \n        }"
    }

    {
        "file_name":"d3dx12_function_25.cpp",
        "line_count":5,
        "code":"void Init(_Out_ D3D12_ROOT_DESCRIPTOR &table, UINT shaderRegister, UINT registerSpace = 0)\n    {\n        table.ShaderRegister = shaderRegister;\n        table.RegisterSpace = registerSpace;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize a D3D12 root descriptor table with the specified shader register and optional register space.\n   >>> Init(table, shaderRegister, registerSpace = 0) *\/",
        "query_nlx":"        \/* Define a function named Init that initializes a D3D12_ROOT_DESCRIPTOR object with the provided shaderRegister and an optional registerSpace parameter.\n        >>> Init(table, 3, 1) will set the ShaderRegister of the table object to 3 and the RegisterSpace to 1.\n        >>> Init(table, 5) will set the ShaderRegister of the table object to 5 and the RegisterSpace to the default value of 0. *\/ \n        void Init(_Out_ D3D12_ROOT_DESCRIPTOR &table, UINT shaderRegister, UINT registerSpace = 0) { \/* Function body omitted *\/ }"
    }

    {
        "file_name":"d3dx12_function_53.cpp",
        "line_count":4,
        "code":"void InitOffsetted(_Out_ D3D12_CPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_CPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize)\n    {\n        handle.ptr = static_cast<SIZE_T>(base.ptr + INT64(offsetInDescriptors) * UINT64(descriptorIncrementSize));\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Initialize a CPU descriptor handle with an offset based on a base handle and descriptor properties.\n        >>> void InitOffsetted(_Out_ handle, _In_ base, offsetInDescriptors, descriptorIncrementSize) { *\/",
        "query_nlx":"        \/* Function named InitOffsetted initializes a CPU descriptor handle by calculating the offset based on a base handle, offset in descriptors, and descriptor increment size.\n        >>> InitOffsetted(_Out_ D3D12_CPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_CPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize) *\/"
    }

    {
        "file_name":"d3dx12_function_57.cpp",
        "line_count":4,
        "code":"void InitOffsetted(_Out_ D3D12_GPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_GPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize)\n    {\n        handle.ptr = static_cast<UINT64>(base.ptr + INT64(offsetInDescriptors) * UINT64(descriptorIncrementSize));\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Initialize a GPU descriptor handle with an offset based on a base handle and descriptor properties.\n        >>> void InitOffsetted(_Out_ handle, _In_ const base, offsetInDescriptors, descriptorIncrementSize) { *\/",
        "query_nlx":"        \/* Function named InitOffsetted initializes a GPU descriptor handle by calculating the offset based on a base handle, offset in descriptors, and descriptor increment size.\n        >>> InitOffsetted(handle, base, 2, 16) *\/ \n        void InitOffsetted(_Out_ D3D12_GPU_DESCRIPTOR_HANDLE &handle, _In_ const D3D12_GPU_DESCRIPTOR_HANDLE &base, INT offsetInDescriptors, UINT descriptorIncrementSize) {"
    }

    {
        "file_name":"d3dx12_function_58.cpp",
        "line_count":4,
        "code":"UINT D3D12CalcSubresource( UINT MipSlice, UINT ArraySlice, UINT PlaneSlice, UINT MipLevels, UINT ArraySize )\n{\n    return MipSlice + ArraySlice * MipLevels + PlaneSlice * MipLevels * ArraySize;\n}",
        "mark":8.0,
        "query_nsx":"        \/* Calculate the subresource index based on the provided parameters.\n        >>> UINT D3D12CalcSubresource( UINT MipSlice, UINT ArraySlice, UINT PlaneSlice, UINT MipLevels, UINT ArraySize ) *\/",
        "query_nlx":"\/* Calculate the subresource index based on the given parameters including MipSlice, ArraySlice, PlaneSlice, MipLevels, and ArraySize.\n   The subresource index is computed by adding MipSlice to the product of ArraySlice and MipLevels, then adding the product of PlaneSlice, MipLevels, and ArraySize.\n   >>> D3D12CalcSubresource(2, 1, 0, 4, 3) returns 10\n   >>> D3D12CalcSubresource(0, 2, 1, 3, 2) returns 7 *\/ \nUINT D3D12CalcSubresource( UINT MipSlice, UINT ArraySlice, UINT PlaneSlice, UINT MipLevels, UINT ArraySize ) { *\/"
    }

    {
        "file_name":"d3dx12_function_59.cpp",
        "line_count":6,
        "code":"void D3D12DecomposeSubresource( UINT Subresource, UINT MipLevels, UINT ArraySize, _Out_ T& MipSlice, _Out_ U& ArraySlice, _Out_ V& PlaneSlice )\n{\n    MipSlice = static_cast<T>(Subresource % MipLevels);\n    ArraySlice = static_cast<U>((Subresource \/ MipLevels) % ArraySize);\n    PlaneSlice = static_cast<V>(Subresource \/ (MipLevels * ArraySize));\n}",
        "mark":8.0,
        "query_nsx":"        \/* Decompose a subresource index into its corresponding mip slice, array slice, and plane slice components.\n        >>> void D3D12DecomposeSubresource( UINT Subresource, UINT MipLevels, UINT ArraySize, _Out_ T& MipSlice, _Out_ U& ArraySlice, _Out_ V& PlaneSlice ) { *\/",
        "query_nlx":"        \/* Function named D3D12DecomposeSubresource decomposes a given subresource index into its corresponding mip slice, array slice, and plane slice components based on the provided mip levels and array size.\n        >>> D3D12DecomposeSubresource(10, 4, 3, mipSlice, arraySlice, planeSlice) \n        mipSlice = 2, arraySlice = 1, planeSlice = 0\n        >>> D3D12DecomposeSubresource(5, 2, 2, mipSlice, arraySlice, planeSlice) \n        mipSlice = 1, arraySlice = 0, planeSlice = 1 *\/ \n        void D3D12DecomposeSubresource( UINT Subresource, UINT MipLevels, UINT ArraySize, _Out_ T& MipSlice, _Out_ U& ArraySlice, _Out_ V& PlaneSlice ) {"
    }

    {
        "file_name":"d3dx12_function_70.cpp",
        "line_count":2,
        "code":"bool D3D12IsLayoutOpaque( D3D12_TEXTURE_LAYOUT Layout )\n{ return Layout == D3D12_TEXTURE_LAYOUT_UNKNOWN || Layout == D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given texture layout is considered opaque.\n   >>> D3D12IsLayoutOpaque( D3D12_TEXTURE_LAYOUT Layout ) *\/",
        "query_nlx":"\/* Check if the given texture layout is either unknown or has a 64KB undefined swizzle.\n   >>> D3D12IsLayoutOpaque(Layout) returns true if Layout is D3D12_TEXTURE_LAYOUT_UNKNOWN or D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE, false otherwise *\/\nbool D3D12IsLayoutOpaque( D3D12_TEXTURE_LAYOUT Layout ) {  *\/"
    }

    {
        "file_name":"deadline_timer_service_function_2.cpp",
        "line_count":5,
        "code":"void construct(implementation_type& impl)\n  {\n    impl.expiry = time_type();\n    impl.might_have_pending_waits = false;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the expiry time and set the flag for pending waits to false in the provided implementation. *\/\nvoid construct(implementation_type& impl) {",
        "query_nlx":"\/* Function named construct initializes the expiry time and sets the flag for pending waits to false in the provided implementation.\n>>> construct(implementation_type& impl) *\/"
    }

    {
        "file_name":"decode_function_1.cpp",
        "line_count":4,
        "code":"int WebPIsPremultipliedMode(WEBP_CSP_MODE mode) {\n  return (mode == MODE_rgbA || mode == MODE_bgrA || mode == MODE_Argb ||\n          mode == MODE_rgbA_4444);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the input color space mode corresponds to a premultiplied alpha format.\n>>> WebPIsPremultipliedMode(mode)\n*\/ \nint WebPIsPremultipliedMode(WEBP_CSP_MODE mode) { ",
        "query_nlx":"\/* Function named WebPIsPremultipliedMode determines if a given color space mode is in premultiplied mode by checking if it matches specific predefined modes.\n>>> WebPIsPremultipliedMode(MODE_rgbA) true\n>>> WebPIsPremultipliedMode(MODE_bgrA) true\n>>> WebPIsPremultipliedMode(MODE_Argb) true\n>>> WebPIsPremultipliedMode(MODE_rgbA_4444) true *\/ \nint WebPIsPremultipliedMode(WEBP_CSP_MODE mode) { "
    }

    {
        "file_name":"decode_function_2.cpp",
        "line_count":5,
        "code":"int WebPIsAlphaMode(WEBP_CSP_MODE mode) {\n  return (mode == MODE_RGBA || mode == MODE_BGRA || mode == MODE_ARGB ||\n          mode == MODE_RGBA_4444 || mode == MODE_YUVA ||\n          WebPIsPremultipliedMode(mode));\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given color space mode is in alpha mode.\n>>> WebPIsAlphaMode(mode)\n*\/ \nint WebPIsAlphaMode(WEBP_CSP_MODE mode) {",
        "query_nlx":"\/* Function named WebPIsAlphaMode determines if a given color space mode is in alpha mode by checking if it matches specific alpha modes or if it is a premultiplied mode.\n>>> WebPIsAlphaMode(MODE_RGBA) true\n>>> WebPIsAlphaMode(MODE_RGB) false *\/ \nint WebPIsAlphaMode(WEBP_CSP_MODE mode) { "
    }

    {
        "file_name":"decode_function_4.cpp",
        "line_count":3,
        "code":"int WebPInitDecBuffer(WebPDecBuffer* buffer) {\n  return WebPInitDecBufferInternal(buffer, WEBP_DECODER_ABI_VERSION);\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize a decoding buffer for a specific version of the decoder.\n>>> WebPInitDecBuffer(WebPDecBuffer* buffer) *\/",
        "query_nlx":"\/* Function named WebPInitDecBuffer initializes a WebPDecBuffer structure using an internal function with the specified decoder ABI version.\n>>> WebPInitDecBuffer(WebPDecBuffer* buffer) returns the result of calling WebPInitDecBufferInternal with the decoder ABI version *\/"
    }

    {
        "file_name":"decode_function_6.cpp",
        "line_count":3,
        "code":"int WebPInitDecoderConfig(WebPDecoderConfig* config) {\n  return WebPInitDecoderConfigInternal(config, WEBP_DECODER_ABI_VERSION);\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize a decoder configuration using the provided settings.\n   >>> WebPInitDecoderConfig(config) int *\/",
        "query_nlx":"\/* Function named WebPInitDecoderConfig initializes the decoder configuration with the given parameters.\n>>> WebPInitDecoderConfig(config) returns the result of calling WebPInitDecoderConfigInternal with the provided configuration and the constant WEBP_DECODER_ABI_VERSION. *\/ \nint WebPInitDecoderConfig(WebPDecoderConfig* config) {"
    }

    {
        "file_name":"Deferred_function_1_1.cpp",
        "line_count":1,
        "code":"void disarm() { armed = false; }",
        "mark":8.0,
        "query_nsx":"\/* Disarm the system by setting the armed status to false.\n   >>> disarm() *\/ \nvoid disarm();",
        "query_nlx":"\/* Define a function named disarm that sets a variable named armed to false. \n   >>> disarm() *\/ \nvoid disarm() {"
    }

    {
        "file_name":"DiscordInstance_function_2.cpp",
        "line_count":3,
        "code":"void SetToken(const std::string& token){\n\t\tm_token = token;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set a token value for the system.\n   >>> SetToken(\"abc123\") *\/ \nvoid SetToken(const std::string& token){",
        "query_nlx":"\/* Function named SetToken sets a token value to a given string.\n   >>> SetToken(\"abc\") *\/ \nvoid SetToken(const std::string& token){ "
    }

    {
        "file_name":"DiscordInstance_function_5.cpp",
        "line_count":4,
        "code":"void OnJsonException(Json::exception & ex)\n{\n\tGetFrontend()->OnJsonException(ex.what());\n}",
        "mark":8.0,
        "query_nsx":"\/* Call a frontend function when a JSON exception occurs.\n   >>> OnJsonException(Json::exception & ex) *\/",
        "query_nlx":"\/* Function named OnJsonException calls a method on the frontend object when a JSON exception occurs.\n>>> OnJsonException(Json::exception & ex) void { *\/"
    }

    {
        "file_name":"display_base_function_4.cpp",
        "line_count":20,
        "code":"else if (status == platf::capture_e::timeout) {\n          \/\/ The D3D11 device is protected by an unfair lock that is held the entire time that\n          \/\/ IDXGIOutputDuplication::AcquireNextFrame() is running. This is normally harmless,\n          \/\/ however sometimes the encoding thread needs to interact with our ID3D11Device to\n          \/\/ create dummy images or initialize the shared state that is used to pass textures\n          \/\/ between the capture and encoding ID3D11Devices.\n          \/\/\n          \/\/ When we're in a state where we're not actively receiving frames regularly, we will\n          \/\/ spend almost 100% of our time in AcquireNextFrame() holding that critical lock.\n          \/\/ Worse still, since it's unfair, we can monopolize it while the encoding thread\n          \/\/ is starved. The encoding thread may acquire it for a few moments across a few\n          \/\/ ID3D11Device calls before losing it again to us for another long time waiting in\n          \/\/ AcquireNextFrame(). The starvation caused by this lock contention causes encoder\n          \/\/ reinitialization to take several seconds instead of a fraction of a second.\n          \/\/\n          \/\/ To avoid starving the encoding thread, sleep without the lock held for a little\n          \/\/ while each time we reach our max frame timeout. This will only happen when nothing\n          \/\/ is updating the display, so no visible stutter should be introduced by the sleep.\n          std::this_thread::sleep_for(10ms);\n        }",
        "mark":8.0,
        "query_nsx":"        \/* Implement a mechanism to prevent starvation of the encoding thread due to lock contention during frame acquisition.\n        >>> else if (status == platf::capture_e::timeout) { *\/",
        "query_nlx":"\/* When the status indicates a timeout during capture, a sleep of 10 milliseconds is performed without holding a lock to prevent starvation of the encoding thread.\n   >>> else if (status == platf::capture_e::timeout) { *\/"
    }

    {
        "file_name":"display_vram_function_16.cpp",
        "line_count":8,
        "code":"void\n      reset() {\n        capture_texture_p = nullptr;\n        encoder_texture.reset();\n        encoder_input_res.reset();\n        encoder_mutex.reset();\n        img_weak.reset();\n      }",
        "mark":8.0,
        "query_nsx":"\/* Reset all internal state variables to their initial values.\n>>> reset() *\/ \nvoid reset();",
        "query_nlx":"\/* Reset all internal variables and pointers to their default or initial state.\n   >>> reset() *\/\nvoid reset() { \/\/ Function signature."
    }

    {
        "file_name":"display_vram_function_8.cpp",
        "line_count":4,
        "code":"blob_t\n  compile_pixel_shader(LPCSTR file) {\n    return compile_shader(file, \"main_ps\", \"ps_5_0\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Compile a pixel shader using the specified file, entry point, and shader model version.\n   >>> compile_pixel_shader(LPCSTR file) *\/\nblob_t compile_pixel_shader(LPCSTR file) {",
        "query_nlx":"\/* Function named compile_pixel_shader compiles a pixel shader using the specified file, entry point, and shader model version.\n>>> compile_pixel_shader(\"shader_file.hlsl\") returns a blob_t object representing the compiled shader *\/ \nblob_t compile_pixel_shader(LPCSTR file) {"
    }

    {
        "file_name":"dllmain_function_2_1.cpp",
        "line_count":6,
        "code":"void truncate_log_file() {\n        if (std::filesystem::exists(_filename)) {\n            std::ofstream ofs(_filename, std::ofstream::out | std::ofstream::trunc);\n            ofs.close();\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Truncate a log file if it exists.\n>>> void truncate_log_file() { *\/",
        "query_nlx":"\/* Function named truncate_log_file deletes the contents of a log file if it exists.\n>>> truncate_log_file() *\/"
    }

    {
        "file_name":"dllmain_function_45.cpp",
        "line_count":3,
        "code":"else if (!FrameGenMotionBlurLockoutScanResult || !FrameGenMotionBlurLogicScanResult) {\n            spdlog::error(\"Frame Generation Motion Blur: Pattern scan failed.\");\n        }",
        "mark":8.0,
        "query_nsx":"\/* Check if the frame generation motion blur pattern scan results are valid.\n   >>> frame_generation_motion_blur_scan_valid() *\/ \n#include <spdlog.h> \nbool frame_generation_motion_blur_scan_valid() {",
        "query_nlx":"\/* Check if either the FrameGenMotionBlurLockoutScanResult or FrameGenMotionBlurLogicScanResult is false, and if so, log an error message stating that the pattern scan for frame generation motion blur has failed. *\/\nelse if (!FrameGenMotionBlurLockoutScanResult || !FrameGenMotionBlurLogicScanResult) { \n    spdlog::error(\"Frame Generation Motion Blur: Pattern scan failed.\"); \n}"
    }

    {
        "file_name":"dllmain_function_62.cpp",
        "line_count":17,
        "code":"DWORD GetMainThreadId (void)\n{\n    THREADENTRY32 te32 { .dwSize = sizeof (THREADENTRY32) };\n\n    const DWORD dwProcId   = GetCurrentProcessId ();\n    HANDLE hThreadSnapshot = CreateToolhelp32Snapshot (TH32CS_SNAPTHREAD, 0);\n\n    if (Thread32First (hThreadSnapshot, &te32)) {\n        do {\n            if (te32.th32OwnerProcessID == dwProcId) {\n                return te32.th32ThreadID;\n            }\n        } while (Thread32Next (hThreadSnapshot, &te32));\n    }\n\n    return 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the main thread ID of the current process.\n   >>> GetMainThreadId() DWORD *\/",
        "query_nlx":"\/* Function named GetMainThreadId retrieves the ID of the main thread of the current process by iterating through the list of threads associated with the process and returning the ID of the first thread that belongs to the same process.\n>>> GetMainThreadId() DWORD *\/"
    }

    {
        "file_name":"DriverEnums_function_1.cpp",
        "line_count":20,
        "code":"bool isUnsignedIntFormat(TextureFormat format) {\n    switch (format) {\n        case TextureFormat::R8UI:\n        case TextureFormat::R16UI:\n        case TextureFormat::R32UI:\n        case TextureFormat::RG8UI:\n        case TextureFormat::RG16UI:\n        case TextureFormat::RG32UI:\n        case TextureFormat::RGB8UI:\n        case TextureFormat::RGB16UI:\n        case TextureFormat::RGB32UI:\n        case TextureFormat::RGBA8UI:\n        case TextureFormat::RGBA16UI:\n        case TextureFormat::RGBA32UI:\n            return true;\n\n        default:\n            return false;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given texture format is an unsigned integer format.\n>>> bool isUnsignedIntFormat(TextureFormat format); *\/",
        "query_nlx":"        \/* Function named isUnsignedIntFormat determines if a given texture format corresponds to an unsigned integer format.\n        >>> isUnsignedIntFormat(TextureFormat format) true if format is R8UI, R16UI, R32UI, RG8UI, RG16UI, RG32UI, RGB8UI, RGB16UI, RGB32UI, RGBA8UI, RGBA16UI, or RGBA32UI; false otherwise *\/ \n        bool isUnsignedIntFormat(TextureFormat format) { "
    }

    {
        "file_name":"DriverEnums_function_2.cpp",
        "line_count":20,
        "code":"bool isSignedIntFormat(TextureFormat format) {\n    switch (format) {\n        case TextureFormat::R8I:\n        case TextureFormat::R16I:\n        case TextureFormat::R32I:\n        case TextureFormat::RG8I:\n        case TextureFormat::RG16I:\n        case TextureFormat::RG32I:\n        case TextureFormat::RGB8I:\n        case TextureFormat::RGB16I:\n        case TextureFormat::RGB32I:\n        case TextureFormat::RGBA8I:\n        case TextureFormat::RGBA16I:\n        case TextureFormat::RGBA32I:\n            return true;\n\n        default:\n            return false;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given texture format is a signed integer format.\n>>> bool isSignedIntFormat(TextureFormat format); *\/",
        "query_nlx":"\/* Function named isSignedIntFormat determines if a given texture format corresponds to a signed integer format.\n>>> isSignedIntFormat(TextureFormat format) \n*\/ \nbool isSignedIntFormat(TextureFormat format) {"
    }

    {
        "file_name":"Dxgi_function_15.cpp",
        "line_count":5,
        "code":"void _DXGIDeclareAdapterRemovalSupport()\n{\n    LOG_FUNC();\n    dxgi.DeclareAdapterRemovalSupport();\n}",
        "mark":8.0,
        "query_nsx":"\/* Declare support for adapter removal in the DXGI interface.\n   >>> _DXGIDeclareAdapterRemovalSupport() *\/",
        "query_nlx":"\/* Declare a function that logs a message and then declares support for adapter removal using the DXGI library.\n   >>> _DXGIDeclareAdapterRemovalSupport() *\/ \nvoid _DXGIDeclareAdapterRemovalSupport() { "
    }

    {
        "file_name":"Dxgi_function_17.cpp",
        "line_count":5,
        "code":"void _ApplyCompatResolutionQuirking()\n{\n    LOG_FUNC();\n    dxgi.ApplyCompatResolutionQuirking();\n}",
        "mark":8.0,
        "query_nsx":"        \/* Apply compatibility resolution quirking by invoking the corresponding function.\n        >>> _ApplyCompatResolutionQuirking() *\/ \n        void _ApplyCompatResolutionQuirking() { ",
        "query_nlx":"\/* Apply compatibility resolution quirking by calling the function dxgi.ApplyCompatResolutionQuirking after logging the function execution.\n>>> _ApplyCompatResolutionQuirking() *\/ \nvoid _ApplyCompatResolutionQuirking() { "
    }

    {
        "file_name":"Dxgi_function_25.cpp",
        "line_count":5,
        "code":"void _DXGIDumpJournal()\n{\n    LOG_FUNC();\n    dxgi.DumpJournal();\n}",
        "mark":8.0,
        "query_nsx":"\/* Dump the journal related to DXGI operations.\n   >>> _DXGIDumpJournal() *\/",
        "query_nlx":"\/* Function named _DXGIDumpJournal logs a function call and then dumps the journal using the dxgi object. \n>>> _DXGIDumpJournal() void *\/"
    }

    {
        "file_name":"Dxgi_function_27.cpp",
        "line_count":5,
        "code":"void _PIXBeginCapture()\n{\n    LOG_FUNC();\n    dxgi.PIXBeginCapture();\n}",
        "mark":8.0,
        "query_nsx":"\/* Begin capturing graphics for performance analysis.\n>>> _PIXBeginCapture() *\/ \nvoid _PIXBeginCapture() {",
        "query_nlx":"\/* Function named _PIXBeginCapture logs a function call and then initiates a capture for a graphics debugging tool.\n>>> _PIXBeginCapture() calls the LOG_FUNC() function and then starts a capture using dxgi.PIXBeginCapture() *\/ \nvoid _PIXBeginCapture() { "
    }

    {
        "file_name":"Dxgi_function_28.cpp",
        "line_count":5,
        "code":"void _PIXEndCapture()\n{\n    LOG_FUNC();\n    dxgi.PIXEndCapture();\n}",
        "mark":8.0,
        "query_nsx":"\/* End the capture process and log the function call before ending the capture.\n>>> _PIXEndCapture() *\/",
        "query_nlx":"\/* Function named _PIXEndCapture logs a function call and then ends a capture process using a specific library function.\n>>> _PIXEndCapture() logs the function call and ends the capture process using a library function *\/ \nvoid _PIXEndCapture() { "
    }

    {
        "file_name":"Dxgi_function_29.cpp",
        "line_count":5,
        "code":"void _PIXGetCaptureState()\n{\n    LOG_FUNC();\n    dxgi.PIXGetCaptureState();\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the current state of capture for debugging and profiling purposes.\n>>> _PIXGetCaptureState() *\/ \nvoid _PIXGetCaptureState() {",
        "query_nlx":"\/* Function named _PIXGetCaptureState calls a logging function and then retrieves the current state of a capture operation using a specific library function. \n>>> _PIXGetCaptureState() *\/ \nvoid _PIXGetCaptureState() { "
    }

    {
        "file_name":"Dxgi_function_30.cpp",
        "line_count":5,
        "code":"void _SetAppCompatStringPointer()\n{\n    LOG_FUNC();\n    dxgi.SetAppCompatStringPointer();\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the application compatibility string pointer.\n>>> void _SetAppCompatStringPointer() *\/",
        "query_nlx":"        \/* Function named _SetAppCompatStringPointer calls a logging function and then sets a string pointer in a DirectX Graphics Infrastructure object. \n        >>> _SetAppCompatStringPointer() *\/ \n        void _SetAppCompatStringPointer() {"
    }

    {
        "file_name":"Dxgi_function_31.cpp",
        "line_count":5,
        "code":"void _UpdateHMDEmulationStatus()\n{\n    LOG_FUNC();\n    dxgi.UpdateHMDEmulationStatus();\n}",
        "mark":8.0,
        "query_nsx":"\/* Update the status of HMD emulation.\n   >>> void _UpdateHMDEmulationStatus(); *\/",
        "query_nlx":"\/* Function named _UpdateHMDEmulationStatus calls a logging function and then updates the emulation status of a Head-Mounted Display (HMD) device using a function provided by a DirectX Graphics Infrastructure (dxgi) object. \n>>> _UpdateHMDEmulationStatus() *\/"
    }

    {
        "file_name":"egl_function_16.cpp",
        "line_count":9,
        "code":"void glad_close_dlopen_handle(void* handle) {\n    if (handle != NULL) {\n#if GLAD_PLATFORM_WIN32\n        FreeLibrary((HMODULE) handle);\n#else\n        dlclose(handle);\n#endif\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Close the dynamic loading handle based on the platform.\n>>> glad_close_dlopen_handle(void* handle) *\/",
        "query_nlx":"\/* Function named glad_close_dlopen_handle closes a dynamic loading handle if it is not NULL. \n>>> glad_close_dlopen_handle(NULL) does nothing \n>>> glad_close_dlopen_handle(handle) closes the handle using platform-specific functions *\/ \nvoid glad_close_dlopen_handle(void* handle) {"
    }

    {
        "file_name":"egl_function_17.cpp",
        "line_count":11,
        "code":"GLADapiproc glad_dlsym_handle(void* handle, const char *name) {\n    if (handle == NULL) {\n        return NULL;\n    }\n\n#if GLAD_PLATFORM_WIN32\n    return (GLADapiproc) GetProcAddress((HMODULE) handle, name);\n#else\n    return GLAD_GNUC_EXTENSION (GLADapiproc) dlsym(handle, name);\n#endif\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a function pointer from a dynamic library handle based on the provided name.\n>>> glad_dlsym_handle(void* handle, const char *name) *\/",
        "query_nlx":"\/* Function named glad_dlsym_handle retrieves the address of a function symbol from a dynamic library handle. \n>>> glad_dlsym_handle(handle, name) returns the function symbol address if the handle is not NULL on Windows platform, otherwise returns NULL. *\/ \nGLADapiproc glad_dlsym_handle(void* handle, const char *name) { *\/"
    }

    {
        "file_name":"egl_function_22.cpp",
        "line_count":6,
        "code":"void gladLoaderUnloadEGL() {\n    if (_egl_handle != NULL) {\n        glad_close_dlopen_handle(_egl_handle);\n        _egl_handle = NULL;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Unload the EGL loader handle if it is currently loaded.\n>>> gladLoaderUnloadEGL() *\/",
        "query_nlx":"\/* Function named gladLoaderUnloadEGL unloads the EGL handle if it is not NULL.\n>>> gladLoaderUnloadEGL() *\/ \nvoid gladLoaderUnloadEGL() {"
    }

    {
        "file_name":"enabled_function_1.cpp",
        "line_count":3,
        "code":"error_code make_error_code(error::value e) {\n    return lib::error_code(static_cast<int>(e), get_category());\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an error code based on the provided error value using a specific category.\n>>> error_code make_error_code(error::value e); *\/",
        "query_nlx":"\/* Create an error code based on a given error value by converting it to an integer and associating it with a specific error category. \n>>> make_error_code(error::value e) error_code *\/"
    }

    {
        "file_name":"enabled_function_16.cpp",
        "line_count":25,
        "code":"string generate_response() {\n        std::string ret = \"permessage-deflate\";\n\n        if (m_server_no_context_takeover) {\n            ret += \"; server_no_context_takeover\";\n        }\n\n        if (m_client_no_context_takeover) {\n            ret += \"; client_no_context_takeover\";\n        }\n\n        if (m_server_max_window_bits < default_server_max_window_bits) {\n            std::stringstream s;\n            s << int(m_server_max_window_bits);\n            ret += \"; server_max_window_bits=\"+s.str();\n        }\n\n        if (m_client_max_window_bits < default_client_max_window_bits) {\n            std::stringstream s;\n            s << int(m_client_max_window_bits);\n            ret += \"; client_max_window_bits=\"+s.str();\n        }\n\n        return ret;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Generate a response string based on certain conditions being met.\n   >>> string generate_response() { *\/",
        "query_nlx":"\/* Generate a response string based on certain conditions including 'permessage-deflate', 'server_no_context_takeover', 'client_no_context_takeover', 'server_max_window_bits', and 'client_max_window_bits'.\n   >>> generate_response() string *\/"
    }

    {
        "file_name":"enabled_function_3.cpp",
        "line_count":3,
        "code":"void enable_server_no_context_takeover() {\n        m_server_no_context_takeover = true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Enable the server to operate without context takeover.\n   >>> enable_server_no_context_takeover() *\/ \nvoid enable_server_no_context_takeover();",
        "query_nlx":"\n\/* Function named enable_server_no_context_takeover sets a flag to enable server-side no context takeover.\n>>> enable_server_no_context_takeover() *\/ \nvoid enable_server_no_context_takeover() {"
    }

    {
        "file_name":"enabled_function_4.cpp",
        "line_count":3,
        "code":"void enable_client_no_context_takeover() {\n        m_client_no_context_takeover = true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Enable the option for the client to not reset the context during communication.\n>>> void enable_client_no_context_takeover() { *\/",
        "query_nlx":"        \/* Function named enable_client_no_context_takeover sets a flag to enable the client to not take over the context. \n        >>> enable_client_no_context_takeover() *\/ \n        void enable_client_no_context_takeover() {"
    }

    {
        "file_name":"encode_function_1.cpp",
        "line_count":4,
        "code":"int WebPConfigInit(WebPConfig* config) {\n  return WebPConfigInitInternal(config, WEBP_PRESET_DEFAULT, 75.f,\n                                WEBP_ENCODER_ABI_VERSION);\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize a configuration for image encoding with default settings and quality level.\n   >>> int WebPConfigInit(WebPConfig* config); *\/",
        "query_nlx":"\/* Function initializes a configuration structure with default values for a web image format.\n   >>> WebPConfigInit(config) initializes the configuration with default preset, quality of 75%, and encoder ABI version *\/ \nint WebPConfigInit(WebPConfig* config) {"
    }

    {
        "file_name":"encode_function_3.cpp",
        "line_count":3,
        "code":"int WebPPictureInit(WebPPicture* picture) {\n  return WebPPictureInitInternal(picture, WEBP_ENCODER_ABI_VERSION);\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize a webp picture using the provided pointer.\n   >>> WebPPictureInit(picture*) *\/",
        "query_nlx":"\/* Initialize a WebPPicture structure by calling the WebPPictureInitInternal function with the provided WebPPicture pointer and the WEBP_ENCODER_ABI_VERSION constant.\n>>> WebPPictureInit(WebPPicture* picture) *\/"
    }

    {
        "file_name":"endpoint_function_10.cpp",
        "line_count":3,
        "code":"void set_tcp_pre_init_handler(tcp_init_handler h) {\n        m_tcp_pre_init_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler function to be called before initializing a TCP connection.\n   >>> set_tcp_pre_init_handler(tcp_init_handler h) *\/",
        "query_nlx":"\/* Define a function that sets a handler for initializing TCP connections before the actual initialization process.\n   >>> set_tcp_pre_init_handler(handler) *\/ \nvoid set_tcp_pre_init_handler(tcp_init_handler h) {"
    }

    {
        "file_name":"endpoint_function_11.cpp",
        "line_count":3,
        "code":"void set_tcp_init_handler(tcp_init_handler h) {\n        set_tcp_pre_init_handler(h);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler for initializing TCP connections by using the provided handler.\n   >>> void set_tcp_init_handler(tcp_init_handler h) { *\/",
        "query_nlx":"\/* Define a function that sets a handler for initializing TCP connections by calling another function to set a pre-initialization handler.\n   >>> set_tcp_init_handler(tcp_init_handler h) *\/"
    }

    {
        "file_name":"endpoint_function_13.cpp",
        "line_count":3,
        "code":"void set_listen_backlog(int backlog) {\n        m_listen_backlog = backlog;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the backlog value for listening connections.\n>>> void set_listen_backlog(int backlog) { *\/",
        "query_nlx":"\/* Define a function that sets the listen backlog value to the provided integer input.\n   >>> set_listen_backlog(10) *\/ \nvoid set_listen_backlog(int backlog) {"
    }

    {
        "file_name":"endpoint_function_14.cpp",
        "line_count":3,
        "code":"void set_reuse_addr(bool value) {\n        m_reuse_addr = value;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the value to enable or disable the reuse of the address for network sockets.\n   >>> set_reuse_addr(true) \n   >>> set_reuse_addr(false) *\/ \n   void set_reuse_addr(bool value) {",
        "query_nlx":"\/* Function named set_reuse_addr sets the value of a boolean variable to indicate whether the address can be reused or not.\n>>> set_reuse_addr(true) \n>>> set_reuse_addr(false) *\/ \nvoid set_reuse_addr(bool value) {"
    }

    {
        "file_name":"endpoint_function_15.cpp",
        "line_count":8,
        "code":"endpoint get_local_endpoint(lib::asio::error_code & ec) {\n        if (m_acceptor) {\n            return m_acceptor->local_endpoint(ec);\n        } else {\n            ec = lib::asio::error::make_error_code(lib::asio::error::bad_descriptor);\n            return lib::asio::ip::tcp::endpoint();\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the local endpoint if available, otherwise return a default TCP endpoint.\n   >>> endpoint get_local_endpoint(lib::asio::error_code & ec) { *\/",
        "query_nlx":"\/* Define a function that retrieves the local endpoint if the acceptor is available; otherwise, it returns an error code for a bad descriptor.\n   >>> get_local_endpoint(error_code ec) endpoint *\/"
    }

    {
        "file_name":"endpoint_function_20.cpp",
        "line_count":5,
        "code":"void listen(InternetProtocol const & internet_protocol, uint16_t port)\n    {\n        lib::asio::ip::tcp::endpoint ep(internet_protocol, port);\n        listen(ep);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Create a function that listens on a specified port using the provided internet protocol.\n   >>> void listen(InternetProtocol const & internet_protocol, uint16_t port) { *\/",
        "query_nlx":"\/* Define a function called listen that takes an InternetProtocol object and a port number as input, creates a TCP endpoint using the provided internet protocol and port, and then calls the listen function with the created endpoint.\n>>> listen(InternetProtocol const & internet_protocol, uint16_t port) *\/"
    }

    {
        "file_name":"endpoint_function_25.cpp",
        "line_count":13,
        "code":"void stop_listening(lib::error_code & ec) {\n        if (m_state != LISTENING) {\n            m_elog->write(log::elevel::library,\n                \"asio::listen called from the wrong state\");\n            using websocketpp::error::make_error_code;\n            ec = make_error_code(websocketpp::error::invalid_state);\n            return;\n        }\n\n        m_acceptor->close();\n        m_state = READY;\n        ec = lib::error_code();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Stop listening for incoming connections and reset the state to ready.\n   >>> void stop_listening(lib::error_code & ec) { *\/",
        "query_nlx":"\n\/* Define a function named stop_listening that handles the process of stopping listening for incoming connections. It checks if the current state is LISTENING, and if not, logs an error message and sets an error code accordingly. If the state is LISTENING, it closes the acceptor, updates the state to READY, and resets the error code.\n>>> stop_listening(lib::error_code & ec) *\/"
    }

    {
        "file_name":"endpoint_function_27.cpp",
        "line_count":3,
        "code":"size_t run() {\n        return m_io_service->run();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of the run operation.\n>>> run() size_t *\/",
        "query_nlx":"\/* Define a function that runs an input\/output service and returns the size of the service's run operation.\n>>> run() returns the size of the run operation of the input\/output service. *\/ \nsize_t run() {"
    }

    {
        "file_name":"endpoint_function_28.cpp",
        "line_count":3,
        "code":"size_t run_one() {\n        return m_io_service->run_one();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return the size of the input service after running it once.\n   >>> run_one()  *\/ \nsize_t run_one();",
        "query_nlx":"\/* Define a function that runs a single operation on an input service and returns the size of the operation's completion.\n   >>> run_one() returns the size of the operation's completion *\/ \nsize_t run_one();"
    }

    {
        "file_name":"endpoint_function_29.cpp",
        "line_count":3,
        "code":"void stop() {\n        m_io_service->stop();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Stop the input\/output service. \n>>> stop() *\/ \nvoid stop();",
        "query_nlx":"\/* Function named stop halts the ongoing operations of the input service.\n   >>> stop()\n*\/ \nvoid stop() {"
    }

    {
        "file_name":"endpoint_function_30.cpp",
        "line_count":3,
        "code":"size_t poll() {\n        return m_io_service->poll();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return the number of events that are ready to be processed.\n   >>> size_t poll() { *\/",
        "query_nlx":"        \/* Define a function that returns the number of pending asynchronous operations in the current I\/O service.\n        >>> poll() returns the number of pending asynchronous operations in the current I\/O service. *\/\n        size_t poll() {  *\/"
    }

    {
        "file_name":"endpoint_function_31.cpp",
        "line_count":3,
        "code":"size_t poll_one() {\n        return m_io_service->poll_one();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return the result of polling the input\/output service for a single event.\n   >>> size_t poll_one() { *\/",
        "query_nlx":"\/* Function named poll_one returns the result of invoking a method on an object referred to by a member variable of the current object. \n>>> poll_one() returns a size_t value representing the result of invoking the poll_one method on the object pointed to by the m_io_service member variable. *\/ \nsize_t poll_one() { "
    }

    {
        "file_name":"endpoint_function_32.cpp",
        "line_count":3,
        "code":"void reset() {\n        m_io_service->reset();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Reset the IO service to its initial state.\n    >>> reset() *\/ \n    void reset();",
        "query_nlx":"\/* Define a function that resets the internal state of an object or service.\n   >>> reset()\n*\/ \nvoid reset() {"
    }

    {
        "file_name":"endpoint_function_34.cpp",
        "line_count":3,
        "code":"void stop_perpetual() {\n        m_work.reset();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Reset the ongoing work process. \n>>> stop_perpetual() *\/ \nvoid stop_perpetual() {",
        "query_nlx":"\/* Define a function that stops a perpetual process by resetting the work state.\n   >>> stop_perpetual() *\/ \nvoid stop_perpetual() { "
    }

    {
        "file_name":"endpoint_function_49.cpp",
        "line_count":5,
        "code":"void log_err(log::level l, char const * msg, error_type const & ec) {\n        std::stringstream s;\n        s << msg << \" error: \" << ec << \" (\" << ec.message() << \")\";\n        m_elog->write(l,s.str());\n    }",
        "mark":8.0,
        "query_nsx":"\/* Log an error message with the specified level and error code details.\n>>> log_err(log::level l, char const * msg, error_type const & ec) *\/\nvoid log_err(log::level l, char const * msg, error_type const & ec) { ",
        "query_nlx":"\/* Function named log_err logs an error message along with an error code and its corresponding message.\n   >>> log_err(log::level l, char const * msg, error_type const & ec) *\/\n   \n   void log_err(log::level l, char const * msg, error_type const & ec) {"
    }

    {
        "file_name":"endpoint_function_50.cpp",
        "line_count":7,
        "code":"error_code clean_up_listen_after_error(error_type const & ec) {\n        if (m_acceptor->is_open()) {\n            m_acceptor->close();\n        }\n        log_err(log::elevel::info,\"asio listen\",ec);\n        return socket_con_type::translate_ec(ec);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Clean up resources and handle errors after listening for incoming connections.\n   >>> error_code clean_up_listen_after_error(error_type const & ec); *\/",
        "query_nlx":"\/* Function named clean_up_listen_after_error closes the acceptor if it is open, logs an error message with the provided error code, and returns the translated error code.\n>>> clean_up_listen_after_error(error_type const & ec) error_code *\/"
    }

    {
        "file_name":"endpoint_function_9.cpp",
        "line_count":3,
        "code":"void set_tcp_pre_bind_handler(tcp_pre_bind_handler h) {\n        m_tcp_pre_bind_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler function to be called before binding a TCP connection.\n   >>> void set_tcp_pre_bind_handler(tcp_pre_bind_handler h); *\/",
        "query_nlx":"\/* Define a function that sets a handler for pre-binding TCP connections.\n   >>> set_tcp_pre_bind_handler(handler) *\/ \nvoid set_tcp_pre_bind_handler(tcp_pre_bind_handler h) {"
    }

    {
        "file_name":"entry_handler_function_8.cpp",
        "line_count":8,
        "code":"void\n  debug_trap() {\n#ifdef _WIN32\n    DebugBreak();\n#else\n    std::raise(SIGTRAP);\n#endif\n  }",
        "mark":8.0,
        "query_nsx":"\/* Trigger a debug trap based on the operating system.\n   >>> debug_trap() *\/\nvoid debug_trap();",
        "query_nlx":"\/* Define a function that triggers a debug trap based on the operating system. \n   >>> debug_trap() *\/ \nvoid debug_trap() {"
    }

    {
        "file_name":"entry_handler_function_9.cpp",
        "line_count":6,
        "code":"void\nlog_publisher_data() {\n  BOOST_LOG(info) << \"Package Publisher: \"sv << SUNSHINE_PUBLISHER_NAME;\n  BOOST_LOG(info) << \"Publisher Website: \"sv << SUNSHINE_PUBLISHER_WEBSITE;\n  BOOST_LOG(info) << \"Get support: \"sv << SUNSHINE_PUBLISHER_ISSUE_URL;\n}",
        "mark":8.0,
        "query_nsx":"\/* Log publisher data including name, website, and support URL.\n>>> log_publisher_data() *\/ \nvoid log_publisher_data() {",
        "query_nlx":"\/* Log publisher data including the package publisher name, publisher website, and support URL using the BOOST_LOG library. \n>>> log_publisher_data() *\/ \nvoid log_publisher_data() {"
    }

    {
        "file_name":"epoll_reactor_function_1.cpp",
        "line_count":1,
        "code":"void set_ready_events(uint32_t events) { task_result_ = events; }",
        "mark":8.0,
        "query_nsx":"\/* Set the ready events for a task with the given value.\n>>> void set_ready_events(uint32_t events) *\/",
        "query_nlx":"\/* Define a function that sets the result of a task to a given set of events.\n   >>> set_ready_events(5) \n   >>> set_ready_events(10) *\/ \nvoid set_ready_events(uint32_t events) { "
    }

    {
        "file_name":"epoll_reactor_function_2.cpp",
        "line_count":1,
        "code":"void add_ready_events(uint32_t events) { task_result_ |= events; }",
        "mark":8.0,
        "query_nsx":"\/* Update the task result with the given events.\n>>> void add_ready_events(uint32_t events); *\/",
        "query_nlx":"\/* Function named add_ready_events updates the task result by adding the input events to it.\n   >>> add_ready_events(5) updates the task result by adding 5 to it.\n   >>> add_ready_events(10) updates the task result by adding 10 to it. *\/ \nvoid add_ready_events(uint32_t events) { "
    }

    {
        "file_name":"error_function_4.cpp",
        "line_count":5,
        "code":"error_code make_error_code(addrinfo_errors e)\n{\n  return asio::error_code(\n      static_cast<int>(e), get_addrinfo_category());\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an error code based on the given addrinfo_errors enumeration value.\n>>> error_code make_error_code(addrinfo_errors e) { *\/",
        "query_nlx":"\/* Create an error code based on the given addrinfo_errors enumeration value by converting it to an integer and associating it with the addrinfo error category.\n>>> make_error_code(addrinfo_errors e) error_code *\/"
    }

    {
        "file_name":"error_function_5.cpp",
        "line_count":5,
        "code":"error_code make_error_code(misc_errors e)\n{\n  return asio::error_code(\n      static_cast<int>(e), get_misc_category());\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an error code based on the given miscellaneous error type.\n>>> error_code make_error_code(misc_errors e) { *\/",
        "query_nlx":"\/* Create an error code based on a miscellaneous error code value by converting it to an integer and associating it with the miscellaneous error category.\n>>> make_error_code(misc_errors e) error_code *\/"
    }

    {
        "file_name":"Event_function_3.cpp",
        "line_count":16,
        "code":"bool addListener(Func&& func, int* idx = nullptr)\n    {\n        if (numListeners + 1 > MaxListeners)\n        {\n            return false;\n        }\n        else\n        {\n            if (idx)\n            {\n                *idx = numListeners;\n            }\n            listeners[numListeners++] = move(func);\n            return true;\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Add a listener function to a collection with an optional index parameter.\n   >>> bool addListener(Func&& func, int* idx = nullptr) *\/",
        "query_nlx":"\/* Function named addListener allows adding a listener function to a collection, optionally specifying an index for the listener.\n   >>> addListener(func) true\n   >>> addListener(func, &idx) true\n   >>> addListener(func, &idx) false *\/ \nbool addListener(Func&& func, int* idx = nullptr) { "
    }

    {
        "file_name":"Event_function_4.cpp",
        "line_count":11,
        "code":"bool removeListener(Func& func)\n    {\n        for (int idx = 0; idx < numListeners; ++idx)\n        {\n            if (listeners[idx] == func)\n            {\n                return removeListenerAt(idx);\n            }\n        }\n        return false;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove a listener function from the list of listeners if it exists.\n   >>> bool removeListener(Func& func); *\/",
        "query_nlx":"\/* Function named removeListener checks if a given function is present in an array of listeners and removes it if found. \n>>> removeListener(func) true \n>>> removeListener(func) false *\/ \nbool removeListener(Func& func) { "
    }

    {
        "file_name":"extension_function_1.cpp",
        "line_count":3,
        "code":"error_code make_error_code(error::value e) {\n    return lib::error_code(static_cast<int>(e), get_category());\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an error code based on the provided error value. \n>>> error_code make_error_code(error::value e) { *\/",
        "query_nlx":"\/* Create an error code based on a given error value by converting it to an integer and associating it with a specific error category. \n>>> make_error_code(error::value e) error_code *\/"
    }

    {
        "file_name":"FfxApi_Proxy_function_18.cpp",
        "line_count":14,
        "code":"string ReturnCodeToString(ffxReturnCode_t result)\n    {\n        switch (result)\n        {\n            case FFX_API_RETURN_OK: return \"The oparation was successful.\";\n            case FFX_API_RETURN_ERROR: return \"An error occurred that is not further specified.\";\n            case FFX_API_RETURN_ERROR_UNKNOWN_DESCTYPE: return \"The structure type given was not recognized for the function or context with which it was used. This is likely a programming error.\";\n            case FFX_API_RETURN_ERROR_RUNTIME_ERROR: return \"The underlying runtime (e.g. D3D12, Vulkan) or effect returned an error code.\";\n            case FFX_API_RETURN_NO_PROVIDER: return \"No provider was found for the given structure type. This is likely a programming error.\";\n            case FFX_API_RETURN_ERROR_MEMORY: return \"A memory allocation failed.\";\n            case FFX_API_RETURN_ERROR_PARAMETER: return \"A parameter was invalid, e.g. a null pointer, empty resource or out-of-bounds enum value.\";\n            default: return \"Unknown\";\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Given a specific return code, this function converts it into a corresponding human-readable message.\n   >>> string ReturnCodeToString(ffxReturnCode_t result) { *\/",
        "query_nlx":"\/* Function named ReturnCodeToString converts a given result code into a human-readable string description based on predefined error cases. \n>>> ReturnCodeToString(FFX_API_RETURN_OK) returns \"The operation was successful.\"\n>>> ReturnCodeToString(FFX_API_RETURN_ERROR) returns \"An error occurred that is not further specified.\"\n>>> ReturnCodeToString(FFX_API_RETURN_ERROR_UNKNOWN_DESCTYPE) returns \"The structure type given was not recognized for the function or context with which it was used. This is likely a programming error.\"\n>>> ReturnCodeToString(FFX_API_RETURN_ERROR_RUNTIME_ERROR) returns \"The underlying runtime (e.g. D3D12, Vulkan) or effect returned an error code.\"\n>>> ReturnCodeToString(FFX_API_RETURN_NO_PROVIDER) returns \"No provider was found for the given structure type. This is likely a programming error.\"\n>>> ReturnCodeToString(FFX_API_RETURN_ERROR_MEMORY) returns \"A memory allocation failed.\"\n>>> ReturnCodeToString(FFX_API_RETURN_ERROR_PARAMETER) returns \"A parameter was invalid, e.g. a null pointer, empty resource or out-of-bounds enum value.\"\n>>> ReturnCodeToString(Any other code) returns \"Unknown\" *\/ \nstring ReturnCodeToString(ffxReturnCode_t result) {"
    }

    {
        "file_name":"ffx_a_function_14.cpp",
        "line_count":1,
        "code":"AD1 AAbsD1(AD1 a){return __builtin_fabs(a);}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the absolute value of a given number.\n   >>> AAbsD1(3.14) 3.14\n   >>> AAbsD1(-5.0) 5.0 *\/ \ndouble AAbsD1(double a){",
        "query_nlx":"\/* Function named AAbsD1 takes a single input parameter of type AD1 and returns the absolute value of that parameter using a built-in function.\n>>> AAbsD1(5.6) returns 5.6\n>>> AAbsD1(-8.9) returns 8.9\n*\/ \nAD1 AAbsD1(AD1 a){ "
    }

    {
        "file_name":"ffx_a_function_475.cpp",
        "line_count":1,
        "code":"AH2 ALerpH2(AH2 x,AH2 y,AH2 a){return lerp(x,y,a);}",
        "mark":8.0,
        "query_nsx":"\/* Interpolate between two values based on a given factor.\n   >>> ALerpH2(AH2 x, AH2 y, AH2 a){ *\/",
        "query_nlx":"\/* Function ALerpH2 calculates the linear interpolation between two values x and y based on a given parameter a.\n   >>> ALerpH2(3.0, 5.0, 0.5) returns 4.0\n   >>> ALerpH2(10.0, 20.0, 0.3) returns 13.0 *\/ \nAH2 ALerpH2(AH2 x, AH2 y, AH2 a){ "
    }

    {
        "file_name":"ffx_fsr2_common_function_17.cpp",
        "line_count":5,
        "code":"FfxFloat32 MinDividedByMax(const FfxFloat32 v0, const FfxFloat32 v1)\n{\n    const FfxFloat32 m = ffxMax(v0, v1);\n    return m != 0 ? ffxMin(v0, v1) \/ m : 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the minimum value divided by the maximum value from two input numbers.\n>>> FfxFloat32 MinDividedByMax(const FfxFloat32 v0, const FfxFloat32 v1) { *\/",
        "query_nlx":"\/* Function named MinDividedByMax calculates the minimum value divided by the maximum value of two input numbers. \n>>> MinDividedByMax(3.5, 2.0) 0.5714286 \n>>> MinDividedByMax(0.0, 4.5) 0.0 *\/ \nFfxFloat32 MinDividedByMax(const FfxFloat32 v0, const FfxFloat32 v1) { *\/"
    }

    {
        "file_name":"ffx_fsr2_common_function_19.cpp",
        "line_count":13,
        "code":"FfxFloat32x3 YCoCgToRGB(FfxFloat32x3 fYCoCg)\n{\n    FfxFloat32x3 fRgb;\n\n    fYCoCg.yz -= FfxFloat32x2(0.5f, 0.5f);  \/\/ [0,1] -> [-0.5,0.5]\n\n    fRgb = FfxFloat32x3(\n        fYCoCg.x + fYCoCg.y - fYCoCg.z,\n        fYCoCg.x + fYCoCg.z,\n        fYCoCg.x - fYCoCg.y - fYCoCg.z);\n\n    return fRgb;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert color values from YCoCg color space to RGB color space.\n>>> YCoCgToRGB(FfxFloat32x3 fYCoCg) \n*\/",
        "query_nlx":"\/* Function named YCoCgToRGB converts a given YCoCg color value to RGB color space.\n>>> YCoCgToRGB({0.2, 0.4, 0.6}) = {0.1, 0.8, -0.2} \n>>> YCoCgToRGB({0.5, 0.3, 0.7}) = {0.5, 1.2, -0.5} *\/ \nFfxFloat32x3 YCoCgToRGB(FfxFloat32x3 fYCoCg) { *\/"
    }

    {
        "file_name":"ffx_fsr2_common_function_23.cpp",
        "line_count":4,
        "code":"FfxFloat32 RGBToLuma(FfxFloat32x3 fLinearRgb)\n{\n    return dot(fLinearRgb, FfxFloat32x3(0.2126f, 0.7152f, 0.0722f));\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the luminance value from RGB color values.\n>>> FfxFloat32 RGBToLuma(FfxFloat32x3 fLinearRgb) *\/",
        "query_nlx":"\/* Function named RGBToLuma calculates the luminance value from a given RGB color represented as a vector of three floating-point values. The luminance value is computed by taking the dot product of the RGB color vector with a predefined vector containing luminance coefficients.\n>>> RGBToLuma({0.5, 0.3, 0.8}) 0.44316\n>>> RGBToLuma({0.1, 0.9, 0.2}) 0.3526 *\/ \nFfxFloat32 RGBToLuma(FfxFloat32x3 fLinearRgb) { *\/"
    }

    {
        "file_name":"ffx_fsr2_common_function_24.cpp",
        "line_count":4,
        "code":"FFX_MIN16_F RGBToLuma(FFX_MIN16_F3 fLinearRgb)\n{\n    return dot(fLinearRgb, FFX_MIN16_F3(0.2126f, 0.7152f, 0.0722f));\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the luminance value from the RGB color values using specific coefficients.\n>>> RGBToLuma(FFX_MIN16_F3 fLinearRgb) FFX_MIN16_F *\/",
        "query_nlx":"\/* Function named RGBToLuma calculates the luminance value of a given RGB color represented as a vector of three floating-point values. The luminance value is computed by taking a weighted sum of the RGB components using the coefficients 0.2126, 0.7152, and 0.0722 respectively.\n>>> RGBToLuma({0.5, 0.3, 0.8}) 0.47516\n>>> RGBToLuma({0.1, 0.9, 0.2}) 0.3526 *\/ \nFFX_MIN16_F RGBToLuma(FFX_MIN16_F3 fLinearRgb) { *\/"
    }

    {
        "file_name":"ffx_fsr2_common_function_31.cpp",
        "line_count":4,
        "code":"FfxInt32x2 ClampLoad(FfxInt32x2 iPxSample, FfxInt32x2 iPxOffset, FfxInt32x2 iTextureSize)\n{\n    return clamp(iPxSample + iPxOffset, FfxInt32x2(0, 0), iTextureSize - FfxInt32x2(1, 1));\n}",
        "mark":8.0,
        "query_nsx":"\/* Given three sets of integer pairs, this function calculates the clamped load based on the sum of the first pair and the second pair, ensuring it does not exceed the maximum texture size minus one. \n>>> FfxInt32x2 ClampLoad(FfxInt32x2 iPxSample, FfxInt32x2 iPxOffset, FfxInt32x2 iTextureSize) *\/",
        "query_nlx":"        \/* Function named ClampLoad calculates the clamped load value based on the input pixel sample, pixel offset, and texture size.\n        >>> ClampLoad(iPxSample, iPxOffset, iTextureSize) FfxInt32x2 *\/"
    }

    {
        "file_name":"ffx_fsr2_common_function_32.cpp",
        "line_count":4,
        "code":"FFX_MIN16_I2 ClampLoad(FFX_MIN16_I2 iPxSample, FFX_MIN16_I2 iPxOffset, FFX_MIN16_I2 iTextureSize)\n{\n    return clamp(iPxSample + iPxOffset, FFX_MIN16_I2(0, 0), iTextureSize - FFX_MIN16_I2(1, 1));\n}",
        "mark":8.0,
        "query_nsx":"\/* Given three values representing a sample, an offset, and a texture size, return a clamped value ensuring it stays within the texture boundaries.\n>>> FFX_MIN16_I2 ClampLoad(FFX_MIN16_I2 iPxSample, FFX_MIN16_I2 iPxOffset, FFX_MIN16_I2 iTextureSize) *\/",
        "query_nlx":"        \/* Function named ClampLoad calculates the clamped sum of two input values within a specified range. \n        >>> ClampLoad(iPxSample, iPxOffset, iTextureSize) FFX_MIN16_I2 *\/"
    }

    {
        "file_name":"ffx_fsr2_common_function_33.cpp",
        "line_count":4,
        "code":"FfxBoolean IsOnScreen(FfxInt32x2 pos, FfxInt32x2 size)\n{\n    return all(FFX_GREATER_THAN_EQUAL(pos, FfxInt32x2(0, 0))) && all(FFX_LESS_THAN(pos, size));\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given position and size are within the visible screen area.\n>>> IsOnScreen(pos, size) *\/ \nFfxBoolean IsOnScreen(FfxInt32x2 pos, FfxInt32x2 size) { ",
        "query_nlx":"        \/* Function named IsOnScreen determines if a given position and size are within the visible screen area.\n        >>> IsOnScreen(pos(0, 0), size(100, 100)) true\n        >>> IsOnScreen(pos(-10, 20), size(50, 50)) false *\/ \n        FfxBoolean IsOnScreen(FfxInt32x2 pos, FfxInt32x2 size) {"
    }

    {
        "file_name":"ffx_fsr2_common_function_40.cpp",
        "line_count":4,
        "code":"FfxFloat32 GetViewSpaceDepthInMeters(FfxFloat32 fDeviceDepth)\n{\n    return GetViewSpaceDepth(fDeviceDepth) * ViewSpaceToMetersFactor();\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the depth in meters in view space based on the device depth input.\n   >>> FfxFloat32 GetViewSpaceDepthInMeters(FfxFloat32 fDeviceDepth) { *\/",
        "query_nlx":"\/* Function named GetViewSpaceDepthInMeters calculates the depth in meters in view space based on the input device depth value by multiplying it with a factor that converts view space to meters.\n>>> GetViewSpaceDepthInMeters(10.0) returns the depth in meters in view space corresponding to a device depth of 10.0 *\/ \nFfxFloat32 GetViewSpaceDepthInMeters(FfxFloat32 fDeviceDepth) { "
    }

    {
        "file_name":"ffx_fsr2_common_function_41.cpp",
        "line_count":12,
        "code":"FfxFloat32x3 GetViewSpacePosition(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth)\n{\n    const FfxFloat32x4 fDeviceToViewDepth = DeviceToViewSpaceTransformFactors();\n\n    const FfxFloat32 Z = GetViewSpaceDepth(fDeviceDepth);\n\n    const FfxFloat32x2 fNdcPos = ComputeNdc(iViewportPos, iViewportSize);\n    const FfxFloat32 X = fDeviceToViewDepth[2] * fNdcPos.x * Z;\n    const FfxFloat32 Y = fDeviceToViewDepth[3] * fNdcPos.y * Z;\n\n    return FfxFloat32x3(X, Y, Z);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the view space position based on the viewport position, viewport size, and device depth.\n>>> GetViewSpacePosition(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth) *\/",
        "query_nlx":"\/* Function GetViewSpacePosition calculates the position in view space based on the given viewport position, viewport size, and device depth.\n>>> GetViewSpacePosition({10, 20}, {1920, 1080}, 0.5) returns the view space position {5.0, 10.0, 0.25} *\/ \nFfxFloat32x3 GetViewSpacePosition(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth) { "
    }

    {
        "file_name":"ffx_fsr2_common_function_42.cpp",
        "line_count":4,
        "code":"FfxFloat32x3 GetViewSpacePositionInMeters(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth)\n{\n    return GetViewSpacePosition(iViewportPos, iViewportSize, fDeviceDepth) * ViewSpaceToMetersFactor();\n}",
        "mark":8.0,
        "query_nsx":"            \/* Calculate the view space position in meters based on the viewport position, size, and device depth.\n            >>> GetViewSpacePositionInMeters(iViewportPos, iViewportSize, fDeviceDepth) FfxFloat32x3 { *\/",
        "query_nlx":"\/* Calculate the view space position in meters based on the viewport position, size, and device depth, using a conversion factor.\n>>> GetViewSpacePositionInMeters(iViewportPos, iViewportSize, fDeviceDepth) FfxFloat32x3 *\/\nFfxFloat32x3 GetViewSpacePositionInMeters(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth) { *\/"
    }

    {
        "file_name":"ffx_fsr2_common_function_44.cpp",
        "line_count":9,
        "code":"FfxFloat32x3 PrepareRgb(FfxFloat32x3 fRgb, FfxFloat32 fExposure, FfxFloat32 fPreExposure)\n{\n    fRgb \/= fPreExposure;\n    fRgb *= fExposure;\n\n    fRgb = clamp(fRgb, 0.0f, FSR2_FP16_MAX);\n\n    return fRgb;\n}",
        "mark":8.0,
        "query_nsx":"\/* Prepare RGB values for display by adjusting exposure levels.\n   >>> PrepareRgb(fRgb, fExposure, fPreExposure) *\/ \nFfxFloat32x3 PrepareRgb(FfxFloat32x3 fRgb, FfxFloat32 fExposure, FfxFloat32 fPreExposure) {",
        "query_nlx":"        \/* Function named PrepareRgb takes a 3-component floating-point RGB color vector, an exposure value, and a pre-exposure value, and prepares the RGB color for display by adjusting its intensity based on the exposure and pre-exposure values. \n        >>> PrepareRgb({0.5, 0.3, 0.8}, 2.0, 0.5) { \n        *\/ \n        FfxFloat32x3 PrepareRgb(FfxFloat32x3 fRgb, FfxFloat32 fExposure, FfxFloat32 fPreExposure) {"
    }

    {
        "file_name":"ffx_fsr2_common_function_46.cpp",
        "line_count":20,
        "code":"BilinearSamplingData GetBilinearSamplingData(FfxFloat32x2 fUv, FfxInt32x2 iSize)\n{\n    BilinearSamplingData data;\n\n    FfxFloat32x2 fPxSample = (fUv * iSize) - FfxFloat32x2(0.5f, 0.5f);\n    data.iBasePos = FfxInt32x2(floor(fPxSample));\n    FfxFloat32x2 fPxFrac = ffxFract(fPxSample);\n\n    data.iOffsets[0] = FfxInt32x2(0, 0);\n    data.iOffsets[1] = FfxInt32x2(1, 0);\n    data.iOffsets[2] = FfxInt32x2(0, 1);\n    data.iOffsets[3] = FfxInt32x2(1, 1);\n\n    data.fWeights[0] = (1 - fPxFrac.x) * (1 - fPxFrac.y);\n    data.fWeights[1] = (fPxFrac.x) * (1 - fPxFrac.y);\n    data.fWeights[2] = (1 - fPxFrac.x) * (fPxFrac.y);\n    data.fWeights[3] = (fPxFrac.x) * (fPxFrac.y);\n\n    return data;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate bilinear sampling data based on the input UV coordinates and image size.\n>>> GetBilinearSamplingData(FfxFloat32x2 fUv, FfxInt32x2 iSize) *\/",
        "query_nlx":"\/* Function GetBilinearSamplingData calculates the bilinear sampling data for a given UV coordinate and image size.\n   >>> GetBilinearSamplingData({0.3, 0.7}, {1024, 768}) returns BilinearSamplingData object with calculated offsets and weights *\/ \nBilinearSamplingData GetBilinearSamplingData(FfxFloat32x2 fUv, FfxInt32x2 iSize) {"
    }

    {
        "file_name":"ffx_fsr2_common_function_47.cpp",
        "line_count":11,
        "code":"PlaneData GetPlaneFromPoints(FfxFloat32x3 fP0, FfxFloat32x3 fP1, FfxFloat32x3 fP2)\n{\n    PlaneData plane;\n\n    FfxFloat32x3 v0 = fP0 - fP1;\n    FfxFloat32x3 v1 = fP0 - fP2;\n    plane.fNormal = normalize(cross(v0, v1));\n    plane.fDistanceFromOrigin = -dot(fP0, plane.fNormal);\n\n    return plane;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the plane defined by three points in 3D space.\n>>> PlaneData GetPlaneFromPoints(FfxFloat32x3 fP0, FfxFloat32x3 fP1, FfxFloat32x3 fP2) *\/",
        "query_nlx":"        \/* Function named GetPlaneFromPoints calculates the plane passing through three given points in 3D space. \n        >>> GetPlaneFromPoints(fP0, fP1, fP2) PlaneData *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_15.cpp",
        "line_count":5,
        "code":"FfxFloat32 MinDividedByMax(const FfxFloat32 v0, const FfxFloat32 v1)\n    {\n        const FfxFloat32 m = ffxMax(v0, v1);\n        return m != 0 ? ffxMin(v0, v1) \/ m : 0;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the ratio of the minimum value to the maximum value in a given pair of numbers.\n   >>> FfxFloat32 MinDividedByMax(const FfxFloat32 v0, const FfxFloat32 v1) { *\/",
        "query_nlx":"\/* Function named MinDividedByMax calculates the minimum value divided by the maximum value from two input floating-point numbers.\n>>> MinDividedByMax(3.5, 2.0) 0.5714286\n>>> MinDividedByMax(0.0, 5.0) 0.0 *\/ \nFfxFloat32 MinDividedByMax(const FfxFloat32 v0, const FfxFloat32 v1) { *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_17.cpp",
        "line_count":11,
        "code":"FfxFloat32x3 YCoCgToRGB(FfxFloat32x3 fYCoCg)\n    {\n        FfxFloat32x3 fRgb;\n\n        fRgb = FfxFloat32x3(\n            fYCoCg.x + fYCoCg.y - fYCoCg.z,\n            fYCoCg.x + fYCoCg.z,\n            fYCoCg.x - fYCoCg.y - fYCoCg.z);\n\n        return fRgb;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert YCoCg color space values to RGB color space values.\n   >>> YCoCgToRGB(FfxFloat32x3 fYCoCg) *\/ \nFfxFloat32x3 YCoCgToRGB(FfxFloat32x3 fYCoCg) {",
        "query_nlx":"        \/* Function named YCoCgToRGB converts a given YCoCg color value to RGB color space.\n        >>> YCoCgToRGB({0.5, 0.3, 0.2}) = {0.6, 0.7, 0.0}\n        >>> YCoCgToRGB({0.8, 0.1, 0.4}) = {1.1, 1.2, 0.3} *\/ \n        FfxFloat32x3 YCoCgToRGB(FfxFloat32x3 fYCoCg) { *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_18.cpp",
        "line_count":11,
        "code":"FFX_MIN16_F3 YCoCgToRGB(FFX_MIN16_F3 fYCoCg)\n    {\n        FFX_MIN16_F3 fRgb;\n\n        fRgb = FFX_MIN16_F3(\n            fYCoCg.x + fYCoCg.y - fYCoCg.z,\n            fYCoCg.x + fYCoCg.z,\n            fYCoCg.x - fYCoCg.y - fYCoCg.z);\n\n        return fRgb;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert YCoCg color space values to RGB color space values.\n   >>> YCoCgToRGB(FFX_MIN16_F3 fYCoCg) *\/",
        "query_nlx":"        \/* Function YCoCgToRGB converts a given YCoCg color value to RGB color space.\n        >>> YCoCgToRGB({0.5, 0.3, 0.2}) = {0.6, 0.7, 0.0} *\/ \n        FFX_MIN16_F3 YCoCgToRGB(FFX_MIN16_F3 fYCoCg) { *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_19.cpp",
        "line_count":11,
        "code":"FfxFloat32x3 RGBToYCoCg(FfxFloat32x3 fRgb)\n    {\n        FfxFloat32x3 fYCoCg;\n\n        fYCoCg = FfxFloat32x3(\n            0.25f * fRgb.r + 0.5f * fRgb.g + 0.25f * fRgb.b,\n            0.5f * fRgb.r - 0.5f * fRgb.b,\n            -0.25f * fRgb.r + 0.5f * fRgb.g - 0.25f * fRgb.b);\n\n        return fYCoCg;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert RGB color values to YCoCg color space.\n   >>> RGBToYCoCg(FfxFloat32x3 fRgb) *\/ \nFfxFloat32x3 RGBToYCoCg(FfxFloat32x3 fRgb);",
        "query_nlx":"\/* Function named RGBToYCoCg converts an RGB color represented as a vector of three floating-point values to the YCoCg color space.\n>>> RGBToYCoCg({0.5, 0.3, 0.8}) = {0.55, 0.1, -0.05}\n>>> RGBToYCoCg({0.1, 0.9, 0.2}) = {0.5, -0.4, 0.1} *\/ \nFfxFloat32x3 RGBToYCoCg(FfxFloat32x3 fRgb) { *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_20.cpp",
        "line_count":11,
        "code":"FFX_MIN16_F3 RGBToYCoCg(FFX_MIN16_F3 fRgb)\n    {\n        FFX_MIN16_F3 fYCoCg;\n\n        fYCoCg = FFX_MIN16_F3(\n            0.25 * fRgb.r + 0.5 * fRgb.g + 0.25 * fRgb.b,\n            0.5 * fRgb.r - 0.5 * fRgb.b,\n            -0.25 * fRgb.r + 0.5 * fRgb.g - 0.25 * fRgb.b);\n\n        return fYCoCg;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert RGB color values to YCoCg color space.\n   >>> RGBToYCoCg(FFX_MIN16_F3 fRgb) *\/",
        "query_nlx":"\/* Function named RGBToYCoCg converts an RGB color value to the YCoCg color space. \n>>> RGBToYCoCg({0.5, 0.3, 0.8}) returns YCoCg color space values \n>>> RGBToYCoCg({0.1, 0.9, 0.2}) returns YCoCg color space values *\/ \nFFX_MIN16_F3 RGBToYCoCg(FFX_MIN16_F3 fRgb) { *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_21.cpp",
        "line_count":4,
        "code":"FfxFloat32 RGBToLuma(FfxFloat32x3 fLinearRgb)\n    {\n        return dot(fLinearRgb, FfxFloat32x3(0.2126f, 0.7152f, 0.0722f));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the luminance value from RGB color values.\n   >>> RGBToLuma(fLinearRgb) *\/ \nFfxFloat32 RGBToLuma(FfxFloat32x3 fLinearRgb) { ",
        "query_nlx":"\/* Function named RGBToLuma calculates the luminance value from a given linear RGB color represented as a vector of three floating-point values. The luminance value is computed by taking the dot product of the input RGB color vector with a predefined vector containing luminance coefficients. \n>>> RGBToLuma({0.5, 0.3, 0.8}) 0.44316 \n>>> RGBToLuma({0.1, 0.9, 0.2}) 0.3126 *\/ \nFfxFloat32 RGBToLuma(FfxFloat32x3 fLinearRgb) { *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_22.cpp",
        "line_count":4,
        "code":"FFX_MIN16_F RGBToLuma(FFX_MIN16_F3 fLinearRgb)\n    {\n        return dot(fLinearRgb, FFX_MIN16_F3(0.2126f, 0.7152f, 0.0722f));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the luminance value from the RGB color values using specific coefficients.\n   >>> RGBToLuma(FFX_MIN16_F3 fLinearRgb) *\/",
        "query_nlx":"\/* Function named RGBToLuma calculates the luminance value from a given RGB color represented as a vector of three floating-point values. The luminance value is computed using the formula Y = 0.2126*R + 0.7152*G + 0.0722*B where R, G, and B are the red, green, and blue components of the color respectively. \n>>> RGBToLuma({0.5, 0.3, 0.8}) 0.48716 \n>>> RGBToLuma({0.1, 0.9, 0.2}) 0.3916 *\/ \nFFX_MIN16_F RGBToLuma(FFX_MIN16_F3 fLinearRgb) { *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_23.cpp",
        "line_count":14,
        "code":"FfxFloat32 RGBToPerceivedLuma(FfxFloat32x3 fLinearRgb)\n    {\n        FfxFloat32 fLuminance = RGBToLuma(fLinearRgb);\n\n        FfxFloat32 fPercievedLuminance = 0;\n        if (fLuminance <= 216.0f \/ 24389.0f) {\n            fPercievedLuminance = fLuminance * (24389.0f \/ 27.0f);\n        }\n        else {\n            fPercievedLuminance = ffxPow(fLuminance, 1.0f \/ 3.0f) * 116.0f - 16.0f;\n        }\n\n        return fPercievedLuminance * 0.01f;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert RGB color values to perceived luminance value.\n>>> FfxFloat32 RGBToPerceivedLuma(FfxFloat32x3 fLinearRgb) *\/",
        "query_nlx":"        \/* Function named RGBToPerceivedLuma calculates the perceived luminance value based on the input linear RGB values.\n        >>> RGBToPerceivedLuma({fLinearRgb}) returns the perceived luminance value as a floating-point number *\/ \n        FfxFloat32 RGBToPerceivedLuma(FfxFloat32x3 fLinearRgb) {"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_31.cpp",
        "line_count":8,
        "code":"FfxFloat32x2 ClampUv(FfxFloat32x2 fUv, FfxInt32x2 iTextureSize, FfxInt32x2 iResourceSize)\n    {\n        const FfxFloat32x2 fSampleLocation = fUv * iTextureSize;\n        const FfxFloat32x2 fClampedLocation = ffxMax(FfxFloat32x2(0.5f, 0.5f), ffxMin(fSampleLocation, FfxFloat32x2(iTextureSize) - FfxFloat32x2(0.5f, 0.5f)));\n        const FfxFloat32x2 fClampedUv = fClampedLocation \/ FfxFloat32x2(iResourceSize);\n\n        return fClampedUv;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the clamped UV coordinates based on the input UV coordinates, texture size, and resource size.\n>>> FfxFloat32x2 ClampUv(FfxFloat32x2 fUv, FfxInt32x2 iTextureSize, FfxInt32x2 iResourceSize) { *\/",
        "query_nlx":"        \/* Function named ClampUv calculates the clamped UV coordinates based on the input UV coordinates, texture size, and resource size.\n        >>> ClampUv({0.3, 0.7}, {1024, 1024}, {512, 512}) = {0.3, 0.7}\n        >>> ClampUv({1.2, 0.5}, {512, 512}, {256, 256}) = {0.5, 0.5} *\/ \n        FfxFloat32x2 ClampUv(FfxFloat32x2 fUv, FfxInt32x2 iTextureSize, FfxInt32x2 iResourceSize) { \/* Function declaration *\/ "
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_36.cpp",
        "line_count":7,
        "code":"FfxInt32x2 ComputeHrPosFromLrPos(FfxInt32x2 iPxLrPos)\n    {\n        FfxFloat32x2 fSrcJitteredPos = FfxFloat32x2(iPxLrPos) + 0.5f - Jitter();\n        FfxFloat32x2 fLrPosInHr = (fSrcJitteredPos \/ RenderSize()) * DisplaySize();\n        FfxInt32x2 iPxHrPos = FfxInt32x2(floor(fLrPosInHr));\n        return iPxHrPos;\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Calculate the high-resolution position from the low-resolution position.\n        >>> FfxInt32x2 ComputeHrPosFromLrPos(FfxInt32x2 iPxLrPos) { *\/",
        "query_nlx":"        \/* Function named ComputeHrPosFromLrPos calculates the high-resolution position from a given low-resolution position by applying jitter and scaling factors.\n        >>> ComputeHrPosFromLrPos({x, y}) returns the high-resolution position based on the input low-resolution position {x, y} after applying jitter and scaling factors. *\/ \n        FfxInt32x2 ComputeHrPosFromLrPos(FfxInt32x2 iPxLrPos) { "
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_38.cpp",
        "line_count":4,
        "code":"FfxFloat32x2 ComputeNdc(FfxFloat32x2 fPxPos, FfxInt32x2 iSize)\n    {\n        return fPxPos \/ FfxFloat32x2(iSize) * FfxFloat32x2(2.0f, -2.0f) + FfxFloat32x2(-1.0f, 1.0f);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate normalized device coordinates (NDC) based on the given pixel position and size.\n   >>> ComputeNdc(fPxPos, iSize) \n*\/ \nFfxFloat32x2 ComputeNdc(FfxFloat32x2 fPxPos, FfxInt32x2 iSize) { ",
        "query_nlx":"        \/* Function named ComputeNdc calculates the normalized device coordinates (NDC) based on the given pixel position and size.\n        >>> ComputeNdc({10.0, 20.0}, {5, 5}) returns a FfxFloat32x2 value representing the NDC coordinates after the computation.\n        >>> ComputeNdc({30.0, 40.0}, {10, 10}) returns a FfxFloat32x2 value representing the NDC coordinates after the computation. *\/ \n        FfxFloat32x2 ComputeNdc(FfxFloat32x2 fPxPos, FfxInt32x2 iSize) { \/\/ Function signature. Body omitted.\n    }"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_40.cpp",
        "line_count":4,
        "code":"FfxFloat32 GetViewSpaceDepthInMeters(FfxFloat32 fDeviceDepth)\n    {\n        return GetViewSpaceDepth(fDeviceDepth) * ViewSpaceToMetersFactor();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the depth in meters in view space based on the device depth value.\n   >>> FfxFloat32 GetViewSpaceDepthInMeters(FfxFloat32 fDeviceDepth) *\/",
        "query_nlx":"\/* Function named GetViewSpaceDepthInMeters calculates the depth in meters in view space based on the input device depth value by multiplying it with the factor that converts view space to meters.\n>>> GetViewSpaceDepthInMeters(10.0) returns the depth in meters in view space for a device depth of 10.0 *\/ \nFfxFloat32 GetViewSpaceDepthInMeters(FfxFloat32 fDeviceDepth) { "
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_41.cpp",
        "line_count":12,
        "code":"FfxFloat32x3 GetViewSpacePosition(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth)\n    {\n        const FfxFloat32x4 fDeviceToViewDepth = DeviceToViewSpaceTransformFactors();\n\n        const FfxFloat32 Z = GetViewSpaceDepth(fDeviceDepth);\n\n        const FfxFloat32x2 fNdcPos = ComputeNdc(iViewportPos, iViewportSize);\n        const FfxFloat32 X = fDeviceToViewDepth[2] * fNdcPos.x * Z;\n        const FfxFloat32 Y = fDeviceToViewDepth[3] * fNdcPos.y * Z;\n\n        return FfxFloat32x3(X, Y, Z);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the view space position based on the viewport position, viewport size, and device depth.\n   >>> GetViewSpacePosition(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth) *\/",
        "query_nlx":"        \/* Function named GetViewSpacePosition calculates the view space position of a given device depth value based on the viewport position, viewport size, and transformation factors. \n        >>> GetViewSpacePosition({10, 20}, {1920, 1080}, 0.5) returns the view space position as a 3D vector \n        >>> GetViewSpacePosition({100, 50}, {1280, 720}, 0.8) returns the view space position as a 3D vector *\/ \n        FfxFloat32x3 GetViewSpacePosition(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth) { "
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_42.cpp",
        "line_count":4,
        "code":"FfxFloat32x3 GetViewSpacePositionInMeters(FfxInt32x2 iViewportPos, FfxInt32x2 iViewportSize, FfxFloat32 fDeviceDepth)\n    {\n        return GetViewSpacePosition(iViewportPos, iViewportSize, fDeviceDepth) * ViewSpaceToMetersFactor();\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Calculate the view space position in meters based on the viewport position, size, and device depth.\n        >>> GetViewSpacePositionInMeters(iViewportPos, iViewportSize, fDeviceDepth) FfxFloat32x3 { *\/",
        "query_nlx":"        \/* Function named GetViewSpacePositionInMeters calculates the view space position in meters based on the viewport position, viewport size, and device depth, then scales it by a factor to convert to meters.\n        >>> GetViewSpacePositionInMeters(iViewportPos: FfxInt32x2, iViewportSize: FfxInt32x2, fDeviceDepth: FfxFloat32) : FfxFloat32x3 { *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_44.cpp",
        "line_count":9,
        "code":"FfxFloat32x3 PrepareRgb(FfxFloat32x3 fRgb, FfxFloat32 fExposure, FfxFloat32 fPreExposure)\n    {\n        fRgb \/= fPreExposure;\n        fRgb *= fExposure;\n\n        fRgb = clamp(fRgb, 0.0f, FSR3UPSCALER_FP16_MAX);\n\n        return fRgb;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Prepare RGB values for display by adjusting exposure levels.\n   >>> PrepareRgb(FfxFloat32x3 fRgb, FfxFloat32 fExposure, FfxFloat32 fPreExposure) *\/",
        "query_nlx":"\/* Function named PrepareRgb takes a 3-component floating-point RGB color value, an exposure value, and a pre-exposure value, and prepares the RGB color for display.\n>>> PrepareRgb({0.5, 0.3, 0.8}, 2.0, 0.5) {0.5, 0.3, 0.8}\n>>> PrepareRgb({1.0, 0.7, 0.2}, 1.5, 0.3) {0.3, 0.21, 0.06} *\/ \nFfxFloat32x3 PrepareRgb(FfxFloat32x3 fRgb, FfxFloat32 fExposure, FfxFloat32 fPreExposure) { *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_45.cpp",
        "line_count":9,
        "code":"FfxFloat16x3 PrepareRgb(FfxFloat16x3 fRgb, FfxFloat16 fExposure, FfxFloat16 fPreExposure)\n    {\n        fRgb \/= fPreExposure;\n        fRgb *= fExposure;\n\n        fRgb = clamp(fRgb, FFX_MIN16_F(0.0f), FFX_MIN16_F(FSR3UPSCALER_FP16_MAX));\n\n        return fRgb;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Prepare RGB values for display by adjusting exposure levels.\n   >>> PrepareRgb(FfxFloat16x3 fRgb, FfxFloat16 fExposure, FfxFloat16 fPreExposure) *\/",
        "query_nlx":"        \/* Function named PrepareRgb takes a 3-component floating-point RGB color value, an exposure value, and a pre-exposure value, and prepares the RGB color for display by adjusting its intensity based on the exposure and pre-exposure values. \n        >>> PrepareRgb({0.5, 0.3, 0.8}, 1.2, 0.9) {0.6, 0.36, 0.96} \n        >>> PrepareRgb({0.1, 0.9, 0.4}, 0.8, 1.0) {0.08, 0.72, 0.32} *\/ \n        FfxFloat16x3 PrepareRgb(FfxFloat16x3 fRgb, FfxFloat16 fExposure, FfxFloat16 fPreExposure) {  *\/"
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_48.cpp",
        "line_count":20,
        "code":"BilinearSamplingData GetBilinearSamplingData(FfxFloat32x2 fUv, FfxInt32x2 iSize)\n    {\n        BilinearSamplingData data;\n\n        FfxFloat32x2 fPxSample = (fUv * iSize) - FfxFloat32x2(0.5f, 0.5f);\n        data.iBasePos = FfxInt32x2(floor(fPxSample));\n        FfxFloat32x2 fPxFrac = ffxFract(fPxSample);\n\n        data.iOffsets[0] = FfxInt32x2(0, 0);\n        data.iOffsets[1] = FfxInt32x2(1, 0);\n        data.iOffsets[2] = FfxInt32x2(0, 1);\n        data.iOffsets[3] = FfxInt32x2(1, 1);\n\n        data.fWeights[0] = (1 - fPxFrac.x) * (1 - fPxFrac.y);\n        data.fWeights[1] = (fPxFrac.x) * (1 - fPxFrac.y);\n        data.fWeights[2] = (1 - fPxFrac.x) * (fPxFrac.y);\n        data.fWeights[3] = (fPxFrac.x) * (fPxFrac.y);\n\n        return data;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve bilinear sampling data based on the input UV coordinates and image size.\n   >>> GetBilinearSamplingData(FfxFloat32x2 fUv, FfxInt32x2 iSize) *\/",
        "query_nlx":"\/* Function GetBilinearSamplingData calculates the bilinear sampling data based on the given UV coordinates and image size.\n   >>> GetBilinearSamplingData(fUv, iSize) returns BilinearSamplingData object containing base position, offsets, and weights for bilinear sampling *\/ \nBilinearSamplingData GetBilinearSamplingData(FfxFloat32x2 fUv, FfxInt32x2 iSize) { "
    }

    {
        "file_name":"ffx_fsr3upscaler_common_function_49.cpp",
        "line_count":11,
        "code":"PlaneData GetPlaneFromPoints(FfxFloat32x3 fP0, FfxFloat32x3 fP1, FfxFloat32x3 fP2)\n    {\n        PlaneData plane;\n\n        FfxFloat32x3 v0 = fP0 - fP1;\n        FfxFloat32x3 v1 = fP0 - fP2;\n        plane.fNormal = normalize(cross(v0, v1));\n        plane.fDistanceFromOrigin = -dot(fP0, plane.fNormal);\n\n        return plane;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the plane defined by three points in 3D space.\n   >>> PlaneData GetPlaneFromPoints(FfxFloat32x3 fP0, FfxFloat32x3 fP1, FfxFloat32 fP2) *\/",
        "query_nlx":"        \/* Function named GetPlaneFromPoints calculates the plane passing through three given points in 3D space. \n        >>> GetPlaneFromPoints(fP0, fP1, fP2) returns the plane data structure containing the normal vector and the distance from the origin. *\/ \n        PlaneData GetPlaneFromPoints(FfxFloat32x3 fP0, FfxFloat32x3 fP1, FfxFloat32x3 fP2) {"
    }

    {
        "file_name":"FileSystemWatcherTest_function_1.cpp",
        "line_count":11,
        "code":"void initClose()\n    {\n        if (test_section(\"Init\/Close\"))\n        {\n            FileSystemWatcher::ThreadRunner runner;\n\n            FileSystemWatcher fileEventsWatcher;\n            SC_TEST_EXPECT(fileEventsWatcher.init(runner));\n            SC_TEST_EXPECT(fileEventsWatcher.close());\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize and close a file system watcher for monitoring file events.\n   >>> initClose()\n*\/ \nvoid initClose() {",
        "query_nlx":"\/* Initialize and close a file system watcher for monitoring file events.\n   >>> initClose() initiates the file system watcher for the \"Init\/Close\" section, initializes a thread runner, creates a file events watcher, and expects successful initialization and closure of the watcher. *\/ \nvoid initClose() { "
    }

    {
        "file_name":"file_handler_function_1.cpp",
        "line_count":11,
        "code":"string\n  get_parent_directory(const std::string &path) {\n    \/\/ remove any trailing path separators\n    std::string trimmed_path = path;\n    while (!trimmed_path.empty() && trimmed_path.back() == '\/') {\n      trimmed_path.pop_back();\n    }\n\n    std::filesystem::path p(trimmed_path);\n    return p.parent_path().string();\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Extract the parent directory from the given path string.\n        >>> get_parent_directory(const string &path) *\/",
        "query_nlx":"\/* Function named get_parent_directory takes a path as input and returns the parent directory of that path after removing any trailing path separators.\n>>> get_parent_directory(\"\/home\/user\/documents\/\") \"\/home\/user\"\n>>> get_parent_directory(\"\/var\/www\/html\/index.html\") \"\/var\/www\/html\" *\/ \nstring get_parent_directory(const std::string &path) {"
    }

    {
        "file_name":"FixedCapacityVector_function_11.cpp",
        "line_count":4,
        "code":"void resize(size_type count, const_reference v) {\n        assertCapacityForSize(count);\n        resize_non_trivial(count, v);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Resize a container to a specified count while ensuring capacity and filling with a given value.\n   >>> resize(size_type count, const_reference v) *\/",
        "query_nlx":"\/* Define a function that resizes a container to a specified count while ensuring capacity and filling the new elements with a given value.\n   >>> resize(size_type count, const_reference v) *\/"
    }

    {
        "file_name":"FixedCapacityVector_function_12.cpp",
        "line_count":6,
        "code":"void swap(FixedCapacityVector& other) {\n        using std::swap;\n        swap(mData, other.mData);\n        swap(mSize, other.mSize);\n        mCapacityAllocator.swap(other.mCapacityAllocator);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Swap the contents of two fixed capacity vectors. \n        >>> void swap(FixedCapacityVector& other) { *\/",
        "query_nlx":"\/* Function named swap exchanges the contents of two FixedCapacityVector objects by swapping their mData, mSize, and mCapacityAllocator attributes.\n>>> swap(vector1, vector2) swaps the mData, mSize, and mCapacityAllocator attributes of vector1 with vector2 *\/ \nvoid swap(FixedCapacityVector& other) {"
    }

    {
        "file_name":"FixedCapacityVector_function_19.cpp",
        "line_count":3,
        "code":"if constexpr(!std::is_trivially_destructible_v<value_type>) {\n            destroy_non_trivial(first, last);\n        }",
        "mark":8.0,
        "query_nsx":"\/* Check if the values in a range need non-trivial destruction and perform the destruction if necessary.\n>>> destroy_non_trivial(first, last) *\/",
        "query_nlx":"\/* If the type of elements in a container is not trivially destructible, call a function to destroy those non-trivial elements.\n   >>> destroy_non_trivial_elements(container.begin(), container.end()) *\/\nif constexpr(!std::is_trivially_destructible_v<value_type>) {"
    }

    {
        "file_name":"FixedCapacityVector_function_7.cpp",
        "line_count":4,
        "code":"iterator erase(const_iterator pos) {\n        assert(pos != end());\n        return erase(pos, pos + 1);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from the collection at the specified position.\n    >>> erase(const_iterator pos) \n*\/",
        "query_nlx":"\/* Define a function named erase that removes the element at a specified position in a collection, ensuring the position is not at the end of the collection.\n   >>> erase(pos) returns an iterator after removing the element at the specified position in the collection. *\/ \niterator erase(const_iterator pos) {"
    }

    {
        "file_name":"FormattedText_function_1.cpp",
        "line_count":13,
        "code":"void SetContentOverride(const std::string & oride)\n\t{\n\t\tif (oride.empty())\n\t\t{\n\t\t\tm_contentOverride = \"\";\n\t\t\tm_ifContent.Set(m_content);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_contentOverride = oride;\n\t\t\tm_ifContent.Set(m_contentOverride);\n\t\t}\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the content override to a specified string if provided, otherwise set it to an empty string and update the content accordingly. \n>>> void SetContentOverride(const string & oride) { *\/",
        "query_nlx":"\/* Define a function that updates the content override based on the input string provided. If the input string is empty, set the content override to an empty string and update the content. Otherwise, set the content override to the input string and update the content accordingly.\n>>> SetContentOverride(\"example_string\") *\/ \nvoid SetContentOverride(const std::string & oride) { "
    }

    {
        "file_name":"FormattedText_function_2.cpp",
        "line_count":4,
        "code":"void UpdateIfContent()\n\t{\n\t\tm_ifContent.Set(GetContentOverride());\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Update the content of a specific object if there is an override available.\n   >>> UpdateIfContent() *\/ \nvoid UpdateIfContent() {",
        "query_nlx":"\/* Function named UpdateIfContent updates the content of an object if there is an override available.\n>>> UpdateIfContent() updates the content of an object using the content override provided. *\/ \nvoid UpdateIfContent() {  \/\/ Function signature\n    m_ifContent.Set(GetContentOverride());  \/\/ Function body omitted\n}  \/\/ End of function"
    }

    {
        "file_name":"FormattedText_function_3.cpp",
        "line_count":7,
        "code":"void Clear() {\n\t\tm_rawMessage.clear();\n\t\tm_blocks.clear();\n\t\tm_tokens.clear();\n\t\tm_words.clear();\n\t\tm_bFormatted = false;\n\t}",
        "mark":9.0,
        "query_nsx":"\/* Clear all stored data and formatting flags.\n   >>> Clear() *\/ \nvoid Clear() {",
        "query_nlx":"\/* Define a function that clears all data stored in various containers and sets a boolean flag to false.\n>>> Clear() *\/ \nvoid Clear() {"
    }

    {
        "file_name":"FormattedText_function_4.cpp",
        "line_count":7,
        "code":"void ClearFormatting() {\n\t\tm_bFormatted = false;\n\n\t\tfor (auto& w : m_words) {\n\t\t\tw.m_rect = {};\n\t\t}\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Reset the formatting of words and rectangles to their default state.\n>>> ClearFormatting() *\/",
        "query_nlx":"\/* Define a function that clears the formatting of a text by setting a flag to false and resetting the bounding rectangles of all words to empty.\n>>> ClearFormatting() *\/ \nvoid ClearFormatting() {"
    }

    {
        "file_name":"FormattedText_function_5.cpp",
        "line_count":3,
        "code":"void AddWord(const Word& w) {\n\t\tm_words.push_back(w);\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Add a word to the list of words.\n   >>> AddWord(const Word& w) *\/",
        "query_nlx":"\/* Define a function AddWord that adds a given word to a collection of words.\n   >>> AddWord(\"example\") *\/ \nvoid AddWord(const Word& w) {"
    }

    {
        "file_name":"FormattedText_function_6.cpp",
        "line_count":10,
        "code":"blocks\n\tfor (auto& w : m_words)\n\t{\n\t\tif (w.m_flags & WORD_MLCODE) {\n\t\t\tRect rc = w.m_rect;\n\t\t\trc.top    += offsetY;\n\t\t\trc.bottom += offsetY;\n\t\t\tMdDrawCodeBackground(context, rc);\n\t\t}\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Draw code background for words with specific flags in a given list of words.\n   >>> blocks *\/ \nvoid drawCodeBackground(vector<Word> m_words, int offsetY) {",
        "query_nlx":"            \/* Iterate through a collection of words and for each word that has a specific flag set, adjust its position on the screen and draw a code background around it.\n            >>> draw_code_background_for_words_with_flag(words, offsetY) *\/ \n            void draw_code_background_for_words_with_flag(vector<Word>& m_words, int offsetY) {"
    }

    {
        "file_name":"frame_function_1.cpp",
        "line_count":4,
        "code":"bool reserved(value v) {\n        return (v >= rsv3 && v <= rsv7) ||\n               (v >= control_rsvb && v <= control_rsvf);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given value falls within a specific range of reserved values. \n>>> bool reserved(value v) { *\/",
        "query_nlx":"\/* Function named reserved determines if a given value falls within specific reserved ranges defined by constants rsv3, rsv7, control_rsvb, and control_rsvf. \n>>> reserved(5) true \n>>> reserved(10) false *\/ \nbool reserved(value v) {"
    }

    {
        "file_name":"frame_function_10.cpp",
        "line_count":3,
        "code":"void set_rsv1(basic_header &h, bool value) {\n    h.b0 = (value ? h.b0 | BHB0_RSV1 : h.b0 & ~BHB0_RSV1);\n}",
        "mark":8.0,
        "query_nsx":"\/* Update the value of a specific flag in the header structure based on the input boolean value.\n>>> void set_rsv1(basic_header &h, bool value) { *\/",
        "query_nlx":"        \/* Function named set_rsv1 modifies a basic header by setting a specific boolean value based on the input parameter.\n        >>> set_rsv1(header, true) updates the basic header with the RSV1 flag set to true.\n        >>> set_rsv1(header, false) updates the basic header with the RSV1 flag set to false. *\/ \n        void set_rsv1(basic_header &h, bool value) { "
    }

    {
        "file_name":"frame_function_11.cpp",
        "line_count":3,
        "code":"bool get_rsv2(const basic_header &h) {\n    return ((h.b0 & BHB0_RSV2) == BHB0_RSV2);\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the specified basic header contains the value for RSV2 flag.\n>>> bool get_rsv2(const basic_header &h) { *\/",
        "query_nlx":"\/* Function named get_rsv2 checks if the value of a specific bit in the given basic header is set to true.\n>>> get_rsv2(const basic_header &h) *\/\nbool get_rsv2(const basic_header &h) {"
    }

    {
        "file_name":"frame_function_13.cpp",
        "line_count":3,
        "code":"bool get_rsv3(const basic_header &h) {\n    return ((h.b0 & BHB0_RSV3) == BHB0_RSV3);\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the given basic header has the RSV3 flag set.\n>>> bool get_rsv3(const basic_header &h) { *\/",
        "query_nlx":"\/* Function named get_rsv3 checks if the third reserved bit in a given basic header is set to 1.\n   >>> get_rsv3({basic_header h}) *\/ \nbool get_rsv3(const basic_header &h) {"
    }

    {
        "file_name":"frame_function_16.cpp",
        "line_count":3,
        "code":"bool get_masked(basic_header const & h) {\n    return ((h.b1 & BHB1_MASK) == BHB1_MASK);\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the specified header meets the masking criteria.\n>>> bool get_masked(basic_header const & h) { *\/",
        "query_nlx":"\/* Function named get_masked checks if the value of a specific field in a given header matches a predefined mask value.\n>>> get_masked(basic_header const & h) *\/\nbool get_masked(basic_header const & h) {"
    }

    {
        "file_name":"frame_function_17.cpp",
        "line_count":3,
        "code":"void set_masked(basic_header & h, bool value) {\n    h.b1 = (value ? h.b1 | BHB1_MASK : h.b1 & ~BHB1_MASK);\n}",
        "mark":8.0,
        "query_nsx":"\/* Update the masked value in the basic header based on the given boolean input.\n   >>> void set_masked(basic_header & h, bool value) { *\/",
        "query_nlx":"\/* Function named set_masked updates the value of a specific field in a given header structure based on a boolean input. \n>>> set_masked(header, true) updates the field with a masked value \n>>> set_masked(header, false) updates the field with an unmasked value *\/ \nstruct basic_header { \n    uint8_t b1; \n};"
    }

    {
        "file_name":"frame_function_20.cpp",
        "line_count":9,
        "code":"int get_masking_key_offset(const basic_header &h) {\n    if (get_basic_size(h) == payload_size_code_16bit) {\n        return 2;\n    } else if (get_basic_size(h) == payload_size_code_64bit) {\n        return 8;\n    } else {\n        return 0;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the offset value for masking based on the size of the basic header payload.\n>>> int get_masking_key_offset(const basic_header &h) { *\/",
        "query_nlx":"\/* Determine the offset value based on the size of the basic header provided.\n   The function get_masking_key_offset takes a basic header as input and returns an integer offset value.\n   The offset value is 2 if the size of the basic header is payload_size_code_16bit, 8 if it is payload_size_code_64bit, and 0 otherwise. *\/ \nint get_masking_key_offset(const basic_header &h) {"
    }

    {
        "file_name":"frame_function_7.cpp",
        "line_count":3,
        "code":"bool get_fin(basic_header const & h) {\n    return ((h.b0 & BHB0_FIN) == BHB0_FIN);\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the given basic header has the FIN flag set.\n>>> bool get_fin(basic_header const & h) { *\/",
        "query_nlx":"\/* Function named get_fin determines if the given basic header contains the FIN flag set.\n   >>> get_fin(basic_header const & h) returns true if the FIN flag is set in the basic header, otherwise false. *\/ \nbool get_fin(basic_header const & h) { "
    }

    {
        "file_name":"frame_function_9.cpp",
        "line_count":3,
        "code":"bool get_rsv1(const basic_header &h) {\n    return ((h.b0 & BHB0_RSV1) == BHB0_RSV1);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the specified header contains the RSV1 bit set.\n>>> bool get_rsv1(const basic_header &h) { *\/",
        "query_nlx":"\/* Function named get_rsv1 checks if the value of a specific bit in the given basic header matches a predefined constant value.\n>>> get_rsv1(const basic_header &h) *\/\nbool get_rsv1(const basic_header &h) {"
    }

    {
        "file_name":"FSR2Feature_212_function_1.cpp",
        "line_count":23,
        "code":"string ResultToString212(Fsr212::FfxErrorCode result)\n{\n\tswitch (result)\n\t{\n\tcase Fsr212::FFX_OK: return \"The operation completed successfully.\";\n\tcase Fsr212::FFX_ERROR_INVALID_POINTER: return \"The operation failed due to an invalid pointer.\";\n\tcase Fsr212::FFX_ERROR_INVALID_ALIGNMENT: return \"The operation failed due to an invalid alignment.\";\n\tcase Fsr212::FFX_ERROR_INVALID_SIZE: return \"The operation failed due to an invalid size.\";\n\tcase Fsr212::FFX_EOF: return \"The end of the file was encountered.\";\n\tcase Fsr212::FFX_ERROR_INVALID_PATH: return \"The operation failed because the specified path was invalid.\";\n\tcase Fsr212::FFX_ERROR_EOF: return \"The operation failed because end of file was reached.\";\n\tcase Fsr212::FFX_ERROR_MALFORMED_DATA: return \"The operation failed because of some malformed data.\";\n\tcase Fsr212::FFX_ERROR_OUT_OF_MEMORY: return \"The operation failed because it ran out memory.\";\n\tcase Fsr212::FFX_ERROR_INCOMPLETE_INTERFACE: return \"The operation failed because the interface was not fully configured.\";\n\tcase Fsr212::FFX_ERROR_INVALID_ENUM: return \"The operation failed because of an invalid enumeration value.\";\n\tcase Fsr212::FFX_ERROR_INVALID_ARGUMENT: return \"The operation failed because an argument was invalid.\";\n\tcase Fsr212::FFX_ERROR_OUT_OF_RANGE: return \"The operation failed because a value was out of range.\";\n\tcase Fsr212::FFX_ERROR_NULL_DEVICE: return \"The operation failed because a device was null.\";\n\tcase Fsr212::FFX_ERROR_BACKEND_API_ERROR: return \"The operation failed because the backend API returned an error code.\";\n\tcase Fsr212::FFX_ERROR_INSUFFICIENT_MEMORY: return \"The operation failed because there was not enough memory.\";\n\tdefault: return \"Unknown\";\n\t}\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a given error code to a corresponding human-readable message.\n>>> string ResultToString212(Fsr212::FfxErrorCode result) *\/",
        "query_nlx":"\/* Function named ResultToString212 converts an FfxErrorCode enum value to a corresponding string message describing the result.\n>>> ResultToString212(Fsr212::FFX_OK) returns \"The operation completed successfully.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_INVALID_POINTER) returns \"The operation failed due to an invalid pointer.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_INVALID_ALIGNMENT) returns \"The operation failed due to an invalid alignment.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_INVALID_SIZE) returns \"The operation failed due to an invalid size.\"\n>>> ResultToString212(Fsr212::FFX_EOF) returns \"The end of the file was encountered.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_INVALID_PATH) returns \"The operation failed because the specified path was invalid.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_EOF) returns \"The operation failed because end of file was reached.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_MALFORMED_DATA) returns \"The operation failed because of some malformed data.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_OUT_OF_MEMORY) returns \"The operation failed because it ran out memory.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_INCOMPLETE_INTERFACE) returns \"The operation failed because the interface was not fully configured.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_INVALID_ENUM) returns \"The operation failed because of an invalid enumeration value.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_INVALID_ARGUMENT) returns \"The operation failed because an argument was invalid.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_OUT_OF_RANGE) returns \"The operation failed because a value was out of range.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_NULL_DEVICE) returns \"The operation failed because a device was null.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_BACKEND_API_ERROR) returns \"The operation failed because the backend API returned an error code.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_INSUFFICIENT_MEMORY) returns \"The operation failed because there was not enough memory.\"\n>>> ResultToString212(Fsr212::FFX_ERROR_UNKNOWN) returns \"Unknown\"\n*\/ \nstring ResultToString212(Fsr212::FfxErrorCode result) {"
    }

    {
        "file_name":"FSR2Feature_function_1.cpp",
        "line_count":23,
        "code":"string ResultToString(FfxErrorCode result)\n{\n\tswitch (result)\n\t{\n\tcase FFX_OK: return \"The operation completed successfully.\";\n\tcase FFX_ERROR_INVALID_POINTER: return \"The operation failed due to an invalid pointer.\";\n\tcase FFX_ERROR_INVALID_ALIGNMENT: return \"The operation failed due to an invalid alignment.\";\n\tcase FFX_ERROR_INVALID_SIZE: return \"The operation failed due to an invalid size.\";\n\tcase FFX_EOF: return \"The end of the file was encountered.\";\n\tcase FFX_ERROR_INVALID_PATH: return \"The operation failed because the specified path was invalid.\";\n\tcase FFX_ERROR_EOF: return \"The operation failed because end of file was reached.\";\n\tcase FFX_ERROR_MALFORMED_DATA: return \"The operation failed because of some malformed data.\";\n\tcase FFX_ERROR_OUT_OF_MEMORY: return \"The operation failed because it ran out memory.\";\n\tcase FFX_ERROR_INCOMPLETE_INTERFACE: return \"The operation failed because the interface was not fully configured.\";\n\tcase FFX_ERROR_INVALID_ENUM: return \"The operation failed because of an invalid enumeration value.\";\n\tcase FFX_ERROR_INVALID_ARGUMENT: return \"The operation failed because an argument was invalid.\";\n\tcase FFX_ERROR_OUT_OF_RANGE: return \"The operation failed because a value was out of range.\";\n\tcase FFX_ERROR_NULL_DEVICE: return \"The operation failed because a device was null.\";\n\tcase FFX_ERROR_BACKEND_API_ERROR: return \"The operation failed because the backend API returned an error code.\";\n\tcase FFX_ERROR_INSUFFICIENT_MEMORY: return \"The operation failed because there was not enough memory.\";\n\tdefault: return \"Unknown\";\n\t}\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert the given error code into a human-readable string description.\n>>> string ResultToString(FfxErrorCode result) *\/",
        "query_nlx":"\/* Function named ResultToString converts an error code into a human-readable error message.\n>>> ResultToString(FFX_OK) returns \"The operation completed successfully.\"\n>>> ResultToString(FFX_ERROR_INVALID_POINTER) returns \"The operation failed due to an invalid pointer.\"\n>>> ResultToString(FFX_ERROR_INVALID_ALIGNMENT) returns \"The operation failed due to an invalid alignment.\"\n>>> ResultToString(FFX_ERROR_INVALID_SIZE) returns \"The operation failed due to an invalid size.\"\n>>> ResultToString(FFX_EOF) returns \"The end of the file was encountered.\"\n>>> ResultToString(FFX_ERROR_INVALID_PATH) returns \"The operation failed because the specified path was invalid.\"\n>>> ResultToString(FFX_ERROR_EOF) returns \"The operation failed because end of file was reached.\"\n>>> ResultToString(FFX_ERROR_MALFORMED_DATA) returns \"The operation failed because of some malformed data.\"\n>>> ResultToString(FFX_ERROR_OUT_OF_MEMORY) returns \"The operation failed because it ran out memory.\"\n>>> ResultToString(FFX_ERROR_INCOMPLETE_INTERFACE) returns \"The operation failed because the interface was not fully configured.\"\n>>> ResultToString(FFX_ERROR_INVALID_ENUM) returns \"The operation failed because of an invalid enumeration value.\"\n>>> ResultToString(FFX_ERROR_INVALID_ARGUMENT) returns \"The operation failed because an argument was invalid.\"\n>>> ResultToString(FFX_ERROR_OUT_OF_RANGE) returns \"The operation failed because a value was out of range.\"\n>>> ResultToString(FFX_ERROR_NULL_DEVICE) returns \"The operation failed because a device was null.\"\n>>> ResultToString(FFX_ERROR_BACKEND_API_ERROR) returns \"The operation failed because the backend API returned an error code.\"\n>>> ResultToString(FFX_ERROR_INSUFFICIENT_MEMORY) returns \"The operation failed because there was not enough memory.\"\n>>> ResultToString(unknown_error_code) returns \"Unknown\"\n*\/ \nstring ResultToString(FfxErrorCode result) {"
    }

    {
        "file_name":"FSR2Feature_Vk_212_function_1.cpp",
        "line_count":28,
        "code":"void transitionImageToShaderReadOnly(VkCommandBuffer commandBuffer, VkImage image, VkFormat format, VkAccessFlagBits flag = VK_ACCESS_SHADER_READ_BIT) \n{\n    VkImageMemoryBarrier barrier = {};\n    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;\n    barrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED; \/\/ Previous layout is unknown or irrelevant\n    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;\n    barrier.image = image;\n    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\n    barrier.subresourceRange.baseMipLevel = 0;\n    barrier.subresourceRange.levelCount = 1;\n    barrier.subresourceRange.baseArrayLayer = 0;\n    barrier.subresourceRange.layerCount = 1;\n\n    barrier.srcAccessMask = 0; \/\/ No previous accesses need to be waited on\n    barrier.dstAccessMask = flag; \n\n    vkCmdPipelineBarrier(\n        commandBuffer,\n        VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, \/\/ Earliest possible stage\n        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \/\/ Transition to fragment shader stage\n        0, \/\/ No special flags\n        0, nullptr, \/\/ No memory barriers\n        0, nullptr, \/\/ No buffer barriers\n        1, &barrier \/\/ One image barrier\n    );\n}",
        "mark":8.25,
        "query_nsx":"\/* Transition an image to be read-only for shaders.\n>>> void transitionImageToShaderReadOnly(VkCommandBuffer commandBuffer, VkImage image, VkFormat format, VkAccessFlagBits flag = VK_ACCESS_SHADER_READ_BIT) { *\/",
        "query_nlx":"        \/* Define a function that transitions an image to be read-only for a shader, specifying the necessary memory barriers and access flags.\n        >>> transitionImageToShaderReadOnly(commandBuffer, image, format, flag = VK_ACCESS_SHADER_READ_BIT) *\/ \n        void transitionImageToShaderReadOnly(VkCommandBuffer commandBuffer, VkImage image, VkFormat format, VkAccessFlagBits flag = VK_ACCESS_SHADER_READ_BIT) {"
    }

    {
        "file_name":"FSR31Feature_Dx11_function_1.cpp",
        "line_count":23,
        "code":"string ResultToString(Fsr31::FfxErrorCode result)\n    {\n        switch (result)\n        {\n        case Fsr31::FFX_OK: return \"The operation completed successfully.\";\n        case Fsr31::FFX_ERROR_INVALID_POINTER: return \"The operation failed due to an invalid pointer.\";\n        case Fsr31::FFX_ERROR_INVALID_ALIGNMENT: return \"The operation failed due to an invalid alignment.\";\n        case Fsr31::FFX_ERROR_INVALID_SIZE: return \"The operation failed due to an invalid size.\";\n        case Fsr31::FFX_EOF: return \"The end of the file was encountered.\";\n        case Fsr31::FFX_ERROR_INVALID_PATH: return \"The operation failed because the specified path was invalid.\";\n        case Fsr31::FFX_ERROR_EOF: return \"The operation failed because end of file was reached.\";\n        case Fsr31::FFX_ERROR_MALFORMED_DATA: return \"The operation failed because of some malformed data.\";\n        case Fsr31::FFX_ERROR_OUT_OF_MEMORY: return \"The operation failed because it ran out memory.\";\n        case Fsr31::FFX_ERROR_INCOMPLETE_INTERFACE: return \"The operation failed because the interface was not fully configured.\";\n        case Fsr31::FFX_ERROR_INVALID_ENUM: return \"The operation failed because of an invalid enumeration value.\";\n        case Fsr31::FFX_ERROR_INVALID_ARGUMENT: return \"The operation failed because an argument was invalid.\";\n        case Fsr31::FFX_ERROR_OUT_OF_RANGE: return \"The operation failed because a value was out of range.\";\n        case Fsr31::FFX_ERROR_NULL_DEVICE: return \"The operation failed because a device was null.\";\n        case Fsr31::FFX_ERROR_BACKEND_API_ERROR: return \"The operation failed because the backend API returned an error code.\";\n        case Fsr31::FFX_ERROR_INSUFFICIENT_MEMORY: return \"The operation failed because there was not enough memory.\";\n        default: return \"Unknown\";\n        }\n    }",
        "mark":8.5,
        "query_nsx":"\/* Convert a given error code into a human-readable message.\n   >>> string ResultToString(Fsr31::FfxErrorCode result) { *\/",
        "query_nlx":"\/* Function named ResultToString converts a given error code into a corresponding error message.\n   >>> ResultToString(Fsr31::FFX_OK) returns \"The operation completed successfully.\"\n   >>> ResultToString(Fsr31::FFX_ERROR_INVALID_POINTER) returns \"The operation failed due to an invalid pointer.\"\n   >>> ResultToString(Fsr31::FFX_ERROR_OUT_OF_MEMORY) returns \"The operation failed because it ran out memory.\"\n   >>> ResultToString(Fsr31::FFX_ERROR_UNKNOWN) returns \"Unknown\" *\/ \nstring ResultToString(Fsr31::FfxErrorCode result) {"
    }

    {
        "file_name":"FSR31Feature_Vk_function_1.cpp",
        "line_count":31,
        "code":"FfxApiResourceDescription ffxApiGetImageResourceDescriptionVKLocal(NVSDK_NGX_Resource_VK* vkResource, bool uav = false)\n{\n    FfxApiResourceDescription resourceDescription = {};\n\n    \/\/ This is valid\n    if (vkResource->Resource.ImageViewInfo.Image == VK_NULL_HANDLE)\n        return resourceDescription;\n\n    \/\/ Set flags properly for resource registration\n    resourceDescription.flags = FFX_API_RESOURCE_FLAGS_NONE;\n\n    \/\/ Unordered access use\n    if (uav)\n        resourceDescription.usage = FFX_API_RESOURCE_USAGE_UAV;\n    else\n        resourceDescription.usage = FFX_API_RESOURCE_USAGE_READ_ONLY;\n\n    resourceDescription.type = FFX_API_RESOURCE_TYPE_TEXTURE2D;\n    resourceDescription.width = vkResource->Resource.ImageViewInfo.Width;\n    resourceDescription.height = vkResource->Resource.ImageViewInfo.Height;\n    resourceDescription.mipCount = 1;\n    resourceDescription.depth = 1;\n\n    \/\/ For No Man's Sky\n    if (vkResource->Resource.ImageViewInfo.Format == VK_FORMAT_D32_SFLOAT_S8_UINT)\n        resourceDescription.format = FFX_API_SURFACE_FORMAT_R32_FLOAT;\n    else\n        resourceDescription.format = ffxApiGetSurfaceFormatVK(vkResource->Resource.ImageViewInfo.Format);\n\n    return resourceDescription;\n}",
        "mark":8.0,
        "query_nsx":"        \/* Create a resource description for an image resource in a specific format for a game called No Man's Sky.\n        >>> FfxApiResourceDescription ffxApiGetImageResourceDescriptionVKLocal(NVSDK_NGX_Resource_VK* vkResource, bool uav = false) { *\/",
        "query_nlx":"        \/* Generate a resource description for an image resource in a Vulkan-based application. \n        >>> ffxApiGetImageResourceDescriptionVKLocal(NVSDK_NGX_Resource_VK* vkResource, bool uav = false) *\/"
    }

    {
        "file_name":"functional_function_2.cpp",
        "line_count":3,
        "code":"void clear_function(T & x) {\n        x.clear();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Clear the contents of the input object.\n    >>> clear_function(T & x) *\/",
        "query_nlx":"\/* Define a function called clear_function that takes a reference to a variable x and clears its contents.\n   >>> clear_function(x) *\/ \nvoid clear_function(T & x) {"
    }

    {
        "file_name":"FunctionTest_function_1.cpp",
        "line_count":1,
        "code":"void setValue(int value) { data = value; }",
        "mark":8.0,
        "query_nsx":"\/* Set the value of a variable to the provided integer value.\n   >>> setValue(int value) *\/",
        "query_nlx":"\/* Define a function named setValue that takes an integer value as input and assigns it to a variable named data. \n   >>> setValue(10) *\/ \nvoid setValue(int value) { "
    }

    {
        "file_name":"FunctionTest_function_2.cpp",
        "line_count":1,
        "code":"int freeFunc(int value) { return value + 1; }",
        "mark":8.0,
        "query_nsx":"\/* Increment the input integer value by 1.\n>>> freeFunc(int value) { *\/",
        "query_nlx":"\/* Function named freeFunc takes an integer value as input and returns the value incremented by 1. \n>>> freeFunc(5) 6 \n>>> freeFunc(-10) -9 *\/ \nint freeFunc(int value) {"
    }

    {
        "file_name":"FunctionTest_function_3.cpp",
        "line_count":1,
        "code":"int freeFunc2(int value) { return value - 1; }",
        "mark":8.0,
        "query_nsx":"\/* Subtract 1 from the input integer value.\n   >>> freeFunc2(int value) { *\/",
        "query_nlx":"\/* Function named freeFunc2 takes an integer value as input and returns the value decremented by 1. \n>>> freeFunc2(5) 4 \n>>> freeFunc2(10) 9 *\/ \nint freeFunc2(int value) { "
    }

    {
        "file_name":"Function_function_2.cpp",
        "line_count":1,
        "code":"int someFunc(float a) { return static_cast<int>(a * 2); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the integer value of a float number multiplied by 2.\n>>> someFunc(float a) { *\/",
        "query_nlx":"\/* Function named someFunc takes a floating-point number as input and returns an integer value that is twice the input value.\n>>> someFunc(3.5) 7\n>>> someFunc(0.25) 0 *\/ \nint someFunc(float a) { "
    }

    {
        "file_name":"gl_function_10.cpp",
        "line_count":18,
        "code":"void glad_gl_load_GL_VERSION_3_1(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) {\n    if(!context->VERSION_3_1) return;\n    context->BindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, \"glBindBufferBase\");\n    context->BindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, \"glBindBufferRange\");\n    context->CopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) load(userptr, \"glCopyBufferSubData\");\n    context->DrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) load(userptr, \"glDrawArraysInstanced\");\n    context->DrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) load(userptr, \"glDrawElementsInstanced\");\n    context->GetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) load(userptr, \"glGetActiveUniformBlockName\");\n    context->GetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) load(userptr, \"glGetActiveUniformBlockiv\");\n    context->GetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC) load(userptr, \"glGetActiveUniformName\");\n    context->GetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) load(userptr, \"glGetActiveUniformsiv\");\n    context->GetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, \"glGetIntegeri_v\");\n    context->GetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) load(userptr, \"glGetUniformBlockIndex\");\n    context->GetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) load(userptr, \"glGetUniformIndices\");\n    context->PrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC) load(userptr, \"glPrimitiveRestartIndex\");\n    context->TexBuffer = (PFNGLTEXBUFFERPROC) load(userptr, \"glTexBuffer\");\n    context->UniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) load(userptr, \"glUniformBlockBinding\");\n}",
        "mark":8.0,
        "query_nsx":"\/* Load OpenGL functions for version 3.1 if supported by the context.\n   >>> glad_gl_load_GL_VERSION_3_1(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) *\/",
        "query_nlx":"\/* Generate function pointers for various OpenGL functions from version 3.1 if available in the given context.\n   >>> glad_gl_load_GL_VERSION_3_1(context, load, userptr) *\/"
    }

    {
        "file_name":"gl_function_11.cpp",
        "line_count":22,
        "code":"void glad_gl_load_GL_VERSION_3_2(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) {\n    if(!context->VERSION_3_2) return;\n    context->ClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) load(userptr, \"glClientWaitSync\");\n    context->DeleteSync = (PFNGLDELETESYNCPROC) load(userptr, \"glDeleteSync\");\n    context->DrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) load(userptr, \"glDrawElementsBaseVertex\");\n    context->DrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) load(userptr, \"glDrawElementsInstancedBaseVertex\");\n    context->DrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) load(userptr, \"glDrawRangeElementsBaseVertex\");\n    context->FenceSync = (PFNGLFENCESYNCPROC) load(userptr, \"glFenceSync\");\n    context->FramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) load(userptr, \"glFramebufferTexture\");\n    context->GetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC) load(userptr, \"glGetBufferParameteri64v\");\n    context->GetInteger64i_v = (PFNGLGETINTEGER64I_VPROC) load(userptr, \"glGetInteger64i_v\");\n    context->GetInteger64v = (PFNGLGETINTEGER64VPROC) load(userptr, \"glGetInteger64v\");\n    context->GetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) load(userptr, \"glGetMultisamplefv\");\n    context->GetSynciv = (PFNGLGETSYNCIVPROC) load(userptr, \"glGetSynciv\");\n    context->IsSync = (PFNGLISSYNCPROC) load(userptr, \"glIsSync\");\n    context->MultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) load(userptr, \"glMultiDrawElementsBaseVertex\");\n    context->ProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) load(userptr, \"glProvokingVertex\");\n    context->SampleMaski = (PFNGLSAMPLEMASKIPROC) load(userptr, \"glSampleMaski\");\n    context->TexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC) load(userptr, \"glTexImage2DMultisample\");\n    context->TexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC) load(userptr, \"glTexImage3DMultisample\");\n    context->WaitSync = (PFNGLWAITSYNCPROC) load(userptr, \"glWaitSync\");\n}",
        "mark":8.0,
        "query_nsx":"\/* Load OpenGL functions for version 3.2 if supported by the context.\n   >>> glad_gl_load_GL_VERSION_3_2(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) *\/",
        "query_nlx":"\/* Generate function to load OpenGL functions for version 3.2 into a context using a user-provided loader function and user pointer.\n   >>> glad_gl_load_GL_VERSION_3_2(context, load, userptr) void *\/"
    }

    {
        "file_name":"gl_function_13.cpp",
        "line_count":49,
        "code":"void glad_gl_load_GL_VERSION_4_0(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) {\n    if(!context->VERSION_4_0) return;\n    context->BeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC) load(userptr, \"glBeginQueryIndexed\");\n    context->BindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) load(userptr, \"glBindTransformFeedback\");\n    context->BlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) load(userptr, \"glBlendEquationSeparatei\");\n    context->BlendEquationi = (PFNGLBLENDEQUATIONIPROC) load(userptr, \"glBlendEquationi\");\n    context->BlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) load(userptr, \"glBlendFuncSeparatei\");\n    context->BlendFunci = (PFNGLBLENDFUNCIPROC) load(userptr, \"glBlendFunci\");\n    context->DeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) load(userptr, \"glDeleteTransformFeedbacks\");\n    context->DrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) load(userptr, \"glDrawArraysIndirect\");\n    context->DrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) load(userptr, \"glDrawElementsIndirect\");\n    context->DrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) load(userptr, \"glDrawTransformFeedback\");\n    context->DrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) load(userptr, \"glDrawTransformFeedbackStream\");\n    context->EndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC) load(userptr, \"glEndQueryIndexed\");\n    context->GenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) load(userptr, \"glGenTransformFeedbacks\");\n    context->GetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC) load(userptr, \"glGetActiveSubroutineName\");\n    context->GetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) load(userptr, \"glGetActiveSubroutineUniformName\");\n    context->GetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) load(userptr, \"glGetActiveSubroutineUniformiv\");\n    context->GetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC) load(userptr, \"glGetProgramStageiv\");\n    context->GetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC) load(userptr, \"glGetQueryIndexediv\");\n    context->GetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC) load(userptr, \"glGetSubroutineIndex\");\n    context->GetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) load(userptr, \"glGetSubroutineUniformLocation\");\n    context->GetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC) load(userptr, \"glGetUniformSubroutineuiv\");\n    context->GetUniformdv = (PFNGLGETUNIFORMDVPROC) load(userptr, \"glGetUniformdv\");\n    context->IsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) load(userptr, \"glIsTransformFeedback\");\n    context->MinSampleShading = (PFNGLMINSAMPLESHADINGPROC) load(userptr, \"glMinSampleShading\");\n    context->PatchParameterfv = (PFNGLPATCHPARAMETERFVPROC) load(userptr, \"glPatchParameterfv\");\n    context->PatchParameteri = (PFNGLPATCHPARAMETERIPROC) load(userptr, \"glPatchParameteri\");\n    context->PauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) load(userptr, \"glPauseTransformFeedback\");\n    context->ResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) load(userptr, \"glResumeTransformFeedback\");\n    context->Uniform1d = (PFNGLUNIFORM1DPROC) load(userptr, \"glUniform1d\");\n    context->Uniform1dv = (PFNGLUNIFORM1DVPROC) load(userptr, \"glUniform1dv\");\n    context->Uniform2d = (PFNGLUNIFORM2DPROC) load(userptr, \"glUniform2d\");\n    context->Uniform2dv = (PFNGLUNIFORM2DVPROC) load(userptr, \"glUniform2dv\");\n    context->Uniform3d = (PFNGLUNIFORM3DPROC) load(userptr, \"glUniform3d\");\n    context->Uniform3dv = (PFNGLUNIFORM3DVPROC) load(userptr, \"glUniform3dv\");\n    context->Uniform4d = (PFNGLUNIFORM4DPROC) load(userptr, \"glUniform4d\");\n    context->Uniform4dv = (PFNGLUNIFORM4DVPROC) load(userptr, \"glUniform4dv\");\n    context->UniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC) load(userptr, \"glUniformMatrix2dv\");\n    context->UniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC) load(userptr, \"glUniformMatrix2x3dv\");\n    context->UniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC) load(userptr, \"glUniformMatrix2x4dv\");\n    context->UniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC) load(userptr, \"glUniformMatrix3dv\");\n    context->UniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC) load(userptr, \"glUniformMatrix3x2dv\");\n    context->UniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC) load(userptr, \"glUniformMatrix3x4dv\");\n    context->UniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC) load(userptr, \"glUniformMatrix4dv\");\n    context->UniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC) load(userptr, \"glUniformMatrix4x2dv\");\n    context->UniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC) load(userptr, \"glUniformMatrix4x3dv\");\n    context->UniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC) load(userptr, \"glUniformSubroutinesuiv\");\n}",
        "mark":8.0,
        "query_nsx":"\/* Load OpenGL functions for version 4.0 if supported by the context.\n   >>> glad_gl_load_GL_VERSION_4_0(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) *\/",
        "query_nlx":"\/* Generate function to load OpenGL functions for version 4.0\n   >>> glad_gl_load_GL_VERSION_4_0(context, load, userptr) void *\/"
    }

    {
        "file_name":"gl_function_30.cpp",
        "line_count":9,
        "code":"void glad_close_dlopen_handle(void* handle) {\n    if (handle != NULL) {\n#if GLAD_PLATFORM_WIN32\n        FreeLibrary((HMODULE) handle);\n#else\n        dlclose(handle);\n#endif\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Close the dynamic loading handle based on the platform.\n>>> glad_close_dlopen_handle(void* handle) *\/",
        "query_nlx":"\/* Function named glad_close_dlopen_handle closes a dynamic loading handle if it is not NULL. \n>>> glad_close_dlopen_handle(NULL) does nothing \n>>> glad_close_dlopen_handle(handle) closes the handle using platform-specific functions *\/ \nvoid glad_close_dlopen_handle(void* handle) {"
    }

    {
        "file_name":"gl_function_31.cpp",
        "line_count":11,
        "code":"GLADapiproc glad_dlsym_handle(void* handle, const char *name) {\n    if (handle == NULL) {\n        return NULL;\n    }\n\n#if GLAD_PLATFORM_WIN32\n    return (GLADapiproc) GetProcAddress((HMODULE) handle, name);\n#else\n    return GLAD_GNUC_EXTENSION (GLADapiproc) dlsym(handle, name);\n#endif\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a function pointer from a dynamic library handle based on the function name.\n>>> glad_dlsym_handle(void* handle, const char *name) *\/",
        "query_nlx":"\/* Function named glad_dlsym_handle retrieves the address of a function symbol from a given handle.\n>>> glad_dlsym_handle(NULL, \"function_name\") returns NULL if the handle is NULL.\n>>> glad_dlsym_handle(handle, \"function_name\") returns the address of the function symbol using platform-specific methods. *\/"
    }

    {
        "file_name":"gl_function_36.cpp",
        "line_count":6,
        "code":"void gladLoaderUnloadGL(void) {\n    if (_gl_handle != NULL) {\n        glad_close_dlopen_handle(_gl_handle);\n        _gl_handle = NULL;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Unload the OpenGL loader handle if it is currently loaded.\n   >>> gladLoaderUnloadGL() *\/ \nvoid gladLoaderUnloadGL(void) {",
        "query_nlx":"\/* Function named gladLoaderUnloadGL unloads the OpenGL loader handle if it is not already NULL.\n>>> gladLoaderUnloadGL() *\/ \nvoid gladLoaderUnloadGL(void) {"
    }

    {
        "file_name":"gl_function_6.cpp",
        "line_count":22,
        "code":"void glad_gl_load_GL_VERSION_1_5(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) {\n    if(!context->VERSION_1_5) return;\n    context->BeginQuery = (PFNGLBEGINQUERYPROC) load(userptr, \"glBeginQuery\");\n    context->BindBuffer = (PFNGLBINDBUFFERPROC) load(userptr, \"glBindBuffer\");\n    context->BufferData = (PFNGLBUFFERDATAPROC) load(userptr, \"glBufferData\");\n    context->BufferSubData = (PFNGLBUFFERSUBDATAPROC) load(userptr, \"glBufferSubData\");\n    context->DeleteBuffers = (PFNGLDELETEBUFFERSPROC) load(userptr, \"glDeleteBuffers\");\n    context->DeleteQueries = (PFNGLDELETEQUERIESPROC) load(userptr, \"glDeleteQueries\");\n    context->EndQuery = (PFNGLENDQUERYPROC) load(userptr, \"glEndQuery\");\n    context->GenBuffers = (PFNGLGENBUFFERSPROC) load(userptr, \"glGenBuffers\");\n    context->GenQueries = (PFNGLGENQUERIESPROC) load(userptr, \"glGenQueries\");\n    context->GetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC) load(userptr, \"glGetBufferParameteriv\");\n    context->GetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC) load(userptr, \"glGetBufferPointerv\");\n    context->GetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC) load(userptr, \"glGetBufferSubData\");\n    context->GetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC) load(userptr, \"glGetQueryObjectiv\");\n    context->GetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC) load(userptr, \"glGetQueryObjectuiv\");\n    context->GetQueryiv = (PFNGLGETQUERYIVPROC) load(userptr, \"glGetQueryiv\");\n    context->IsBuffer = (PFNGLISBUFFERPROC) load(userptr, \"glIsBuffer\");\n    context->IsQuery = (PFNGLISQUERYPROC) load(userptr, \"glIsQuery\");\n    context->MapBuffer = (PFNGLMAPBUFFERPROC) load(userptr, \"glMapBuffer\");\n    context->UnmapBuffer = (PFNGLUNMAPBUFFERPROC) load(userptr, \"glUnmapBuffer\");\n}",
        "mark":8.0,
        "query_nsx":"\/* Load OpenGL functions for version 1.5 if supported by the context.\n   >>> glad_gl_load_GL_VERSION_1_5(GladGLContext *context, GLADuserptrloadfunc load, void* userptr) *\/",
        "query_nlx":"\/* Function loads OpenGL functions for version 1.5 into the provided context using the specified loader function and user pointer.\n   >>> glad_gl_load_GL_VERSION_1_5(context, load, userptr) *\/"
    }

    {
        "file_name":"GuildHeader_function_1.cpp",
        "line_count":3,
        "code":"bool IsPlacementGuildType(eButtonPlacement pl) {\n\t\treturn pl == BUTTON_GUILD_LEFT || pl == BUTTON_GUILD_RIGHT;\n\t}",
        "mark":9.0,
        "query_nsx":"\/* Check if the button placement is of type guild on the left or right side.\n>>> bool IsPlacementGuildType(eButtonPlacement pl) { *\/",
        "query_nlx":"\/* Function named IsPlacementGuildType determines if a given button placement is either BUTTON_GUILD_LEFT or BUTTON_GUILD_RIGHT.\n>>> IsPlacementGuildType(BUTTON_GUILD_LEFT) true\n>>> IsPlacementGuildType(BUTTON_GUILD_RIGHT) true\n>>> IsPlacementGuildType(BUTTON_GUILD_TOP) false\n*\/ \nbool IsPlacementGuildType(eButtonPlacement pl) {"
    }

    {
        "file_name":"GuildHeader_function_2.cpp",
        "line_count":3,
        "code":"bool IsPlacementChannelType(eButtonPlacement pl) {\n\t\treturn pl == BUTTON_RIGHT || pl == BUTTON_LEFT;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Check if the button placement is either on the right or left side.\n>>> bool IsPlacementChannelType(eButtonPlacement pl) { *\/",
        "query_nlx":"\/* Function named IsPlacementChannelType determines if a given button placement is either BUTTON_RIGHT or BUTTON_LEFT.\n>>> IsPlacementChannelType(BUTTON_RIGHT) true\n>>> IsPlacementChannelType(BUTTON_LEFT) true\n>>> IsPlacementChannelType(BUTTON_TOP) false *\/ \nbool IsPlacementChannelType(eButtonPlacement pl) {"
    }

    {
        "file_name":"GuildLister_function_1.cpp",
        "line_count":4,
        "code":"int GetProfileBorderRenderSize()\n{\n\treturn ScaleByDPI(Supports32BitIcons() ? (PROFILE_PICTURE_SIZE_DEF + 12) : 64);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the size for rendering profile borders based on certain conditions.\n>>> int GetProfileBorderRenderSize() *\/",
        "query_nlx":"\/* Determine the render size for a profile border based on whether 32-bit icons are supported. If supported, the render size is the default profile picture size plus 12; otherwise, it is 64.\n>>> GetProfileBorderRenderSize() returns an integer value representing the render size for the profile border. *\/ \nint GetProfileBorderRenderSize() { "
    }

    {
        "file_name":"Guild_function_1.cpp",
        "line_count":3,
        "code":"void AddKnownMember(Snowflake sf) {\n\t\tm_knownMembers.insert(sf);\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Add a new member to the list of known members.\n   >>> AddKnownMember(sf) *\/ \nvoid AddKnownMember(Snowflake sf) {",
        "query_nlx":"\/* Define a function called AddKnownMember that takes a Snowflake parameter and adds it to a collection of known members.\n>>> AddKnownMember(sf) *\/ \nvoid AddKnownMember(Snowflake sf) {"
    }

    {
        "file_name":"handler_work_function_4.cpp",
        "line_count":7,
        "code":"void dispatch(Function& function, Handler& handler)\n  {\n    \/\/ When using a native implementation, I\/O completion handlers are\n    \/\/ already dispatched according to the execution context's executor's\n    \/\/ rules. We can call the function directly.\n    asio_handler_invoke_helpers::invoke(function, handler);\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Dispatch a function using the provided handler.\n        >>> dispatch(Function& function, Handler& handler) *\/",
        "query_nlx":"\/* Implement a function that dispatches a given function and handler. \n   >>> dispatch(Function& function, Handler& handler) *\/"
    }

    {
        "file_name":"hash_map_function_4.cpp",
        "line_count":4,
        "code":"iterator begin()\n  {\n    return values_.begin();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the iterator pointing to the beginning of a collection of values.\n   >>> iterator begin() *\/",
        "query_nlx":"\/* Define a function that returns an iterator pointing to the beginning of a collection of values.\n   >>> begin() *\/"
    }

    {
        "file_name":"hash_map_function_9.cpp",
        "line_count":11,
        "code":"void clear()\n  {\n    \/\/ Clear the values.\n    values_.clear();\n    size_ = 0;\n\n    \/\/ Initialise all buckets to empty.\n    iterator end_it = values_.end();\n    for (size_t i = 0; i < num_buckets_; ++i)\n      buckets_[i].first = buckets_[i].last = end_it;\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Clear all values and initialise buckets to empty.\n        >>> clear() *\/",
        "query_nlx":"\/* Define a function that clears the values stored in a data structure and initializes all buckets to empty.\n>>> clear()\n*\/ \nvoid clear() {"
    }

    {
        "file_name":"helper_function_5.cpp",
        "line_count":7,
        "code":"int HexStringToInt(const std::string& hexString) {\n        int num;\n        std::stringstream ss;\n        ss << std::hex << hexString;\n        ss >> num;\n        return num;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert a hexadecimal string to an integer value.\n    >>> int HexStringToInt(const std::string& hexString) { *\/",
        "query_nlx":"\/* Function named HexStringToInt converts a given hexadecimal string to an integer value.\n   >>> HexStringToInt(\"1A\") returns 26\n   >>> HexStringToInt(\"FF\") returns 255 *\/ \nint HexStringToInt(const std::string& hexString) {"
    }

    {
        "file_name":"helper_math_function_100.cpp",
        "line_count":4,
        "code":"float\nlength(float3 v) {\n  return sqrtf(dot(v, v));\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the length of a 3D vector represented by three float values.\n>>> length(float3 v) *\/",
        "query_nlx":"\/* Function calculates the length of a 3D vector by taking the square root of the dot product of the vector with itself. \n>>> length({1.0, 2.0, 3.0}) \n*\/ \nfloat length(float3 v) { "
    }

    {
        "file_name":"helper_math_function_104.cpp",
        "line_count":5,
        "code":"float4\nnormalize(float4 v) {\n  float invLen = rsqrtf(dot(v, v));\n  return v * invLen;\n}",
        "mark":8.0,
        "query_nsx":"\/* Normalize a 4-dimensional vector by calculating its inverse length and returning the normalized vector.\n>>> normalize(float4 v) *\/",
        "query_nlx":"\/* Function named normalize takes a 4-dimensional vector and returns the normalized version of it. \n>>> normalize({1.0, 2.0, 3.0, 4.0}) { \n    float invLen = rsqrtf(dot(v, v));\n    return v * invLen;\n} *\/"
    }

    {
        "file_name":"helper_math_function_105.cpp",
        "line_count":4,
        "code":"float2\nfloorf(float2 v) {\n  return make_float2(floorf(v.x), floorf(v.y));\n}",
        "mark":8.0,
        "query_nsx":"\/* Return the floor values of each element in a 2D vector of floating-point numbers.\n>>> float2 floorf(float2 v) { *\/",
        "query_nlx":"\/* Function named floorf_float2 takes a 2D vector of floating-point numbers and returns a new 2D vector where each element is the floor value of the corresponding element in the input vector.\n>>> floorf_float2({2.5, 3.7}, {1.2, 4.8}) = {2.0, 3.0}\n>>> floorf_float2({-1.5, 0.9}, {3.3, -2.7}) = {-2.0, -3.0} *\/ \nfloat2 floorf(float2 v) {"
    }

    {
        "file_name":"helper_math_function_106.cpp",
        "line_count":4,
        "code":"float3\nfloorf(float3 v) {\n  return make_float3(floorf(v.x), floorf(v.y), floorf(v.z));\n}",
        "mark":8.0,
        "query_nsx":"\/* Return the floor values of each element in a 3D vector.\n>>> float3 floorf(float3 v) *\/",
        "query_nlx":"\/* Function named floorf takes a 3D vector as input and returns a new 3D vector where each component is the floor value of the corresponding component in the input vector. \n>>> floorf({2.5, 3.7, 1.2}) = {2.0, 3.0, 1.0} \n>>> floorf({-1.8, 0.3, 5.9}) = {-2.0, 0.0, 5.0} *\/ \nfloat3 floorf(float3 v) {"
    }

    {
        "file_name":"helper_math_function_107.cpp",
        "line_count":4,
        "code":"float4\nfloorf(float4 v) {\n  return make_float4(floorf(v.x), floorf(v.y), floorf(v.z), floorf(v.w));\n}",
        "mark":8.0,
        "query_nsx":"\/* Return a vector where each element is the floor value of the corresponding element in the input vector.\n>>> float4 floorf(float4 v) *\/",
        "query_nlx":"\/* Function named floorf takes a 4-dimensional vector as input and returns a new 4-dimensional vector where each component is the floor value of the corresponding component in the input vector.\n>>> floorf({3.5, 2.8, 1.2, 4.7}) = {3.0, 2.0, 1.0, 4.0}\n>>> floorf({-2.3, 5.6, 7.9, -4.1}) = {-3.0, 5.0, 7.0, -5.0} *\/ \nfloat4 floorf(float4 v) { "
    }

    {
        "file_name":"helper_math_function_108.cpp",
        "line_count":4,
        "code":"float\nfracf(float v) {\n  return v - floorf(v);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the fractional part of a given floating-point number.\n>>> fracf(float v) { *\/",
        "query_nlx":"\/* Define a function that calculates the fractional part of a given floating-point number by subtracting its floor value.\n>>> fracf(float v) *\/"
    }

    {
        "file_name":"helper_math_function_114.cpp",
        "line_count":4,
        "code":"float4\nfmodf(float4 a, float4 b) {\n  return make_float4(fmodf(a.x, b.x), fmodf(a.y, b.y), fmodf(a.z, b.z), fmodf(a.w, b.w));\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the remainder of each component in two sets of four floating-point numbers.\n>>> fmodf(float4 a, float4 b); *\/",
        "query_nlx":"            \/* Define a function that calculates the remainder of each component of two input vectors of floating-point numbers.\n            >>> fmodf({1.2, 3.4, 5.6, 7.8}, {0.5, 1.0, 2.0, 3.0}) {0.2, 0.4, 1.6, 1.8}\n            >>> fmodf({-2.5, 4.7, -6.3, 8.9}, {1.5, 2.0, 3.0, 4.0}) {-1.0, 0.7, -0.3, 0.9} *\/ \n            float4 fmodf(float4 a, float4 b) {"
    }

    {
        "file_name":"helper_math_function_117.cpp",
        "line_count":4,
        "code":"float4\nfabs(float4 v) {\n  return make_float4(fabs(v.x), fabs(v.y), fabs(v.z), fabs(v.w));\n}",
        "mark":8.0,
        "query_nsx":"\/* Return the absolute values of each element in a 4-dimensional vector.\n>>> float4 fabs(float4 v) { *\/",
        "query_nlx":"\/* Function named fabs calculates the absolute values of each element in a 4-dimensional vector and returns a new vector with the absolute values of each element. \n>>> fabs({-1.0, -2.0, 3.0, -4.0}) {1.0, 2.0, 3.0, 4.0} \n>>> fabs({0.0, -5.5, 6.7, -8.9}) {0.0, 5.5, 6.7, 8.9} *\/ \nfloat4 fabs(float4 v) { *\/"
    }

    {
        "file_name":"helper_math_function_121.cpp",
        "line_count":4,
        "code":"float3\nreflect(float3 i, float3 n) {\n  return i - 2.0f * n * dot(n, i);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the reflection of an incident vector based on a surface normal vector.\n>>> float3 reflect(float3 i, float3 n) { *\/",
        "query_nlx":"\/* Function named reflect calculates the reflection of an incident vector i off a surface with a normal vector n. \n>>> reflect({1.0, 2.0, 3.0}, {0.0, 1.0, 0.0}) { calculation of the reflected vector } *\/ \nfloat3 reflect(float3 i, float3 n) { "
    }

    {
        "file_name":"helper_math_function_122.cpp",
        "line_count":4,
        "code":"float3\ncross(float3 a, float3 b) {\n  return make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the cross product of two 3D vectors.\n>>> float3 cross(float3 a, float3 b); *\/",
        "query_nlx":"\/* Function named cross calculates the cross product of two 3D vectors represented by float3 data type. \n>>> cross({a.x, a.y, a.z}, {b.x, b.y, b.z}) returns a new float3 vector with components calculated as follows: \n    - x component: a.y * b.z - a.z * b.y \n    - y component: a.z * b.x - a.x * b.z \n    - z component: a.x * b.y - a.y * b.x *\/ \nfloat3 cross(float3 a, float3 b) {"
    }

    {
        "file_name":"helper_math_function_123.cpp",
        "line_count":5,
        "code":"float\nsmoothstep(float a, float b, float x) {\n  float y = clamp((x - a) \/ (b - a), 0.0f, 1.0f);\n  return (y * y * (3.0f - (2.0f * y)));\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate a smooth interpolation value between two given points.\n>>> smoothstep(float a, float b, float x) *\/",
        "query_nlx":"        \/* Function smoothstep calculates a smooth Hermite interpolation between two values based on a given input value. \n        >>> smoothstep(0.0, 1.0, 0.5) 0.5 \n        >>> smoothstep(0.0, 1.0, 0.2) 0.104 \n        *\/ \n        float smoothstep(float a, float b, float x) {"
    }

    {
        "file_name":"helper_math_function_126.cpp",
        "line_count":5,
        "code":"float4\nsmoothstep(float4 a, float4 b, float4 x) {\n  float4 y = clamp((x - a) \/ (b - a), 0.0f, 1.0f);\n  return (y * y * (make_float4(3.0f) - (make_float4(2.0f) * y)));\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate a smooth interpolation between two ranges of values based on a given input value.\n>>> float4 smoothstep(float4 a, float4 b, float4 x) { *\/",
        "query_nlx":"\/* Function named smoothstep calculates a smooth interpolation between two given float4 values based on a third float4 input value. \n>>> smoothstep({1.0f, 2.0f, 3.0f, 4.0f}, {5.0f, 6.0f, 7.0f, 8.0f}, {0.5f, 0.6f, 0.7f, 0.8f}) \n*\/ \nfloat4 smoothstep(float4 a, float4 b, float4 x) { "
    }

    {
        "file_name":"helper_math_function_2.cpp",
        "line_count":4,
        "code":"float\nfmaxf(float a, float b) {\n  return a > b ? a : b;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the maximum value between two given floating-point numbers.\n>>> fmaxf(float a, float b) *\/",
        "query_nlx":"\/* Function named fmaxf calculates the maximum value between two given floating-point numbers.\n>>> fmaxf(3.5, 2.8) returns 3.5\n>>> fmaxf(1.2, 5.6) returns 5.6 *\/ \nfloat fmaxf(float a, float b) {"
    }

    {
        "file_name":"helper_math_function_21.cpp",
        "line_count":4,
        "code":"float3\nmake_float3(int3 a) {\n  return make_float3(float(a.x), float(a.y), float(a.z));\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a 3D integer vector to a 3D float vector.\n>>> make_float3(int3 a) *\/",
        "query_nlx":"\/* Create a function that takes an integer vector of three elements and converts them to a float vector of three elements.\n>>> make_float3({1, 2, 3}) { \n*\/ \nfloat3 make_float3(int3 a) {"
    }

    {
        "file_name":"helper_math_function_22.cpp",
        "line_count":4,
        "code":"float3\nmake_float3(uint3 a) {\n  return make_float3(float(a.x), float(a.y), float(a.z));\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a 3D unsigned integer vector to a 3D floating-point vector.\n>>> make_float3(uint3 a) *\/",
        "query_nlx":"\/* Create a function that takes a uint3 type variable and converts it into a float3 type variable by converting each component to a float type.\n>>> make_float3(uint3 a) *\/\nfloat3 make_float3(uint3 a) {"
    }

    {
        "file_name":"helper_math_function_3.cpp",
        "line_count":4,
        "code":"int\nmax(int a, int b) {\n  return a > b ? a : b;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the maximum value between two integers.\n>>> max(int a, int b) *\/",
        "query_nlx":"\/* Function named max takes two integer inputs and returns the maximum of the two.\n>>> max(5, 10) 10\n>>> max(-3, -7) -3\n*\/ \nint max(int a, int b) {"
    }

    {
        "file_name":"helper_math_function_33.cpp",
        "line_count":4,
        "code":"float4\nmake_float4(float s) {\n  return make_float4(s, s, s, s);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a vector with four identical float values.\n>>> make_float4(2.5) { *\/ \nfloat4 make_float4(float s) {",
        "query_nlx":"\/* Function named make_float4 creates a 4-dimensional vector with all elements set to the same value provided as input. \n>>> make_float4(2.0) returns {2.0, 2.0, 2.0, 2.0} \n>>> make_float4(0.5) returns {0.5, 0.5, 0.5, 0.5} *\/ \nfloat4 make_float4(float s) {"
    }

    {
        "file_name":"helper_math_function_34.cpp",
        "line_count":4,
        "code":"float4\nmake_float4(float3 a) {\n  return make_float4(a.x, a.y, a.z, 0.0f);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a 4-dimensional floating-point vector from a 3-dimensional floating-point vector.\n>>> make_float4({1.0, 2.0, 3.0}) \n*\/ \nfloat4 make_float4(float3 a) {",
        "query_nlx":"\/* Function named make_float4 creates a 4-dimensional floating-point vector from a given 3-dimensional floating-point vector by adding a fourth element with a value of 0.0. \n>>> make_float4({1.0, 2.0, 3.0}) { \n*\/ \nfloat4 make_float4(float3 a) {"
    }

    {
        "file_name":"helper_math_function_35.cpp",
        "line_count":4,
        "code":"float4\nmake_float4(float3 a, float w) {\n  return make_float4(a.x, a.y, a.z, w);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a 4-dimensional floating-point vector from a 3-dimensional vector and a single float value.\n>>> make_float4({x, y, z}, w) \n*\/ \nfloat4 make_float4(float3 a, float w) {",
        "query_nlx":"\/* Function named make_float4 creates a 4-dimensional float vector from a 3-dimensional float vector and a single float value. \n>>> make_float4({1.0, 2.0, 3.0}, 4.0) returns {1.0, 2.0, 3.0, 4.0} *\/ \nfloat4 make_float4(float3 a, float w) {"
    }

    {
        "file_name":"helper_math_function_36.cpp",
        "line_count":4,
        "code":"float4\nmake_float4(int4 a) {\n  return make_float4(float(a.x), float(a.y), float(a.z), float(a.w));\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a 4-dimensional integer vector to a 4-dimensional float vector.\n>>> make_float4(int4 a) \n*\/",
        "query_nlx":"\/* Function named make_float4 converts a given integer vector into a float vector of size 4 by converting each element of the input vector to a float value. \n>>> make_float4({1, 2, 3, 4}) {1.0, 2.0, 3.0, 4.0} \n>>> make_float4({-1, 0, 5, -3}) {-1.0, 0.0, 5.0, -3.0} *\/ \nfloat4 make_float4(int4 a) { "
    }

    {
        "file_name":"helper_math_function_37.cpp",
        "line_count":4,
        "code":"float4\nmake_float4(uint4 a) {\n  return make_float4(float(a.x), float(a.y), float(a.z), float(a.w));\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a vector of unsigned integers to a vector of floating-point numbers.\n>>> make_float4(uint4 a) *\/",
        "query_nlx":"\/* Create a function that takes a 4-dimensional unsigned integer vector and converts it into a 4-dimensional float vector.\n   >>> make_float4({1, 2, 3, 4}) {1.0, 2.0, 3.0, 4.0}\n   >>> make_float4({10, 20, 30, 40}) {10.0, 20.0, 30.0, 40.0} *\/ \nfloat4 make_float4(uint4 a) {"
    }

    {
        "file_name":"helper_math_function_4.cpp",
        "line_count":4,
        "code":"int\nmin(int a, int b) {\n  return a < b ? a : b;\n}",
        "mark":8.0,
        "query_nsx":"\/* Return the minimum value between two integers.\n>>> min(int a, int b) { *\/",
        "query_nlx":"\/* Function named min calculates and returns the minimum value between two given integers.\n>>> min(5, 10) 5\n>>> min(-3, 0) -3\n*\/ \nint min(int a, int b) {"
    }

    {
        "file_name":"helper_math_function_53.cpp",
        "line_count":4,
        "code":"uint2\nmin(uint2 a, uint2 b) {\n  return make_uint2(min(a.x, b.x), min(a.y, b.y));\n}",
        "mark":8.0,
        "query_nsx":"\/* Return the minimum values of two sets of unsigned integers.\n>>> min(uint2 a, uint2 b) { *\/",
        "query_nlx":"\/* Function named min_uint2 returns a uint2 value that contains the minimum values of two input uint2 values in each component.\n>>> min_uint2({a.x, a.y}, {b.x, b.y}) { return make_uint2(min(a.x, b.x), min(a.y, b.y)); *\/ \nuint2 min(uint2 a, uint2 b) { "
    }

    {
        "file_name":"helper_math_function_65.cpp",
        "line_count":4,
        "code":"float\nlerp(float a, float b, float t) {\n  return a + t * (b - a);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate a linear interpolation between two floating-point numbers based on a given parameter value.\n>>> lerp(float a, float b, float t) *\/",
        "query_nlx":"\/* Function named lerp calculates the linear interpolation between two given float values a and b based on a parameter t. \n>>> lerp(1.0, 2.0, 0.5) returns 1.5 \n>>> lerp(5.0, 10.0, 0.3) returns 6.5 *\/ \nfloat lerp(float a, float b, float t) {"
    }

    {
        "file_name":"helper_math_function_66.cpp",
        "line_count":4,
        "code":"float2\nlerp(float2 a, float2 b, float t) {\n  return a + t * (b - a);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate a linear interpolation between two 2D points based on a given parameter value.\n>>> float2 lerp(float2 a, float2 b, float t) { *\/",
        "query_nlx":"\/* Function named lerp calculates the linear interpolation between two 2D points a and b based on a parameter t. \n>>> lerp({1.0, 2.0}, {3.0, 4.0}, 0.5) {2.0, 3.0} \n>>> lerp({-1.0, 0.0}, {5.0, 2.0}, 0.75) {3.0, 1.5} *\/ \nfloat2 lerp(float2 a, float2 b, float t) {"
    }

    {
        "file_name":"helper_math_function_67.cpp",
        "line_count":4,
        "code":"float3\nlerp(float3 a, float3 b, float t) {\n  return a + t * (b - a);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate a linear interpolation between two 3D vectors based on a given interpolation factor.\n>>> lerp(float3 a, float3 b, float t) *\/",
        "query_nlx":"\/* Function named lerp calculates the linear interpolation between two 3D vectors a and b based on a given interpolation factor t. \n>>> lerp({1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, 0.5) {2.5, 3.5, 4.5} \n>>> lerp({0.0, 0.0, 0.0}, {10.0, 10.0, 10.0}, 0.2) {2.0, 2.0, 2.0} *\/ \nfloat3 lerp(float3 a, float3 b, float t) { "
    }

    {
        "file_name":"helper_math_function_68.cpp",
        "line_count":4,
        "code":"float4\nlerp(float4 a, float4 b, float t) {\n  return a + t * (b - a);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate a linear interpolation between two 4-dimensional floating point vectors based on a given interpolation factor.\n>>> lerp(float4 a, float4 b, float t) *\/",
        "query_nlx":"\/* Function named lerp calculates the linear interpolation between two 4-dimensional floating-point vectors a and b based on a given interpolation factor t. \n>>> lerp(float4 a, float4 b, float t) { *\/"
    }

    {
        "file_name":"helper_math_function_69.cpp",
        "line_count":4,
        "code":"float\nclamp(float f, float a, float b) {\n  return fmaxf(a, fminf(f, b));\n}",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that restricts a given floating-point number within a specified range.\n>>> clamp(float f, float a, float b) *\/",
        "query_nlx":"\/* Define a function that restricts a given value within a specified range.\n>>> clamp(2.5, 1.0, 3.0) returns 2.5\n>>> clamp(0.5, 1.0, 3.0) returns 1.0\n*\/ \nfloat clamp(float f, float a, float b) { "
    }

    {
        "file_name":"helper_math_function_71.cpp",
        "line_count":4,
        "code":"uint\nclamp(uint f, uint a, uint b) {\n  return max(a, min(f, b));\n}",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that restricts a given value within a specified range.\n>>> clamp(uint f, uint a, uint b){ *\/",
        "query_nlx":"\/* Define a function named clamp that takes three unsigned integers f, a, and b as input and returns the result of clamping f between the values of a and b.\n>>> clamp(5, 0, 10) 5\n>>> clamp(15, 0, 10) 10\n*\/ \nuint clamp(uint f, uint a, uint b) {"
    }

    {
        "file_name":"helper_math_function_84.cpp",
        "line_count":4,
        "code":"uint2\nclamp(uint2 v, uint a, uint b) {\n  return make_uint2(clamp(v.x, a, b), clamp(v.y, a, b));\n}",
        "mark":8.0,
        "query_nsx":"\/* Given a vector of unsigned integers and a range defined by two unsigned integers, clamp each element of the vector to the specified range.\n   >>> clamp(uint2 v, uint a, uint b) *\/\n   uint2 clamp(uint2 v, uint a, uint b) {",
        "query_nlx":"\/* Function named clamp_uint2 takes a 2D unsigned integer vector and two unsigned integers as input, and returns a new 2D unsigned integer vector where each element is clamped between the provided range.\n>>> clamp_uint2({3, 5}, 1, 4) {2, 4}\n>>> clamp_uint2({10, 15}, 5, 12) {10, 12} *\/ \nuint2\nclamp(uint2 v, uint a, uint b) {"
    }

    {
        "file_name":"helper_math_function_85.cpp",
        "line_count":4,
        "code":"uint2\nclamp(uint2 v, uint2 a, uint2 b) {\n  return make_uint2(clamp(v.x, a.x, b.x), clamp(v.y, a.y, b.y));\n}",
        "mark":8.0,
        "query_nsx":"\/* Given a vector of unsigned integers and two ranges, clamp each element of the vector within the specified ranges.\n   >>> clamp(uint2 v, uint2 a, uint2 b) *\/",
        "query_nlx":"\/* Function named clamp restricts each component of a 2D unsigned integer vector to be within a specified range defined by two other 2D unsigned integer vectors.\n>>> clamp({3, 5}, {1, 2}, {4, 6}) {3, 5}\n>>> clamp({10, 8}, {5, 6}, {7, 9}) {7, 8} *\/ \nuint2\nclamp(uint2 v, uint2 a, uint2 b) { \/\/ Function declaration\n  \/\/ Body of the function is omitted\n} \/\/ End of function declaration."
    }

    {
        "file_name":"helper_math_function_90.cpp",
        "line_count":4,
        "code":"float\ndot(float2 a, float2 b) {\n  return a.x * b.x + a.y * b.y;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the dot product of two 2D vectors.\n>>> dot(float2 a, float2 b) *\/",
        "query_nlx":"\/* Function named dot calculates the dot product of two 2D vectors represented by float values. \n>>> dot({a.x, a.y}, {b.x, b.y}) returns the dot product of the two input vectors *\/ \nfloat dot(float2 a, float2 b) {"
    }

    {
        "file_name":"helper_math_function_91.cpp",
        "line_count":4,
        "code":"float\ndot(float3 a, float3 b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the dot product of two 3-dimensional vectors.\n>>> dot(float3 a, float3 b) *\/",
        "query_nlx":"\/* Function named dot calculates the dot product of two 3D vectors represented by float values. \n>>> dot({a.x, a.y, a.z}, {b.x, b.y, b.z}) returns the dot product of the two input vectors *\/ \nfloat dot(float3 a, float3 b) {"
    }

    {
        "file_name":"helper_math_function_92.cpp",
        "line_count":4,
        "code":"float\ndot(float4 a, float4 b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the dot product of two 4-dimensional vectors.\n>>> dot(float4 a, float4 b) *\/",
        "query_nlx":"\/* Function named dot calculates the dot product of two 4-dimensional vectors represented by float4 data types. \n>>> dot({a.x, a.y, a.z, a.w}, {b.x, b.y, b.z, b.w}) returns the sum of the element-wise multiplication of corresponding components of the two vectors. *\/ \nfloat dot(float4 a, float4 b) { "
    }

    {
        "file_name":"HotReloadSystem_function_7.cpp",
        "line_count":25,
        "code":"void onFileChange(const FileSystemWatcher::Notification& notification)\n    {\n        if (notification.relativePath.endsWith(\".cpp\"))\n        {\n            const size_t numberOfPlugins = registry.getNumberOfEntries();\n            for (size_t idx = 0; idx < numberOfPlugins; ++idx)\n            {\n                const PluginDynamicLibrary& library = registry.getPluginDynamicLibraryAt(idx);\n                for (const PluginFile& file : library.definition.files)\n                {\n                    if (file.absolutePath.view().endsWith(notification.relativePath))\n                    {\n                        const Time::Relative elapsed = Time::Absolute::now().subtract(library.lastLoadTime);\n                        if (elapsed.inRoundedUpperMilliseconds().ms > 500)\n                        {\n                            \/\/ Only reload if at least 500ms have passed, as sometimes FSEvents on macOS\n                            \/\/ likes to send multiple events that are difficult to filter properly\n                            (void)load(registry.getIdentifierAt(idx).view());\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Reload a plugin if a file with a specific extension has been changed.\n        >>> void onFileChange(const FileSystemWatcher::Notification& notification) { *\/",
        "query_nlx":"\n\/* Function named onFileChange processes file change notifications and reloads plugins if necessary based on specific conditions.\n>>> onFileChange(FileSystemWatcher::Notification notification) *\/"
    }

    {
        "file_name":"httplib_function_102.cpp",
        "line_count":11,
        "code":"string params_to_query_str(const Params &params) {\n  std::string query;\n\n  for (auto it = params.begin(); it != params.end(); ++it) {\n\tif (it != params.begin()) { query += \"&\"; }\n\tquery += it->first;\n\tquery += \"=\";\n\tquery += encode_query_param(it->second);\n  }\n  return query;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a set of parameters into a query string format.\n>>> string params_to_query_str(const Params &params) { *\/",
        "query_nlx":"\/* Function named params_to_query_str takes a map of parameters and converts them into a query string format by concatenating key-value pairs with an equal sign in between and an ampersand to separate multiple pairs.\n>>> params_to_query_str({{\"key1\", \"value1\"}, {\"key2\", \"value2\"}, {\"key3\", \"value3\"}}) \"key1=value1&key2=value2&key3=value3\" *\/ \nstring params_to_query_str(const Params &params) { "
    }

    {
        "file_name":"httplib_function_109.cpp",
        "line_count":5,
        "code":"void clear_file_info() {\n\tfile_.name.clear();\n\tfile_.filename.clear();\n\tfile_.content_type.clear();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Clear the information related to a file, including its name, filename, and content type.\n   >>> clear_file_info() *\/ \nvoid clear_file_info() {",
        "query_nlx":"\/* Function named clear_file_info that clears the name, filename, and content type fields of a file object.\n>>> clear_file_info() *\/ \nvoid clear_file_info() {"
    }

    {
        "file_name":"httplib_function_11.cpp",
        "line_count":7,
        "code":"void duration_to_sec_and_usec(const T &duration, U callback) {\n  auto sec = std::chrono::duration_cast<std::chrono::seconds>(duration).count();\n  auto usec = std::chrono::duration_cast<std::chrono::microseconds>(\n\t\t\t\t  duration - std::chrono::seconds(sec))\n\t\t\t\t  .count();\n  callback(static_cast<time_t>(sec), static_cast<time_t>(usec));\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a given duration to seconds and microseconds and pass the result to a callback function. \n>>> void duration_to_sec_and_usec(const T &duration, U callback) { *\/",
        "query_nlx":"\/* Implement a function that converts a given duration into seconds and microseconds and calls a provided callback function with the converted values.\n>>> duration_to_sec_and_usec(duration, callback) void *\/"
    }

    {
        "file_name":"httplib_function_112.cpp",
        "line_count":9,
        "code":"string to_lower(const char *beg, const char *end) {\n  std::string out;\n  auto it = beg;\n  while (it != end) {\n\tout += static_cast<char>(::tolower(*it));\n\tit++;\n  }\n  return out;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a given range of characters to lowercase and return the result as a string.\n>>> string to_lower(const char *beg, const char *end) { *\/",
        "query_nlx":"\/* Function named to_lower converts a given range of characters to lowercase and returns the resulting string.\n   >>> to_lower(\"Hello\", \"World\") \"hello\"\n   >>> to_lower(\"UPPERCASE\", \"STRING\") \"uppercase\" *\/ \nstring to_lower(const char *beg, const char *end) {"
    }

    {
        "file_name":"httplib_function_113.cpp",
        "line_count":21,
        "code":"string make_multipart_data_boundary() {\n  static const char data[] =\n\t  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n  \/\/ std::random_device might actually be deterministic on some\n  \/\/ platforms, but due to lack of support in the c++ standard library,\n  \/\/ doing better requires either some ugly hacks or breaking portability.\n  std::random_device seed_gen;\n\n  \/\/ Request 128 bits of entropy for initialization\n  std::seed_seq seed_sequence{seed_gen(), seed_gen(), seed_gen(), seed_gen()};\n  std::mt19937 engine(seed_sequence);\n\n  std::string result = \"--cpp-httplib-multipart-data-\";\n\n  for (auto i = 0; i < 16; i++) {\n\tresult += data[engine() % (sizeof(data) - 1)];\n  }\n\n  return result;\n}",
        "mark":8.0,
        "query_nsx":"\/* Generate a unique boundary string for multipart data.\n>>> string make_multipart_data_boundary() { *\/",
        "query_nlx":"\/* Generate a random multipart data boundary string that starts with \"--cpp-httplib-multipart-data-\" followed by 16 characters randomly selected from a predefined set of alphanumeric characters.\n>>> make_multipart_data_boundary() string *\/"
    }

    {
        "file_name":"httplib_function_114.cpp",
        "line_count":11,
        "code":"bool is_multipart_boundary_chars_valid(const std::string &boundary) {\n  auto valid = true;\n  for (size_t i = 0; i < boundary.size(); i++) {\n\tauto c = boundary[i];\n\tif (!std::isalnum(c) && c != '-' && c != '_') {\n\t  valid = false;\n\t  break;\n\t}\n  }\n  return valid;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the characters in the provided string for a multipart boundary are valid.\n>>> bool is_multipart_boundary_chars_valid(const std::string &boundary) { *\/",
        "query_nlx":"\/* Function checks if the characters in a given string representing a boundary for a multipart message are valid. Valid characters include alphanumeric characters, hyphen (-), and underscore (_). \n>>> is_multipart_boundary_chars_valid(\"boundary123\") true \n>>> is_multipart_boundary_chars_valid(\"invalid@boundary\") false *\/ \nbool is_multipart_boundary_chars_valid(const std::string &boundary) {"
    }

    {
        "file_name":"httplib_function_116.cpp",
        "line_count":1,
        "code":"string serialize_multipart_formdata_item_end() { return \"\\r\\n\"; }",
        "mark":8.0,
        "query_nsx":"\/* Serialize the end of a multipart form data item.\n>>> string serialize_multipart_formdata_item_end() *\/",
        "query_nlx":"            \/* Function named serialize_multipart_formdata_item_end generates a string representing the end of a multipart form data item. \n            >>> serialize_multipart_formdata_item_end() \"\\r\\n\" *\/ \n            string serialize_multipart_formdata_item_end() { "
    }

    {
        "file_name":"httplib_function_117.cpp",
        "line_count":4,
        "code":"string\nserialize_multipart_formdata_finish(const std::string &boundary) {\n  return \"--\" + boundary + \"--\\r\\n\";\n}",
        "mark":8.0,
        "query_nsx":"\/* Serialize multipart form data by finishing with the specified boundary.\n>>> serialize_multipart_formdata_finish(\"boundary123\") returns \"--boundary123--\\r\\n\" *\/",
        "query_nlx":"\/* Create a function that generates the ending boundary string for a multipart form data serialization.\n>>> serialize_multipart_formdata_finish(\"boundary123\") returns \"--boundary123--\\r\\n\" *\/ \nstring serialize_multipart_formdata_finish(const std::string &boundary) {"
    }

    {
        "file_name":"httplib_function_128.cpp",
        "line_count":8,
        "code":"bool has_crlf(const std::string &s) {\n  auto p = s.c_str();\n  while (*p) {\n\tif (*p == '\\r' || *p == '\\n') { return true; }\n\tp++;\n  }\n  return false;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the input string contains carriage return or line feed characters.\n>>> has_crlf(const std::string &s) *\/",
        "query_nlx":"\/* Function named has_crlf checks if a given string contains either a carriage return ('\\r') or a line feed ('\\n') character.\n>>> has_crlf(\"Hello\\r\\nWorld\") true\n>>> has_crlf(\"No CRLF here\") false *\/ \nbool has_crlf(const std::string &s) {"
    }

    {
        "file_name":"httplib_function_129.cpp",
        "line_count":19,
        "code":"string message_digest(const std::string &s, const EVP_MD *algo) {\n  auto context = std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)>(\n\t  EVP_MD_CTX_new(), EVP_MD_CTX_free);\n\n  unsigned int hash_length = 0;\n  unsigned char hash[EVP_MAX_MD_SIZE];\n\n  EVP_DigestInit_ex(context.get(), algo, nullptr);\n  EVP_DigestUpdate(context.get(), s.c_str(), s.size());\n  EVP_DigestFinal_ex(context.get(), hash, &hash_length);\n\n  std::stringstream ss;\n  for (auto i = 0u; i < hash_length; ++i) {\n\tss << std::hex << std::setw(2) << std::setfill('0')\n\t   << (unsigned int)hash[i];\n  }\n\n  return ss.str();\n}",
        "mark":8.0,
        "query_nsx":"\/* Generate a message digest (hash) for a given input string using a specified algorithm.\n>>> string message_digest(const string &s, const EVP_MD *algo) { *\/",
        "query_nlx":"\/* Function named message_digest calculates the hash value of a given string using a specified algorithm.\n>>> message_digest(\"example_string\", SHA256) returns the hash value as a string in hexadecimal format\n>>> message_digest(\"data123\", MD5) returns the hash value as a string in hexadecimal format *\/\nstring message_digest(const std::string &s, const EVP_MD *algo) { *\/"
    }

    {
        "file_name":"httplib_function_130.cpp",
        "line_count":3,
        "code":"string MD5(const std::string &s) {\n  return message_digest(s, EVP_md5());\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the MD5 hash value of a given input string.\n>>> MD5(input_string) output_hash_value *\/ \nstring MD5(const string &s) {",
        "query_nlx":"\/* Function named MD5 calculates the MD5 hash value of a given string using a message digest function.\n>>> MD5(\"example_string\") returns the MD5 hash value of the input string.\n*\/ \nstring MD5(const string &s) { "
    }

    {
        "file_name":"httplib_function_131.cpp",
        "line_count":3,
        "code":"string SHA_256(const std::string &s) {\n  return message_digest(s, EVP_sha256());\n}",
        "mark":8.0,
        "query_nsx":"\/* Compute the SHA-256 hash value of a given string.\n>>> SHA_256(const string &s) *\/",
        "query_nlx":"\/* Function named SHA_256 calculates the SHA-256 hash value of a given string using a message digest function.\n>>> SHA_256(\"example_string\") returns the SHA-256 hash value of the input string\n*\/ \nstring SHA_256(const std::string &s) {"
    }

    {
        "file_name":"httplib_function_132.cpp",
        "line_count":3,
        "code":"string SHA_512(const std::string &s) {\n  return message_digest(s, EVP_sha512());\n}",
        "mark":8.0,
        "query_nsx":"\/* Compute the SHA-512 hash value of a given string.\n>>> string SHA_512(const string &s) { *\/",
        "query_nlx":"\/* Function named SHA_512 calculates the SHA-512 hash value of a given string using a message digest function.\n>>> SHA_512(\"example_string\") \"SHA-512 hash value of the input string\"\n*\/ \nstring SHA_512(const std::string &s) { "
    }

    {
        "file_name":"httplib_function_136.cpp",
        "line_count":12,
        "code":"string random_string(size_t length) {\n  auto randchar = []() -> char {\n\tconst char charset[] = \"0123456789\"\n\t\t\t\t\t\t   \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\t\t\t\t   \"abcdefghijklmnopqrstuvwxyz\";\n\tconst size_t max_index = (sizeof(charset) - 1);\n\treturn charset[static_cast<size_t>(std::rand()) % max_index];\n  };\n  std::string str(length, 0);\n  std::generate_n(str.begin(), length, randchar);\n  return str;\n}",
        "mark":8.0,
        "query_nsx":"\/* Generate a random string of a specified length.\n   >>> string random_string(size_t length) { *\/",
        "query_nlx":"\/* Generate a random string of a specified length using characters from the alphanumeric character set.\n   >>> random_string(10) \"3aBcD5eFgH\"\n   >>> random_string(5) \"1aBcD\" *\/\nstring random_string(size_t length) {"
    }

    {
        "file_name":"httplib_function_14.cpp",
        "line_count":22,
        "code":"string to_string(const Error error) {\n  switch (error) {\n  case Error::Success: return \"Success (no error)\";\n  case Error::Connection: return \"Could not establish connection\";\n  case Error::BindIPAddress: return \"Failed to bind IP address\";\n  case Error::Read: return \"Failed to read connection\";\n  case Error::Write: return \"Failed to write connection\";\n  case Error::ExceedRedirectCount: return \"Maximum redirect count exceeded\";\n  case Error::Canceled: return \"Connection handling canceled\";\n  case Error::SSLConnection: return \"SSL connection failed\";\n  case Error::SSLLoadingCerts: return \"SSL certificate loading failed\";\n  case Error::SSLServerVerification: return \"SSL server verification failed\";\n  case Error::UnsupportedMultipartBoundaryChars:\n\treturn \"Unsupported HTTP multipart boundary characters\";\n  case Error::Compression: return \"Compression failed\";\n  case Error::ConnectionTimeout: return \"Connection timed out\";\n  case Error::Unknown: return \"Unknown\";\n  default: break;\n  }\n\n  return \"Invalid\";\n}",
        "mark":8.0,
        "query_nsx":"\/* Define a function that converts an error code into a corresponding error message.\n   >>> string to_string(const Error error) { *\/",
        "query_nlx":"\/* Function named to_string converts an error code into a human-readable error message. \n>>> to_string(Error::Success) returns \"Success (no error)\" \n>>> to_string(Error::Connection) returns \"Could not establish connection\" \n>>> to_string(Error::BindIPAddress) returns \"Failed to bind IP address\" \n>>> to_string(Error::Read) returns \"Failed to read connection\" \n>>> to_string(Error::Write) returns \"Failed to write connection\" \n>>> to_string(Error::ExceedRedirectCount) returns \"Maximum redirect count exceeded\" \n>>> to_string(Error::Canceled) returns \"Connection handling canceled\" \n>>> to_string(Error::SSLConnection) returns \"SSL connection failed\" \n>>> to_string(Error::SSLLoadingCerts) returns \"SSL certificate loading failed\" \n>>> to_string(Error::SSLServerVerification) returns \"SSL server verification failed\" \n>>> to_string(Error::UnsupportedMultipartBoundaryChars) returns \"Unsupported HTTP multipart boundary characters\" \n>>> to_string(Error::Compression) returns \"Compression failed\" \n>>> to_string(Error::ConnectionTimeout) returns \"Connection timed out\" \n>>> to_string(Error::Unknown) returns \"Unknown\" \n>>> to_string(static_cast<Error>(100)) returns \"Invalid\" *\/ \nstring to_string(const Error error) {"
    }

    {
        "file_name":"httplib_function_157.cpp",
        "line_count":3,
        "code":"else if (type == detail::EncodingType::Brotli) {\n\t\t\tres.set_header(\"Content-Encoding\", \"br\");\n\t\t  }",
        "mark":8.0,
        "query_nsx":"\/* Set the Content-Encoding header to 'br' if the encoding type is Brotli.\n>>> set_content_encoding_brotli() *\/ \nvoid set_content_encoding_brotli() {",
        "query_nlx":"\/* When the type is Brotli, set the response header \"Content-Encoding\" to \"br\".\n>>> set_content_encoding_to_br(detail::EncodingType type, Response res) *\/ \nvoid set_content_encoding_to_br(detail::EncodingType type, Response res) {"
    }

    {
        "file_name":"httplib_function_26.cpp",
        "line_count":27,
        "code":"string base64_encode(const std::string &in) {\n  static const auto lookup =\n\t  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/\";\n\n  std::string out;\n  out.reserve(in.size());\n\n  int val = 0;\n  int valb = -6;\n\n  for (auto c : in) {\n\tval = (val << 8) + static_cast<uint8_t>(c);\n\tvalb += 8;\n\twhile (valb >= 0) {\n\t  out.push_back(lookup[(val >> valb) & 0x3F]);\n\t  valb -= 6;\n\t}\n  }\n\n  if (valb > -6) { out.push_back(lookup[((val << 8) >> (valb + 8)) & 0x3F]); }\n\n  while (out.size() % 4) {\n\tout.push_back('=');\n  }\n\n  return out;\n}",
        "mark":8.0,
        "query_nsx":"\/* Encode a given input string into a base64 format.\n>>> string base64_encode(const std::string &in) { *\/",
        "query_nlx":"\/* Function named base64_encode encodes a given input string into a base64 encoded string.\n>>> base64_encode(\"Hello, World!\") \"SGVsbG8sIFdvcmxkIQ==\"\n>>> base64_encode(\"12345\") \"MTIzNDU=\"\n*\/ \nstring base64_encode(const std::string &in) {"
    }

    {
        "file_name":"httplib_function_27.cpp",
        "line_count":8,
        "code":"bool is_file(const std::string &path) {\n#if defined(_WIN32) && !defined(MINGW_SPECIFIC_HACKS)\n  return _access_s(path.c_str(), 0) == 0;\n#else\n  struct stat st;\n  return stat(path.c_str(), &st) >= 0 && S_ISREG(st.st_mode);\n#endif\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if a file exists at the specified path.\n>>> bool is_file(const std::string &path) { *\/",
        "query_nlx":"        \/* Function named is_file determines if a given path corresponds to a file in the system. \n        >>> is_file(\"\/path\/to\/file.txt\") true \n        >>> is_file(\"\/path\/to\/directory\/\") false *\/ \n        bool is_file(const std::string &path) {"
    }

    {
        "file_name":"httplib_function_28.cpp",
        "line_count":4,
        "code":"bool is_dir(const std::string &path) {\n  struct stat st;\n  return stat(path.c_str(), &st) >= 0 && S_ISDIR(st.st_mode);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the specified path is a directory.\n>>> bool is_dir(const std::string &path); *\/",
        "query_nlx":"\/* Function named is_dir determines if a given path corresponds to a directory in the file system.\n   >>> is_dir(\"\/path\/to\/directory\") true\n   >>> is_dir(\"\/path\/to\/file\") false *\/ \nbool is_dir(const std::string &path) {"
    }

    {
        "file_name":"httplib_function_3.cpp",
        "line_count":4,
        "code":"void hl__freeaddrinfo(struct addrinfo* ai)\n{\n\tasio::detail::socket_ops::freeaddrinfo(ai);\n}",
        "mark":8.0,
        "query_nsx":"\/* Free the memory allocated for address information structure.\n>>> hl__freeaddrinfo(struct addrinfo* ai) *\/",
        "query_nlx":"\/* Function named hl__freeaddrinfo calls a function to free the memory allocated for a given addrinfo structure.\n>>> hl__freeaddrinfo(struct addrinfo* ai) *\/"
    }

    {
        "file_name":"httplib_function_30.cpp",
        "line_count":20,
        "code":"string encode_query_param(const std::string &value) {\n  std::ostringstream escaped;\n  escaped.fill('0');\n  escaped << std::hex;\n\n  for (auto c : value) {\n\tif (std::isalnum(static_cast<uint8_t>(c)) || c == '-' || c == '_' ||\n\t\tc == '.' || c == '!' || c == '~' || c == '*' || c == '\\'' || c == '(' ||\n\t\tc == ')') {\n\t  escaped << c;\n\t} else {\n\t  escaped << std::uppercase;\n\t  escaped << '%' << std::setw(2)\n\t\t\t  << static_cast<int>(static_cast<unsigned char>(c));\n\t  escaped << std::nouppercase;\n\t}\n  }\n\n  return escaped.str();\n}",
        "mark":8.0,
        "query_nsx":"\/* Encode a given string value to be used as a query parameter in a URL.\n>>> string encode_query_param(const string &value) { *\/",
        "query_nlx":"\/* Function named encode_query_param takes a string value and encodes it for use as a query parameter in a URL.\n>>> encode_query_param(\"Hello, World!\") returns \"Hello%2C%20World%21\" *\/ \nstring encode_query_param(const std::string &value) {"
    }

    {
        "file_name":"httplib_function_35.cpp",
        "line_count":6,
        "code":"string file_extension(const std::string &path) {\n  std::smatch m;\n  static auto re = std::regex(\"\\\\.([a-zA-Z0-9]+)$\");\n  if (std::regex_search(path, m, re)) { return m[1].str(); }\n  return std::string();\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the file extension from the given file path.\n>>> string file_extension(const string &path) { *\/",
        "query_nlx":"\/* Function named file_extension extracts the file extension from a given file path string. \n>>> file_extension(\"\/path\/to\/file.txt\") \"txt\" \n>>> file_extension(\"\/documents\/report.docx\") \"docx\" *\/ \nstring file_extension(const std::string &path) {"
    }

    {
        "file_name":"httplib_function_36.cpp",
        "line_count":1,
        "code":"bool is_space_or_tab(char c) { return c == ' ' || c == '\\t'; }",
        "mark":9.0,
        "query_nsx":"\/* Determine if a given character is either a space or a tab.\n>>> bool is_space_or_tab(char c) { *\/",
        "query_nlx":"\/* Function named is_space_or_tab checks if a given character is either a space or a tab character.\n>>> is_space_or_tab(' ') true\n>>> is_space_or_tab('\\t') true\n>>> is_space_or_tab('a') false *\/ \nbool is_space_or_tab(char c) { "
    }

    {
        "file_name":"httplib_function_39.cpp",
        "line_count":7,
        "code":"int close_socket(socket_t sock) {\n#ifdef _WIN32\n  return closesocket(sock);\n#else\n  return close(sock);\n#endif\n}",
        "mark":8.0,
        "query_nsx":"\/* Define a function that closes a socket connection.\n>>> int close_socket(socket_t sock) *\/",
        "query_nlx":"\/* Function named close_socket takes a socket as input and closes it based on the operating system.\n>>> close_socket(123) closes the socket with ID 123 on Windows.\n>>> close_socket(456) closes the socket with ID 456 on Unix-like systems. *\/\nint close_socket(socket_t sock) {"
    }

    {
        "file_name":"httplib_function_62.cpp",
        "line_count":7,
        "code":"int shutdown_socket(socket_t sock) {\n#ifdef _WIN32\n  return shutdown(sock, SD_BOTH);\n#else\n  return shutdown(sock, SHUT_RDWR);\n#endif\n}",
        "mark":8.0,
        "query_nsx":"\/* Shutdown a socket connection.\n>>> int shutdown_socket(socket_t sock) *\/",
        "query_nlx":"\/* Function named shutdown_socket closes a given socket connection gracefully based on the operating system's specific shutdown requirements.\n>>> shutdown_socket(socket_t sock) on Windows shuts down the socket for both sending and receiving data.\n>>> shutdown_socket(socket_t sock) on other operating systems shuts down the socket for both sending and receiving data. *\/ \nint shutdown_socket(socket_t sock) {"
    }

    {
        "file_name":"httplib_function_67.cpp",
        "line_count":10,
        "code":"void set_nonblocking(socket_t sock, bool nonblocking) {\n#ifdef _WIN32\n  auto flags = nonblocking ? 1UL : 0UL;\n  ioctlsocket(sock, FIONBIO, &flags);\n#else\n  auto flags = fcntl(sock, F_GETFL, 0);\n  fcntl(sock, F_SETFL,\n\t\tnonblocking ? (flags | O_NONBLOCK) : (flags & (~O_NONBLOCK)));\n#endif\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the socket to non-blocking mode.\n>>> void set_nonblocking(socket_t sock, bool nonblocking) { *\/",
        "query_nlx":"\/* Define a function that sets the non-blocking mode for a given socket based on the operating system.\n>>> set_nonblocking(socket_t sock, bool nonblocking) *\/"
    }

    {
        "file_name":"httplib_function_82.cpp",
        "line_count":3,
        "code":"bool has_header(const Headers &headers, const std::string &key) {\n  return headers.find(key) != headers.end();\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given set of headers contains a specific key.\n>>> has_header(const Headers &headers, const std::string &key) *\/",
        "query_nlx":"\/* Function named has_header checks if a given set of headers contains a specific key. \n>>> has_header({\"Content-Type\": \"application\/json\", \"Authorization\": \"Bearer token\"}, \"Authorization\") true \n>>> has_header({\"Content-Type\": \"application\/json\", \"Accept\": \"application\/xml\"}, \"Location\") false *\/ \nbool has_header(const Headers &headers, const std::string &key) { "
    }

    {
        "file_name":"httplib_function_9.cpp",
        "line_count":4,
        "code":"streamsize xsputn(const char *s, std::streamsize n) {\n\t  sink_.write(s, static_cast<size_t>(n));\n\t  return n;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Write a function that writes a specified number of characters from a given string to a sink and returns the number of characters written.\n>>> xsputn(const char *s, std::streamsize n) *\/\n#include <iostream>\n#include <fstream>\nstd::streamsize xsputn(const char *s, std::streamsize n) { *\/",
        "query_nlx":"\/* Function named xsputn writes a given character array to a sink and returns the number of characters written.\n>>> xsputn(\"hello\", 5) 5\n>>> xsputn(\"world\", 3) 3 *\/ \nstreamsize xsputn(const char *s, std::streamsize n) {"
    }

    {
        "file_name":"httplib_function_90.cpp",
        "line_count":4,
        "code":"bool is_chunked_transfer_encoding(const Headers &headers) {\n  return !strcasecmp(get_header_value(headers, \"Transfer-Encoding\", 0, \"\"),\n\t\t\t\t\t \"chunked\");\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the provided headers indicate chunked transfer encoding.\n>>> bool is_chunked_transfer_encoding(const Headers &headers) { *\/",
        "query_nlx":"\/* Function named is_chunked_transfer_encoding determines if the given headers contain a \"Transfer-Encoding\" value that is equal to \"chunked\".\n>>> is_chunked_transfer_encoding(headers) returns true if the \"Transfer-Encoding\" value is \"chunked\", false otherwise. *\/\nbool is_chunked_transfer_encoding(const Headers &headers) {"
    }

    {
        "file_name":"httplib_function_94.cpp",
        "line_count":13,
        "code":"ssize_t write_headers(Stream &strm, const Headers &headers) {\n  ssize_t write_len = 0;\n  for (const auto &x : headers) {\n\tauto len =\n\t\tstrm.write_format(\"%s: %s\\r\\n\", x.first.c_str(), x.second.c_str());\n\tif (len < 0) { return len; }\n\twrite_len += len;\n  }\n  auto len = strm.write(\"\\r\\n\");\n  if (len < 0) { return len; }\n  write_len += len;\n  return write_len;\n}",
        "mark":8.0,
        "query_nsx":"\/* Write headers with key-value pairs to a stream and return the total length of characters written.\n>>> write_headers(Stream &strm, const Headers &headers) *\/",
        "query_nlx":"\/* Function named write_headers writes the given headers to a stream in the format \"key: value\\r\\n\" and returns the total length of the written headers.\n   >>> write_headers(strm, {{\"Content-Type\", \"text\/html\"}, {\"Connection\", \"keep-alive\"}}) 30\n   >>> write_headers(strm, {{\"Server\", \"Apache\/2.4.41\"}, {\"Content-Length\", \"1234\"}}) 35 *\/ \nssize_t write_headers(Stream &strm, const Headers &headers) {"
    }

    {
        "file_name":"httplib_function_95.cpp",
        "line_count":9,
        "code":"bool write_data(Stream &strm, const char *d, size_t l) {\n  size_t offset = 0;\n  while (offset < l) {\n\tauto length = strm.write(d + offset, l - offset);\n\tif (length < 0) { return false; }\n\toffset += static_cast<size_t>(length);\n  }\n  return true;\n}",
        "mark":8.0,
        "query_nsx":"\/* Write data to a stream until all data is successfully written.\n   >>> bool write_data(Stream &strm, const char *d, size_t l); *\/",
        "query_nlx":"\/* Implement a function that writes data to a stream in chunks until all data is written successfully.\n   >>> write_data(stream, data, length) true\/false *\/ \nbool write_data(Stream &strm, const char *d, size_t l) {"
    }

    {
        "file_name":"hybi13_function_12.cpp",
        "line_count":13,
        "code":"void reset_headers() {\n        m_state = HEADER_BASIC;\n        m_bytes_needed = frame::BASIC_HEADER_LENGTH;\n\n        m_basic_header.b0 = 0x00;\n        m_basic_header.b1 = 0x00;\n\n        std::fill_n(\n            m_extended_header.bytes,\n            frame::MAX_EXTENDED_HEADER_LENGTH,\n            0x00\n        );\n    }",
        "mark":8.0,
        "query_nsx":"\/* Reset the headers to their initial state.\n   >>> reset_headers() *\/ \nvoid reset_headers() {",
        "query_nlx":"\/* Reset the headers by setting the state to basic, initializing the bytes needed for basic header length, setting basic header bytes to 0x00, and filling the extended header bytes with 0x00.\n>>> reset_headers() *\/ \nvoid reset_headers() {"
    }

    {
        "file_name":"hybi13_function_20.cpp",
        "line_count":9,
        "code":"size_t copy_extended_header_bytes(uint8_t const * buf, size_t len) {\n        size_t bytes_to_read = (std::min)(m_bytes_needed,len);\n\n        std::copy(buf,buf+bytes_to_read,m_extended_header.bytes+m_cursor);\n        m_cursor += bytes_to_read;\n        m_bytes_needed -= bytes_to_read;\n\n        return bytes_to_read;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Copy a specified number of bytes from a buffer to an extended header structure.\n   >>> size_t copy_extended_header_bytes(uint8_t const * buf, size_t len); *\/",
        "query_nlx":"\/* Define a function that copies a specified number of bytes from a given buffer to an extended header, updating the cursor position and the remaining bytes needed accordingly.\n   >>> copy_extended_header_bytes(buf, len) returns the number of bytes copied to the extended header *\/ \nsize_t copy_extended_header_bytes(uint8_t const * buf, size_t len) {"
    }

    {
        "file_name":"HybridObjectPrototype_function_1.cpp",
        "line_count":7,
        "code":"void ensureInitialized() {\n    if (!_didLoadMethods) [[unlikely]] {\n      \/\/ lazy-load all exposed methods\n      loadHybridMethods();\n      _didLoadMethods = true;\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Ensure that all exposed methods are lazily loaded when needed.\n   >>> ensureInitialized() *\/ \nvoid ensureInitialized() {",
        "query_nlx":"\/* Ensure that all exposed methods are lazily loaded only if they have not been loaded before.\n   >>> ensureInitialized() *\/ \nvoid ensureInitialized() {"
    }

    {
        "file_name":"icu_function_2.cpp",
        "line_count":10,
        "code":"size_type length(const char_type* p)\n   {\n      size_type result = 0;\n      while (*p)\n      {\n         ++p;\n         ++result;\n      }\n      return result;\n   }",
        "mark":8.0,
        "query_nsx":"\/* Determine the length of a given sequence of characters.\n   >>> size_type length(const char_type* p) *\/",
        "query_nlx":"\/* Function named length calculates the number of characters in a given string by iterating through each character until reaching the null terminator. \n>>> length(\"hello\") 5 \n>>> length(\"world\") 5 *\/ \nsize_type length(const char_type* p) {"
    }

    {
        "file_name":"icu_function_57.cpp",
        "line_count":4,
        "code":"BaseIterator extract_output_base(const utf8_output_iterator<BaseIterator>& b)\n{\n   return b.base();\n}",
        "mark":8.0,
        "query_nsx":"\/* Extract the base iterator from the given UTF-8 output iterator. \n>>> BaseIterator extract_output_base(const utf8_output_iterator<BaseIterator>& b) { *\/",
        "query_nlx":"\/* Function named extract_output_base takes a utf8_output_iterator and returns the base iterator associated with it.\n>>> extract_output_base(b) returns the base iterator of the given utf8_output_iterator b. *\/ \nBaseIterator extract_output_base(const utf8_output_iterator<BaseIterator>& b) { "
    }

    {
        "file_name":"icu_function_58.cpp",
        "line_count":4,
        "code":"BaseIterator extract_output_base(const utf16_output_iterator<BaseIterator>& b)\n{\n   return b.base();\n}",
        "mark":8.0,
        "query_nsx":"\/* Extract the base iterator from the given UTF-16 output iterator.\n   >>> extract_output_base(utf16_output_iterator<BaseIterator>& b) BaseIterator *\/",
        "query_nlx":"\/* Function named extract_output_base takes a utf16_output_iterator and returns the base iterator associated with it.\n   >>> extract_output_base(utf16_output_iterator) BaseIterator *\/"
    }

    {
        "file_name":"IFeature_function_1.cpp",
        "line_count":1,
        "code":"void SetInit(bool InValue) { _isInited = InValue; }",
        "mark":8.0,
        "query_nsx":"\/* Set the initialization state to the given value.\n   >>> SetInit(true) \n   >>> SetInit(false) *\/ \nvoid SetInit(bool InValue) { ",
        "query_nlx":"\/* Function named SetInit sets the initialization status to a given boolean value.\n>>> SetInit(true) \n>>> SetInit(false) *\/ \nvoid SetInit(bool InValue) { "
    }

    {
        "file_name":"IFeature_function_2.cpp",
        "line_count":1,
        "code":"int GetNextHandleId() { return handleCounter++; }",
        "mark":8.0,
        "query_nsx":"\/* Return the next available handle ID. \n   >>> GetNextHandleId() *\/ \nint GetNextHandleId() { ",
        "query_nlx":"            \/* Function named GetNextHandleId returns the next available handle ID each time it is called. \n            >>> GetNextHandleId() 0 \n            >>> GetNextHandleId() 1 \n            >>> GetNextHandleId() 2 *\/ \n            int GetNextHandleId() { "
    }

    {
        "file_name":"IFeature_function_3.cpp",
        "line_count":1,
        "code":"long FrameCount() { return _frameCount; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the total number of frames in the current context. \n>>> long FrameCount() { *\/",
        "query_nlx":"\/* Function named FrameCount returns the value of the frame count variable. \n   >>> FrameCount()  *\/ \nlong FrameCount() { "
    }

    {
        "file_name":"ImageFormat_function_2.cpp",
        "line_count":9,
        "code":"Value toJSI(jsi::Runtime& runtime, ImageFormat arg) {\n      switch (arg) {\n        case ImageFormat::JPG: return JSIConverter<std::string>::toJSI(runtime, \"jpg\");\n        case ImageFormat::PNG: return JSIConverter<std::string>::toJSI(runtime, \"png\");\n        default: [[unlikely]]\n          throw std::invalid_argument(\"Cannot convert ImageFormat to JS - invalid value: \"\n                                    + std::to_string(static_cast<int>(arg)) + \"!\");\n      }\n    }",
        "mark":8.5,
        "query_nsx":"\/* Convert ImageFormat enum values to JSI format strings.\n   >>> Value toJSI(jsi::Runtime& runtime, ImageFormat arg) { *\/",
        "query_nlx":"\/* Function to convert an ImageFormat enum value to a JSI value using a given runtime.\n   The function takes a runtime reference and an ImageFormat enum value as input and returns the corresponding JSI value.\n   The function handles cases for JPG and PNG formats, converting them to \"jpg\" and \"png\" strings respectively.\n   If the input ImageFormat is not recognized, an exception is thrown with an error message indicating the invalid value. \n   >>> toJSI(jsi::Runtime& runtime, ImageFormat arg) \n*\/"
    }

    {
        "file_name":"ImageLoader_function_1.cpp",
        "line_count":1,
        "code":"void NopFree(void* unused) {}",
        "mark":8.0,
        "query_nsx":"\/* Define a function that performs a no-operation (NOP) operation when called.\n   >>> NopFree(void* unused) *\/",
        "query_nlx":"\/* Define a function called NopFree that takes a pointer as input and does nothing with it.\n   >>> NopFree(void* unused) *\/"
    }

    {
        "file_name":"ImageSize_function_2.cpp",
        "line_count":6,
        "code":"Value toJSI(jsi::Runtime& runtime, const ImageSize& arg) {\n      jsi::Object obj(runtime);\n      obj.setProperty(runtime, \"width\", JSIConverter<double>::toJSI(runtime, arg.width));\n      obj.setProperty(runtime, \"height\", JSIConverter<double>::toJSI(runtime, arg.height));\n      return obj;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Create a JSI object representing an image size with width and height properties.\n   >>> Value toJSI(jsi::Runtime& runtime, const ImageSize& arg) { *\/",
        "query_nlx":"        \/* Function named toJSI takes a runtime and an ImageSize argument and converts it into a JavaScript Object with 'width' and 'height' properties.\n        >>> toJSI(jsi::Runtime& runtime, const ImageSize& arg) returns a JavaScript Object with 'width' and 'height' properties set based on the values from the ImageSize argument *\/"
    }

    {
        "file_name":"ImageSize_function_3.cpp",
        "line_count":9,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isObject()) {\n        return false;\n      }\n      jsi::Object obj = value.getObject(runtime);\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"width\"))) return false;\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"height\"))) return false;\n      return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the given object contains properties \"width\" and \"height\" that can be converted to double values.\n>>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"        \/* Function named canConvert checks if a given object contains properties \"width\" and \"height\" that can be converted to double values.\n        >>> canConvert(runtime, value) true\n        >>> canConvert(runtime, value) false *\/ \n        bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {"
    }

    {
        "file_name":"ImageViewer_function_1.cpp",
        "line_count":6,
        "code":"void KillImageBitmaps()\n{\n\tif (g_hBitmapFull)    delete g_hBitmapFull;\n\tif (g_hBitmapPreview) delete g_hBitmapPreview;\n\tg_hBitmapFull = g_hBitmapPreview = NULL;\n}",
        "mark":8.0,
        "query_nsx":"\/* Release memory allocated for image bitmaps.\n   >>> KillImageBitmaps() *\/ \nvoid KillImageBitmaps() {",
        "query_nlx":"\/* Define a function that deallocates memory for two image bitmaps if they exist and sets their pointers to NULL.\n>>> KillImageBitmaps() *\/ \nvoid KillImageBitmaps() {  \/\/ Function signature."
    }

    {
        "file_name":"ImageViewer_function_12.cpp",
        "line_count":9,
        "code":"void KillImageViewer()\n{\n\tif (!g_ivHwnd)\n\t\treturn;\n\n\tDestroyWindow(g_ivHwnd);\n\tg_ivHwnd = NULL;\n\tg_ivChildHwnd = NULL;\n}",
        "mark":8.0,
        "query_nsx":"\/* Close the image viewer window if it is currently open.\n   >>> KillImageViewer() *\/",
        "query_nlx":"\/* Function named KillImageViewer defines a procedure to close the image viewer window if it is currently open.\n>>> KillImageViewer() closes the image viewer window and resets the window handles to NULL if the image viewer window is currently open. *\/ \nvoid KillImageViewer() { "
    }

    {
        "file_name":"ImageViewer_function_13.cpp",
        "line_count":5,
        "code":"void ImageViewerFinishSaveIfNeeded()\n{\n\tif (g_ivHwnd)\n\t\tSendMessage(g_ivHwnd, WM_IMAGESAVED, 0, 0);\n}",
        "mark":8.0,
        "query_nsx":"\/* Notify the image viewer window that the image has been saved.\n   >>> ImageViewerFinishSaveIfNeeded() *\/",
        "query_nlx":"\/* Function named ImageViewerFinishSaveIfNeeded sends a message to the image viewer window handle if it exists.\n>>> ImageViewerFinishSaveIfNeeded() *\/"
    }

    {
        "file_name":"ImageViewer_function_14.cpp",
        "line_count":5,
        "code":"void ImageViewerClearSaveIfNeeded()\n{\n\tif (g_ivHwnd)\n\t\tSendMessage(g_ivHwnd, WM_IMAGECLEARSAVE, 0, 0);\n}",
        "mark":8.0,
        "query_nsx":"\/* Clear any saved image data in the image viewer window if it exists.\n>>> ImageViewerClearSaveIfNeeded() *\/",
        "query_nlx":"\/* Function named ImageViewerClearSaveIfNeeded sends a message to clear any saved image in the image viewer window if the window handle is valid.\n>>> ImageViewerClearSaveIfNeeded() *\/"
    }

    {
        "file_name":"ImageViewer_function_4.cpp",
        "line_count":4,
        "code":"bool ImageViewerNeedScrollBars(int winWidth, int winHeight)\n{\n\treturn g_bChildZoomedIn && (g_ivWidth != winWidth || g_ivHeight != winHeight);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the image viewer needs scroll bars based on the window dimensions and zoom level.\n>>> bool ImageViewerNeedScrollBars(int winWidth, int winHeight) *\/",
        "query_nlx":"\/* Determine if the image viewer needs scroll bars based on whether the child is zoomed in and if the image viewer width or height does not match the window width or height.\n>>> ImageViewerNeedScrollBars(800, 600) true\n>>> ImageViewerNeedScrollBars(1024, 768) false *\/ \nbool ImageViewerNeedScrollBars(int winWidth, int winHeight) {"
    }

    {
        "file_name":"ImageViewer_function_8.cpp",
        "line_count":4,
        "code":"void ImageViewerOnLoadNT(NetRequest* pRequest)\n{\n\tSendMessage(g_ivHwnd, WM_REQUESTDONE, 0, (LPARAM)pRequest);\n}",
        "mark":8.0,
        "query_nsx":"\/* Send a message to the image viewer window when a network request is completed.\n>>> void ImageViewerOnLoadNT(NetRequest* pRequest) *\/",
        "query_nlx":"\/* Function named ImageViewerOnLoadNT sends a message to a specified window handle indicating that a network request has been completed.\n>>> ImageViewerOnLoadNT(NetRequest* pRequest) *\/"
    }

    {
        "file_name":"ImguiSpdLog_function_2.cpp",
        "line_count":13,
        "code":"void ClearLogBuffers(IN bool DisableLock = false)\n\t{\n\t\tif (!DisableLock)\n\t\t\tsink_t::mutex_.lock();\n\n\t\tLoggedContent.clear();\n\t\tLogMetaData.clear();\n\t\tNumberOfLogEntries = 0;\n\t\tIndicesInBytes = 0;\n\n\t\tif (!DisableLock)\n\t\t\tsink_t::mutex_.unlock();\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Clear log buffers by resetting logged content, metadata, and log entry counts with optional locking mechanism.\n>>> ClearLogBuffers(IN bool DisableLock = false) *\/",
        "query_nlx":"\n\/* Define a function that clears the log buffers, optionally disabling the lock mechanism.\n>>> ClearLogBuffers(IN bool DisableLock = false) *\/"
    }

    {
        "file_name":"imgui_common_function_1.cpp",
        "line_count":1,
        "code":"void Dx11Inited() { _dx11Ready = true; }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to indicate that the DirectX 11 initialization process has been completed. \n>>> Dx11Inited() *\/ \nvoid Dx11Inited();",
        "query_nlx":"\/* Function named Dx11Inited sets a boolean variable to true to indicate that the DirectX 11 initialization process has been completed successfully. \n>>> Dx11Inited() *\/ \nvoid Dx11Inited() { "
    }

    {
        "file_name":"imgui_common_function_2.cpp",
        "line_count":1,
        "code":"void Dx12Inited() { _dx12Ready = true; }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to indicate that the DirectX 12 initialization process has been completed.\n>>> Dx12Inited() *\/ \nvoid Dx12Inited();",
        "query_nlx":"\/* Function named Dx12Inited sets a flag to indicate that the DirectX 12 initialization process has been completed successfully. \n>>> Dx12Inited() *\/ \nvoid Dx12Inited() { "
    }

    {
        "file_name":"imgui_common_function_3.cpp",
        "line_count":1,
        "code":"void VulkanInited() { _vulkanReady = true; }",
        "mark":8.0,
        "query_nsx":"\/* Indicate that Vulkan initialization process has been completed successfully.\n   >>> VulkanInited() *\/ \nvoid VulkanInited();",
        "query_nlx":"\/* Function named VulkanInited sets a flag to indicate that Vulkan has been initialized.\n>>> VulkanInited() void *\/"
    }

    {
        "file_name":"imgui_common_function_4.cpp",
        "line_count":1,
        "code":"bool IsInited() { return _isInited; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the initialization status is true or false.\n>>> IsInited() bool *\/",
        "query_nlx":"\/* Function named IsInited checks if a certain variable representing initialization status is true or false.\n   >>> IsInited() true\n   >>> IsInited() false *\/ \nbool IsInited() { "
    }

    {
        "file_name":"imgui_common_function_5.cpp",
        "line_count":1,
        "code":"bool IsVisible() { return _isVisible; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the object is currently visible or not.\n>>> IsVisible() true\n>>> IsVisible() false *\/ \nbool IsVisible() { ",
        "query_nlx":"\/* Function named IsVisible checks if a certain property indicating visibility is true or false.\n>>> IsVisible() true\n>>> IsVisible() false *\/ \nbool IsVisible() {"
    }

    {
        "file_name":"imgui_common_function_6.cpp",
        "line_count":1,
        "code":"bool IsResetRequested() { return _isResetRequested; }",
        "mark":9.0,
        "query_nsx":"\/* Determine if a reset request is currently pending.\n   >>> IsResetRequested() true\n   >>> IsResetRequested() false *\/ \nbool IsResetRequested() { ",
        "query_nlx":"\/* Function named IsResetRequested checks if a reset request is currently active.\n   >>> IsResetRequested() true\n   >>> IsResetRequested() false *\/ \nbool IsResetRequested() { "
    }

    {
        "file_name":"imgui_common_function_7.cpp",
        "line_count":1,
        "code":"HWND Handle() { return _handle; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the handle value associated with a specific object.\n   >>> Handle() HWND *\/",
        "query_nlx":"\/* Function named Handle returns a handle value that represents a window or object in the system.\n   >>> Handle() _handle *\/"
    }

    {
        "file_name":"imgui_demo_function_1.cpp",
        "line_count":11,
        "code":"void HelpMarker(const char* desc)\n{\n    ImGui::TextDisabled(\"(?)\");\n    if (ImGui::BeginItemTooltip())\n    {\n        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);\n        ImGui::TextUnformatted(desc);\n        ImGui::PopTextWrapPos();\n        ImGui::EndTooltip();\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Display a help marker with a tooltip containing a description when activated.\n>>> HelpMarker(const char* desc) *\/",
        "query_nlx":"\/* Create a function called HelpMarker that displays a tooltip with a description when a user hovers over a help icon.\n   >>> HelpMarker(\"This function displays a tooltip with the provided description when hovered over.\") *\/ \nvoid HelpMarker(const char* desc) { "
    }

    {
        "file_name":"imgui_demo_function_103.cpp",
        "line_count":9,
        "code":"void NotifyOfDocumentsClosedElsewhere()\n    {\n        for (MyDocument& doc : Documents)\n        {\n            if (!doc.Open && doc.OpenPrev)\n                ImGui::SetTabItemClosed(doc.Name);\n            doc.OpenPrev = doc.Open;\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Notify if any documents have been closed elsewhere based on their open status.\n>>> void NotifyOfDocumentsClosedElsewhere() { *\/",
        "query_nlx":"        \/* Function named NotifyOfDocumentsClosedElsewhere iterates through a collection of documents and notifies if any document was closed elsewhere since the last check. \n        >>> NotifyOfDocumentsClosedElsewhere() *\/ \n        void NotifyOfDocumentsClosedElsewhere() {"
    }

    {
        "file_name":"imgui_demo_function_112.cpp",
        "line_count":5,
        "code":"void ClearItems()\n    {\n        Items.clear();\n        Selection.Clear();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Clear all items in a collection and reset the selection.\n   >>> ClearItems() *\/ \nvoid ClearItems();",
        "query_nlx":"        \/* Function named ClearItems clears all items in a collection and resets the selection.\n        >>> ClearItems() *\/ \n        void ClearItems() {"
    }

    {
        "file_name":"imgui_demo_function_117.cpp",
        "line_count":6,
        "code":"void ShowExampleAppAssetsBrowser(bool* p_open)\n{\n    IMGUI_DEMO_MARKER(\"Examples\/Assets Browser\");\n    static ExampleAssetsBrowser assets_browser;\n    assets_browser.Draw(\"Example: Assets Browser\", p_open);\n}",
        "mark":8.0,
        "query_nsx":"\/* Display an example assets browser interface that allows users to browse assets.\n   >>> ShowExampleAppAssetsBrowser(bool* p_open) *\/",
        "query_nlx":"\/* Query: Define a function that displays an example assets browser interface and takes a boolean pointer as input to control its visibility.\n   >>> ShowExampleAppAssetsBrowser(bool* p_open) *\/\n\nvoid ShowExampleAppAssetsBrowser(bool* p_open) {"
    }

    {
        "file_name":"imgui_demo_function_13.cpp",
        "line_count":11,
        "code":"int MyResizeCallback(ImGuiInputTextCallbackData* data)\n                {\n                    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)\n                    {\n                        ImVector<char>* my_str = (ImVector<char>*)data->UserData;\n                        IM_ASSERT(my_str->begin() == data->Buf);\n                        my_str->resize(data->BufSize); \/\/ NB: On resizing calls, generally data->BufSize == data->BufTextLen + 1\n                        data->Buf = my_str->begin();\n                    }\n                    return 0;\n                }",
        "mark":8.0,
        "query_nsx":"\/* Resize the input text buffer when a specific event flag is triggered.\n   >>> MyResizeCallback(ImGuiInputTextCallbackData* data) *\/",
        "query_nlx":"\/* Function named MyResizeCallback that resizes a given string buffer based on input text callback data.\n   >>> MyResizeCallback(data) resizes the string buffer stored in data to match the input text length + 1\n   >>> MyResizeCallback(data) returns 0 after resizing the string buffer *\/\nint MyResizeCallback(ImGuiInputTextCallbackData* data) { *\/"
    }

    {
        "file_name":"imgui_demo_function_2.cpp",
        "line_count":63,
        "code":"void ShowDemoWindowMenuBar(ImGuiDemoWindowData* demo_data)\n{\n    IMGUI_DEMO_MARKER(\"Menu\");\n    if (ImGui::BeginMenuBar())\n    {\n        if (ImGui::BeginMenu(\"Menu\"))\n        {\n            IMGUI_DEMO_MARKER(\"Menu\/File\");\n            ShowExampleMenuFile();\n            ImGui::EndMenu();\n        }\n        if (ImGui::BeginMenu(\"Examples\"))\n        {\n            IMGUI_DEMO_MARKER(\"Menu\/Examples\");\n            ImGui::MenuItem(\"Main menu bar\", NULL, &demo_data->ShowMainMenuBar);\n\n            ImGui::SeparatorText(\"Mini apps\");\n            ImGui::MenuItem(\"Assets Browser\", NULL, &demo_data->ShowAppAssetsBrowser);\n            ImGui::MenuItem(\"Console\", NULL, &demo_data->ShowAppConsole);\n            ImGui::MenuItem(\"Custom rendering\", NULL, &demo_data->ShowAppCustomRendering);\n            ImGui::MenuItem(\"Documents\", NULL, &demo_data->ShowAppDocuments);\n            ImGui::MenuItem(\"Log\", NULL, &demo_data->ShowAppLog);\n            ImGui::MenuItem(\"Property editor\", NULL, &demo_data->ShowAppPropertyEditor);\n            ImGui::MenuItem(\"Simple layout\", NULL, &demo_data->ShowAppLayout);\n            ImGui::MenuItem(\"Simple overlay\", NULL, &demo_data->ShowAppSimpleOverlay);\n\n            ImGui::SeparatorText(\"Concepts\");\n            ImGui::MenuItem(\"Auto-resizing window\", NULL, &demo_data->ShowAppAutoResize);\n            ImGui::MenuItem(\"Constrained-resizing window\", NULL, &demo_data->ShowAppConstrainedResize);\n            ImGui::MenuItem(\"Fullscreen window\", NULL, &demo_data->ShowAppFullscreen);\n            ImGui::MenuItem(\"Long text display\", NULL, &demo_data->ShowAppLongText);\n            ImGui::MenuItem(\"Manipulating window titles\", NULL, &demo_data->ShowAppWindowTitles);\n\n            ImGui::EndMenu();\n        }\n        \/\/if (ImGui::MenuItem(\"MenuItem\")) {} \/\/ You can also use MenuItem() inside a menu bar!\n        if (ImGui::BeginMenu(\"Tools\"))\n        {\n            IMGUI_DEMO_MARKER(\"Menu\/Tools\");\n            ImGuiIO& io = ImGui::GetIO();\n#ifndef IMGUI_DISABLE_DEBUG_TOOLS\n            const bool has_debug_tools = true;\n#else\n            const bool has_debug_tools = false;\n#endif\n            ImGui::MenuItem(\"Metrics\/Debugger\", NULL, &demo_data->ShowMetrics, has_debug_tools);\n            ImGui::MenuItem(\"Debug Log\", NULL, &demo_data->ShowDebugLog, has_debug_tools);\n            ImGui::MenuItem(\"ID Stack Tool\", NULL, &demo_data->ShowIDStackTool, has_debug_tools);\n            bool is_debugger_present = io.ConfigDebugIsDebuggerPresent;\n            if (ImGui::MenuItem(\"Item Picker\", NULL, false, has_debug_tools && is_debugger_present))\n                ImGui::DebugStartItemPicker();\n            if (!is_debugger_present)\n                ImGui::SetItemTooltip(\"Requires io.ConfigDebugIsDebuggerPresent=true to be set.\\n\\nWe otherwise disable the menu option to avoid casual users crashing the application.\\n\\nYou can however always access the Item Picker in Metrics->Tools.\");\n            ImGui::MenuItem(\"Style Editor\", NULL, &demo_data->ShowStyleEditor);\n            ImGui::MenuItem(\"About Dear ImGui\", NULL, &demo_data->ShowAbout);\n\n            ImGui::SeparatorText(\"Debug Options\");\n            ImGui::MenuItem(\"Highlight ID Conflicts\", NULL, &io.ConfigDebugHighlightIdConflicts, has_debug_tools);\n            ImGui::EndMenu();\n        }\n        ImGui::EndMenuBar();\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Display a demo window with a menu bar containing various options for examples, tools, and debug options.\n>>> ShowDemoWindowMenuBar(ImGuiDemoWindowData* demo_data) *\/",
        "query_nlx":"\/* Function named ShowDemoWindowMenuBar displays a menu bar with various options including 'Menu', 'Examples', and 'Tools'. \n   It allows the user to interact with different functionalities like opening files, displaying mini apps, and accessing debug tools. \n   The function takes an ImGuiDemoWindowData pointer as a parameter. \n   The menu bar contains submenus with specific actions and options related to each category. \n   The user can navigate through the menu bar to access different features and tools. *\/ \nvoid ShowDemoWindowMenuBar(ImGuiDemoWindowData* demo_data) { "
    }

    {
        "file_name":"imgui_demo_function_45.cpp",
        "line_count":297,
        "code":"void ShowDemoWindowPopups()\n{\n    IMGUI_DEMO_MARKER(\"Popups\");\n    if (!ImGui::CollapsingHeader(\"Popups & Modal windows\"))\n        return;\n\n    \/\/ The properties of popups windows are:\n    \/\/ - They block normal mouse hovering detection outside them. (*)\n    \/\/ - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.\n    \/\/ - Their visibility state (~bool) is held internally by Dear ImGui instead of being held by the programmer as\n    \/\/   we are used to with regular Begin() calls. User can manipulate the visibility state by calling OpenPopup().\n    \/\/ (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even\n    \/\/     when normally blocked by a popup.\n    \/\/ Those three properties are connected. The library needs to hold their visibility state BECAUSE it can close\n    \/\/ popups at any time.\n\n    \/\/ Typical use for regular windows:\n    \/\/   bool my_tool_is_active = false; if (ImGui::Button(\"Open\")) my_tool_is_active = true; [...] if (my_tool_is_active) Begin(\"My Tool\", &my_tool_is_active) { [...] } End();\n    \/\/ Typical use for popups:\n    \/\/   if (ImGui::Button(\"Open\")) ImGui::OpenPopup(\"MyPopup\"); if (ImGui::BeginPopup(\"MyPopup\") { [...] EndPopup(); }\n\n    \/\/ With popups we have to go through a library call (here OpenPopup) to manipulate the visibility state.\n    \/\/ This may be a bit confusing at first but it should quickly make sense. Follow on the examples below.\n\n    IMGUI_DEMO_MARKER(\"Popups\/Popups\");\n    if (ImGui::TreeNode(\"Popups\"))\n    {\n        ImGui::TextWrapped(\n            \"When a popup is active, it inhibits interacting with windows that are behind the popup. \"\n            \"Clicking outside the popup closes it.\");\n\n        static int selected_fish = -1;\n        const char* names[] = { \"Bream\", \"Haddock\", \"Mackerel\", \"Pollock\", \"Tilefish\" };\n        static bool toggles[] = { true, false, false, false, false };\n\n        \/\/ Simple selection popup (if you want to show the current selection inside the Button itself,\n        \/\/ you may want to build a string using the \"###\" operator to preserve a constant ID with a variable label)\n        if (ImGui::Button(\"Select..\"))\n            ImGui::OpenPopup(\"my_select_popup\");\n        ImGui::SameLine();\n        ImGui::TextUnformatted(selected_fish == -1 ? \"<None>\" : names[selected_fish]);\n        if (ImGui::BeginPopup(\"my_select_popup\"))\n        {\n            ImGui::SeparatorText(\"Aquarium\");\n            for (int i = 0; i < IM_ARRAYSIZE(names); i++)\n                if (ImGui::Selectable(names[i]))\n                    selected_fish = i;\n            ImGui::EndPopup();\n        }\n\n        \/\/ Showing a menu with toggles\n        if (ImGui::Button(\"Toggle..\"))\n            ImGui::OpenPopup(\"my_toggle_popup\");\n        if (ImGui::BeginPopup(\"my_toggle_popup\"))\n        {\n            for (int i = 0; i < IM_ARRAYSIZE(names); i++)\n                ImGui::MenuItem(names[i], \"\", &toggles[i]);\n            if (ImGui::BeginMenu(\"Sub-menu\"))\n            {\n                ImGui::MenuItem(\"Click me\");\n                ImGui::EndMenu();\n            }\n\n            ImGui::Separator();\n            ImGui::Text(\"Tooltip here\");\n            ImGui::SetItemTooltip(\"I am a tooltip over a popup\");\n\n            if (ImGui::Button(\"Stacked Popup\"))\n                ImGui::OpenPopup(\"another popup\");\n            if (ImGui::BeginPopup(\"another popup\"))\n            {\n                for (int i = 0; i < IM_ARRAYSIZE(names); i++)\n                    ImGui::MenuItem(names[i], \"\", &toggles[i]);\n                if (ImGui::BeginMenu(\"Sub-menu\"))\n                {\n                    ImGui::MenuItem(\"Click me\");\n                    if (ImGui::Button(\"Stacked Popup\"))\n                        ImGui::OpenPopup(\"another popup\");\n                    if (ImGui::BeginPopup(\"another popup\"))\n                    {\n                        ImGui::Text(\"I am the last one here.\");\n                        ImGui::EndPopup();\n                    }\n                    ImGui::EndMenu();\n                }\n                ImGui::EndPopup();\n            }\n            ImGui::EndPopup();\n        }\n\n        \/\/ Call the more complete ShowExampleMenuFile which we use in various places of this demo\n        if (ImGui::Button(\"With a menu..\"))\n            ImGui::OpenPopup(\"my_file_popup\");\n        if (ImGui::BeginPopup(\"my_file_popup\", ImGuiWindowFlags_MenuBar))\n        {\n            if (ImGui::BeginMenuBar())\n            {\n                if (ImGui::BeginMenu(\"File\"))\n                {\n                    ShowExampleMenuFile();\n                    ImGui::EndMenu();\n                }\n                if (ImGui::BeginMenu(\"Edit\"))\n                {\n                    ImGui::MenuItem(\"Dummy\");\n                    ImGui::EndMenu();\n                }\n                ImGui::EndMenuBar();\n            }\n            ImGui::Text(\"Hello from popup!\");\n            ImGui::Button(\"This is a dummy button..\");\n            ImGui::EndPopup();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Popups\/Context menus\");\n    if (ImGui::TreeNode(\"Context menus\"))\n    {\n        HelpMarker(\"\\\"Context\\\" functions are simple helpers to associate a Popup to a given Item or Window identifier.\");\n\n        \/\/ BeginPopupContextItem() is a helper to provide common\/simple popup behavior of essentially doing:\n        \/\/     if (id == 0)\n        \/\/         id = GetItemID(); \/\/ Use last item id\n        \/\/     if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))\n        \/\/         OpenPopup(id);\n        \/\/     return BeginPopup(id);\n        \/\/ For advanced uses you may want to replicate and customize this code.\n        \/\/ See more details in BeginPopupContextItem().\n\n        \/\/ Example 1\n        \/\/ When used after an item that has an ID (e.g. Button), we can skip providing an ID to BeginPopupContextItem(),\n        \/\/ and BeginPopupContextItem() will use the last item ID as the popup ID.\n        {\n            const char* names[5] = { \"Label1\", \"Label2\", \"Label3\", \"Label4\", \"Label5\" };\n            static int selected = -1;\n            for (int n = 0; n < 5; n++)\n            {\n                if (ImGui::Selectable(names[n], selected == n))\n                    selected = n;\n                if (ImGui::BeginPopupContextItem()) \/\/ <-- use last item id as popup id\n                {\n                    selected = n;\n                    ImGui::Text(\"This a popup for \\\"%s\\\"!\", names[n]);\n                    if (ImGui::Button(\"Close\"))\n                        ImGui::CloseCurrentPopup();\n                    ImGui::EndPopup();\n                }\n                ImGui::SetItemTooltip(\"Right-click to open popup\");\n            }\n        }\n\n        \/\/ Example 2\n        \/\/ Popup on a Text() element which doesn't have an identifier: we need to provide an identifier to BeginPopupContextItem().\n        \/\/ Using an explicit identifier is also convenient if you want to activate the popups from different locations.\n        {\n            HelpMarker(\"Text() elements don't have stable identifiers so we need to provide one.\");\n            static float value = 0.5f;\n            ImGui::Text(\"Value = %.3f <-- (1) right-click this text\", value);\n            if (ImGui::BeginPopupContextItem(\"my popup\"))\n            {\n                if (ImGui::Selectable(\"Set to zero\")) value = 0.0f;\n                if (ImGui::Selectable(\"Set to PI\")) value = 3.1415f;\n                ImGui::SetNextItemWidth(-FLT_MIN);\n                ImGui::DragFloat(\"##Value\", &value, 0.1f, 0.0f, 0.0f);\n                ImGui::EndPopup();\n            }\n\n            \/\/ We can also use OpenPopupOnItemClick() to toggle the visibility of a given popup.\n            \/\/ Here we make it that right-clicking this other text element opens the same popup as above.\n            \/\/ The popup itself will be submitted by the code above.\n            ImGui::Text(\"(2) Or right-click this text\");\n            ImGui::OpenPopupOnItemClick(\"my popup\", ImGuiPopupFlags_MouseButtonRight);\n\n            \/\/ Back to square one: manually open the same popup.\n            if (ImGui::Button(\"(3) Or click this button\"))\n                ImGui::OpenPopup(\"my popup\");\n        }\n\n        \/\/ Example 3\n        \/\/ When using BeginPopupContextItem() with an implicit identifier (NULL == use last item ID),\n        \/\/ we need to make sure your item identifier is stable.\n        \/\/ In this example we showcase altering the item label while preserving its identifier, using the ### operator (see FAQ).\n        {\n            HelpMarker(\"Showcase using a popup ID linked to item ID, with the item having a changing label + stable ID using the ### operator.\");\n            static char name[32] = \"Label1\";\n            char buf[64];\n            sprintf(buf, \"Button: %s###Button\", name); \/\/ ### operator override ID ignoring the preceding label\n            ImGui::Button(buf);\n            if (ImGui::BeginPopupContextItem())\n            {\n                ImGui::Text(\"Edit name:\");\n                ImGui::InputText(\"##edit\", name, IM_ARRAYSIZE(name));\n                if (ImGui::Button(\"Close\"))\n                    ImGui::CloseCurrentPopup();\n                ImGui::EndPopup();\n            }\n            ImGui::SameLine(); ImGui::Text(\"(<-- right-click here)\");\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Popups\/Modals\");\n    if (ImGui::TreeNode(\"Modals\"))\n    {\n        ImGui::TextWrapped(\"Modal windows are like popups but the user cannot close them by clicking outside.\");\n\n        if (ImGui::Button(\"Delete..\"))\n            ImGui::OpenPopup(\"Delete?\");\n\n        \/\/ Always center this window when appearing\n        ImVec2 center = ImGui::GetMainViewport()->GetCenter();\n        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));\n\n        if (ImGui::BeginPopupModal(\"Delete?\", NULL, ImGuiWindowFlags_AlwaysAutoResize))\n        {\n            ImGui::Text(\"All those beautiful files will be deleted.\\nThis operation cannot be undone!\");\n            ImGui::Separator();\n\n            \/\/static int unused_i = 0;\n            \/\/ImGui::Combo(\"Combo\", &unused_i, \"Delete\\0Delete harder\\0\");\n\n            static bool dont_ask_me_next_time = false;\n            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));\n            ImGui::Checkbox(\"Don't ask me next time\", &dont_ask_me_next_time);\n            ImGui::PopStyleVar();\n\n            if (ImGui::Button(\"OK\", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }\n            ImGui::SetItemDefaultFocus();\n            ImGui::SameLine();\n            if (ImGui::Button(\"Cancel\", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }\n            ImGui::EndPopup();\n        }\n\n        if (ImGui::Button(\"Stacked modals..\"))\n            ImGui::OpenPopup(\"Stacked 1\");\n        if (ImGui::BeginPopupModal(\"Stacked 1\", NULL, ImGuiWindowFlags_MenuBar))\n        {\n            if (ImGui::BeginMenuBar())\n            {\n                if (ImGui::BeginMenu(\"File\"))\n                {\n                    if (ImGui::MenuItem(\"Some menu item\")) {}\n                    ImGui::EndMenu();\n                }\n                ImGui::EndMenuBar();\n            }\n            ImGui::Text(\"Hello from Stacked The First\\nUsing style.Colors[ImGuiCol_ModalWindowDimBg] behind it.\");\n\n            \/\/ Testing behavior of widgets stacking their own regular popups over the modal.\n            static int item = 1;\n            static float color[4] = { 0.4f, 0.7f, 0.0f, 0.5f };\n            ImGui::Combo(\"Combo\", &item, \"aaaa\\0bbbb\\0cccc\\0dddd\\0eeee\\0\\0\");\n            ImGui::ColorEdit4(\"Color\", color);\n\n            if (ImGui::Button(\"Add another modal..\"))\n                ImGui::OpenPopup(\"Stacked 2\");\n\n            \/\/ Also demonstrate passing a bool* to BeginPopupModal(), this will create a regular close button which\n            \/\/ will close the popup. Note that the visibility state of popups is owned by imgui, so the input value\n            \/\/ of the bool actually doesn't matter here.\n            bool unused_open = true;\n            if (ImGui::BeginPopupModal(\"Stacked 2\", &unused_open))\n            {\n                ImGui::Text(\"Hello from Stacked The Second!\");\n                ImGui::ColorEdit4(\"Color\", color); \/\/ Allow opening another nested popup\n                if (ImGui::Button(\"Close\"))\n                    ImGui::CloseCurrentPopup();\n                ImGui::EndPopup();\n            }\n\n            if (ImGui::Button(\"Close\"))\n                ImGui::CloseCurrentPopup();\n            ImGui::EndPopup();\n        }\n\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Popups\/Menus inside a regular window\");\n    if (ImGui::TreeNode(\"Menus inside a regular window\"))\n    {\n        ImGui::TextWrapped(\"Below we are testing adding menu items to a regular window. It's rather unusual but should work!\");\n        ImGui::Separator();\n\n        ImGui::MenuItem(\"Menu item\", \"CTRL+M\");\n        if (ImGui::BeginMenu(\"Menu inside a regular window\"))\n        {\n            ShowExampleMenuFile();\n            ImGui::EndMenu();\n        }\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n}",
        "mark":8.5,
        "query_nsx":"\/* Describe a function that demonstrates the usage of popups, modal windows, and context menus in a graphical user interface.\n   >>> ShowDemoWindowPopups() *\/",
        "query_nlx":"\/* Generate a demo window showcasing popups, modal windows, and menus inside a regular window.\n   >>> ShowDemoWindowPopups() *\/ \nvoid ShowDemoWindowPopups() { \n    \/\/ Function body is omitted for brevity \n}"
    }

    {
        "file_name":"imgui_demo_function_49.cpp",
        "line_count":4,
        "code":"void PopStyleCompact()\n{\n    ImGui::PopStyleVar(2);\n}",
        "mark":8.0,
        "query_nsx":"\/* Remove two style variables from the current style stack.\n   >>> PopStyleCompact() *\/ \nvoid PopStyleCompact(){",
        "query_nlx":"\/* Function named PopStyleCompact removes the last two style variable changes made in the user interface.\n>>> PopStyleCompact() removes the last two style variable changes in the interface. *\/ \nvoid PopStyleCompact() { "
    }

    {
        "file_name":"imgui_demo_function_52.cpp",
        "line_count":7,
        "code":"void ShowTableColumnsStatusFlags(ImGuiTableColumnFlags flags)\n{\n    ImGui::CheckboxFlags(\"_IsEnabled\", &flags, ImGuiTableColumnFlags_IsEnabled);\n    ImGui::CheckboxFlags(\"_IsVisible\", &flags, ImGuiTableColumnFlags_IsVisible);\n    ImGui::CheckboxFlags(\"_IsSorted\", &flags, ImGuiTableColumnFlags_IsSorted);\n    ImGui::CheckboxFlags(\"_IsHovered\", &flags, ImGuiTableColumnFlags_IsHovered);\n}",
        "mark":8.0,
        "query_nsx":"\/* Check and display the status flags of a table column such as enabled, visible, sorted, and hovered.\n>>> ShowTableColumnsStatusFlags(ImGuiTableColumnFlags flags) *\/",
        "query_nlx":"\/* Define a function called ShowTableColumnsStatusFlags that takes in a set of flags representing the status of table columns and displays checkboxes for each status flag: IsEnabled, IsVisible, IsSorted, and IsHovered.\n   >>> ShowTableColumnsStatusFlags(ImGuiTableColumnFlags flags) *\/"
    }

    {
        "file_name":"imgui_demo_function_59.cpp",
        "line_count":205,
        "code":"void ShowDemoWindowColumns()\n{\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\");\n    bool open = ImGui::TreeNode(\"Legacy Columns API\");\n    ImGui::SameLine();\n    HelpMarker(\"Columns() is an old API! Prefer using the more flexible and powerful BeginTable() API!\");\n    if (!open)\n        return;\n\n    \/\/ Basic columns\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Basic\");\n    if (ImGui::TreeNode(\"Basic\"))\n    {\n        ImGui::Text(\"Without border:\");\n        ImGui::Columns(3, \"mycolumns3\", false);  \/\/ 3-ways, no border\n        ImGui::Separator();\n        for (int n = 0; n < 14; n++)\n        {\n            char label[32];\n            sprintf(label, \"Item %d\", n);\n            if (ImGui::Selectable(label)) {}\n            \/\/if (ImGui::Button(label, ImVec2(-FLT_MIN,0.0f))) {}\n            ImGui::NextColumn();\n        }\n        ImGui::Columns(1);\n        ImGui::Separator();\n\n        ImGui::Text(\"With border:\");\n        ImGui::Columns(4, \"mycolumns\"); \/\/ 4-ways, with border\n        ImGui::Separator();\n        ImGui::Text(\"ID\"); ImGui::NextColumn();\n        ImGui::Text(\"Name\"); ImGui::NextColumn();\n        ImGui::Text(\"Path\"); ImGui::NextColumn();\n        ImGui::Text(\"Hovered\"); ImGui::NextColumn();\n        ImGui::Separator();\n        const char* names[3] = { \"One\", \"Two\", \"Three\" };\n        const char* paths[3] = { \"\/path\/one\", \"\/path\/two\", \"\/path\/three\" };\n        static int selected = -1;\n        for (int i = 0; i < 3; i++)\n        {\n            char label[32];\n            sprintf(label, \"%04d\", i);\n            if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))\n                selected = i;\n            bool hovered = ImGui::IsItemHovered();\n            ImGui::NextColumn();\n            ImGui::Text(names[i]); ImGui::NextColumn();\n            ImGui::Text(paths[i]); ImGui::NextColumn();\n            ImGui::Text(\"%d\", hovered); ImGui::NextColumn();\n        }\n        ImGui::Columns(1);\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Borders\");\n    if (ImGui::TreeNode(\"Borders\"))\n    {\n        \/\/ NB: Future columns API should allow automatic horizontal borders.\n        static bool h_borders = true;\n        static bool v_borders = true;\n        static int columns_count = 4;\n        const int lines_count = 3;\n        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);\n        ImGui::DragInt(\"##columns_count\", &columns_count, 0.1f, 2, 10, \"%d columns\");\n        if (columns_count < 2)\n            columns_count = 2;\n        ImGui::SameLine();\n        ImGui::Checkbox(\"horizontal\", &h_borders);\n        ImGui::SameLine();\n        ImGui::Checkbox(\"vertical\", &v_borders);\n        ImGui::Columns(columns_count, NULL, v_borders);\n        for (int i = 0; i < columns_count * lines_count; i++)\n        {\n            if (h_borders && ImGui::GetColumnIndex() == 0)\n                ImGui::Separator();\n            ImGui::PushID(i);\n            ImGui::Text(\"%c%c%c\", 'a' + i, 'a' + i, 'a' + i);\n            ImGui::Text(\"Width %.2f\", ImGui::GetColumnWidth());\n            ImGui::Text(\"Avail %.2f\", ImGui::GetContentRegionAvail().x);\n            ImGui::Text(\"Offset %.2f\", ImGui::GetColumnOffset());\n            ImGui::Text(\"Long text that is likely to clip\");\n            ImGui::Button(\"Button\", ImVec2(-FLT_MIN, 0.0f));\n            ImGui::PopID();\n            ImGui::NextColumn();\n        }\n        ImGui::Columns(1);\n        if (h_borders)\n            ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    \/\/ Create multiple items in a same cell before switching to next column\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Mixed items\");\n    if (ImGui::TreeNode(\"Mixed items\"))\n    {\n        ImGui::Columns(3, \"mixed\");\n        ImGui::Separator();\n\n        ImGui::Text(\"Hello\");\n        ImGui::Button(\"Banana\");\n        ImGui::NextColumn();\n\n        ImGui::Text(\"ImGui\");\n        ImGui::Button(\"Apple\");\n        static float foo = 1.0f;\n        ImGui::InputFloat(\"red\", &foo, 0.05f, 0, \"%.3f\");\n        ImGui::Text(\"An extra line here.\");\n        ImGui::NextColumn();\n\n        ImGui::Text(\"Sailor\");\n        ImGui::Button(\"Corniflower\");\n        static float bar = 1.0f;\n        ImGui::InputFloat(\"blue\", &bar, 0.05f, 0, \"%.3f\");\n        ImGui::NextColumn();\n\n        if (ImGui::CollapsingHeader(\"Category A\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\n        if (ImGui::CollapsingHeader(\"Category B\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\n        if (ImGui::CollapsingHeader(\"Category C\")) { ImGui::Text(\"Blah blah blah\"); } ImGui::NextColumn();\n        ImGui::Columns(1);\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    \/\/ Word wrapping\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Word-wrapping\");\n    if (ImGui::TreeNode(\"Word-wrapping\"))\n    {\n        ImGui::Columns(2, \"word-wrapping\");\n        ImGui::Separator();\n        ImGui::TextWrapped(\"The quick brown fox jumps over the lazy dog.\");\n        ImGui::TextWrapped(\"Hello Left\");\n        ImGui::NextColumn();\n        ImGui::TextWrapped(\"The quick brown fox jumps over the lazy dog.\");\n        ImGui::TextWrapped(\"Hello Right\");\n        ImGui::Columns(1);\n        ImGui::Separator();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Horizontal Scrolling\");\n    if (ImGui::TreeNode(\"Horizontal Scrolling\"))\n    {\n        ImGui::SetNextWindowContentSize(ImVec2(1500.0f, 0.0f));\n        ImVec2 child_size = ImVec2(0, ImGui::GetFontSize() * 20.0f);\n        ImGui::BeginChild(\"##ScrollingRegion\", child_size, ImGuiChildFlags_None, ImGuiWindowFlags_HorizontalScrollbar);\n        ImGui::Columns(10);\n\n        \/\/ Also demonstrate using clipper for large vertical lists\n        int ITEMS_COUNT = 2000;\n        ImGuiListClipper clipper;\n        clipper.Begin(ITEMS_COUNT);\n        while (clipper.Step())\n        {\n            for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\n                for (int j = 0; j < 10; j++)\n                {\n                    ImGui::Text(\"Line %d Column %d...\", i, j);\n                    ImGui::NextColumn();\n                }\n        }\n        ImGui::Columns(1);\n        ImGui::EndChild();\n        ImGui::TreePop();\n    }\n\n    IMGUI_DEMO_MARKER(\"Columns (legacy API)\/Tree\");\n    if (ImGui::TreeNode(\"Tree\"))\n    {\n        ImGui::Columns(2, \"tree\", true);\n        for (int x = 0; x < 3; x++)\n        {\n            bool open1 = ImGui::TreeNode((void*)(intptr_t)x, \"Node%d\", x);\n            ImGui::NextColumn();\n            ImGui::Text(\"Node contents\");\n            ImGui::NextColumn();\n            if (open1)\n            {\n                for (int y = 0; y < 3; y++)\n                {\n                    bool open2 = ImGui::TreeNode((void*)(intptr_t)y, \"Node%d.%d\", x, y);\n                    ImGui::NextColumn();\n                    ImGui::Text(\"Node contents\");\n                    if (open2)\n                    {\n                        ImGui::Text(\"Even more contents\");\n                        if (ImGui::TreeNode(\"Tree in column\"))\n                        {\n                            ImGui::Text(\"The quick brown fox jumps over the lazy dog\");\n                            ImGui::TreePop();\n                        }\n                    }\n                    ImGui::NextColumn();\n                    if (open2)\n                        ImGui::TreePop();\n                }\n                ImGui::TreePop();\n            }\n        }\n        ImGui::Columns(1);\n        ImGui::TreePop();\n    }\n\n    ImGui::TreePop();\n}",
        "mark":8.0,
        "query_nsx":"\/* Display various column layouts and functionalities using legacy API.\n>>> ShowDemoWindowColumns() *\/",
        "query_nlx":"\/* Generate a demo window showcasing the usage of columns using the legacy API.\n   The window includes basic columns, columns with borders, columns with mixed items, word-wrapping, horizontal scrolling, and a tree structure.\n   >>> ShowDemoWindowColumns() *\/"
    }

    {
        "file_name":"imgui_demo_function_62.cpp",
        "line_count":1,
        "code":"bool IsLegacyNativeDupe(ImGuiKey key) { return key >= 0 && key < 512 && ImGui::GetIO().KeyMap[key] != -1; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a key input is a legacy native duplicate based on a specified range of values.\n>>> bool IsLegacyNativeDupe(ImGuiKey key) { *\/",
        "query_nlx":"\/* Function named IsLegacyNativeDupe checks if a given ImGuiKey value is within the range of 0 to 511 and if the corresponding key mapping in the ImGui input-output structure is not equal to -1. \n>>> IsLegacyNativeDupe(256) true \n>>> IsLegacyNativeDupe(700) false *\/ \nbool IsLegacyNativeDupe(ImGuiKey key) { "
    }

    {
        "file_name":"imgui_demo_function_63.cpp",
        "line_count":22,
        "code":"void ShowExampleAppMainMenuBar()\n{\n    if (ImGui::BeginMainMenuBar())\n    {\n        if (ImGui::BeginMenu(\"File\"))\n        {\n            ShowExampleMenuFile();\n            ImGui::EndMenu();\n        }\n        if (ImGui::BeginMenu(\"Edit\"))\n        {\n            if (ImGui::MenuItem(\"Undo\", \"CTRL+Z\")) {}\n            if (ImGui::MenuItem(\"Redo\", \"CTRL+Y\", false, false)) {}  \/\/ Disabled item\n            ImGui::Separator();\n            if (ImGui::MenuItem(\"Cut\", \"CTRL+X\")) {}\n            if (ImGui::MenuItem(\"Copy\", \"CTRL+C\")) {}\n            if (ImGui::MenuItem(\"Paste\", \"CTRL+V\")) {}\n            ImGui::EndMenu();\n        }\n        ImGui::EndMainMenuBar();\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Define a function that displays a main menu bar with options for 'File' and 'Edit'. \n   >>> ShowExampleAppMainMenuBar() *\/",
        "query_nlx":"        \/* Function named ShowExampleAppMainMenuBar defines a user interface menu bar with options for \"File\" and \"Edit\" menus. \n        >>> ShowExampleAppMainMenuBar() *\/"
    }

    {
        "file_name":"imgui_demo_function_71.cpp",
        "line_count":5,
        "code":"int TextEditCallbackStub(ImGuiInputTextCallbackData* data)\n    {\n        ExampleAppConsole* console = (ExampleAppConsole*)data->UserData;\n        return console->TextEditCallback(data);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Execute a text editing callback function using provided input text callback data.\n   >>> TextEditCallbackStub(ImGuiInputTextCallbackData* data) *\/",
        "query_nlx":"\/* Function named TextEditCallbackStub takes input text callback data and calls the TextEditCallback function of a console object associated with the user data.\n>>> TextEditCallbackStub(ImGuiInputTextCallbackData* data) *\/\nint TextEditCallbackStub(ImGuiInputTextCallbackData* data) { "
    }

    {
        "file_name":"imgui_demo_function_76.cpp",
        "line_count":6,
        "code":"void    Clear()\n    {\n        Buf.clear();\n        LineOffsets.clear();\n        LineOffsets.push_back(0);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Clear the buffer and line offsets, preparing for new data input.\n   >>> Clear() *\/ \nvoid Clear() {",
        "query_nlx":"\/* Define a function that clears the contents of a buffer and resets line offsets.\n   >>> Clear() *\/ \nvoid Clear() {"
    }

    {
        "file_name":"imgui_demo_function_86.cpp",
        "line_count":19,
        "code":"void ShowExampleAppAutoResize(bool* p_open)\n{\n    if (!ImGui::Begin(\"Example: Auto-resizing window\", p_open, ImGuiWindowFlags_AlwaysAutoResize))\n    {\n        ImGui::End();\n        return;\n    }\n    IMGUI_DEMO_MARKER(\"Examples\/Auto-resizing window\");\n\n    static int lines = 10;\n    ImGui::TextUnformatted(\n        \"Window will resize every-frame to the size of its content.\\n\"\n        \"Note that you probably don't want to query the window size to\\n\"\n        \"output your content because that would create a feedback loop.\");\n    ImGui::SliderInt(\"Number of lines\", &lines, 1, 20);\n    for (int i = 0; i < lines; i++)\n        ImGui::Text(\"%*sThis is line %d\", i * 4, \"\", i); \/\/ Pad with space to extend size horizontally\n    ImGui::End();\n}",
        "mark":8.0,
        "query_nsx":"\/* Display an example application with an auto-resizing window that adjusts its size based on content.\n   >>> ShowExampleAppAutoResize(bool* p_open) *\/",
        "query_nlx":"\/* Query: Define a function that displays an example application with an auto-resizing window that adjusts its size based on content. The window should contain text explaining its behavior and a slider to control the number of lines displayed. Each line should be numbered and padded with spaces to extend horizontally. \n   >>> ShowExampleAppAutoResize(bool* p_open) *\/"
    }

    {
        "file_name":"imgui_demo_function_89.cpp",
        "line_count":4,
        "code":"void Square(ImGuiSizeCallbackData* data)\n        {\n            data->DesiredSize.x = data->DesiredSize.y = IM_MAX(data->DesiredSize.x, data->DesiredSize.y);\n        }",
        "mark":8.0,
        "query_nsx":"\/* Set the size of a given element to be a square shape.\n>>> void Square(ImGuiSizeCallbackData* data){ *\/",
        "query_nlx":"\/* Function named Square updates the x and y components of the DesiredSize attribute in the provided ImGuiSizeCallbackData structure to be the maximum value between the current x and y components. \n>>> Square(ImGuiSizeCallbackData* data) *\/"
    }

    {
        "file_name":"imgui_demo_function_93.cpp",
        "line_count":30,
        "code":"void ShowExampleAppFullscreen(bool* p_open)\n{\n    static bool use_work_area = true;\n    static ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings;\n\n    \/\/ We demonstrate using the full viewport area or the work area (without menu-bars, task-bars etc.)\n    \/\/ Based on your use case you may want one or the other.\n    const ImGuiViewport* viewport = ImGui::GetMainViewport();\n    ImGui::SetNextWindowPos(use_work_area ? viewport->WorkPos : viewport->Pos);\n    ImGui::SetNextWindowSize(use_work_area ? viewport->WorkSize : viewport->Size);\n\n    if (ImGui::Begin(\"Example: Fullscreen window\", p_open, flags))\n    {\n        ImGui::Checkbox(\"Use work area instead of main area\", &use_work_area);\n        ImGui::SameLine();\n        HelpMarker(\"Main Area = entire viewport,\\nWork Area = entire viewport minus sections used by the main menu bars, task bars etc.\\n\\nEnable the main-menu bar in Examples menu to see the difference.\");\n\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoBackground\", &flags, ImGuiWindowFlags_NoBackground);\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoDecoration\", &flags, ImGuiWindowFlags_NoDecoration);\n        ImGui::Indent();\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoTitleBar\", &flags, ImGuiWindowFlags_NoTitleBar);\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoCollapse\", &flags, ImGuiWindowFlags_NoCollapse);\n        ImGui::CheckboxFlags(\"ImGuiWindowFlags_NoScrollbar\", &flags, ImGuiWindowFlags_NoScrollbar);\n        ImGui::Unindent();\n\n        if (p_open && ImGui::Button(\"Close this window\"))\n            *p_open = false;\n    }\n    ImGui::End();\n}",
        "mark":8.0,
        "query_nsx":"\/* Show an example application in fullscreen mode with the option to use the full viewport area or the work area. \n>>> ShowExampleAppFullscreen(bool* p_open) *\/",
        "query_nlx":"\/* Function named ShowExampleAppFullscreen displays a window that can be toggled to occupy the full viewport area or the work area excluding menu bars and task bars.\n>>> ShowExampleAppFullscreen(bool* p_open) *\/"
    }

    {
        "file_name":"imgui_demo_function_96.cpp",
        "line_count":300,
        "code":"void ShowExampleAppCustomRendering(bool* p_open)\n{\n    if (!ImGui::Begin(\"Example: Custom rendering\", p_open))\n    {\n        ImGui::End();\n        return;\n    }\n    IMGUI_DEMO_MARKER(\"Examples\/Custom Rendering\");\n\n    \/\/ Tip: If you do a lot of custom rendering, you probably want to use your own geometrical types and benefit of\n    \/\/ overloaded operators, etc. Define IM_VEC2_CLASS_EXTRA in imconfig.h to create implicit conversions between your\n    \/\/ types and ImVec2\/ImVec4. Dear ImGui defines overloaded operators but they are internal to imgui.cpp and not\n    \/\/ exposed outside (to avoid messing with your types) In this example we are not using the maths operators!\n\n    if (ImGui::BeginTabBar(\"##TabBar\"))\n    {\n        if (ImGui::BeginTabItem(\"Primitives\"))\n        {\n            ImGui::PushItemWidth(-ImGui::GetFontSize() * 15);\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n\n            \/\/ Draw gradients\n            \/\/ (note that those are currently exacerbating our sRGB\/Linear issues)\n            \/\/ Calling ImGui::GetColorU32() multiplies the given colors by the current Style Alpha, but you may pass the IM_COL32() directly as well..\n            ImGui::Text(\"Gradients\");\n            ImVec2 gradient_size = ImVec2(ImGui::CalcItemWidth(), ImGui::GetFrameHeight());\n            {\n                ImVec2 p0 = ImGui::GetCursorScreenPos();\n                ImVec2 p1 = ImVec2(p0.x + gradient_size.x, p0.y + gradient_size.y);\n                ImU32 col_a = ImGui::GetColorU32(IM_COL32(0, 0, 0, 255));\n                ImU32 col_b = ImGui::GetColorU32(IM_COL32(255, 255, 255, 255));\n                draw_list->AddRectFilledMultiColor(p0, p1, col_a, col_b, col_b, col_a);\n                ImGui::InvisibleButton(\"##gradient1\", gradient_size);\n            }\n            {\n                ImVec2 p0 = ImGui::GetCursorScreenPos();\n                ImVec2 p1 = ImVec2(p0.x + gradient_size.x, p0.y + gradient_size.y);\n                ImU32 col_a = ImGui::GetColorU32(IM_COL32(0, 255, 0, 255));\n                ImU32 col_b = ImGui::GetColorU32(IM_COL32(255, 0, 0, 255));\n                draw_list->AddRectFilledMultiColor(p0, p1, col_a, col_b, col_b, col_a);\n                ImGui::InvisibleButton(\"##gradient2\", gradient_size);\n            }\n\n            \/\/ Draw a bunch of primitives\n            ImGui::Text(\"All primitives\");\n            static float sz = 36.0f;\n            static float thickness = 3.0f;\n            static int ngon_sides = 6;\n            static bool circle_segments_override = false;\n            static int circle_segments_override_v = 12;\n            static bool curve_segments_override = false;\n            static int curve_segments_override_v = 8;\n            static ImVec4 colf = ImVec4(1.0f, 1.0f, 0.4f, 1.0f);\n            ImGui::DragFloat(\"Size\", &sz, 0.2f, 2.0f, 100.0f, \"%.0f\");\n            ImGui::DragFloat(\"Thickness\", &thickness, 0.05f, 1.0f, 8.0f, \"%.02f\");\n            ImGui::SliderInt(\"N-gon sides\", &ngon_sides, 3, 12);\n            ImGui::Checkbox(\"##circlesegmentoverride\", &circle_segments_override);\n            ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n            circle_segments_override |= ImGui::SliderInt(\"Circle segments override\", &circle_segments_override_v, 3, 40);\n            ImGui::Checkbox(\"##curvessegmentoverride\", &curve_segments_override);\n            ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);\n            curve_segments_override |= ImGui::SliderInt(\"Curves segments override\", &curve_segments_override_v, 3, 40);\n            ImGui::ColorEdit4(\"Color\", &colf.x);\n\n            const ImVec2 p = ImGui::GetCursorScreenPos();\n            const ImU32 col = ImColor(colf);\n            const float spacing = 10.0f;\n            const ImDrawFlags corners_tl_br = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBottomRight;\n            const float rounding = sz \/ 5.0f;\n            const int circle_segments = circle_segments_override ? circle_segments_override_v : 0;\n            const int curve_segments = curve_segments_override ? curve_segments_override_v : 0;\n            const ImVec2 cp3[3] = { ImVec2(0.0f, sz * 0.6f), ImVec2(sz * 0.5f, -sz * 0.4f), ImVec2(sz, sz) }; \/\/ Control points for curves\n            const ImVec2 cp4[4] = { ImVec2(0.0f, 0.0f), ImVec2(sz * 1.3f, sz * 0.3f), ImVec2(sz - sz * 1.3f, sz - sz * 0.3f), ImVec2(sz, sz) };\n\n            float x = p.x + 4.0f;\n            float y = p.y + 4.0f;\n            for (int n = 0; n < 2; n++)\n            {\n                \/\/ First line uses a thickness of 1.0f, second line uses the configurable thickness\n                float th = (n == 0) ? 1.0f : thickness;\n                draw_list->AddNgon(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, ngon_sides, th);                 x += sz + spacing;  \/\/ N-gon\n                draw_list->AddCircle(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, circle_segments, th);          x += sz + spacing;  \/\/ Circle\n                draw_list->AddEllipse(ImVec2(x + sz*0.5f, y + sz*0.5f), ImVec2(sz*0.5f, sz*0.3f), col, -0.3f, circle_segments, th); x += sz + spacing;\t\/\/ Ellipse\n                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 0.0f, ImDrawFlags_None, th);          x += sz + spacing;  \/\/ Square\n                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, rounding, ImDrawFlags_None, th);      x += sz + spacing;  \/\/ Square with all rounded corners\n                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, rounding, corners_tl_br, th);         x += sz + spacing;  \/\/ Square with two rounded corners\n                draw_list->AddTriangle(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col, th);x += sz + spacing;  \/\/ Triangle\n                \/\/draw_list->AddTriangle(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col, th);x+= sz*0.4f + spacing; \/\/ Thin triangle\n                PathConcaveShape(draw_list, x, y, sz); draw_list->PathStroke(col, ImDrawFlags_Closed, th);          x += sz + spacing;  \/\/ Concave Shape\n                \/\/draw_list->AddPolyline(concave_shape, IM_ARRAYSIZE(concave_shape), col, ImDrawFlags_Closed, th);\n                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y), col, th);                                       x += sz + spacing;  \/\/ Horizontal line (note: drawing a filled rectangle will be faster!)\n                draw_list->AddLine(ImVec2(x, y), ImVec2(x, y + sz), col, th);                                       x += spacing;       \/\/ Vertical line (note: drawing a filled rectangle will be faster!)\n                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y + sz), col, th);                                  x += sz + spacing;  \/\/ Diagonal line\n\n                \/\/ Path\n                draw_list->PathArcTo(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, 3.141592f, 3.141592f * -0.5f);\n                draw_list->PathStroke(col, ImDrawFlags_None, th);\n                x += sz + spacing;\n\n                \/\/ Quadratic Bezier Curve (3 control points)\n                draw_list->AddBezierQuadratic(ImVec2(x + cp3[0].x, y + cp3[0].y), ImVec2(x + cp3[1].x, y + cp3[1].y), ImVec2(x + cp3[2].x, y + cp3[2].y), col, th, curve_segments);\n                x += sz + spacing;\n\n                \/\/ Cubic Bezier Curve (4 control points)\n                draw_list->AddBezierCubic(ImVec2(x + cp4[0].x, y + cp4[0].y), ImVec2(x + cp4[1].x, y + cp4[1].y), ImVec2(x + cp4[2].x, y + cp4[2].y), ImVec2(x + cp4[3].x, y + cp4[3].y), col, th, curve_segments);\n\n                x = p.x + 4;\n                y += sz + spacing;\n            }\n\n            \/\/ Filled shapes\n            draw_list->AddNgonFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, col, ngon_sides);             x += sz + spacing;  \/\/ N-gon\n            draw_list->AddCircleFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, col, circle_segments);      x += sz + spacing;  \/\/ Circle\n            draw_list->AddEllipseFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), ImVec2(sz * 0.5f, sz * 0.3f), col, -0.3f, circle_segments); x += sz + spacing;\/\/ Ellipse\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col);                                    x += sz + spacing;  \/\/ Square\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f);                             x += sz + spacing;  \/\/ Square with all rounded corners\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_tl_br);              x += sz + spacing;  \/\/ Square with two rounded corners\n            draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col);  x += sz + spacing;  \/\/ Triangle\n            \/\/draw_list->AddTriangleFilled(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col); x += sz*0.4f + spacing; \/\/ Thin triangle\n            PathConcaveShape(draw_list, x, y, sz); draw_list->PathFillConcave(col);                                 x += sz + spacing;  \/\/ Concave shape\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + thickness), col);                             x += sz + spacing;  \/\/ Horizontal line (faster than AddLine, but only handle integer thickness)\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + thickness, y + sz), col);                             x += spacing * 2.0f;\/\/ Vertical line (faster than AddLine, but only handle integer thickness)\n            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + 1, y + 1), col);                                      x += sz;            \/\/ Pixel (faster than AddLine)\n\n            \/\/ Path\n            draw_list->PathArcTo(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, 3.141592f * -0.5f, 3.141592f);\n            draw_list->PathFillConvex(col);\n            x += sz + spacing;\n\n            \/\/ Quadratic Bezier Curve (3 control points)\n            draw_list->PathLineTo(ImVec2(x + cp3[0].x, y + cp3[0].y));\n            draw_list->PathBezierQuadraticCurveTo(ImVec2(x + cp3[1].x, y + cp3[1].y), ImVec2(x + cp3[2].x, y + cp3[2].y), curve_segments);\n            draw_list->PathFillConvex(col);\n            x += sz + spacing;\n\n            draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x + sz, y + sz), IM_COL32(0, 0, 0, 255), IM_COL32(255, 0, 0, 255), IM_COL32(255, 255, 0, 255), IM_COL32(0, 255, 0, 255));\n            x += sz + spacing;\n\n            ImGui::Dummy(ImVec2((sz + spacing) * 13.2f, (sz + spacing) * 3.0f));\n            ImGui::PopItemWidth();\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"Canvas\"))\n        {\n            static ImVector<ImVec2> points;\n            static ImVec2 scrolling(0.0f, 0.0f);\n            static bool opt_enable_grid = true;\n            static bool opt_enable_context_menu = true;\n            static bool adding_line = false;\n\n            ImGui::Checkbox(\"Enable grid\", &opt_enable_grid);\n            ImGui::Checkbox(\"Enable context menu\", &opt_enable_context_menu);\n            ImGui::Text(\"Mouse Left: drag to add lines,\\nMouse Right: drag to scroll, click for context menu.\");\n\n            \/\/ Typically you would use a BeginChild()\/EndChild() pair to benefit from a clipping region + own scrolling.\n            \/\/ Here we demonstrate that this can be replaced by simple offsetting + custom drawing + PushClipRect\/PopClipRect() calls.\n            \/\/ To use a child window instead we could use, e.g:\n            \/\/      ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));      \/\/ Disable padding\n            \/\/      ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(50, 50, 50, 255));  \/\/ Set a background color\n            \/\/      ImGui::BeginChild(\"canvas\", ImVec2(0.0f, 0.0f), ImGuiChildFlags_Borders, ImGuiWindowFlags_NoMove);\n            \/\/      ImGui::PopStyleColor();\n            \/\/      ImGui::PopStyleVar();\n            \/\/      [...]\n            \/\/      ImGui::EndChild();\n\n            \/\/ Using InvisibleButton() as a convenience 1) it will advance the layout cursor and 2) allows us to use IsItemHovered()\/IsItemActive()\n            ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();      \/\/ ImDrawList API uses screen coordinates!\n            ImVec2 canvas_sz = ImGui::GetContentRegionAvail();   \/\/ Resize canvas to what's available\n            if (canvas_sz.x < 50.0f) canvas_sz.x = 50.0f;\n            if (canvas_sz.y < 50.0f) canvas_sz.y = 50.0f;\n            ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);\n\n            \/\/ Draw border and background color\n            ImGuiIO& io = ImGui::GetIO();\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n            draw_list->AddRectFilled(canvas_p0, canvas_p1, IM_COL32(50, 50, 50, 255));\n            draw_list->AddRect(canvas_p0, canvas_p1, IM_COL32(255, 255, 255, 255));\n\n            \/\/ This will catch our interactions\n            ImGui::InvisibleButton(\"canvas\", canvas_sz, ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight);\n            const bool is_hovered = ImGui::IsItemHovered(); \/\/ Hovered\n            const bool is_active = ImGui::IsItemActive();   \/\/ Held\n            const ImVec2 origin(canvas_p0.x + scrolling.x, canvas_p0.y + scrolling.y); \/\/ Lock scrolled origin\n            const ImVec2 mouse_pos_in_canvas(io.MousePos.x - origin.x, io.MousePos.y - origin.y);\n\n            \/\/ Add first and second point\n            if (is_hovered && !adding_line && ImGui::IsMouseClicked(ImGuiMouseButton_Left))\n            {\n                points.push_back(mouse_pos_in_canvas);\n                points.push_back(mouse_pos_in_canvas);\n                adding_line = true;\n            }\n            if (adding_line)\n            {\n                points.back() = mouse_pos_in_canvas;\n                if (!ImGui::IsMouseDown(ImGuiMouseButton_Left))\n                    adding_line = false;\n            }\n\n            \/\/ Pan (we use a zero mouse threshold when there's no context menu)\n            \/\/ You may decide to make that threshold dynamic based on whether the mouse is hovering something etc.\n            const float mouse_threshold_for_pan = opt_enable_context_menu ? -1.0f : 0.0f;\n            if (is_active && ImGui::IsMouseDragging(ImGuiMouseButton_Right, mouse_threshold_for_pan))\n            {\n                scrolling.x += io.MouseDelta.x;\n                scrolling.y += io.MouseDelta.y;\n            }\n\n            \/\/ Context menu (under default mouse threshold)\n            ImVec2 drag_delta = ImGui::GetMouseDragDelta(ImGuiMouseButton_Right);\n            if (opt_enable_context_menu && drag_delta.x == 0.0f && drag_delta.y == 0.0f)\n                ImGui::OpenPopupOnItemClick(\"context\", ImGuiPopupFlags_MouseButtonRight);\n            if (ImGui::BeginPopup(\"context\"))\n            {\n                if (adding_line)\n                    points.resize(points.size() - 2);\n                adding_line = false;\n                if (ImGui::MenuItem(\"Remove one\", NULL, false, points.Size > 0)) { points.resize(points.size() - 2); }\n                if (ImGui::MenuItem(\"Remove all\", NULL, false, points.Size > 0)) { points.clear(); }\n                ImGui::EndPopup();\n            }\n\n            \/\/ Draw grid + all lines in the canvas\n            draw_list->PushClipRect(canvas_p0, canvas_p1, true);\n            if (opt_enable_grid)\n            {\n                const float GRID_STEP = 64.0f;\n                for (float x = fmodf(scrolling.x, GRID_STEP); x < canvas_sz.x; x += GRID_STEP)\n                    draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p1.y), IM_COL32(200, 200, 200, 40));\n                for (float y = fmodf(scrolling.y, GRID_STEP); y < canvas_sz.y; y += GRID_STEP)\n                    draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p1.x, canvas_p0.y + y), IM_COL32(200, 200, 200, 40));\n            }\n            for (int n = 0; n < points.Size; n += 2)\n                draw_list->AddLine(ImVec2(origin.x + points[n].x, origin.y + points[n].y), ImVec2(origin.x + points[n + 1].x, origin.y + points[n + 1].y), IM_COL32(255, 255, 0, 255), 2.0f);\n            draw_list->PopClipRect();\n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"BG\/FG draw lists\"))\n        {\n            static bool draw_bg = true;\n            static bool draw_fg = true;\n            ImGui::Checkbox(\"Draw in Background draw list\", &draw_bg);\n            ImGui::SameLine(); HelpMarker(\"The Background draw list will be rendered below every Dear ImGui windows.\");\n            ImGui::Checkbox(\"Draw in Foreground draw list\", &draw_fg);\n            ImGui::SameLine(); HelpMarker(\"The Foreground draw list will be rendered over every Dear ImGui windows.\");\n            ImVec2 window_pos = ImGui::GetWindowPos();\n            ImVec2 window_size = ImGui::GetWindowSize();\n            ImVec2 window_center = ImVec2(window_pos.x + window_size.x * 0.5f, window_pos.y + window_size.y * 0.5f);\n            if (draw_bg)\n                ImGui::GetBackgroundDrawList()->AddCircle(window_center, window_size.x * 0.6f, IM_COL32(255, 0, 0, 200), 0, 10 + 4);\n            if (draw_fg)\n                ImGui::GetForegroundDrawList()->AddCircle(window_center, window_size.y * 0.6f, IM_COL32(0, 255, 0, 200), 0, 10);\n            ImGui::EndTabItem();\n        }\n\n        \/\/ Demonstrate out-of-order rendering via channels splitting\n        \/\/ We use functions in ImDrawList as each draw list contains a convenience splitter,\n        \/\/ but you can also instantiate your own ImDrawListSplitter if you need to nest them.\n        if (ImGui::BeginTabItem(\"Draw Channels\"))\n        {\n            ImDrawList* draw_list = ImGui::GetWindowDrawList();\n            {\n                ImGui::Text(\"Blue shape is drawn first: appears in back\");\n                ImGui::Text(\"Red shape is drawn after: appears in front\");\n                ImVec2 p0 = ImGui::GetCursorScreenPos();\n                draw_list->AddRectFilled(ImVec2(p0.x, p0.y), ImVec2(p0.x + 50, p0.y + 50), IM_COL32(0, 0, 255, 255)); \/\/ Blue\n                draw_list->AddRectFilled(ImVec2(p0.x + 25, p0.y + 25), ImVec2(p0.x + 75, p0.y + 75), IM_COL32(255, 0, 0, 255)); \/\/ Red\n                ImGui::Dummy(ImVec2(75, 75));\n            }\n            ImGui::Separator();\n            {\n                ImGui::Text(\"Blue shape is drawn first, into channel 1: appears in front\");\n                ImGui::Text(\"Red shape is drawn after, into channel 0: appears in back\");\n                ImVec2 p1 = ImGui::GetCursorScreenPos();\n\n                \/\/ Create 2 channels and draw a Blue shape THEN a Red shape.\n                \/\/ You can create any number of channels. Tables API use 1 channel per column in order to better batch draw calls.\n                draw_list->ChannelsSplit(2);\n                draw_list->ChannelsSetCurrent(1);\n                draw_list->AddRectFilled(ImVec2(p1.x, p1.y), ImVec2(p1.x + 50, p1.y + 50), IM_COL32(0, 0, 255, 255)); \/\/ Blue\n                draw_list->ChannelsSetCurrent(0);\n                draw_list->AddRectFilled(ImVec2(p1.x + 25, p1.y + 25), ImVec2(p1.x + 75, p1.y + 75), IM_COL32(255, 0, 0, 255)); \/\/ Red\n\n                \/\/ Flatten\/reorder channels. Red shape is in channel 0 and it appears below the Blue shape in channel 1.\n                \/\/ This works by copying draw indices only (vertices are not copied).\n                draw_list->ChannelsMerge();\n                ImGui::Dummy(ImVec2(75, 75));\n                ImGui::Text(\"After reordering, contents of channel 0 appears below channel 1.\");\n            }\n            ImGui::EndTabItem();\n        }\n\n        ImGui::EndTabBar();\n    }\n\n    ImGui::End();\n}",
        "mark":8.25,
        "query_nsx":"\/* Display a custom rendering example with various shapes and primitives using ImGui library.\n>>> ShowExampleAppCustomRendering(bool* p_open) *\/",
        "query_nlx":"\/* Generate a custom rendering interface with various shapes and options. \n>>> ShowExampleAppCustomRendering(bool* p_open) *\/"
    }

    {
        "file_name":"imgui_draw_function_11.cpp",
        "line_count":9,
        "code":"ImVec2 ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t)\n{\n    float u = 1.0f - t;\n    float w1 = u * u * u;\n    float w2 = 3 * u * u * t;\n    float w3 = 3 * u * t * t;\n    float w4 = t * t * t;\n    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the position of a point on a cubic Bezier curve given four control points and a parameter value.\n>>> ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t) *\/",
        "query_nlx":"        \/* Function named ImBezierCubicCalc calculates the position of a point on a cubic Bezier curve given four control points and a parameter t.\n        >>> ImBezierCubicCalc({p1, p2, p3, p4, t}) returns the position of the point on the Bezier curve at parameter t *\/ \n        ImVec2 ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t) {"
    }

    {
        "file_name":"imgui_draw_function_12.cpp",
        "line_count":8,
        "code":"ImVec2 ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t)\n{\n    float u = 1.0f - t;\n    float w1 = u * u;\n    float w2 = 2 * u * t;\n    float w3 = t * t;\n    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x, w1 * p1.y + w2 * p2.y + w3 * p3.y);\n}",
        "mark":8.5,
        "query_nsx":"\/* Calculate the position of a point on a quadratic Bezier curve given three control points and a parameter value.\n>>> ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t) *\/",
        "query_nlx":"        \/* Function named ImBezierQuadraticCalc calculates the position on a quadratic Bezier curve given three control points and a parameter t.\n        >>> ImBezierQuadraticCalc({1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}, 0.5) returns the position on the curve at t = 0.5\n        >>> ImBezierQuadraticCalc({0.0, 0.0}, {1.0, 1.0}, {2.0, 2.0}, 0.75) returns the position on the curve at t = 0.75 *\/ \n        ImVec2 ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t) { "
    }

    {
        "file_name":"imgui_draw_function_21.cpp",
        "line_count":1,
        "code":"int EstimateTriangleCount(int points_count)      { return (points_count < 3) ? 0 : points_count - 2; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the estimated number of triangles that can be formed with a given count of points.\n   >>> int EstimateTriangleCount(int points_count) { *\/",
        "query_nlx":"\/* Function named EstimateTriangleCount calculates the estimated number of triangles that can be formed using a given number of points. \n>>> EstimateTriangleCount(5) returns 3 \n>>> EstimateTriangleCount(2) returns 0 *\/ \nint EstimateTriangleCount(int points_count) { "
    }

    {
        "file_name":"imgui_dx_base_function_1.cpp",
        "line_count":23,
        "code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n\t{\n\t\tswitch (format) {\n\t\t\tcase DXGI_FORMAT_R32G32B32A32_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R32G32B32A32_FLOAT;\n\t\t\tcase DXGI_FORMAT_R32G32B32_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R32G32B32_FLOAT;\n\t\t\tcase DXGI_FORMAT_R16G16B16A16_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R16G16B16A16_FLOAT;\n\t\t\tcase DXGI_FORMAT_R10G10B10A2_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R10G10B10A2_UINT;\n\t\t\tcase DXGI_FORMAT_R8G8B8A8_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R8G8B8A8_UNORM;\n\t\t\tcase DXGI_FORMAT_B8G8R8A8_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_B8G8R8A8_UNORM;\n\t\t\tcase DXGI_FORMAT_R16G16_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R16G16_FLOAT;\n\t\t\tcase DXGI_FORMAT_R32G32_TYPELESS:\n\t\t\t\treturn DXGI_FORMAT_R32G32_FLOAT;\n\t\t\tdefault:\n\t\t\t\treturn format;\n\t\t}\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Translate typeless DXGI formats to their corresponding non-typeless formats.\n   >>> DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format); *\/",
        "query_nlx":"\/* TranslateTypelessFormats function maps typeless DXGI formats to their corresponding non-typeless formats.\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R32G32B32A32_TYPELESS) returns DXGI_FORMAT_R32G32B32A32_FLOAT\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R16G16B16A16_TYPELESS) returns DXGI_FORMAT_R16G16B16A16_FLOAT\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R8G8B8A8_TYPELESS) returns DXGI_FORMAT_R8G8B8A8_UNORM\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R32G32_TYPELESS) returns DXGI_FORMAT_R32G32_FLOAT\n   >>> TranslateTypelessFormats(DXGI_FORMAT_UNKNOWN) returns DXGI_FORMAT_UNKNOWN *\/ \nDXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format) { "
    }

    {
        "file_name":"imgui_dx_base_function_2.cpp",
        "line_count":1,
        "code":"int Width() { return _width; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the width value stored in the system.\n>>> Width() int *\/",
        "query_nlx":"\/* Function named Width returns the value of the width attribute. \n>>> Width()  *\/ \nint Width() {"
    }

    {
        "file_name":"imgui_dx_base_function_3.cpp",
        "line_count":1,
        "code":"int Height() { return _height; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the height value stored in the system. \n>>> Height()  *\/ \nint Height();",
        "query_nlx":"\/* Function named Height returns the value of the height attribute. \n>>> Height()  *\/ \nint Height() {"
    }

    {
        "file_name":"imgui_dx_base_function_4.cpp",
        "line_count":1,
        "code":"int Top() { return _top; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the top integer value stored in the data structure.\n   >>> Top() int *\/",
        "query_nlx":"\/* Define a function that returns the value stored in the variable _top.\n   >>> Top()  *\/ \nint Top() { "
    }

    {
        "file_name":"imgui_dx_base_function_5.cpp",
        "line_count":1,
        "code":"int Left() { return _left; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the value stored in the left variable.\n   >>> Left() 42 *\/ \nint Left();",
        "query_nlx":"\/* Function named Left returns the value stored in the variable _left. \n>>> Left() 42 *\/ \nint Left() { "
    }

    {
        "file_name":"imgui_dx_base_function_6.cpp",
        "line_count":1,
        "code":"HWND Handle() { return _handle; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the handle value associated with a specific object.\n   >>> Handle() HWND *\/",
        "query_nlx":"\/* Query: Define a function that returns a handle value without explicitly mentioning the programming language used.\n   >>> Handle() returns the handle value. *\/ \nHWND Handle() {"
    }

    {
        "file_name":"imgui_function_100.cpp",
        "line_count":1,
        "code":"float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }",
        "mark":8.0,
        "query_nsx":"\/* Determine the line height with spacing for items.\n   >>> float GetItemsLineHeightWithSpacing(); *\/",
        "query_nlx":"\/* Retrieve the line height with spacing for items by calling the function that calculates the frame height with spacing.\n>>> GetItemsLineHeightWithSpacing() float *\/ \nfloat GetItemsLineHeightWithSpacing() { "
    }

    {
        "file_name":"imgui_function_101.cpp",
        "line_count":1,
        "code":"bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }",
        "mark":8.0,
        "query_nsx":"\/* Check if the root window or any of its child windows are being hovered over.\n>>> IsRootWindowOrAnyChildHovered() { *\/",
        "query_nlx":"\/* Function named IsRootWindowOrAnyChildHovered checks if the root window or any of its child windows are currently being hovered over.\n>>> IsRootWindowOrAnyChildHovered() returns true if any window, including the root window, is being hovered over, otherwise false. *\/ \nbool IsRootWindowOrAnyChildHovered() { "
    }

    {
        "file_name":"imgui_function_103.cpp",
        "line_count":1,
        "code":"void  SetNextWindowPosCenter(ImGuiCond c=0) { SetNextWindowPos(GetMainViewport()->GetCenter(), c, ImVec2(0.5f,0.5f)); }",
        "mark":8.0,
        "query_nsx":"\/* Set the next window position to the center of the main viewport.\n   >>> SetNextWindowPosCenter() void { *\/",
        "query_nlx":"\/* Define a function named SetNextWindowPosCenter that sets the next window position to the center of the main viewport with the given condition and a specific offset. \n>>> SetNextWindowPosCenter() void *\/"
    }

    {
        "file_name":"imgui_function_104.cpp",
        "line_count":1,
        "code":"bool  IsItemHoveredRect()                   { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the item is being hovered over only within the boundaries of a rectangle.\n>>> IsItemHoveredRect() *\/",
        "query_nlx":"\/* Function named IsItemHoveredRect defines a boolean function that checks if the current item is being hovered over with the cursor, considering only the rectangular shape of the item.\n>>> IsItemHoveredRect() returns true if the item is being hovered over with the cursor within its rectangular boundaries, otherwise false. *\/ \nbool IsItemHoveredRect() { "
    }

    {
        "file_name":"imgui_function_106.cpp",
        "line_count":1,
        "code":"bool  IsMouseHoveringAnyWindow()            { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }",
        "mark":8.0,
        "query_nsx":"\/* Check if the mouse cursor is hovering over any window.\n>>> IsMouseHoveringAnyWindow() *\/",
        "query_nlx":"\/* Function named IsMouseHoveringAnyWindow checks if the mouse cursor is hovering over any window in the interface.\n>>> IsMouseHoveringAnyWindow() returns a boolean value indicating whether the mouse cursor is currently hovering over any window. *\/ \nbool IsMouseHoveringAnyWindow() {  \/\/ Function signature."
    }

    {
        "file_name":"imgui_function_107.cpp",
        "line_count":1,
        "code":"bool  IsMouseHoveringWindow()               { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }",
        "mark":8.0,
        "query_nsx":"\/* Check if the mouse cursor is hovering over the window.\n>>> IsMouseHoveringWindow() \n*\/",
        "query_nlx":"\/* Query: Determine if the mouse cursor is currently hovering over the window by checking if the window is being hovered, even when blocked by a popup or an active item.\n   >>> IsMouseHoveringWindow() bool *\/"
    }

    {
        "file_name":"imgui_function_109.cpp",
        "line_count":1,
        "code":"float GetWindowFontSize()                   { return GetFontSize(); }",
        "mark":8.0,
        "query_nsx":"\/* Determine the font size of a window.\n>>> float GetWindowFontSize() { *\/",
        "query_nlx":"\/* Retrieve the font size of the window by calling a function that returns the font size.\n   >>> GetWindowFontSize() returns the font size of the window *\/ \nfloat GetWindowFontSize() {  \/\/ function signature\n    return GetFontSize();  \/\/ function body omitted\n}  \/\/ end of function"
    }

    {
        "file_name":"imgui_function_114.cpp",
        "line_count":12,
        "code":"ImGuiKeyChord GetModForLRModKey(ImGuiKey key)\n{\n    if (key == ImGuiKey_LeftCtrl || key == ImGuiKey_RightCtrl)\n        return ImGuiMod_Ctrl;\n    if (key == ImGuiKey_LeftShift || key == ImGuiKey_RightShift)\n        return ImGuiMod_Shift;\n    if (key == ImGuiKey_LeftAlt || key == ImGuiKey_RightAlt)\n        return ImGuiMod_Alt;\n    if (key == ImGuiKey_LeftSuper || key == ImGuiKey_RightSuper)\n        return ImGuiMod_Super;\n    return ImGuiMod_None;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the modifier key associated with a given keyboard key.\n   >>> ImGuiKeyChord GetModForLRModKey(ImGuiKey key); *\/",
        "query_nlx":"\/* Function named GetModForLRModKey determines the modifier key associated with a given ImGuiKey key, such as Ctrl, Shift, Alt, or Super.\n>>> GetModForLRModKey(ImGuiKey_LeftCtrl) returns ImGuiMod_Ctrl\n>>> GetModForLRModKey(ImGuiKey_RightShift) returns ImGuiMod_Shift\n>>> GetModForLRModKey(ImGuiKey_LeftAlt) returns ImGuiMod_Alt\n>>> GetModForLRModKey(ImGuiKey_RightSuper) returns ImGuiMod_Super\n>>> GetModForLRModKey(ImGuiKey_UpArrow) returns ImGuiMod_None *\/ \nImGuiKeyChord GetModForLRModKey(ImGuiKey key) { *\/"
    }

    {
        "file_name":"imgui_function_115.cpp",
        "line_count":5,
        "code":"ImGuiID GetRoutingIdFromOwnerId(ImGuiID owner_id)\n{\n    ImGuiContext& g = *GImGui;\n    return (owner_id != ImGuiKeyOwner_NoOwner && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a unique identifier associated with a given owner identifier, prioritizing the owner identifier if valid, otherwise defaulting to the current focus scope identifier. *\/\nImGuiID GetRoutingIdFromOwnerId(ImGuiID owner_id) {",
        "query_nlx":"\/* Function named GetRoutingIdFromOwnerId takes an owner ID as input and returns a routing ID based on certain conditions. \n   >>> GetRoutingIdFromOwnerId(5) returns 5\n   >>> GetRoutingIdFromOwnerId(ImGuiKeyOwner_NoOwner) returns the current focus scope ID *\/"
    }

    {
        "file_name":"imgui_function_120.cpp",
        "line_count":7,
        "code":"void UpdateAliasKey(ImGuiKey key, bool v, float analog_value)\n{\n    IM_ASSERT(ImGui::IsAliasKey(key));\n    ImGuiKeyData* key_data = ImGui::GetKeyData(key);\n    key_data->Down = v;\n    key_data->AnalogValue = analog_value;\n}",
        "mark":8.0,
        "query_nsx":"\/* Update the state of a specific key with a new value and analog input.\n>>> UpdateAliasKey(ImGuiKey key, bool v, float analog_value) *\/",
        "query_nlx":"\/* Define a function called UpdateAliasKey that takes in a key, a boolean value, and a floating-point analog value as parameters. This function is responsible for updating the state of a given key by setting its 'Down' property to the provided boolean value and its 'AnalogValue' property to the provided floating-point value.\n   >>> UpdateAliasKey(ImGuiKey key, bool v, float analog_value) *\/"
    }

    {
        "file_name":"imgui_function_121.cpp",
        "line_count":9,
        "code":"ImGuiKeyChord GetMergedModsFromKeys()\n{\n    ImGuiKeyChord mods = 0;\n    if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }\n    if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }\n    if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }\n    if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }\n    return mods;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the merged modifier keys from the currently pressed keys.\n   >>> GetMergedModsFromKeys() ImGuiKeyChord *\/",
        "query_nlx":"\/* Function named GetMergedModsFromKeys calculates the merged key modifiers based on the current state of key presses. \n>>> GetMergedModsFromKeys() returns the combined key modifiers represented by a single value. *\/ \nImGuiKeyChord GetMergedModsFromKeys() { "
    }

    {
        "file_name":"imgui_function_137.cpp",
        "line_count":6,
        "code":"ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)\n{\n    if (ImFabs(dx) > ImFabs(dy))\n        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;\n    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the direction quadrant based on the change in x and y coordinates.\n   >>> ImGetDirQuadrantFromDelta(float dx, float dy) *\/",
        "query_nlx":"\/* Function named ImGetDirQuadrantFromDelta determines the direction of a point in a 2D plane based on the change in x and y coordinates. \n>>> ImGetDirQuadrantFromDelta(1.5, -2.0) returns ImGuiDir_Left \n>>> ImGetDirQuadrantFromDelta(-3.0, 4.0) returns ImGuiDir_Down *\/"
    }

    {
        "file_name":"imgui_function_164.cpp",
        "line_count":7,
        "code":"void WindowSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)\n{\n    ImGuiContext& g = *ctx;\n    for (ImGuiWindow* window : g.Windows)\n        window->SettingsOffset = -1;\n    g.SettingsWindows.clear();\n}",
        "mark":8.0,
        "query_nsx":"\/* Clear all window settings by resetting their offsets and clearing the list of settings windows.\n>>> WindowSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*) *\/",
        "query_nlx":"\/* Function named WindowSettingsHandler_ClearAll clears all window settings in the given context.\n   >>> WindowSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*) *\/"
    }

    {
        "file_name":"imgui_function_167.cpp",
        "line_count":47,
        "code":"void WindowSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)\n{\n    \/\/ Gather data from windows that were active during this session\n    \/\/ (if a window wasn't opened in this session we preserve its settings)\n    ImGuiContext& g = *ctx;\n    for (ImGuiWindow* window : g.Windows)\n    {\n        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)\n            continue;\n\n        ImGuiWindowSettings* settings = ImGui::FindWindowSettingsByWindow(window);\n        if (!settings)\n        {\n            settings = ImGui::CreateNewWindowSettings(window->Name);\n            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);\n        }\n        IM_ASSERT(settings->ID == window->ID);\n        settings->Pos = ImVec2ih(window->Pos);\n        settings->Size = ImVec2ih(window->SizeFull);\n        settings->IsChild = (window->Flags & ImGuiWindowFlags_ChildWindow) != 0;\n        settings->Collapsed = window->Collapsed;\n        settings->WantDelete = false;\n    }\n\n    \/\/ Write to text buffer\n    buf->reserve(buf->size() + g.SettingsWindows.size() * 6); \/\/ ballpark reserve\n    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))\n    {\n        if (settings->WantDelete)\n            continue;\n        const char* settings_name = settings->GetName();\n        buf->appendf(\"[%s][%s]\\n\", handler->TypeName, settings_name);\n        if (settings->IsChild)\n        {\n            buf->appendf(\"IsChild=1\\n\");\n            buf->appendf(\"Size=%d,%d\\n\", settings->Size.x, settings->Size.y);\n        }\n        else\n        {\n            buf->appendf(\"Pos=%d,%d\\n\", settings->Pos.x, settings->Pos.y);\n            buf->appendf(\"Size=%d,%d\\n\", settings->Size.x, settings->Size.y);\n            if (settings->Collapsed)\n                buf->appendf(\"Collapsed=1\\n\");\n        }\n        buf->append(\"\\n\");\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Write window settings data to a text buffer based on active windows and their properties.\n>>> void WindowSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf) *\/",
        "query_nlx":"\/* Write all window settings data from active windows in the current session to a text buffer, preserving settings for windows not opened in this session.\n   The function WindowSettingsHandler_WriteAll takes in the ImGuiContext pointer ctx, ImGuiSettingsHandler pointer handler, and ImGuiTextBuffer pointer buf. \n   It iterates through active windows in the context, gathers their settings, and writes them to the text buffer. *\/"
    }

    {
        "file_name":"imgui_function_170.cpp",
        "line_count":9,
        "code":"void Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext* ctx, const char* text)\n{\n    ImGuiContext& g = *ctx;\n    g.ClipboardHandlerData.clear();\n    const char* text_end = text + strlen(text);\n    g.ClipboardHandlerData.resize((int)(text_end - text) + 1);\n    memcpy(&g.ClipboardHandlerData[0], text, (size_t)(text_end - text));\n    g.ClipboardHandlerData[(int)(text_end - text)] = 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the text content to the clipboard handler data after clearing any existing data.\n   >>> Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext* ctx, const char* text) *\/",
        "query_nlx":"\/* Define a function that sets the text content to the system clipboard in the current user interface context.\n   >>> Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext* ctx, const char* text) *\/"
    }

    {
        "file_name":"imgui_function_179.cpp",
        "line_count":11,
        "code":"void MetricsHelpMarker(const char* desc)\n{\n    ImGui::TextDisabled(\"(?)\");\n    if (ImGui::BeginItemTooltip())\n    {\n        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);\n        ImGui::TextUnformatted(desc);\n        ImGui::PopTextWrapPos();\n        ImGui::EndTooltip();\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Display a help marker with additional information when hovering over a specific UI element.\n>>> MetricsHelpMarker(const char* desc) *\/",
        "query_nlx":"\/* Define a function named MetricsHelpMarker that takes a description as input and displays a help marker with the description as a tooltip when hovered over.\n   >>> MetricsHelpMarker(\"This is a sample description.\") *\/"
    }

    {
        "file_name":"imgui_function_204.cpp",
        "line_count":1,
        "code":"bool IsLegacyNativeDupe(ImGuiKey key) { return key >= 0 && key < 512 && GetIO().KeyMap[key] != -1; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a specific key is a legacy native duplicate within a certain range.\n   >>> bool IsLegacyNativeDupe(ImGuiKey key) { *\/",
        "query_nlx":"\/* Function named IsLegacyNativeDupe checks if a given ImGuiKey value is within the range of 0 to 511 and if the corresponding value in the KeyMap array of the current input\/output state is not equal to -1.\n>>> IsLegacyNativeDupe(256) true\n>>> IsLegacyNativeDupe(700) false *\/ \nbool IsLegacyNativeDupe(ImGuiKey key) { "
    }

    {
        "file_name":"imgui_function_27.cpp",
        "line_count":1,
        "code":"void                Clear() { Data.clear(); }",
        "mark":8.0,
        "query_nsx":"\/* Clear the data stored in the container. \n>>> Clear() *\/",
        "query_nlx":"\/* Function named Clear removes all elements from a data structure. \n>>> Clear() *\/ \nvoid Clear() { Data.clear(); }"
    }

    {
        "file_name":"imgui_function_30.cpp",
        "line_count":1,
        "code":"void ForceDisplayRangeByIndices(int item_begin, int item_end) { IncludeItemsByIndex(item_begin, item_end); }",
        "mark":8.0,
        "query_nsx":"\/* Force display a range of items specified by their indices.\n   >>> ForceDisplayRangeByIndices(3, 7) *\/ \nvoid ForceDisplayRangeByIndices(int item_begin, int item_end) {",
        "query_nlx":"\/* Define a function called ForceDisplayRangeByIndices that includes items in a range specified by their indices.\n>>> ForceDisplayRangeByIndices(3, 7) will include items with indices from 3 to 7. *\/ \nvoid ForceDisplayRangeByIndices(int item_begin, int item_end) {  }"
    }

    {
        "file_name":"imgui_function_34.cpp",
        "line_count":1,
        "code":"ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r, g, b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r, g, b, a); }",
        "mark":8.0,
        "query_nsx":"\/* Convert the input values representing a color in HSV format to RGB format and return the corresponding color.\n   >>> ImColor HSV(float h, float s, float v, float a = 1.0f) *\/",
        "query_nlx":"\/* Function named HSV converts a given set of HSV (Hue, Saturation, Value) color values to RGB (Red, Green, Blue) color values and returns an ImColor object with an optional alpha value.\n>>> HSV(0.5, 0.8, 0.9) returns an ImColor object representing the RGB color values converted from the input HSV values with the default alpha value of 1.0\n>>> HSV(0.2, 0.6, 0.7, 0.8) returns an ImColor object representing the RGB color values converted from the input HSV values with the specified alpha value of 0.8 *\/ \nImColor HSV(float h, float s, float v, float a = 1.0f) { *\/"
    }

    {
        "file_name":"imgui_function_39.cpp",
        "line_count":1,
        "code":"void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }",
        "mark":8.0,
        "query_nsx":"\/* Add a point to the current path line.\n>>> PathLineTo(const ImVec2& pos) *\/",
        "query_nlx":"\/* Define a function that adds a given position to a path.\n   >>> PathLineTo({x, y}) adds the position (x, y) to the path. *\/ \nvoid PathLineTo(const ImVec2& pos) {  *\/"
    }

    {
        "file_name":"imgui_function_4.cpp",
        "line_count":1,
        "code":"void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }",
        "mark":8.0,
        "query_nsx":"\/* Delete a dynamically allocated object and free its memory.\n   >>> void IM_DELETE(T* p) { *\/",
        "query_nlx":"\/* Function named IM_DELETE deallocates memory for an object of type T by calling its destructor and freeing the memory. \n>>> IM_DELETE(pointer_to_object) \n*\/ \nvoid IM_DELETE(T* p) { "
    }

    {
        "file_name":"imgui_function_50.cpp",
        "line_count":1,
        "code":"void  AddEllipse(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f) { AddEllipse(center, ImVec2(radius_x, radius_y), col, rot, num_segments, thickness); }",
        "mark":8.0,
        "query_nsx":"\/* Add an ellipse with specified center, radii, color, rotation, number of segments, and thickness.\n>>> void AddEllipse(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f) { *\/",
        "query_nlx":"\/* Define a function that adds an ellipse to a given location with specified radii, color, rotation, number of segments, and thickness.\n>>> AddEllipse(center: ImVec2, radius_x: float, radius_y: float, col: ImU32, rot: float = 0.0f, num_segments: int = 0, thickness: float = 1.0f) *\/ \nvoid AddEllipse(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f) { "
    }

    {
        "file_name":"imgui_function_51.cpp",
        "line_count":1,
        "code":"void  AddEllipseFilled(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0) { AddEllipseFilled(center, ImVec2(radius_x, radius_y), col, rot, num_segments); }",
        "mark":8.0,
        "query_nsx":"\/* Add a filled ellipse with specified center, radii, color, rotation, and number of segments.\n>>> void AddEllipseFilled(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0) { *\/",
        "query_nlx":"\/* Function named AddEllipseFilled adds a filled ellipse to the specified location with the given radii, color, rotation, and number of segments. \n>>> AddEllipseFilled({100, 100}, 50.0, 30.0, 0xFF0000FF, 45.0, 20) *\/ \nvoid AddEllipseFilled(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0) { "
    }

    {
        "file_name":"imgui_function_52.cpp",
        "line_count":1,
        "code":"void  PathEllipticalArcTo(const ImVec2& center, float radius_x, float radius_y, float rot, float a_min, float a_max, int num_segments = 0) { PathEllipticalArcTo(center, ImVec2(radius_x, radius_y), rot, a_min, a_max, num_segments); }",
        "mark":8.0,
        "query_nsx":"\/* Draw an elliptical arc segment defined by its center, radii, rotation angle, and start\/end angles.\n   >>> PathEllipticalArcTo(const ImVec2& center, float radius_x, float radius_y, float rot, float a_min, float a_max, int num_segments = 0) { *\/",
        "query_nlx":"\/* Define a function that adds an elliptical arc to the current path given the center point, radii, rotation angle, start angle, end angle, and number of segments.\n   >>> PathEllipticalArcTo({10.0, 20.0}, 30.0, 40.0, 45.0, 0.0, 180.0, 10) *\/ \nvoid PathEllipticalArcTo(const ImVec2& center, float radius_x, float radius_y, float rot, float a_min, float a_max, int num_segments = 0) { "
    }

    {
        "file_name":"imgui_function_53.cpp",
        "line_count":1,
        "code":"void  AddBezierCurve(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0) { AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments); }",
        "mark":8.0,
        "query_nsx":"\/* Add a Bezier curve defined by four control points with a specified color, thickness, and optional number of segments.\n>>> AddBezierCurve(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0) *\/",
        "query_nlx":"\/* Define a function that adds a Bezier curve to a drawing with given control points, color, thickness, and optional number of segments.\n   >>> AddBezierCurve(p1, p2, p3, p4, col, thickness, num_segments) void { *\/"
    }

    {
        "file_name":"imgui_function_54.cpp",
        "line_count":1,
        "code":"void  PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0) { PathBezierCubicCurveTo(p2, p3, p4, num_segments); }",
        "mark":8.0,
        "query_nsx":"\/* Describe a function that creates a Bezier curve path using control points p2, p3, and p4 with a specified number of segments.\n>>> PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0) *\/",
        "query_nlx":"\/* Define a function that creates a Bezier curve path using three control points and an optional number of segments for smoother rendering.\n>>> PathBezierCurveTo(p2: ImVec2, p3: ImVec2, p4: ImVec2, num_segments: int) *\/ \nvoid PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0) { "
    }

    {
        "file_name":"imgui_function_62.cpp",
        "line_count":1,
        "code":"void  PushButtonRepeat(bool repeat)                           { PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat); }",
        "mark":8.0,
        "query_nsx":"\/* Set the repeat behavior for a push button.\n   >>> PushButtonRepeat(true) \n   >>> PushButtonRepeat(false) *\/\nvoid PushButtonRepeat(bool repeat) { ",
        "query_nlx":"\/* Define a function called PushButtonRepeat that takes a boolean parameter to determine if a button should repeat when held down.\n   >>> PushButtonRepeat(true) sets the button to repeat when held down\n   >>> PushButtonRepeat(false) disables the button from repeating when held down *\/ \nvoid PushButtonRepeat(bool repeat) { "
    }

    {
        "file_name":"imgui_function_64.cpp",
        "line_count":1,
        "code":"void  PushTabStop(bool tab_stop)                              { PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop); }",
        "mark":8.0,
        "query_nsx":"\/* Toggle the ability for an item to be tabbed to or not.\n   >>> PushTabStop(true) \n   >>> PushTabStop(false) *\/\nvoid PushTabStop(bool tab_stop) { ",
        "query_nlx":"\/* Function named PushTabStop modifies the tab stop behavior of an item by toggling the tab stop flag.\n>>> PushTabStop(true) sets the item to be tab stoppable.\n>>> PushTabStop(false) sets the item to be non-tab stoppable. *\/ \nvoid PushTabStop(bool tab_stop) {  *\/"
    }

    {
        "file_name":"imgui_function_66.cpp",
        "line_count":1,
        "code":"bool  BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags window_flags = 0)  { return BeginChild(id, size, ImGuiChildFlags_FrameStyle, window_flags); }",
        "mark":8.0,
        "query_nsx":"\/* Begin a child frame within a parent window with specified ID, size, and optional window flags. \n   >>> BeginChildFrame(123, {100, 100}) \n   >>> BeginChildFrame(456, {200, 150}, ImGuiWindowFlags_NoScrollbar) *\/",
        "query_nlx":"\/* Function named BeginChildFrame takes an identifier, a size represented by a 2D vector, and optional window flags to begin a child frame with a frame style. \n>>> BeginChildFrame(123, {100, 50}, ImGuiWindowFlags_NoTitleBar) returns true\n>>> BeginChildFrame(456, {200, 100}) returns true *\/ \nbool BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags window_flags = 0) { "
    }

    {
        "file_name":"imgui_function_68.cpp",
        "line_count":1,
        "code":"bool BeginChild(const char* str_id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags){ return BeginChild(str_id, size_arg, borders ? ImGuiChildFlags_Borders : ImGuiChildFlags_None, window_flags); }",
        "mark":8.0,
        "query_nsx":"\/* Begin a child window with specified ID, size, borders, and window flags.\n   >>> bool BeginChild(const char* str_id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags){ *\/",
        "query_nlx":"\/* Define a function called BeginChild that takes a string identifier, a 2D vector representing size, a boolean for borders, and window flags. This function returns a boolean value.\n   >>> BeginChild(\"example_id\", {100, 100}, true, ImGuiWindowFlags_NoTitleBar) \n*\/ \nbool BeginChild(const char* str_id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags){ "
    }

    {
        "file_name":"imgui_function_69.cpp",
        "line_count":1,
        "code":"bool BeginChild(ImGuiID id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags)        { return BeginChild(id, size_arg, borders ? ImGuiChildFlags_Borders : ImGuiChildFlags_None, window_flags);     }",
        "mark":8.0,
        "query_nsx":"\/* Begin a child window with specified ID, size, borders, and window flags.\n   >>> BeginChild(id, size_arg, borders, window_flags) returns a boolean value. *\/ \nbool BeginChild(ImGuiID id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags) { ",
        "query_nlx":"\/* Define a function called BeginChild that takes an identifier, a size argument, a boolean for borders, and window flags. \n   The function returns a boolean value based on whether a child window should begin with the given parameters. *\/\nbool BeginChild(ImGuiID id, const ImVec2& size_arg, bool borders, ImGuiWindowFlags window_flags) { *\/"
    }

    {
        "file_name":"imgui_function_71.cpp",
        "line_count":1,
        "code":"void  PushAllowKeyboardFocus(bool tab_stop)                   { PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop); }",
        "mark":8.0,
        "query_nsx":"\/* Toggle the ability for an item to receive keyboard focus when tabbing through elements.\n   >>> PushAllowKeyboardFocus(true) \n   >>> PushAllowKeyboardFocus(false) *\/ \nvoid PushAllowKeyboardFocus(bool tab_stop) { ",
        "query_nlx":"\/* Function named PushAllowKeyboardFocus modifies the item flag to allow or disallow keyboard focus for an item based on the provided boolean value.\n>>> PushAllowKeyboardFocus(true) sets the item flag to allow keyboard focus.\n>>> PushAllowKeyboardFocus(false) sets the item flag to disallow keyboard focus. *\/ \nvoid PushAllowKeyboardFocus(bool tab_stop) {  *\/"
    }

    {
        "file_name":"imgui_function_74.cpp",
        "line_count":1,
        "code":"void  CaptureKeyboardFromApp(bool want_capture_keyboard = true)     { SetNextFrameWantCaptureKeyboard(want_capture_keyboard); }",
        "mark":8.0,
        "query_nsx":"\/* Set whether the application should capture keyboard input or not.\n   >>> CaptureKeyboardFromApp(true) \n   >>> CaptureKeyboardFromApp(false) *\/ \nvoid CaptureKeyboardFromApp(bool want_capture_keyboard = true) {",
        "query_nlx":"\/* Define a function called CaptureKeyboardFromApp that sets whether the application wants to capture keyboard input or not.\n   >>> CaptureKeyboardFromApp(true) sets the application to capture keyboard input\n   >>> CaptureKeyboardFromApp(false) sets the application to not capture keyboard input *\/ \nvoid CaptureKeyboardFromApp(bool want_capture_keyboard = true) {  *\/"
    }

    {
        "file_name":"imgui_function_76.cpp",
        "line_count":1,
        "code":"float GetWindowContentRegionWidth()                                               { return GetWindowContentRegionMax().x - GetWindowContentRegionMin().x; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the width of the content region within the window.\n>>> float GetWindowContentRegionWidth() { *\/",
        "query_nlx":"\/* Function named GetWindowContentRegionWidth calculates the width of the content region within a window by subtracting the x-coordinate of the minimum point from the x-coordinate of the maximum point.\n>>> GetWindowContentRegionWidth() float *\/"
    }

    {
        "file_name":"imgui_function_80.cpp",
        "line_count":1,
        "code":"bool  DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power = 1.0f)    { return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power); }",
        "mark":8.0,
        "query_nsx":"\/* Describe a function that allows dragging a floating-point value within a specified range using a given speed.\n   >>> DragFloat(label, v, v_speed, v_min, v_max, format, power = 1.0f) *\/",
        "query_nlx":"\/* Define a function called DragFloat that allows for dragging a floating-point value within a specified range with a given speed and format. \n   >>> DragFloat(\"Slider\", &value, 0.1f, 0.0f, 100.0f, \"%.2f\") true *\/ \nbool DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { "
    }

    {
        "file_name":"imgui_function_81.cpp",
        "line_count":1,
        "code":"bool  DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power); }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that allows dragging a 2D floating-point value with a specified speed, minimum and maximum values, and optional power parameter.\n   >>> bool DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { *\/",
        "query_nlx":"\/* Function DragFloat2 allows the user to interactively drag a 2D floating-point value within a specified range and speed.\n   >>> DragFloat2(\"Position\", position, 0.1f, 0.0f, 100.0f, \"%.2f\", 1.5f) *\/ \nbool DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) {"
    }

    {
        "file_name":"imgui_function_82.cpp",
        "line_count":1,
        "code":"bool  DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power); }",
        "mark":8.0,
        "query_nsx":"\/* Define a function that allows the user to interactively adjust three floating-point values using a draggable input control.\n   >>> DragFloat3(\"Position\", position, 0.1f, 0.0f, 100.0f, \"%.2f\", 2.0f) *\/ \nbool DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { ",
        "query_nlx":"\/* Function DragFloat3 allows the user to interactively drag a 3D floating-point value with a given label, speed, minimum and maximum values, format, and optional power parameter.\n>>> DragFloat3(\"Position\", position_values, 0.1f, 0.0f, 100.0f, \"%.2f\", 2.0f) true\n>>> DragFloat3(\"Scale\", scale_values, 0.05f, 0.0f, 10.0f, \"%.1f\") true *\/ \nbool DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { *\/"
    }

    {
        "file_name":"imgui_function_83.cpp",
        "line_count":1,
        "code":"bool  DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power); }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that allows dragging a 4-element float array with specified speed, minimum, and maximum values. \n>>> DragFloat4(\"Draggable Float Array\", v, v_speed, v_min, v_max, \"%.2f\", power) *\/",
        "query_nlx":"\/* Function named DragFloat4 allows the user to interactively adjust a 4-element float array using a draggable input control with a specified label, speed, minimum and maximum values, and format. The function also includes an optional power parameter for fine-tuning the drag behavior.\n>>> DragFloat4(\"Adjust Values\", {1.0f, 2.0f, 3.0f, 4.0f}, 0.1f, 0.0f, 10.0f, \"%.2f\") true *\/ \nbool DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power = 1.0f) { *\/"
    }

    {
        "file_name":"imgui_function_85.cpp",
        "line_count":1,
        "code":"bool  SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power = 1.0f)              { return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power); }",
        "mark":8.0,
        "query_nsx":"\/* Create a slider interface with two float values that can be adjusted within a specified range.\n   >>> SliderFloat2(\"Temperature\", temperatureValues, 0.0, 100.0, \"%.1f\", 0.5) *\/",
        "query_nlx":"\/* Function named SliderFloat2 creates a slider interface for two floating-point values with a specified label, minimum and maximum values, format, and optional power parameter.\n>>> SliderFloat2(\"Temperature\", temperature_values, 0.0, 100.0, \"%.1f\", 2.0) returns true if the slider interface is successfully created.\n>>> SliderFloat2(\"Volume\", volume_values, 0.0, 10.0, \"%.2f\") returns true if the slider interface is successfully created. *\/ \nbool SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power = 1.0f) { *\/"
    }

    {
        "file_name":"imgui_function_86.cpp",
        "line_count":1,
        "code":"bool  SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power = 1.0f)              { return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power); }",
        "mark":8.0,
        "query_nsx":"\/* Create a slider interface for adjusting three floating-point values within a specified range.\n>>> SliderFloat3(\"Position\", position, 0.0f, 100.0f, \"%.1f\") *\/",
        "query_nlx":"\/* Function named SliderFloat3 creates a slider interface for adjusting a 3D float vector within specified minimum and maximum values, with optional formatting and power parameter.\n>>> SliderFloat3(\"Position\", position, 0.0f, 100.0f, \"%.1f\", 2.0f) returns true if the slider interface is successfully created.\n>>> SliderFloat3(\"Scale\", scale, 1.0f, 10.0f, \"%.2f\") returns true if the slider interface is successfully created. *\/ \nbool SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power = 1.0f) { *\/"
    }

    {
        "file_name":"imgui_function_87.cpp",
        "line_count":1,
        "code":"bool  SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power = 1.0f)              { return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power); }",
        "mark":8.0,
        "query_nsx":"\/* Create a slider interface with four float values that can be adjusted within a specified range.\n>>> SliderFloat4(\"Example Slider\", values, 0.0, 100.0, \"%.2f\", 1.5) *\/",
        "query_nlx":"\/* Define a function named SliderFloat4 that creates a slider control for a 4-element float array with a given label, minimum and maximum values, format, and optional power parameter.\n   >>> SliderFloat4(\"Slider\", v, 0.0f, 100.0f, \"%.2f\", 2.0f) \n   >>> SliderFloat4(\"Temperature\", temperatureValues, -50.0f, 150.0f, \"%.1f\", 1.5f) *\/ \nbool SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power = 1.0f) { "
    }

    {
        "file_name":"imgui_function_90.cpp",
        "line_count":1,
        "code":"void  SetNextTreeNodeOpen(bool open, ImGuiCond cond = 0) { SetNextItemOpen(open, cond); }",
        "mark":8.0,
        "query_nsx":"\/* Set the next tree node to be open or closed based on the provided condition.\n   >>> SetNextTreeNodeOpen(true) \n   >>> SetNextTreeNodeOpen(false) *\/ \nvoid SetNextTreeNodeOpen(bool open, ImGuiCond cond = 0) { ",
        "query_nlx":"\/* Function named SetNextTreeNodeOpen sets the next tree node to be open or closed based on the provided boolean value and condition.\n>>> SetNextTreeNodeOpen(true, 1)\n>>> SetNextTreeNodeOpen(false) *\/ \nvoid SetNextTreeNodeOpen(bool open, ImGuiCond cond = 0) { "
    }

    {
        "file_name":"imgui_function_91.cpp",
        "line_count":1,
        "code":"float GetContentRegionAvailWidth()          { return GetContentRegionAvail().x; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the available width of the content region.\n>>> GetContentRegionAvailWidth() float *\/",
        "query_nlx":"\/* Query: Retrieve the width of the available content region by calling a function that returns the x-coordinate of the available content region.\n   >>> GetContentRegionAvailWidth() *\/ \nfloat GetContentRegionAvailWidth() { "
    }

    {
        "file_name":"imgui_function_92.cpp",
        "line_count":1,
        "code":"void  SetScrollHere(float ratio = 0.5f)     { SetScrollHereY(ratio); }",
        "mark":8.0,
        "query_nsx":"\/* Set the scroll position to a specified ratio within the scroll area.\n   >>> SetScrollHere(float ratio = 0.5f) *\/",
        "query_nlx":"\/* Define a function named SetScrollHere that sets the scroll position to a specified ratio, defaulting to 0.5 if no ratio is provided. \n>>> SetScrollHere(0.3) calls SetScrollHereY(0.3) \n>>> SetScrollHere() calls SetScrollHereY(0.5) *\/ \nvoid SetScrollHere(float ratio = 0.5f) { "
    }

    {
        "file_name":"imgui_function_94.cpp",
        "line_count":1,
        "code":"bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }",
        "mark":8.0,
        "query_nsx":"\/* Check if any window is currently focused.\n>>> IsAnyWindowFocused() *\/\nbool IsAnyWindowFocused();",
        "query_nlx":"\/* Function named IsAnyWindowFocused checks if any window is currently focused in the user interface.\n   >>> IsAnyWindowFocused() returns true if any window is focused, otherwise false *\/ \nbool IsAnyWindowFocused() { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }"
    }

    {
        "file_name":"imgui_function_95.cpp",
        "line_count":1,
        "code":"bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }",
        "mark":8.0,
        "query_nsx":"\/* Check if any window is currently being hovered over.\n>>> IsAnyWindowHovered() { *\/",
        "query_nlx":"\/* Function named IsAnyWindowHovered checks if any window is currently being hovered over.\n   >>> IsAnyWindowHovered() returns true if any window is being hovered over, otherwise false *\/ \nbool IsAnyWindowHovered() {  *\/"
    }

    {
        "file_name":"imgui_function_97.cpp",
        "line_count":1,
        "code":"bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the root window is currently focused.\n>>> IsRootWindowFocused() bool *\/",
        "query_nlx":"\/* Function named IsRootWindowFocused checks if the root window is currently focused.\n   >>> IsRootWindowFocused() returns a boolean value indicating whether the root window is focused or not. *\/ \nbool IsRootWindowFocused() {  *\/"
    }

    {
        "file_name":"imgui_function_98.cpp",
        "line_count":1,
        "code":"bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }",
        "mark":8.0,
        "query_nsx":"\/* Check if the root window or any of its child windows are currently focused.\n>>> IsRootWindowOrAnyChildFocused() *\/",
        "query_nlx":"\/* Function named IsRootWindowOrAnyChildFocused checks if the root window or any of its child windows are currently focused.\n>>> IsRootWindowOrAnyChildFocused() returns true if either the root window or any child window is focused, otherwise false. *\/ \nbool IsRootWindowOrAnyChildFocused() { "
    }

    {
        "file_name":"imgui_impl_dx11_function_8.cpp",
        "line_count":15,
        "code":"void ImGui_ImplDX11_Shutdown()\n{\n    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplDX11_InvalidateDeviceObjects();\n    if (bd->pFactory)             { bd->pFactory->Release(); }\n    if (bd->pd3dDevice)           { bd->pd3dDevice->Release(); }\n    if (bd->pd3dDeviceContext)    { bd->pd3dDeviceContext->Release(); }\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}",
        "mark":8.0,
        "query_nsx":"\/* Shutdown the renderer backend and release associated resources.\n   >>> ImGui_ImplDX11_Shutdown() *\/",
        "query_nlx":"        \/* Function named ImGui_ImplDX11_Shutdown deallocates resources used by the DirectX 11 backend of the ImGui library.\n        >>> ImGui_ImplDX11_Shutdown() releases the DirectX 11 factory, device, and device context if they exist, invalidates device objects, clears backend renderer name and user data, and updates backend flags. *\/"
    }

    {
        "file_name":"imgui_impl_dx11_function_9.cpp",
        "line_count":8,
        "code":"void ImGui_ImplDX11_NewFrame()\n{\n    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Context or backend not initialized! Did you call ImGui_ImplDX11_Init()?\");\n\n    if (!bd->pFontSampler)\n        ImGui_ImplDX11_CreateDeviceObjects();\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the backend data is initialized and create device objects if font sampler is not available.\n>>> ImGui_ImplDX11_NewFrame() *\/",
        "query_nlx":"\/* Function named ImGui_ImplDX11_NewFrame checks if the font sampler is not initialized in the backend data and calls ImGui_ImplDX11_CreateDeviceObjects if it is not initialized.\n>>> ImGui_ImplDX11_NewFrame() void *\/"
    }

    {
        "file_name":"imgui_impl_dx12_function_1.cpp",
        "line_count":56,
        "code":"void ImGui_ImplDX12_SetupRenderState(ImDrawData* draw_data, ID3D12GraphicsCommandList* ctx, ImGui_ImplDX12_RenderBuffers* fr)\n{\n    ImGui_ImplDX12_Data* bd = ImGui_ImplDX12_GetBackendData();\n\n    \/\/ Setup orthographic projection matrix into our constant buffer\n    \/\/ Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right).\n    VERTEX_CONSTANT_BUFFER_DX12 vertex_constant_buffer;\n    {\n        float L = draw_data->DisplayPos.x;\n        float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;\n        float T = draw_data->DisplayPos.y;\n        float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;\n        float mvp[4][4] =\n        {\n            { 2.0f\/(R-L),   0.0f,           0.0f,       0.0f },\n            { 0.0f,         2.0f\/(T-B),     0.0f,       0.0f },\n            { 0.0f,         0.0f,           0.5f,       0.0f },\n            { (R+L)\/(L-R),  (T+B)\/(B-T),    0.5f,       1.0f },\n        };\n        memcpy(&vertex_constant_buffer.mvp, mvp, sizeof(mvp));\n    }\n\n    \/\/ Setup viewport\n    D3D12_VIEWPORT vp;\n    memset(&vp, 0, sizeof(D3D12_VIEWPORT));\n    vp.Width = draw_data->DisplaySize.x;\n    vp.Height = draw_data->DisplaySize.y;\n    vp.MinDepth = 0.0f;\n    vp.MaxDepth = 1.0f;\n    vp.TopLeftX = vp.TopLeftY = 0.0f;\n    ctx->RSSetViewports(1, &vp);\n\n    \/\/ Bind shader and vertex buffers\n    unsigned int stride = sizeof(ImDrawVert);\n    unsigned int offset = 0;\n    D3D12_VERTEX_BUFFER_VIEW vbv;\n    memset(&vbv, 0, sizeof(D3D12_VERTEX_BUFFER_VIEW));\n    vbv.BufferLocation = fr->VertexBuffer->GetGPUVirtualAddress() + offset;\n    vbv.SizeInBytes = fr->VertexBufferSize * stride;\n    vbv.StrideInBytes = stride;\n    ctx->IASetVertexBuffers(0, 1, &vbv);\n    D3D12_INDEX_BUFFER_VIEW ibv;\n    memset(&ibv, 0, sizeof(D3D12_INDEX_BUFFER_VIEW));\n    ibv.BufferLocation = fr->IndexBuffer->GetGPUVirtualAddress();\n    ibv.SizeInBytes = fr->IndexBufferSize * sizeof(ImDrawIdx);\n    ibv.Format = sizeof(ImDrawIdx) == 2 ? DXGI_FORMAT_R16_UINT : DXGI_FORMAT_R32_UINT;\n    ctx->IASetIndexBuffer(&ibv);\n    ctx->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n    ctx->SetPipelineState(bd->pPipelineState);\n    ctx->SetGraphicsRootSignature(bd->pRootSignature);\n    ctx->SetGraphicsRoot32BitConstants(0, 16, &vertex_constant_buffer, 0);\n\n    \/\/ Setup blend factor\n    const float blend_factor[4] = { 0.f, 0.f, 0.f, 0.f };\n    ctx->OMSetBlendFactor(blend_factor);\n}",
        "mark":8.0,
        "query_nsx":"\/* Set up rendering state for ImGui elements using DirectX 12.\n>>> ImGui_ImplDX12_SetupRenderState(ImDrawData* draw_data, ID3D12GraphicsCommandList* ctx, ImGui_ImplDX12_RenderBuffers* fr) *\/",
        "query_nlx":"\/* Define a function ImGui_ImplDX12_SetupRenderState that sets up the render state for ImGui rendering using DirectX 12.\n   The function takes in parameters draw_data of type ImDrawData*, ctx of type ID3D12GraphicsCommandList*, and fr of type ImGui_ImplDX12_RenderBuffers*.\n   The function sets up the orthographic projection matrix, viewport, binds shaders and vertex buffers, sets pipeline state, root signature, and graphics constants, and sets blend factor.\n   This function prepares the rendering state for ImGui elements to be displayed on the screen using DirectX 12. *\/"
    }

    {
        "file_name":"imgui_impl_dx12_function_10.cpp",
        "line_count":8,
        "code":"void ImGui_ImplDX12_NewFrame()\n{\n    ImGui_ImplDX12_Data* bd = ImGui_ImplDX12_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Context or backend not initialized! Did you call ImGui_ImplDX12_Init()?\");\n\n    if (!bd->pPipelineState)\n        ImGui_ImplDX12_CreateDeviceObjects();\n}",
        "mark":8.0,
        "query_nsx":"\/* Ensure that the necessary backend data is initialized before proceeding with creating device objects.\n   >>> ImGui_ImplDX12_NewFrame() *\/ \nvoid ImGui_ImplDX12_NewFrame() {",
        "query_nlx":"\/* Function named ImGui_ImplDX12_NewFrame checks if the pipeline state is initialized in the backend data structure and creates device objects if it is not initialized.\n>>> ImGui_ImplDX12_NewFrame() void *\/"
    }

    {
        "file_name":"imgui_impl_dx12_function_2.cpp",
        "line_count":6,
        "code":"void SafeRelease(T*& res)\n{\n    if (res)\n        res->Release();\n    res = nullptr;\n}",
        "mark":8.0,
        "query_nsx":"\/* Release the allocated resources safely by checking if the resource exists and then releasing it before setting it to null.\n>>> SafeRelease(T*& res) *\/",
        "query_nlx":"\/* Define a function called SafeRelease that takes a reference to a pointer as input and releases the resource it points to safely.\n>>> SafeRelease(pointer) releases the resource pointed to by the input pointer and sets the pointer to nullptr. *\/ \nvoid SafeRelease(T*& res) { "
    }

    {
        "file_name":"imgui_impl_dx12_function_9.cpp",
        "line_count":14,
        "code":"void ImGui_ImplDX12_Shutdown()\n{\n    ImGui_ImplDX12_Data* bd = ImGui_ImplDX12_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    \/\/ Clean up windows and device objects\n    ImGui_ImplDX12_InvalidateDeviceObjects();\n    delete[] bd->pFrameResources;\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}",
        "mark":8.0,
        "query_nsx":"        \/* Shutdown the renderer backend and clean up associated resources.\n        >>> ImGui_ImplDX12_Shutdown() *\/ \n        void ImGui_ImplDX12_Shutdown() {",
        "query_nlx":"        \/* Function named ImGui_ImplDX12_Shutdown shuts down the ImGui DirectX 12 implementation by cleaning up resources and resetting backend data.\n        >>> ImGui_ImplDX12_Shutdown() *\/ \n        void ImGui_ImplDX12_Shutdown() {"
    }

    {
        "file_name":"imgui_impl_vulkan_function_13.cpp",
        "line_count":23,
        "code":"void ImGui_ImplVulkan_CreateShaderModules(VkDevice device, const VkAllocationCallbacks* allocator)\n{\n    \/\/ Create the shader modules\n    ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();\n    if (bd->ShaderModuleVert == VK_NULL_HANDLE)\n    {\n        VkShaderModuleCreateInfo vert_info = {};\n        vert_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;\n        vert_info.codeSize = sizeof(__glsl_shader_vert_spv);\n        vert_info.pCode = (uint32_t*)__glsl_shader_vert_spv;\n        VkResult err = vkCreateShaderModule(device, &vert_info, allocator, &bd->ShaderModuleVert);\n        check_vk_result(err);\n    }\n    if (bd->ShaderModuleFrag == VK_NULL_HANDLE)\n    {\n        VkShaderModuleCreateInfo frag_info = {};\n        frag_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;\n        frag_info.codeSize = sizeof(__glsl_shader_frag_spv);\n        frag_info.pCode = (uint32_t*)__glsl_shader_frag_spv;\n        VkResult err = vkCreateShaderModule(device, &frag_info, allocator, &bd->ShaderModuleFrag);\n        check_vk_result(err);\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Create shader modules if they do not already exist.\n>>> ImGui_ImplVulkan_CreateShaderModules(VkDevice device, const VkAllocationCallbacks* allocator) *\/",
        "query_nlx":"        \/* Create shader modules by loading vertex and fragment shader code into Vulkan shader modules.\n        >>> ImGui_ImplVulkan_CreateShaderModules(VkDevice device, const VkAllocationCallbacks* allocator) *\/"
    }

    {
        "file_name":"imgui_impl_vulkan_function_19.cpp",
        "line_count":12,
        "code":"void ImGui_ImplVulkan_Shutdown()\n{\n    ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplVulkan_DestroyDeviceObjects();\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}",
        "mark":8.0,
        "query_nsx":"\/* Shutdown the Vulkan renderer backend for ImGui.\n   >>> ImGui_ImplVulkan_Shutdown() *\/",
        "query_nlx":"\/* Function named ImGui_ImplVulkan_Shutdown shuts down the ImGui Vulkan implementation by cleaning up resources and resetting backend data.\n   >>> ImGui_ImplVulkan_Shutdown() cleans up Vulkan resources used by ImGui, resets backend renderer name and user data, and updates backend flags.\n*\/ \nvoid ImGui_ImplVulkan_Shutdown() { "
    }

    {
        "file_name":"imgui_impl_vulkan_function_20.cpp",
        "line_count":8,
        "code":"void ImGui_ImplVulkan_NewFrame()\n{\n    ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Context or backend not initialized! Did you call ImGui_ImplVulkan_Init()?\");\n\n    if (!bd->FontDescriptorSet)\n        ImGui_ImplVulkan_CreateFontsTexture();\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the fonts texture descriptor set exists; if not, create it.\n>>> ImGui_ImplVulkan_NewFrame() *\/",
        "query_nlx":"\/* Function named ImGui_ImplVulkan_NewFrame checks if the FontDescriptorSet in the backend data is not initialized and calls ImGui_ImplVulkan_CreateFontsTexture if it is not initialized.\n>>> ImGui_ImplVulkan_NewFrame() void *\/"
    }

    {
        "file_name":"imgui_impl_vulkan_function_22.cpp",
        "line_count":33,
        "code":"VkDescriptorSet ImGui_ImplVulkan_AddTexture(VkSampler sampler, VkImageView image_view, VkImageLayout image_layout)\n{\n    ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();\n    ImGui_ImplVulkan_InitInfo* v = &bd->VulkanInitInfo;\n\n    \/\/ Create Descriptor Set:\n    VkDescriptorSet descriptor_set;\n    {\n        VkDescriptorSetAllocateInfo alloc_info = {};\n        alloc_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;\n        alloc_info.descriptorPool = v->DescriptorPool;\n        alloc_info.descriptorSetCount = 1;\n        alloc_info.pSetLayouts = &bd->DescriptorSetLayout;\n        VkResult err = vkAllocateDescriptorSets(v->Device, &alloc_info, &descriptor_set);\n        check_vk_result(err);\n    }\n\n    \/\/ Update the Descriptor Set:\n    {\n        VkDescriptorImageInfo desc_image[1] = {};\n        desc_image[0].sampler = sampler;\n        desc_image[0].imageView = image_view;\n        desc_image[0].imageLayout = image_layout;\n        VkWriteDescriptorSet write_desc[1] = {};\n        write_desc[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;\n        write_desc[0].dstSet = descriptor_set;\n        write_desc[0].descriptorCount = 1;\n        write_desc[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;\n        write_desc[0].pImageInfo = desc_image;\n        vkUpdateDescriptorSets(v->Device, 1, write_desc, 0, nullptr);\n    }\n    return descriptor_set;\n}",
        "mark":8.25,
        "query_nsx":"\/* Create a Vulkan descriptor set for an ImGui texture using the provided sampler, image view, and image layout.\n   >>> VkDescriptorSet ImGui_ImplVulkan_AddTexture(VkSampler sampler, VkImageView image_view, VkImageLayout image_layout) *\/",
        "query_nlx":"        \/* Function named ImGui_ImplVulkan_AddTexture creates a new descriptor set for a given sampler, image view, and image layout.\n        >>> ImGui_ImplVulkan_AddTexture(VkSampler sampler, VkImageView image_view, VkImageLayout image_layout) VkDescriptorSet *\/"
    }

    {
        "file_name":"imgui_impl_vulkan_function_25.cpp",
        "line_count":9,
        "code":"void ImGui_ImplVulkan_DestroyWindowRenderBuffers(VkDevice device, ImGui_ImplVulkan_WindowRenderBuffers* buffers, const VkAllocationCallbacks* allocator)\n{\n    for (uint32_t n = 0; n < buffers->Count; n++)\n        ImGui_ImplVulkan_DestroyFrameRenderBuffers(device, &buffers->FrameRenderBuffers[n], allocator);\n    IM_FREE(buffers->FrameRenderBuffers);\n    buffers->FrameRenderBuffers = nullptr;\n    buffers->Index = 0;\n    buffers->Count = 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Destroy window render buffers associated with Vulkan implementation.\n   >>> ImGui_ImplVulkan_DestroyWindowRenderBuffers(VkDevice device, ImGui_ImplVulkan_WindowRenderBuffers* buffers, const VkAllocationCallbacks* allocator) *\/",
        "query_nlx":"        \/* Function named ImGui_ImplVulkan_DestroyWindowRenderBuffers deallocates memory and resets variables associated with window render buffers in the ImGui Vulkan implementation.\n        >>> ImGui_ImplVulkan_DestroyWindowRenderBuffers(device, buffers, allocator) *\/ \n        #include<vulkan\/vulkan.h>\n        void ImGui_ImplVulkan_DestroyWindowRenderBuffers(VkDevice device, ImGui_ImplVulkan_WindowRenderBuffers* buffers, const VkAllocationCallbacks* allocator) {"
    }

    {
        "file_name":"imgui_impl_vulkan_function_37.cpp",
        "line_count":6,
        "code":"void ImGui_ImplVulkanH_DestroyFrameSemaphores(VkDevice device, ImGui_ImplVulkanH_FrameSemaphores* fsd, const VkAllocationCallbacks* allocator)\n{\n    vkDestroySemaphore(device, fsd->ImageAcquiredSemaphore, allocator);\n    vkDestroySemaphore(device, fsd->RenderCompleteSemaphore, allocator);\n    fsd->ImageAcquiredSemaphore = fsd->RenderCompleteSemaphore = VK_NULL_HANDLE;\n}",
        "mark":8.5,
        "query_nsx":"        \/* Destroy Vulkan frame semaphores associated with the given device and frame semaphores data structure.\n        >>> void ImGui_ImplVulkanH_DestroyFrameSemaphores(VkDevice device, ImGui_ImplVulkanH_FrameSemaphores* fsd, const VkAllocationCallbacks* allocator) { *\/",
        "query_nlx":"\/* Function named ImGui_ImplVulkanH_DestroyFrameSemaphores destroys the Vulkan semaphores associated with a given frame semaphore structure. \n>>> ImGui_ImplVulkanH_DestroyFrameSemaphores(device, fsd, allocator) \nThe function takes a Vulkan device, a frame semaphore structure, and an allocation callback as input parameters. It destroys the ImageAcquiredSemaphore and RenderCompleteSemaphore associated with the frame semaphore structure using the Vulkan API function vkDestroySemaphore. Finally, it sets both semaphores to VK_NULL_HANDLE. *\/ \nvoid ImGui_ImplVulkanH_DestroyFrameSemaphores(VkDevice device, ImGui_ImplVulkanH_FrameSemaphores* fsd, const VkAllocationCallbacks* allocator) { "
    }

    {
        "file_name":"imgui_impl_vulkan_function_5.cpp",
        "line_count":4,
        "code":"VkDeviceSize AlignBufferSize(VkDeviceSize size, VkDeviceSize alignment)\n{\n    return (size + alignment - 1) & ~(alignment - 1);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the aligned buffer size based on the input size and alignment value.\n>>> VkDeviceSize AlignBufferSize(VkDeviceSize size, VkDeviceSize alignment) *\/",
        "query_nlx":"\/* Define a function that aligns a buffer size to a given alignment value.\n   >>> AlignBufferSize(100, 16) returns 112\n   >>> AlignBufferSize(256, 64) returns 320 *\/ \nVkDeviceSize AlignBufferSize(VkDeviceSize size, VkDeviceSize alignment) {"
    }

    {
        "file_name":"imgui_impl_win32_function_10.cpp",
        "line_count":14,
        "code":"void ImGui_ImplWin32_ProcessKeyEventsWorkarounds()\n{\n    \/\/ Left & right Shift keys: when both are pressed together, Windows tend to not generate the WM_KEYUP event for the first released one.\n    if (ImGui::IsKeyDown(ImGuiKey_LeftShift) && !IsVkDown(VK_LSHIFT))\n        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_LeftShift, false, VK_LSHIFT);\n    if (ImGui::IsKeyDown(ImGuiKey_RightShift) && !IsVkDown(VK_RSHIFT))\n        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_RightShift, false, VK_RSHIFT);\n\n    \/\/ Sometimes WM_KEYUP for Win key is not passed down to the app (e.g. for Win+V on some setups, according to GLFW).\n    if (ImGui::IsKeyDown(ImGuiKey_LeftSuper) && !IsVkDown(VK_LWIN))\n        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_LeftSuper, false, VK_LWIN);\n    if (ImGui::IsKeyDown(ImGuiKey_RightSuper) && !IsVkDown(VK_RWIN))\n        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_RightSuper, false, VK_RWIN);\n}",
        "mark":8.0,
        "query_nsx":"        \/* Process key events workarounds for handling special key combinations that may not generate the expected events.\n        >>> ImGui_ImplWin32_ProcessKeyEventsWorkarounds() *\/",
        "query_nlx":"        \/* Identify and handle specific key event workarounds for the Win32 platform.\n        >>> ImGui_ImplWin32_ProcessKeyEventsWorkarounds() *\/ \n        void ImGui_ImplWin32_ProcessKeyEventsWorkarounds() {"
    }

    {
        "file_name":"imgui_impl_win32_function_11.cpp",
        "line_count":8,
        "code":"void ImGui_ImplWin32_UpdateKeyModifiers()\n{\n    ImGuiIO& io = ImGui::GetIO();\n    io.AddKeyEvent(ImGuiMod_Ctrl, IsVkDown(VK_CONTROL));\n    io.AddKeyEvent(ImGuiMod_Shift, IsVkDown(VK_SHIFT));\n    io.AddKeyEvent(ImGuiMod_Alt, IsVkDown(VK_MENU));\n    io.AddKeyEvent(ImGuiMod_Super, IsVkDown(VK_LWIN) || IsVkDown(VK_RWIN));\n}",
        "mark":8.0,
        "query_nsx":"\/* Update key modifiers for the ImGui user interface based on the state of specific keys.\n>>> ImGui_ImplWin32_UpdateKeyModifiers() *\/",
        "query_nlx":"\/* Function named ImGui_ImplWin32_UpdateKeyModifiers updates the key modifiers for the ImGui user interface library based on the state of specific virtual keys.\n>>> ImGui_ImplWin32_UpdateKeyModifiers() updates the key modifiers for Ctrl, Shift, Alt, and Super keys by checking if the corresponding virtual keys are currently pressed. *\/ \nvoid ImGui_ImplWin32_UpdateKeyModifiers() {"
    }

    {
        "file_name":"imgui_impl_win32_function_18.cpp",
        "line_count":128,
        "code":"ImGuiKey ImGui_ImplWin32_KeyEventToImGuiKey(WPARAM wParam, LPARAM lParam)\n{\n    \/\/ There is no distinct VK_xxx for keypad enter, instead it is VK_RETURN + KF_EXTENDED.\n    if ((wParam == VK_RETURN) && (HIWORD(lParam) & KF_EXTENDED))\n        return ImGuiKey_KeypadEnter;\n\n    switch (wParam)\n    {\n        case VK_TAB: return ImGuiKey_Tab;\n        case VK_LEFT: return ImGuiKey_LeftArrow;\n        case VK_RIGHT: return ImGuiKey_RightArrow;\n        case VK_UP: return ImGuiKey_UpArrow;\n        case VK_DOWN: return ImGuiKey_DownArrow;\n        case VK_PRIOR: return ImGuiKey_PageUp;\n        case VK_NEXT: return ImGuiKey_PageDown;\n        case VK_HOME: return ImGuiKey_Home;\n        case VK_END: return ImGuiKey_End;\n        case VK_INSERT: return ImGuiKey_Insert;\n        case VK_DELETE: return ImGuiKey_Delete;\n        case VK_BACK: return ImGuiKey_Backspace;\n        case VK_SPACE: return ImGuiKey_Space;\n        case VK_RETURN: return ImGuiKey_Enter;\n        case VK_ESCAPE: return ImGuiKey_Escape;\n        case VK_OEM_7: return ImGuiKey_Apostrophe;\n        case VK_OEM_COMMA: return ImGuiKey_Comma;\n        case VK_OEM_MINUS: return ImGuiKey_Minus;\n        case VK_OEM_PERIOD: return ImGuiKey_Period;\n        case VK_OEM_2: return ImGuiKey_Slash;\n        case VK_OEM_1: return ImGuiKey_Semicolon;\n        case VK_OEM_PLUS: return ImGuiKey_Equal;\n        case VK_OEM_4: return ImGuiKey_LeftBracket;\n        case VK_OEM_5: return ImGuiKey_Backslash;\n        case VK_OEM_6: return ImGuiKey_RightBracket;\n        case VK_OEM_3: return ImGuiKey_GraveAccent;\n        case VK_CAPITAL: return ImGuiKey_CapsLock;\n        case VK_SCROLL: return ImGuiKey_ScrollLock;\n        case VK_NUMLOCK: return ImGuiKey_NumLock;\n        case VK_SNAPSHOT: return ImGuiKey_PrintScreen;\n        case VK_PAUSE: return ImGuiKey_Pause;\n        case VK_NUMPAD0: return ImGuiKey_Keypad0;\n        case VK_NUMPAD1: return ImGuiKey_Keypad1;\n        case VK_NUMPAD2: return ImGuiKey_Keypad2;\n        case VK_NUMPAD3: return ImGuiKey_Keypad3;\n        case VK_NUMPAD4: return ImGuiKey_Keypad4;\n        case VK_NUMPAD5: return ImGuiKey_Keypad5;\n        case VK_NUMPAD6: return ImGuiKey_Keypad6;\n        case VK_NUMPAD7: return ImGuiKey_Keypad7;\n        case VK_NUMPAD8: return ImGuiKey_Keypad8;\n        case VK_NUMPAD9: return ImGuiKey_Keypad9;\n        case VK_DECIMAL: return ImGuiKey_KeypadDecimal;\n        case VK_DIVIDE: return ImGuiKey_KeypadDivide;\n        case VK_MULTIPLY: return ImGuiKey_KeypadMultiply;\n        case VK_SUBTRACT: return ImGuiKey_KeypadSubtract;\n        case VK_ADD: return ImGuiKey_KeypadAdd;\n        case VK_LSHIFT: return ImGuiKey_LeftShift;\n        case VK_LCONTROL: return ImGuiKey_LeftCtrl;\n        case VK_LMENU: return ImGuiKey_LeftAlt;\n        case VK_LWIN: return ImGuiKey_LeftSuper;\n        case VK_RSHIFT: return ImGuiKey_RightShift;\n        case VK_RCONTROL: return ImGuiKey_RightCtrl;\n        case VK_RMENU: return ImGuiKey_RightAlt;\n        case VK_RWIN: return ImGuiKey_RightSuper;\n        case VK_APPS: return ImGuiKey_Menu;\n        case '0': return ImGuiKey_0;\n        case '1': return ImGuiKey_1;\n        case '2': return ImGuiKey_2;\n        case '3': return ImGuiKey_3;\n        case '4': return ImGuiKey_4;\n        case '5': return ImGuiKey_5;\n        case '6': return ImGuiKey_6;\n        case '7': return ImGuiKey_7;\n        case '8': return ImGuiKey_8;\n        case '9': return ImGuiKey_9;\n        case 'A': return ImGuiKey_A;\n        case 'B': return ImGuiKey_B;\n        case 'C': return ImGuiKey_C;\n        case 'D': return ImGuiKey_D;\n        case 'E': return ImGuiKey_E;\n        case 'F': return ImGuiKey_F;\n        case 'G': return ImGuiKey_G;\n        case 'H': return ImGuiKey_H;\n        case 'I': return ImGuiKey_I;\n        case 'J': return ImGuiKey_J;\n        case 'K': return ImGuiKey_K;\n        case 'L': return ImGuiKey_L;\n        case 'M': return ImGuiKey_M;\n        case 'N': return ImGuiKey_N;\n        case 'O': return ImGuiKey_O;\n        case 'P': return ImGuiKey_P;\n        case 'Q': return ImGuiKey_Q;\n        case 'R': return ImGuiKey_R;\n        case 'S': return ImGuiKey_S;\n        case 'T': return ImGuiKey_T;\n        case 'U': return ImGuiKey_U;\n        case 'V': return ImGuiKey_V;\n        case 'W': return ImGuiKey_W;\n        case 'X': return ImGuiKey_X;\n        case 'Y': return ImGuiKey_Y;\n        case 'Z': return ImGuiKey_Z;\n        case VK_F1: return ImGuiKey_F1;\n        case VK_F2: return ImGuiKey_F2;\n        case VK_F3: return ImGuiKey_F3;\n        case VK_F4: return ImGuiKey_F4;\n        case VK_F5: return ImGuiKey_F5;\n        case VK_F6: return ImGuiKey_F6;\n        case VK_F7: return ImGuiKey_F7;\n        case VK_F8: return ImGuiKey_F8;\n        case VK_F9: return ImGuiKey_F9;\n        case VK_F10: return ImGuiKey_F10;\n        case VK_F11: return ImGuiKey_F11;\n        case VK_F12: return ImGuiKey_F12;\n        case VK_F13: return ImGuiKey_F13;\n        case VK_F14: return ImGuiKey_F14;\n        case VK_F15: return ImGuiKey_F15;\n        case VK_F16: return ImGuiKey_F16;\n        case VK_F17: return ImGuiKey_F17;\n        case VK_F18: return ImGuiKey_F18;\n        case VK_F19: return ImGuiKey_F19;\n        case VK_F20: return ImGuiKey_F20;\n        case VK_F21: return ImGuiKey_F21;\n        case VK_F22: return ImGuiKey_F22;\n        case VK_F23: return ImGuiKey_F23;\n        case VK_F24: return ImGuiKey_F24;\n        case VK_BROWSER_BACK: return ImGuiKey_AppBack;\n        case VK_BROWSER_FORWARD: return ImGuiKey_AppForward;\n        default: return ImGuiKey_None;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Map Windows key events to ImGui key codes.\n   >>> ImGuiKey ImGui_ImplWin32_KeyEventToImGuiKey(WPARAM wParam, LPARAM lParam); *\/",
        "query_nlx":"\/* Define a function that maps Windows key events to ImGui key events.\n   The function should return the corresponding ImGui key based on the Windows key event parameters provided.\n   The function should handle special cases like keypad enter and various key mappings.\n   >>> ImGuiKey ImGui_ImplWin32_KeyEventToImGuiKey(WPARAM wParam, LPARAM lParam) *\/"
    }

    {
        "file_name":"imgui_impl_win32_function_19.cpp",
        "line_count":9,
        "code":"ImGuiMouseSource GetMouseSourceFromMessageExtraInfo()\n{\n    LPARAM extra_info = ::GetMessageExtraInfo();\n    if ((extra_info & 0xFFFFFF80) == 0xFF515700)\n        return ImGuiMouseSource_Pen;\n    if ((extra_info & 0xFFFFFF80) == 0xFF515780)\n        return ImGuiMouseSource_TouchScreen;\n    return ImGuiMouseSource_Mouse;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the source of mouse input based on the message extra info.\n   >>> GetMouseSourceFromMessageExtraInfo() *\/\nImGuiMouseSource GetMouseSourceFromMessageExtraInfo() { ",
        "query_nlx":"\/* Function named GetMouseSourceFromMessageExtraInfo determines the source of mouse input based on the message extra info.\n   >>> GetMouseSourceFromMessageExtraInfo() returns ImGuiMouseSource_Pen if the extra info matches 0xFF515700.\n   >>> GetMouseSourceFromMessageExtraInfo() returns ImGuiMouseSource_TouchScreen if the extra info matches 0xFF515780.\n   >>> GetMouseSourceFromMessageExtraInfo() returns ImGuiMouseSource_Mouse for any other case. *\/\nImGuiMouseSource GetMouseSourceFromMessageExtraInfo() { "
    }

    {
        "file_name":"imgui_impl_win32_function_2.cpp",
        "line_count":9,
        "code":"void ImGui_ImplWin32_UpdateKeyboardCodePage()\n{\n    \/\/ Retrieve keyboard code page, required for handling of non-Unicode Windows.\n    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();\n    HKL keyboard_layout = ::GetKeyboardLayout(0);\n    LCID keyboard_lcid = MAKELCID(HIWORD(keyboard_layout), SORT_DEFAULT);\n    if (::GetLocaleInfoA(keyboard_lcid, (LOCALE_RETURN_NUMBER | LOCALE_IDEFAULTANSICODEPAGE), (LPSTR)&bd->KeyboardCodePage, sizeof(bd->KeyboardCodePage)) == 0)\n        bd->KeyboardCodePage = CP_ACP; \/\/ Fallback to default ANSI code page when fails.\n}",
        "mark":8.0,
        "query_nsx":"        \/* Update the keyboard code page used for handling non-Unicode Windows.\n        >>> void ImGui_ImplWin32_UpdateKeyboardCodePage() *\/",
        "query_nlx":"        \/* Retrieve the keyboard code page necessary for handling non-Unicode Windows by obtaining the keyboard layout and associated code page information.\n        >>> ImGui_ImplWin32_UpdateKeyboardCodePage() *\/"
    }

    {
        "file_name":"imgui_impl_win32_function_27.cpp",
        "line_count":5,
        "code":"float ImGui_ImplWin32_GetDpiScaleForHwnd(void* hwnd)\n{\n    HMONITOR monitor = ::MonitorFromWindow((HWND)hwnd, MONITOR_DEFAULTTONEAREST);\n    return ImGui_ImplWin32_GetDpiScaleForMonitor(monitor);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the DPI scale factor for a given window handle.\n>>> float ImGui_ImplWin32_GetDpiScaleForHwnd(void* hwnd) { *\/",
        "query_nlx":"\/* Function named ImGui_ImplWin32_GetDpiScaleForHwnd calculates the DPI scale factor for a given window handle by first obtaining the monitor associated with the window and then retrieving the DPI scale factor for that monitor.\n>>> ImGui_ImplWin32_GetDpiScaleForHwnd(void* hwnd) float *\/"
    }

    {
        "file_name":"imgui_impl_win32_function_3.cpp",
        "line_count":53,
        "code":"bool ImGui_ImplWin32_InitEx(void* hwnd, bool platform_has_own_dc)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    IMGUI_CHECKVERSION();\n    IM_ASSERT(io.BackendPlatformUserData == nullptr && \"Already initialized a platform backend!\");\n\n    INT64 perf_frequency, perf_counter;\n    if (!::QueryPerformanceFrequency((LARGE_INTEGER*)&perf_frequency))\n        return false;\n    if (!::QueryPerformanceCounter((LARGE_INTEGER*)&perf_counter))\n        return false;\n\n    \/\/ Setup backend capabilities flags\n    ImGui_ImplWin32_Data* bd = IM_NEW(ImGui_ImplWin32_Data)();\n    io.BackendPlatformUserData = (void*)bd;\n    io.BackendPlatformName = \"imgui_impl_win32\";\n    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         \/\/ We can honor GetMouseCursor() values (optional)\n    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          \/\/ We can honor io.WantSetMousePos requests (optional, rarely used)\n\n    bd->hWnd = (HWND)hwnd;\n    bd->TicksPerSecond = perf_frequency;\n    bd->Time = perf_counter;\n    bd->LastMouseCursor = ImGuiMouseCursor_COUNT;\n    ImGui_ImplWin32_UpdateKeyboardCodePage();\n\n    \/\/ Set platform dependent data in viewport\n    ImGuiViewport* main_viewport = ImGui::GetMainViewport();\n    main_viewport->PlatformHandle = main_viewport->PlatformHandleRaw = (void*)bd->hWnd;\n    IM_UNUSED(platform_has_own_dc); \/\/ Used in 'docking' branch\n\n    \/\/ Dynamically load XInput library\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n    bd->WantUpdateHasGamepad = true;\n    const char* xinput_dll_names[] =\n    {\n        \"xinput1_4.dll\",   \/\/ Windows 8+\n        \"xinput1_3.dll\",   \/\/ DirectX SDK\n        \"xinput9_1_0.dll\", \/\/ Windows Vista, Windows 7\n        \"xinput1_2.dll\",   \/\/ DirectX SDK\n        \"xinput1_1.dll\"    \/\/ DirectX SDK\n    };\n    for (int n = 0; n < IM_ARRAYSIZE(xinput_dll_names); n++)\n        if (HMODULE dll = ::LoadLibraryA(xinput_dll_names[n]))\n        {\n            bd->XInputDLL = dll;\n            bd->XInputGetCapabilities = (PFN_XInputGetCapabilities)::GetProcAddress(dll, \"XInputGetCapabilities\");\n            bd->XInputGetState = (PFN_XInputGetState)::GetProcAddress(dll, \"XInputGetState\");\n            break;\n        }\n#endif \/\/ IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n\n    return true;\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize the Win32 platform for ImGui user interface library.\n   >>> bool ImGui_ImplWin32_InitEx(void* hwnd, bool platform_has_own_dc) *\/",
        "query_nlx":"\/* Define a function that initializes the Win32 platform for ImGui, taking a window handle and a boolean indicating if the platform has its own device context.\n>>> ImGui_ImplWin32_InitEx(void* hwnd, bool platform_has_own_dc) *\/"
    }

    {
        "file_name":"imgui_impl_win32_function_4.cpp",
        "line_count":4,
        "code":"bool     ImGui_ImplWin32_Init(void* hwnd)\n{\n    return ImGui_ImplWin32_InitEx(hwnd, false);\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize the ImGui library for Win32 platform using the provided window handle.\n>>> ImGui_ImplWin32_Init(hwnd) returns true if successful, false otherwise *\/ \nbool ImGui_ImplWin32_Init(void* hwnd) {",
        "query_nlx":"\/* Function named ImGui_ImplWin32_Init initializes the ImGui library for Win32 platform with the given window handle.\n>>> ImGui_ImplWin32_Init(hwnd) returns the result of calling ImGui_ImplWin32_InitEx with the provided window handle and false as parameters. *\/ \nbool ImGui_ImplWin32_Init(void* hwnd) { "
    }

    {
        "file_name":"imgui_impl_win32_function_6.cpp",
        "line_count":17,
        "code":"void    ImGui_ImplWin32_Shutdown()\n{\n    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No platform backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    \/\/ Unload XInput library\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n    if (bd->XInputDLL)\n        ::FreeLibrary(bd->XInputDLL);\n#endif \/\/ IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n\n    io.BackendPlatformName = nullptr;\n    io.BackendPlatformUserData = nullptr;\n    io.BackendFlags &= ~(ImGuiBackendFlags_HasMouseCursors | ImGuiBackendFlags_HasSetMousePos | ImGuiBackendFlags_HasGamepad);\n    IM_DELETE(bd);\n}",
        "mark":8.0,
        "query_nsx":"\/* Shutdown the platform backend and release associated resources.\n>>> ImGui_ImplWin32_Shutdown() *\/",
        "query_nlx":"        \/* Shutdown the Win32 platform backend for ImGui, releasing resources and resetting platform-related configurations.\n        >>> ImGui_ImplWin32_Shutdown() *\/"
    }

    {
        "file_name":"imgui_impl_win32_function_8.cpp",
        "line_count":4,
        "code":"bool IsVkDown(int vk)\n{\n    return (::GetKeyState(vk) & 0x8000) != 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if a specific virtual key is currently in the down state.\n>>> IsVkDown(int vk) *\/",
        "query_nlx":"\/* Function named IsVkDown determines if a specific virtual key is currently in the down state.\n   >>> IsVkDown(0x41) true\n   >>> IsVkDown(0x42) false *\/ \nbool IsVkDown(int vk) {"
    }

    {
        "file_name":"imgui_impl_win32_function_9.cpp",
        "line_count":7,
        "code":"void ImGui_ImplWin32_AddKeyEvent(ImGuiKey key, bool down, int native_keycode, int native_scancode = -1)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    io.AddKeyEvent(key, down);\n    io.SetKeyEventNativeData(key, native_keycode, native_scancode); \/\/ To support legacy indexing (<1.87 user code)\n    IM_UNUSED(native_scancode);\n}",
        "mark":8.0,
        "query_nsx":"        \/* Add a key event with its state and native data to the ImGui input system.\n        >>> ImGui_ImplWin32_AddKeyEvent(ImGuiKey key, bool down, int native_keycode, int native_scancode = -1) *\/",
        "query_nlx":"        \/* Define a function named ImGui_ImplWin32_AddKeyEvent that adds a key event for the ImGui library with the specified key, key state (pressed or released), and native key and scancode values. \n        >>> ImGui_ImplWin32_AddKeyEvent(ImGuiKey key, bool down, int native_keycode, int native_scancode = -1) *\/"
    }

    {
        "file_name":"imgui_internal_function_1.cpp",
        "line_count":1,
        "code":"bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the input integer is a power of two.\n>>> ImIsPowerOfTwo(int v) *\/",
        "query_nlx":"\/* Function named ImIsPowerOfTwo checks if a given integer is a power of two.\n   >>> ImIsPowerOfTwo(0) false\n   >>> ImIsPowerOfTwo(1) true\n   >>> ImIsPowerOfTwo(16) true *\/ \nbool ImIsPowerOfTwo(int v) { "
    }

    {
        "file_name":"imgui_internal_function_102.cpp",
        "line_count":1,
        "code":"void        ClearFreeMemory()           { TextA.clear(); InitialTextA.clear(); }",
        "mark":8.0,
        "query_nsx":"\/* Clear all stored text data to free up memory space.\n>>> ClearFreeMemory() *\/ \nvoid ClearFreeMemory() {  }",
        "query_nlx":"\/* Function named ClearFreeMemory clears the contents of two text variables, TextA and InitialTextA. \n>>> ClearFreeMemory() *\/ \nvoid ClearFreeMemory() {  }"
    }

    {
        "file_name":"imgui_internal_function_118.cpp",
        "line_count":1,
        "code":"void             SetWindowParentWindowForFocusRoute(ImGuiWindow* window, ImGuiWindow* parent_window) { window->ParentWindowForFocusRoute = parent_window; }",
        "mark":8.0,
        "query_nsx":"\/* Set the parent window for focus routing for a given window.\n   >>> SetWindowParentWindowForFocusRoute(window, parent_window) *\/ \nvoid SetWindowParentWindowForFocusRoute(ImGuiWindow* window, ImGuiWindow* parent_window) { ",
        "query_nlx":"\/* Define a function named SetWindowParentWindowForFocusRoute that assigns a parent window to a given window for focus routing.\n   >>> SetWindowParentWindowForFocusRoute(window, parent_window) *\/ \nvoid SetWindowParentWindowForFocusRoute(ImGuiWindow* window, ImGuiWindow* parent_window) { "
    }

    {
        "file_name":"imgui_internal_function_123.cpp",
        "line_count":1,
        "code":"void             ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& rect) { ScrollToRect(window, rect, ImGuiScrollFlags_KeepVisibleEdgeY); }",
        "mark":8.0,
        "query_nsx":"\/* Scroll a window to bring a specified rectangle into view.\n   >>> ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& rect){ *\/",
        "query_nlx":"\/* Function named ScrollToBringRectIntoView scrolls the given window to bring the specified rectangle into view while keeping the vertical edge visible.\n>>> ScrollToBringRectIntoView(window, rect) *\/ \nvoid ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& rect) { "
    }

    {
        "file_name":"imgui_internal_function_124.cpp",
        "line_count":1,
        "code":"ImGuiItemStatusFlags GetItemStatusFlags() { ImGuiContext& g = *GImGui; return g.LastItemData.StatusFlags; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the status flags associated with the current GUI item.\n   >>> ImGuiItemStatusFlags GetItemStatusFlags() { *\/",
        "query_nlx":"\/* Retrieve the status flags of the last item data from the current context.\n   >>> GetItemStatusFlags() ImGuiItemStatusFlags *\/ \nImGuiItemStatusFlags GetItemStatusFlags() { "
    }

    {
        "file_name":"imgui_internal_function_129.cpp",
        "line_count":1,
        "code":"bool             IsNamedKey(ImGuiKey key)                    { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; }",
        "mark":8.0,
        "query_nsx":"\/* Check if the given key is a named key within a specific range.\n>>> IsNamedKey(ImGuiKey key) *\/",
        "query_nlx":"\/* Function IsNamedKey checks if a given key is within the range of named keys.\n   >>> IsNamedKey(ImGuiKey key) { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; } *\/"
    }

    {
        "file_name":"imgui_internal_function_130.cpp",
        "line_count":1,
        "code":"bool             IsNamedKeyOrMod(ImGuiKey key)               { return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given key is a named key or a modifier key.\n   >>> IsNamedKeyOrMod(key) \n   >>> IsNamedKeyOrMod(ImGuiKey key) { *\/",
        "query_nlx":"\/* Function IsNamedKeyOrMod checks if a given key is a named key or a modifier key such as Ctrl, Shift, Alt, or Super.\n>>> IsNamedKeyOrMod(ImGuiKey key) { *\/"
    }

    {
        "file_name":"imgui_internal_function_131.cpp",
        "line_count":1,
        "code":"bool             IsLegacyKey(ImGuiKey key)                   { return key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_LegacyNativeKey_END; }",
        "mark":8.0,
        "query_nsx":"\/* Check if the given key is a legacy native key. \n>>> IsLegacyKey(ImGuiKey key) { *\/",
        "query_nlx":"\/* Function named IsLegacyKey determines if a given key is a legacy native key by checking if it falls within a specific range of values. \n>>> IsLegacyKey(ImGuiKey key) \n*\/"
    }

    {
        "file_name":"imgui_internal_function_132.cpp",
        "line_count":1,
        "code":"bool             IsKeyboardKey(ImGuiKey key)                 { return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given key corresponds to a keyboard key.\n   >>> IsKeyboardKey(key) \n*\/ \nbool IsKeyboardKey(ImGuiKey key) {",
        "query_nlx":"\/* Function named IsKeyboardKey determines if a given key belongs to the range of keyboard keys. \n>>> IsKeyboardKey(ImGuiKey key) { return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END; } *\/"
    }

    {
        "file_name":"imgui_internal_function_133.cpp",
        "line_count":1,
        "code":"bool             IsGamepadKey(ImGuiKey key)                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }",
        "mark":8.0,
        "query_nsx":"\/* Check if the given key corresponds to a gamepad key.\n   >>> IsGamepadKey(key) \n*\/ \nbool IsGamepadKey(ImGuiKey key) { ",
        "query_nlx":"\/* Function named IsGamepadKey determines if a given key belongs to the range of gamepad keys. \n>>> IsGamepadKey(ImGuiKey_Tab) false \n>>> IsGamepadKey(ImGuiKey_Gamepad_BEGIN) true *\/ \nbool IsGamepadKey(ImGuiKey key) { "
    }

    {
        "file_name":"imgui_internal_function_134.cpp",
        "line_count":1,
        "code":"bool             IsMouseKey(ImGuiKey key)                    { return key >= ImGuiKey_Mouse_BEGIN && key < ImGuiKey_Mouse_END; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given key corresponds to a mouse-related action.\n   >>> IsMouseKey(key) \n*\/ \nbool IsMouseKey(ImGuiKey key) { ",
        "query_nlx":"\/* Function named IsMouseKey checks if a given key is a mouse key, which is defined as a key greater than or equal to ImGuiKey_Mouse_BEGIN and less than ImGuiKey_Mouse_END. \n>>> IsMouseKey(ImGuiKey_Tab) false \n>>> IsMouseKey(ImGuiKey_MouseBegin) true *\/ \nbool IsMouseKey(ImGuiKey key) { "
    }

    {
        "file_name":"imgui_internal_function_135.cpp",
        "line_count":1,
        "code":"bool             IsAliasKey(ImGuiKey key)                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }",
        "mark":8.0,
        "query_nsx":"\/* Check if the given key is an alias key within a specified range.\n>>> IsAliasKey(ImGuiKey key) *\/",
        "query_nlx":"\/* Function named IsAliasKey determines if a given key is within the range of alias keys. \n>>> IsAliasKey(ImGuiKey key) { *\/"
    }

    {
        "file_name":"imgui_internal_function_136.cpp",
        "line_count":1,
        "code":"bool             IsLRModKey(ImGuiKey key)                    { return key >= ImGuiKey_LeftCtrl && key <= ImGuiKey_RightSuper; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given key is a modifier key (e.g., Ctrl, Shift, Alt, or Super). \n   >>> IsLRModKey(key) \n*\/ \nbool IsLRModKey(ImGuiKey key) { ",
        "query_nlx":"\/* Function named IsLRModKey determines if a given key belongs to the set of keys representing left control, right control, left alt, right alt, left shift, right shift, left super, or right super keys.\n>>> IsLRModKey(ImGuiKey key) { return key >= ImGuiKey_LeftCtrl && key <= ImGuiKey_RightSuper; } *\/"
    }

    {
        "file_name":"imgui_internal_function_140.cpp",
        "line_count":1,
        "code":"ImGuiID          GetCurrentFocusScope() { ImGuiContext& g = *GImGui; return g.CurrentFocusScopeId; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the identifier of the currently focused scope.\n   >>> GetCurrentFocusScope() ImGuiID *\/",
        "query_nlx":"\/* Function named GetCurrentFocusScope retrieves the identifier of the currently focused scope within the user interface.\n>>> GetCurrentFocusScope() returns the identifier of the current focus scope. *\/ \nImGuiID GetCurrentFocusScope() { "
    }

    {
        "file_name":"imgui_internal_function_145.cpp",
        "line_count":1,
        "code":"bool     TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0)    { return TreeNodeUpdateNextOpen(id, flags); }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the behavior of a tree node with a specific ID is open or closed.\n   >>> TreeNodeBehaviorIsOpen(123) true\n   >>> TreeNodeBehaviorIsOpen(456) false *\/ \nbool TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0) { ",
        "query_nlx":"\/* Function named TreeNodeBehaviorIsOpen determines if the behavior of a tree node with a given ID is open or not based on optional flags.\n>>> TreeNodeBehaviorIsOpen(123) returns true\n>>> TreeNodeBehaviorIsOpen(456, ImGuiTreeNodeFlags_DefaultOpen) returns true *\/ \nbool TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0) { "
    }

    {
        "file_name":"imgui_internal_function_17.cpp",
        "line_count":1,
        "code":"int    ImAbs(int x)               { return x < 0 ? -x : x; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the absolute value of an integer input.\n   >>> ImAbs(int x) { *\/",
        "query_nlx":"\/* Function named ImAbs calculates the absolute value of an integer input by returning the input if it is non-negative and its negation if it is negative. \n>>> ImAbs(-5) 5 \n>>> ImAbs(10) 10 *\/ \nint ImAbs(int x) { "
    }

    {
        "file_name":"imgui_internal_function_18.cpp",
        "line_count":1,
        "code":"float  ImAbs(float x)             { return fabsf(x); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the absolute value of a given floating-point number.\n>>> ImAbs(float x) *\/",
        "query_nlx":"\/* Function named ImAbs calculates the absolute value of a given floating-point number.\n>>> ImAbs(-3.14) returns 3.14\n>>> ImAbs(0.0) returns 0.0\n*\/ \nfloat ImAbs(float x) {  *\/"
    }

    {
        "file_name":"imgui_internal_function_19.cpp",
        "line_count":1,
        "code":"double ImAbs(double x)            { return fabs(x); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the absolute value of a given number.\n>>> ImAbs(double x) *\/",
        "query_nlx":"\/* Function named ImAbs calculates the absolute value of a given input number.\n   >>> ImAbs(-3.14) returns 3.14\n   >>> ImAbs(0) returns 0.0\n   >>> ImAbs(10) returns 10.0 *\/ \ndouble ImAbs(double x) { "
    }

    {
        "file_name":"imgui_internal_function_2.cpp",
        "line_count":1,
        "code":"bool      ImIsPowerOfTwo(ImU64 v)         { return v != 0 && (v & (v - 1)) == 0; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the input unsigned 64-bit integer is a power of two.\n>>> ImIsPowerOfTwo(10) false\n>>> ImIsPowerOfTwo(16) true *\/ \nbool ImIsPowerOfTwo(ImU64 v) { ",
        "query_nlx":"\/* Function named ImIsPowerOfTwo checks if a given unsigned 64-bit integer is a power of two.\n   >>> ImIsPowerOfTwo(16) true\n   >>> ImIsPowerOfTwo(15) false *\/ \nbool ImIsPowerOfTwo(ImU64 v) { "
    }

    {
        "file_name":"imgui_internal_function_20.cpp",
        "line_count":1,
        "code":"float  ImSign(float x)            { return (x < 0.0f) ? -1.0f : (x > 0.0f) ? 1.0f : 0.0f; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the sign of a given floating-point number.\n   >>> ImSign(float x) *\/",
        "query_nlx":"\/* Function named ImSign calculates the sign of a given floating-point number x. \n>>> ImSign(-3.5) returns -1.0 \n>>> ImSign(7.2) returns 1.0 \n>>> ImSign(0.0) returns 0.0 *\/ \nfloat ImSign(float x) { "
    }

    {
        "file_name":"imgui_internal_function_21.cpp",
        "line_count":1,
        "code":"double ImSign(double x)           { return (x < 0.0) ? -1.0 : (x > 0.0) ? 1.0 : 0.0; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the sign of a given number.\n   >>> ImSign(double x) { *\/",
        "query_nlx":"\/* Function named ImSign calculates the sign of a given number by returning -1.0 if the number is negative, 1.0 if the number is positive, and 0.0 if the number is zero. \n>>> ImSign(-3.5) -1.0 \n>>> ImSign(7.2) 1.0 \n>>> ImSign(0.0) 0.0 *\/ \ndouble ImSign(double x) { "
    }

    {
        "file_name":"imgui_internal_function_25.cpp",
        "line_count":1,
        "code":"T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the minimum value between two input values.\n   >>> ImMin(lhs, rhs) *\/",
        "query_nlx":"\/* Function named ImMin finds the minimum value between two input values of the same type.\n   >>> ImMin(5, 10) returns 5\n   >>> ImMin(3.14, 2.71) returns 2.71 *\/ \nT ImMin(T lhs, T rhs) { "
    }

    {
        "file_name":"imgui_internal_function_29.cpp",
        "line_count":1,
        "code":"void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }",
        "mark":8.0,
        "query_nsx":"\/* Swap the values of two variables of the same type.\n   >>> ImSwap(T& a, T& b) *\/",
        "query_nlx":"\/* Function named ImSwap swaps the values of two input variables of the same type. \n   >>> ImSwap(a, b) swaps the values of variables a and b. *\/ \nvoid ImSwap(T& a, T& b) { "
    }

    {
        "file_name":"imgui_internal_function_35.cpp",
        "line_count":1,
        "code":"ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate a linear interpolation between two 2D points based on a given factor.\n>>> ImLerp(const ImVec2& a, const ImVec2& b, float t) *\/",
        "query_nlx":"\/* Function named ImLerp calculates the linear interpolation between two 2D vectors a and b based on a given interpolation factor t. \n>>> ImLerp({1.0, 2.0}, {3.0, 4.0}, 0.5) returns {2.0, 3.0} \n>>> ImLerp({-1.0, 0.0}, {5.0, 2.0}, 0.75) returns {3.0, 1.5} *\/ \nImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t) { *\/"
    }

    {
        "file_name":"imgui_internal_function_36.cpp",
        "line_count":1,
        "code":"ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate a linear interpolation between two 2D points based on a given factor.\n>>> ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t) *\/",
        "query_nlx":"\/* Function named ImLerp calculates the linear interpolation between two 2D vectors a and b based on the interpolation factor t for both x and y components. \n>>> ImLerp({1.0, 2.0}, {3.0, 4.0}, {0.5, 0.5}) { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); } *\/"
    }

    {
        "file_name":"imgui_internal_function_37.cpp",
        "line_count":1,
        "code":"ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate a linear interpolation between two 4-dimensional vectors based on a given factor.\n>>> ImLerp(const ImVec4& a, const ImVec4& b, float t) *\/",
        "query_nlx":"\/* Function named ImLerp calculates the linear interpolation between two 4-dimensional vectors by interpolating each component individually based on a given interpolation factor.\n>>> ImLerp({1.0, 2.0, 3.0, 4.0}, {5.0, 6.0, 7.0, 8.0}, 0.5) returns {3.0, 4.0, 5.0, 6.0}\n>>> ImLerp({0.0, 0.0, 0.0, 0.0}, {10.0, 10.0, 10.0, 10.0}, 0.2) returns {2.0, 2.0, 2.0, 2.0} *\/ \nImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { *\/"
    }

    {
        "file_name":"imgui_internal_function_39.cpp",
        "line_count":1,
        "code":"float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the squared length of a 2D vector.\n>>> ImLengthSqr({3.0, 4.0}) 25.0\n>>> ImLengthSqr({-1.5, 2.5}) 8.5 *\/ \nfloat ImLengthSqr(const ImVec2& lhs) { ",
        "query_nlx":"\/* Function named ImLengthSqr calculates the square of the length of a 2D vector represented by the input ImVec2 structure.\n>>> ImLengthSqr({3.0, 4.0}) 25.0\n>>> ImLengthSqr({-1.5, 2.5}) 10.0 *\/ \nfloat ImLengthSqr(const ImVec2& lhs) { *\/"
    }

    {
        "file_name":"imgui_internal_function_40.cpp",
        "line_count":1,
        "code":"float  ImLengthSqr(const ImVec4& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the squared length of a 4-dimensional vector.\n>>> ImLengthSqr(const ImVec4& lhs) *\/",
        "query_nlx":"\/* Function named ImLengthSqr calculates the square of the length of a given 4-dimensional vector represented by the ImVec4 struct. \n>>> ImLengthSqr({1.0, 2.0, 3.0, 4.0}) returns 30.0 \n>>> ImLengthSqr({-1.0, 0.0, 2.5, -3.5}) returns 19.5 *\/ \nfloat ImLengthSqr(const ImVec4& lhs) {  *\/"
    }

    {
        "file_name":"imgui_internal_function_45.cpp",
        "line_count":1,
        "code":"ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2(ImFloor(v.x), ImFloor(v.y)); }",
        "mark":8.0,
        "query_nsx":"\/* Round down each component of a 2D vector to the nearest integer value. \n>>> ImFloor(const ImVec2& v){ *\/",
        "query_nlx":"\/* Function named ImFloor rounds down each component of a given 2D vector to the nearest integer values. \n>>> ImFloor({3.6, 4.2}) returns {3, 4} \n>>> ImFloor({-2.8, 5.9}) returns {-3, 5} *\/ \nImVec2 ImFloor(const ImVec2& v) {  *\/"
    }

    {
        "file_name":"imgui_internal_function_47.cpp",
        "line_count":1,
        "code":"float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }",
        "mark":9.0,
        "query_nsx":"\/* Calculate the dot product of two 2D vectors.\n>>> ImDot(const ImVec2& a, const ImVec2& b) *\/",
        "query_nlx":"\/* Function named ImDot calculates the dot product of two 2D vectors represented by ImVec2 structures. \n>>> ImDot({a.x, a.y}, {b.x, b.y}) returns the dot product of the two input vectors. *\/ \nfloat ImDot(const ImVec2& a, const ImVec2& b) {  *\/"
    }

    {
        "file_name":"imgui_internal_function_48.cpp",
        "line_count":1,
        "code":"ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the new position of a 2D point after rotating it by a given angle. \n>>> ImRotate(const ImVec2& v, float cos_a, float sin_a) *\/",
        "query_nlx":"\/* Function named ImRotate calculates the new coordinates of a 2D vector after rotating it by a given angle represented by cosine and sine values. \n>>> ImRotate({3.0, 4.0}, 0.5, 0.5) returns {1.5, 5.0} \n>>> ImRotate({-2.0, 1.0}, 0.707, -0.707) returns {-2.121, -0.707} *\/ \nImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a) {  *\/"
    }

    {
        "file_name":"imgui_internal_function_5.cpp",
        "line_count":1,
        "code":"bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\\t'; }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given character is a blank space or a tab character.\n>>> bool ImCharIsBlankA(char c) { *\/",
        "query_nlx":"\/* Function named ImCharIsBlankA checks if a given character is either a space or a tab character.\n>>> ImCharIsBlankA(' ') true\n>>> ImCharIsBlankA('\\t') true\n>>> ImCharIsBlankA('a') false *\/ \nbool ImCharIsBlankA(char c) { "
    }

    {
        "file_name":"imgui_internal_function_51.cpp",
        "line_count":1,
        "code":"ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the product of two 2D vectors element-wise.\n   >>> ImMul(const ImVec2& lhs, const ImVec2& rhs) *\/",
        "query_nlx":"\/* Function named ImMul calculates the element-wise multiplication of two 2D vectors.\n>>> ImMul({2.0, 3.0}, {4.0, 5.0}) returns {8.0, 15.0}\n>>> ImMul({-1.0, 0.5}, {3.0, -2.0}) returns {-3.0, -1.0} *\/ \nImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs) { *\/"
    }

    {
        "file_name":"imgui_internal_function_6.cpp",
        "line_count":1,
        "code":"bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\\t' || c == 0x3000; }",
        "mark":8.0,
        "query_nsx":"\/* Check if the input character is a blank space, tab, or a special character. \n>>> bool ImCharIsBlankW(unsigned int c) { *\/",
        "query_nlx":"\/* Function named ImCharIsBlankW checks if a given unsigned integer represents a blank character, which includes space, tab, or a specific Unicode character.\n>>> ImCharIsBlankW(32) true\n>>> ImCharIsBlankW(9) true\n>>> ImCharIsBlankW(12288) true *\/ \nbool ImCharIsBlankW(unsigned int c) { "
    }

    {
        "file_name":"imgui_internal_function_61.cpp",
        "line_count":1,
        "code":"void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }",
        "mark":8.0,
        "query_nsx":"\/* Update the X-coordinate values of a 2D shape by adding a given value to both the minimum and maximum X-coordinate.\n>>> TranslateX(float dx) *\/",
        "query_nlx":"\/* Function named TranslateX updates the x-coordinates of two points by adding a given value to each of them.\n>>> TranslateX(2.0) \n*\/ \nvoid TranslateX(float dx) {  *\/"
    }

    {
        "file_name":"imgui_internal_function_62.cpp",
        "line_count":1,
        "code":"void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }",
        "mark":8.0,
        "query_nsx":"\/* Update the Y-coordinate values of a bounding box by adding a specified value to each coordinate.\n>>> TranslateY(float dy) *\/",
        "query_nlx":"\/* Function named TranslateY modifies the y-coordinates of a given rectangle by adding a specified value to both the minimum and maximum y-coordinates.\n>>> TranslateY(2.0) \n*\/ \nvoid TranslateY(float dy) { "
    }

    {
        "file_name":"imgui_internal_function_7.cpp",
        "line_count":1,
        "code":"bool      ImCharIsXdigitA(char c)         { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'); }",
        "mark":8.0,
        "query_nsx":"\/* Check if the input character is a hexadecimal digit.\n>>> ImCharIsXdigitA(char c) *\/",
        "query_nlx":"\/* Function named ImCharIsXdigitA checks if a given character is a hexadecimal digit (0-9, A-F, a-f).\n>>> ImCharIsXdigitA('7') true\n>>> ImCharIsXdigitA('G') false *\/ \nbool ImCharIsXdigitA(char c) { "
    }

    {
        "file_name":"imgui_internal_function_77.cpp",
        "line_count":1,
        "code":"void            Clear()                     { Storage.clear(); }",
        "mark":8.0,
        "query_nsx":"\/* Clear the storage container. \n>>> Clear() *\/ \nvoid Clear();",
        "query_nlx":"\/* Function named Clear clears the storage data structure. \n>>> Clear() *\/ \nvoid Clear() {"
    }

    {
        "file_name":"imgui_overlay_dx_function_30.cpp",
        "line_count":17,
        "code":"HRESULT hkD3D12CreateDevice(IUnknown* pAdapter, D3D_FEATURE_LEVEL MinimumFeatureLevel, REFIID riid, void** ppDevice)\n{\n    LOG_FUNC();\n\n    auto result = o_D3D12CreateDevice(pAdapter, MinimumFeatureLevel, riid, ppDevice);\n\n    if (result == S_OK)\n    {\n        LOG_INFO(\"Device captured\");\n        g_pd3dDeviceParam = (ID3D12Device*)*ppDevice;\n        HookToDevice(g_pd3dDeviceParam);\n    }\n\n    LOG_FUNC_RESULT(result);\n\n    return result;\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a device using specified parameters and capture it if successful.\n   >>> HRESULT hkD3D12CreateDevice(IUnknown* pAdapter, D3D_FEATURE_LEVEL MinimumFeatureLevel, REFIID riid, void** ppDevice) { *\/",
        "query_nlx":"        \/* This function hkD3D12CreateDevice creates a D3D12 device using the provided adapter, minimum feature level, and reference ID, capturing the device if successful.\n        >>> hkD3D12CreateDevice(IUnknown* pAdapter, D3D_FEATURE_LEVEL MinimumFeatureLevel, REFIID riid, void** ppDevice) *\/"
    }

    {
        "file_name":"imgui_overlay_vk_function_8.cpp",
        "line_count":24,
        "code":"VkResult hkvkCreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)\n{\n    LOG_FUNC();\n\n    auto result = o_vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);\n\n    auto procHwnd = Util::GetProcessWindow();\n    LOG_DEBUG(\"procHwnd: {0:X}, swapchain hwnd: {1:X}\", (UINT64)procHwnd, (UINT64)pCreateInfo->hwnd);\n\n    if (result == VK_SUCCESS && !Config::Instance()->VulkanSkipHooks && procHwnd == pCreateInfo->hwnd)\n    {\n        DestroyVulkanObjects(false);\n\n        _instance = instance;\n        LOG_DEBUG(\"_instance captured: {0:X}\", (UINT64)_instance);\n        _hwnd = pCreateInfo->hwnd;\n        LOG_DEBUG(\"_hwnd captured: {0:X}\", (UINT64)_hwnd);\n    }\n\n    LOG_FUNC_RESULT(result);\n\n    return result;\n\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a Win32 surface for Vulkan instance.\n>>> hkvkCreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) *\/",
        "query_nlx":"\/* Query: Defines a function that creates a Win32 surface for Vulkan, capturing the instance and window handle if successful and certain conditions are met.\n   >>> hkvkCreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) *\/"
    }

    {
        "file_name":"imgui_tables_function_1.cpp",
        "line_count":32,
        "code":"ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window)\n{\n    \/\/ Adjust flags: set default sizing policy\n    if ((flags & ImGuiTableFlags_SizingMask_) == 0)\n        flags |= ((flags & ImGuiTableFlags_ScrollX) || (outer_window->Flags & ImGuiWindowFlags_AlwaysAutoResize)) ? ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_SizingStretchSame;\n\n    \/\/ Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame\n    if ((flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)\n        flags |= ImGuiTableFlags_NoKeepColumnsVisible;\n\n    \/\/ Adjust flags: enforce borders when resizable\n    if (flags & ImGuiTableFlags_Resizable)\n        flags |= ImGuiTableFlags_BordersInnerV;\n\n    \/\/ Adjust flags: disable NoHostExtendX\/NoHostExtendY if we have any scrolling going on\n    if (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY))\n        flags &= ~(ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_NoHostExtendY);\n\n    \/\/ Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody\n    if (flags & ImGuiTableFlags_NoBordersInBodyUntilResize)\n        flags &= ~ImGuiTableFlags_NoBordersInBody;\n\n    \/\/ Adjust flags: disable saved settings if there's nothing to save\n    if ((flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Sortable)) == 0)\n        flags |= ImGuiTableFlags_NoSavedSettings;\n\n    \/\/ Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)\n    if (outer_window->RootWindow->Flags & ImGuiWindowFlags_NoSavedSettings)\n        flags |= ImGuiTableFlags_NoSavedSettings;\n\n    return flags;\n}",
        "mark":8.25,
        "query_nsx":"        \/* Determine the appropriate flags configuration for an ImGui table based on specified parameters.\n        >>> ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window) *\/",
        "query_nlx":"        \/* Define a function TableFixFlags that adjusts various flags based on specific conditions provided in the input parameters. \n        >>> TableFixFlags(flags, outer_window) \n        Adjusts the input flags to set a default sizing policy if none is specified, enables a specific flag when using a particular sizing option, enforces borders when resizable, disables certain flags if scrolling is present, prioritizes a flag over another in a specific scenario, disables saved settings if certain conditions are not met, and inherits a flag from the top-level window. *\/ \n        ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window) { "
    }

    {
        "file_name":"imgui_tables_function_31.cpp",
        "line_count":4,
        "code":"size_t TableSettingsCalcChunkSize(int columns_count)\n{\n    return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the total size needed for storing table settings based on the number of columns.\n>>> size_t TableSettingsCalcChunkSize(int columns_count); *\/",
        "query_nlx":"\/* Calculate the total size needed to store settings for a table with a given number of columns.\n   >>> TableSettingsCalcChunkSize(5) returns the size in bytes required to store settings for a table with 5 columns\n   >>> TableSettingsCalcChunkSize(10) returns the size in bytes required to store settings for a table with 10 columns *\/\nsize_t TableSettingsCalcChunkSize(int columns_count) { "
    }

    {
        "file_name":"imgui_widgets_function_110.cpp",
        "line_count":6,
        "code":"IMGUI_CDECL TabItemComparerByBeginOrder(const void* lhs, const void* rhs)\n{\n    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;\n    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;\n    return (int)(a->BeginOrder - b->BeginOrder);\n}",
        "mark":8.0,
        "query_nsx":"\/* Compare two tab items based on their beginning order.\n   >>> TabItemComparerByBeginOrder(const void* lhs, const void* rhs) *\/",
        "query_nlx":"\/* Define a comparison function for tab items based on their BeginOrder property.\n   >>> TabItemComparerByBeginOrder({TabItem1, TabItem2}) returns an integer representing the comparison result based on the BeginOrder values of the two tab items. *\/ \nIMGUI_CDECL TabItemComparerByBeginOrder(const void* lhs, const void* rhs) { "
    }

    {
        "file_name":"imgui_widgets_function_12.cpp",
        "line_count":6,
        "code":"int DataTypeCompareT(const T* lhs, const T* rhs)\n{\n    if (*lhs < *rhs) return -1;\n    if (*lhs > *rhs) return +1;\n    return 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Compare two elements of a generic data type and return their relationship.\n   >>> int DataTypeCompareT(const T* lhs, const T* rhs) *\/",
        "query_nlx":"\/* Function named DataTypeCompareT compares two elements of a generic data type and returns -1 if the first element is less than the second, +1 if the first element is greater than the second, and 0 if they are equal.\n>>> DataTypeCompareT(const T* lhs, const T* rhs) *\/"
    }

    {
        "file_name":"imgui_widgets_function_27.cpp",
        "line_count":1,
        "code":"int     STB_TEXTEDIT_STRINGLEN(const ImGuiInputTextState* obj)                             { return obj->CurLenA; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the length of a text string stored in the input text state object.\n   >>> STB_TEXTEDIT_STRINGLEN(const ImGuiInputTextState* obj) *\/",
        "query_nlx":"\/* Function named STB_TEXTEDIT_STRINGLEN calculates the length of a given text input in characters.\n>>> STB_TEXTEDIT_STRINGLEN(obj) returns the length of the text input stored in the object obj. *\/ \nint STB_TEXTEDIT_STRINGLEN(const ImGuiInputTextState* obj) {  *\/"
    }

    {
        "file_name":"imgui_widgets_function_32.cpp",
        "line_count":7,
        "code":"int IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL(ImGuiInputTextState* obj, int idx)\n{\n    if (idx <= 0)\n        return -1;\n    const char* p = ImTextFindPreviousUtf8Codepoint(obj->TextA.Data, obj->TextA.Data + idx);\n    return (int)(p - obj->TextA.Data);\n}",
        "mark":8.0,
        "query_nsx":"        \/* Given a text input state and an index, this function retrieves the index of the previous character in the text.\n        >>> int IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL(ImGuiInputTextState* obj, int idx) { *\/",
        "query_nlx":"        \/* Function named IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL finds the index of the previous character in a given text input state object based on the current index.\n        >>> IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL(obj, idx) returns the index of the previous character in the text input state object.\n        >>> IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL(obj, 5) returns 4 *\/"
    }

    {
        "file_name":"imgui_widgets_function_78.cpp",
        "line_count":7,
        "code":"else if (flags & ImGuiColorEditFlags_InputHSV)\n    {\n        if (flags & ImGuiColorEditFlags_NoAlpha)\n            Text(\"H: %.3f, S: %.3f, V: %.3f\", col[0], col[1], col[2]);\n        else\n            Text(\"H: %.3f, S: %.3f, V: %.3f, A: %.3f\", col[0], col[1], col[2], col[3]);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine the display format based on the input color edit flags, showing the Hue, Saturation, Value, and optionally Alpha values.\n   >>> Display the color values in HSV format with or without Alpha based on the flags provided. *\/ \nelse if (flags & ImGuiColorEditFlags_InputHSV) {",
        "query_nlx":"\/* Query: If the input flags include the ImGuiColorEditFlags_InputHSV flag, display the color values in HSV format. If the ImGuiColorEditFlags_NoAlpha flag is not set, include the alpha value as well.\n   >>> Display the color values in HSV format with or without alpha based on the input flags. *\/\n\nelse if (flags & ImGuiColorEditFlags_InputHSV)\n{\n    \/\/ Code implementation omitted for brevity\n}"
    }

    {
        "file_name":"imgui_widgets_function_86.cpp",
        "line_count":12,
        "code":"void BoxSelectPreStartDrag(ImGuiID id, ImGuiSelectionUserData clicked_item)\n{\n    ImGuiContext& g = *GImGui;\n    ImGuiBoxSelectState* bs = &g.BoxSelectState;\n    bs->ID = id;\n    bs->IsStarting = true; \/\/ Consider starting box-select.\n    bs->IsStartedFromVoid = (clicked_item == ImGuiSelectionUserData_Invalid);\n    bs->IsStartedSetNavIdOnce = bs->IsStartedFromVoid;\n    bs->KeyMods = g.IO.KeyMods;\n    bs->StartPosRel = bs->EndPosRel = ImGui::WindowPosAbsToRel(g.CurrentWindow, g.IO.MousePos);\n    bs->ScrollAccum = ImVec2(0.0f, 0.0f);\n}",
        "mark":8.0,
        "query_nsx":"        \/* Initialize box-select state for starting a selection drag operation.\n        >>> BoxSelectPreStartDrag(123, some_item) *\/",
        "query_nlx":"        \/* Define a function named BoxSelectPreStartDrag that updates the state of a box selection based on user interaction.\n        >>> BoxSelectPreStartDrag(123, some_clicked_item) *\/ \n        void BoxSelectPreStartDrag(ImGuiID id, ImGuiSelectionUserData clicked_item) {"
    }

    {
        "file_name":"imgui_widgets_function_88.cpp",
        "line_count":11,
        "code":"void BoxSelectDeactivateDrag(ImGuiBoxSelectState* bs)\n{\n    ImGuiContext& g = *GImGui;\n    bs->IsActive = bs->IsStarting = false;\n    if (g.ActiveId == bs->ID)\n    {\n        IMGUI_DEBUG_LOG_SELECTION(\"[selection] BeginBoxSelect() 0X%08X: Deactivate\\n\", bs->ID);\n        ImGui::ClearActiveID();\n    }\n    bs->ID = 0;\n}",
        "mark":8.0,
        "query_nsx":"        \/* Deactivate box selection drag operation.\n        >>> void BoxSelectDeactivateDrag(ImGuiBoxSelectState* bs) { *\/",
        "query_nlx":"        \/* Function named BoxSelectDeactivateDrag deactivates the box selection drag operation by resetting the state variables and clearing the active ID if necessary.\n        >>> BoxSelectDeactivateDrag(ImGuiBoxSelectState* bs) *\/"
    }

    {
        "file_name":"imgui_widgets_function_9.cpp",
        "line_count":7,
        "code":"float CalcMaxPopupHeightFromItemCount(int items_count)\n{\n    ImGuiContext& g = *GImGui;\n    if (items_count <= 0)\n        return FLT_MAX;\n    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the maximum height for a popup based on the number of items to be displayed.\n   >>> CalcMaxPopupHeightFromItemCount(int items_count) float *\/",
        "query_nlx":"\/* Calculate the maximum height of a popup based on the number of items it contains.\n   >>> CalcMaxPopupHeightFromItemCount(5) 65.0\n   >>> CalcMaxPopupHeightFromItemCount(0) FLT_MAX *\/ \nfloat CalcMaxPopupHeightFromItemCount(int items_count) {"
    }

    {
        "file_name":"imgui_widgets_function_98.cpp",
        "line_count":6,
        "code":"IMGUI_CDECL PairComparerByValueInt(const void* lhs, const void* rhs)\n{\n    int lhs_v = ((const ImGuiStoragePair*)lhs)->val_i;\n    int rhs_v = ((const ImGuiStoragePair*)rhs)->val_i;\n    return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1 : 0);\n}",
        "mark":8.0,
        "query_nsx":"\/* Compare pairs of values represented by integers and return their relative order.\n   >>> PairComparerByValueInt(const void* lhs, const void* rhs) *\/",
        "query_nlx":"\/* Define a function that compares pairs of values by their integer values. The function takes two void pointers as input and extracts the integer values from each pair. It then compares the integer values and returns +1 if the left-hand side value is greater than the right-hand side value, -1 if the left-hand side value is less than the right-hand side value, and 0 if they are equal.\n>>> PairComparerByValueInt(lhs: void*, rhs: void*) *\/"
    }

    {
        "file_name":"imstb_textedit_function_17.cpp",
        "line_count":7,
        "code":"void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)\n{\n   if (!STB_TEXT_HAS_SELECTION(state))\n      state->select_start = state->select_end = state->cursor;\n   else\n      state->cursor = state->select_end;\n}",
        "mark":8.0,
        "query_nsx":"\/* Prepare the selection at the cursor position in the text editor state.\n   >>> stb_textedit_prep_selection_at_cursor(STB_TexteditState *state) *\/",
        "query_nlx":"\/* Function named stb_textedit_prep_selection_at_cursor updates the selection start and end positions based on the cursor position in a text editing state.\n>>> stb_textedit_prep_selection_at_cursor(state) updates the selection start and end positions to the cursor position if there is no existing selection.\n>>> stb_textedit_prep_selection_at_cursor(state) sets the cursor position to the selection end if there is an existing selection. *\/ \nvoid stb_textedit_prep_selection_at_cursor(STB_TexteditState *state) { "
    }

    {
        "file_name":"imstb_textedit_function_18.cpp",
        "line_count":9,
        "code":"int stb_textedit_cut(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      stb_textedit_delete_selection(str,state); \/\/ implicitly clamps\n      state->has_preferred_x = 0;\n      return 1;\n   }\n   return 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Cut the selected text in the text editor if there is a selection.\n>>> stb_textedit_cut(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) *\/",
        "query_nlx":"        \/* Function stb_textedit_cut deletes the selected text in a text editor if there is a selection present, resetting the preferred x-coordinate to 0.\n        >>> stb_textedit_cut(str, state) returns 1 if text was successfully cut, 0 otherwise. *\/ \n        int stb_textedit_cut(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {"
    }

    {
        "file_name":"imstb_textedit_function_33.cpp",
        "line_count":4,
        "code":"void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)\n{\n   stb_text_createundo(&state->undostate, where, 0, length);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an undo state for inserting text at a specific position with a given length.\n>>> void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length) *\/",
        "query_nlx":"\/* Create an undo operation for inserting text at a specific position with a given length in the text editor state.\n   >>> stb_text_makeundo_insert(state, 5, 10) *\/ \nvoid stb_text_makeundo_insert(STB_TexteditState *state, int where, int length) { "
    }

    {
        "file_name":"imstb_textedit_function_38.cpp",
        "line_count":4,
        "code":"int stb_textedit_paste(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE const *ctext, int len)\n{\n   return stb_textedit_paste_internal(str, state, (IMSTB_TEXTEDIT_CHARTYPE *) ctext, len);\n}",
        "mark":8.0,
        "query_nsx":"\/* Paste the given text into the text editor's state.\n   >>> stb_textedit_paste(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE const *ctext, int len) *\/",
        "query_nlx":"\/* Function named stb_textedit_paste takes a string, text editing state, character array, and length as input parameters and calls an internal function to paste the character array into the string. \n>>> stb_textedit_paste(str, state, ctext, len) *\/ \nint stb_textedit_paste(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE const *ctext, int len) {"
    }

    {
        "file_name":"imstb_textedit_function_8.cpp",
        "line_count":12,
        "code":"void stb_textedit_clamp(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)\n{\n   int n = STB_TEXTEDIT_STRINGLEN(str);\n   if (STB_TEXT_HAS_SELECTION(state)) {\n      if (state->select_start > n) state->select_start = n;\n      if (state->select_end   > n) state->select_end = n;\n      \/\/ if clamping forced them to be equal, move the cursor to match\n      if (state->select_start == state->select_end)\n         state->cursor = state->select_start;\n   }\n   if (state->cursor > n) state->cursor = n;\n}",
        "mark":8.0,
        "query_nsx":"\/* Ensure that the text cursor and selection boundaries are within the valid range of the text content.\n>>> stb_textedit_clamp(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) *\/",
        "query_nlx":"        \/* Function stb_textedit_clamp clamps the selection and cursor positions within the bounds of the given text string length.\n        >>> stb_textedit_clamp(str, state) clamps the selection and cursor positions to be within the length of the text string.\n        *\/ \n        void stb_textedit_clamp(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) { "
    }

    {
        "file_name":"imstb_truetype_function_11.cpp",
        "line_count":8,
        "code":"stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)\n{\n   stbtt__buf r = stbtt__new_buf(NULL, 0);\n   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;\n   r.data = b->data + o;\n   r.size = s;\n   return r;\n}",
        "mark":8.0,
        "query_nsx":"\/* Extract a range of data from a buffer based on specified offsets and size.\n   >>> stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s) *\/",
        "query_nlx":"        \/* Function named stbtt__buf_range creates a new buffer that is a subset of the input buffer based on the given offset and size parameters. \n        >>> stbtt__buf_range(b, o, s) returns a new buffer containing data from buffer b starting at offset o with a size of s. *\/ \n        stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s) { "
    }

    {
        "file_name":"imstb_truetype_function_115.cpp",
        "line_count":6,
        "code":"void stbtt__add_point(stbtt__point *points, int n, float x, float y)\n{\n   if (!points) return; \/\/ during first pass, it's unallocated\n   points[n].x = x;\n   points[n].y = y;\n}",
        "mark":8.0,
        "query_nsx":"\/* Update the coordinates of a point in a collection of points.\n   >>> void stbtt__add_point(stbtt__point *points, int n, float x, float y) *\/",
        "query_nlx":"        \/* Function named stbtt__add_point adds a point with given x and y coordinates to an array of points at a specific index.\n        >>> stbtt__add_point(points, n, 3.5, 2.0) \n        This function adds a point with x coordinate 3.5 and y coordinate 2.0 to the array of points at index n. *\/ \n        void stbtt__add_point(stbtt__point *points, int n, float x, float y) { "
    }

    {
        "file_name":"imstb_truetype_function_120.cpp",
        "line_count":4,
        "code":"void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}",
        "mark":8.0,
        "query_nsx":"\/* Free the allocated memory for a bitmap image.\n>>> stbtt_FreeBitmap(unsigned char *bitmap, void *userdata) *\/",
        "query_nlx":"\/* Function named stbtt_FreeBitmap deallocates memory for a given bitmap using a provided function. \n>>> stbtt_FreeBitmap(bitmap, userdata) *\/ \nvoid stbtt_FreeBitmap(unsigned char *bitmap, void *userdata) { "
    }

    {
        "file_name":"imstb_truetype_function_122.cpp",
        "line_count":4,
        "code":"void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);\n}",
        "mark":8.0,
        "query_nsx":"\/* Generate a glyph bitmap using the specified font information and scaling factors.\n>>> stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph) *\/",
        "query_nlx":"\n\/* This function generates a glyph bitmap using the specified font information, output buffer, dimensions, scaling factors, and glyph index.\n>>> stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph) *\/"
    }

    {
        "file_name":"imstb_truetype_function_124.cpp",
        "line_count":4,
        "code":"void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)\n{\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));\n}",
        "mark":8.0,
        "query_nsx":"\/* Generate a subpixel bitmap for a specified codepoint using the provided font information and scaling parameters.\n>>> stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint) *\/",
        "query_nlx":"\/* Function stbtt_MakeCodepointBitmapSubpixel generates a subpixel-optimized bitmap for a specified codepoint in a given font, applying scaling and shifting factors. \n>>> stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, codepoint) *\/ \n*\/ \n*\/"
    }

    {
        "file_name":"imstb_truetype_function_127.cpp",
        "line_count":10,
        "code":"void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)\n{\n   con->width  = pw;\n   con->height = ph;\n   con->x = 0;\n   con->y = 0;\n   con->bottom_y = 0;\n   STBTT__NOTUSED(nodes);\n   STBTT__NOTUSED(num_nodes);\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize the target context with the specified width and height values.\n   >>> stbrp_init_target(con, 800, 600, nodes, 10) *\/ \nvoid stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes) { ",
        "query_nlx":"\/* Initialize the target dimensions and position within a context using the provided width and height values. \n   >>> stbrp_init_target(con, 800, 600, nodes, 10) *\/ \nvoid stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes) {"
    }

    {
        "file_name":"imstb_truetype_function_130.cpp",
        "line_count":5,
        "code":"void stbtt_PackEnd  (stbtt_pack_context *spc)\n{\n   STBTT_free(spc->nodes    , spc->user_allocator_context);\n   STBTT_free(spc->pack_info, spc->user_allocator_context);\n}",
        "mark":8.0,
        "query_nsx":"\/* Free memory allocated for packing context.\n   >>> stbtt_PackEnd(spc) *\/ \nvoid stbtt_PackEnd(stbtt_pack_context *spc) {",
        "query_nlx":"\/* Function named stbtt_PackEnd deallocates memory for the nodes and pack_info arrays using the user-provided allocator context.\n>>> stbtt_PackEnd(spc) *\/ \nvoid stbtt_PackEnd(stbtt_pack_context *spc) { "
    }

    {
        "file_name":"imstb_truetype_function_132.cpp",
        "line_count":4,
        "code":"void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)\n{\n   spc->skip_missing = skip;\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the option to skip missing codepoints in the packing context.\n>>> void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip) { *\/",
        "query_nlx":"\/* Define a function that allows setting whether to skip missing codepoints during packing.\n   >>> stbtt_PackSetSkipMissingCodepoints(spc, skip)\n   where spc is the pack context and skip is a boolean flag indicating whether to skip missing codepoints. *\/ \nvoid stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip) {  *\/"
    }

    {
        "file_name":"imstb_truetype_function_139.cpp",
        "line_count":11,
        "code":"float stbtt__oversample_shift(int oversample)\n{\n   if (!oversample)\n      return 0.0f;\n\n   \/\/ The prefilter is a box filter of width \"oversample\",\n   \/\/ which shifts phase by (oversample - 1)\/2 pixels in\n   \/\/ oversampled space. We want to shift in the opposite\n   \/\/ direction to counter this.\n   return (float)-(oversample - 1) \/ (2.0f * (float)oversample);\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the shift value based on the oversampling factor to counteract the phase shift caused by the prefilter.\n   >>> float stbtt__oversample_shift(int oversample) *\/",
        "query_nlx":"        \/* Function calculates the shift value based on the oversample factor to counteract the phase shift caused by a box filter.\n        >>> stbtt__oversample_shift(0) 0.0\n        >>> stbtt__oversample_shift(2) -0.25\n        >>> stbtt__oversample_shift(4) -0.375 *\/ \n        float stbtt__oversample_shift(int oversample) { "
    }

    {
        "file_name":"imstb_truetype_function_148.cpp",
        "line_count":12,
        "code":"void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)\n{\n   int i_ascent, i_descent, i_lineGap;\n   float scale;\n   stbtt_fontinfo info;\n   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));\n   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);\n   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);\n   *ascent  = (float) i_ascent  * scale;\n   *descent = (float) i_descent * scale;\n   *lineGap = (float) i_lineGap * scale;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the vertical metrics of a scaled font based on the provided font data, index, and size.\n>>> stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap) *\/",
        "query_nlx":"        \/* Function named stbtt_GetScaledFontVMetrics calculates the vertical metrics of a font scaled to a specified size. \n        >>> stbtt_GetScaledFontVMetrics(fontdata, index, size, &ascent, &descent, &lineGap) *\/ \n        void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap) { "
    }

    {
        "file_name":"imstb_truetype_function_160.cpp",
        "line_count":4,
        "code":"void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)\n{\n   STBTT_free(bitmap, userdata);\n}",
        "mark":8.0,
        "query_nsx":"\/* Free the memory allocated for a signed distance field (SDF) bitmap.\n>>> stbtt_FreeSDF(unsigned char *bitmap, void *userdata) *\/",
        "query_nlx":"\/* Function named stbtt_FreeSDF deallocates memory for a given bitmap and associated user data.\n>>> stbtt_FreeSDF(bitmap, userdata) *\/ \nvoid stbtt_FreeSDF(unsigned char *bitmap, void *userdata) { "
    }

    {
        "file_name":"imstb_truetype_function_172.cpp",
        "line_count":4,
        "code":"int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)\n{\n   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the font offset for a specific index from the font data.\n   >>> int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index) *\/",
        "query_nlx":"\/* Retrieve the font offset for a given index from the provided data array.\n   >>> stbtt_GetFontOffsetForIndex(data, index) int *\/"
    }

    {
        "file_name":"imstb_truetype_function_173.cpp",
        "line_count":4,
        "code":"int stbtt_GetNumberOfFonts(const unsigned char *data)\n{\n   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the number of fonts present in the provided data.\n>>> int stbtt_GetNumberOfFonts(const unsigned char *data) *\/",
        "query_nlx":"\/* Function named stbtt_GetNumberOfFonts calculates the number of fonts present in a given data array by calling an internal function with a typecasted data pointer.\n>>> stbtt_GetNumberOfFonts(data) returns the number of fonts in the data array *\/ \nint stbtt_GetNumberOfFonts(const unsigned char *data) { "
    }

    {
        "file_name":"imstb_truetype_function_174.cpp",
        "line_count":4,
        "code":"int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)\n{\n   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize a font using the provided font information and data.\n   >>> stbtt_InitFont(info, data, offset)\n*\/ \nint stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset) {",
        "query_nlx":"\/* Function named stbtt_InitFont initializes a font using the provided font information, data, and offset.\n>>> stbtt_InitFont(info, data, offset) int *\/"
    }

    {
        "file_name":"imstb_truetype_function_21.cpp",
        "line_count":1,
        "code":"stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }",
        "mark":8.0,
        "query_nsx":"\/* Extract an unsigned 32-bit integer from a given array of bytes.\n   >>> ttULONG(unsigned char *data) *\/",
        "query_nlx":"\/* Function named ttULONG takes an array of unsigned 8-bit integers and combines them to form a 32-bit unsigned integer value. \n>>> ttULONG({255, 255, 255, 255}) 4294967295 \n>>> ttULONG({0, 0, 0, 0}) 0 *\/ \nstbtt_uint32 ttULONG(stbtt_uint8 *p) { *\/"
    }

    {
        "file_name":"imstb_truetype_function_22.cpp",
        "line_count":1,
        "code":"stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }",
        "mark":8.0,
        "query_nsx":"\/* Extract a 32-bit integer value from a given array of unsigned 8-bit integers.\n   >>> ttLONG(p) *\/",
        "query_nlx":"\/* Function named ttLONG takes an array of unsigned 8-bit integers and combines them to form a 32-bit signed integer. \n>>> ttLONG({255, 255, 255, 255}) returns -1 \n>>> ttLONG({0, 0, 0, 0}) returns 0 *\/ \nstbtt_int32 ttLONG(stbtt_uint8 *p) { *\/"
    }

    {
        "file_name":"imstb_truetype_function_35.cpp",
        "line_count":4,
        "code":"int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)\n{\n   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);\n}",
        "mark":8.0,
        "query_nsx":"\n\/* Retrieve the shape of a specified Unicode codepoint from a font.\n>>> int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices) { *\/",
        "query_nlx":"\/* Function named stbtt_GetCodepointShape retrieves the shape of a given Unicode codepoint from a font using the provided font information and stores the vertices in a pointer to a vertex array.\n>>> stbtt_GetCodepointShape(info, unicode_codepoint, vertices) returns the shape of the specified Unicode codepoint as vertices. *\/ \nint stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices) { "
    }

    {
        "file_name":"imstb_truetype_function_36.cpp",
        "line_count":8,
        "code":"void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)\n{\n   v->type = type;\n   v->x = (stbtt_int16) x;\n   v->y = (stbtt_int16) y;\n   v->cx = (stbtt_int16) cx;\n   v->cy = (stbtt_int16) cy;\n}",
        "mark":8.5,
        "query_nsx":"\/* Set the type, coordinates, and control points for a vertex in a font glyph. \n>>> stbtt_setvertex(v, type, x, y, cx, cy) *\/ \nvoid stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy) {  *\/",
        "query_nlx":"\/* Define a function stbtt_setvertex that sets the properties of a vertex including its type, coordinates, and control points.\n>>> stbtt_setvertex(v, type, x, y, cx, cy) void *\/"
    }

    {
        "file_name":"imstb_truetype_function_40.cpp",
        "line_count":4,
        "code":"int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)\n{\n   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);\n}",
        "mark":8.0,
        "query_nsx":"        \/* Retrieve the bounding box coordinates of a specified codepoint in a font. \n        >>> int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1) { *\/",
        "query_nlx":"        \/* Function named stbtt_GetCodepointBox retrieves the bounding box coordinates of a specified codepoint in a font using the provided font information.\n        >>> stbtt_GetCodepointBox(font_info, codepoint, &x0, &y0, &x1, &y1) returns the bounding box coordinates of the specified codepoint in the font. *\/ \n        int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1) { "
    }

    {
        "file_name":"imstb_truetype_function_5.cpp",
        "line_count":6,
        "code":"stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor++];\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the next 8-bit unsigned integer from the buffer if available.\n   >>> stbtt__buf_get8(buffer) \n*\/",
        "query_nlx":"\/* Define a function that retrieves an unsigned 8-bit integer from a buffer. The function should increment the cursor position in the buffer after retrieval. \n   >>> stbtt__buf_get8(buffer) returns an unsigned 8-bit integer from the buffer. If the cursor position is at the end of the buffer, it returns 0. *\/ \nstbtt_uint8 stbtt__buf_get8(stbtt__buf *b) {  *\/"
    }

    {
        "file_name":"imstb_truetype_function_51.cpp",
        "line_count":7,
        "code":"void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   stbtt__csctx_close_shape(ctx);\n   ctx->first_x = ctx->x = ctx->x + dx;\n   ctx->first_y = ctx->y = ctx->y + dy;\n   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}",
        "mark":8.0,
        "query_nsx":"\/* Move the current context to a new position specified by the given offsets.\n   >>> stbtt__csctx_rmove_to(ctx, dx, dy) *\/",
        "query_nlx":"\/* Define a function stbtt__csctx_rmove_to that updates the current context by moving the pen position by a specified amount in the x and y directions. \n   >>> stbtt__csctx_rmove_to(ctx, dx, dy) \n   - This function closes the current shape in the context, sets the new pen position by adding the specified dx and dy values to the current x and y positions, and then moves the pen to the new position. *\/ \nvoid stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy) { "
    }

    {
        "file_name":"imstb_truetype_function_52.cpp",
        "line_count":6,
        "code":"void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)\n{\n   ctx->x += dx;\n   ctx->y += dy;\n   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);\n}",
        "mark":8.0,
        "query_nsx":"\/* Update the current position by moving a specified distance in the x and y directions.\n   >>> stbtt__csctx_rline_to(ctx, 2.0, 3.0) *\/ \nvoid stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy) {  *\/",
        "query_nlx":"\/* Function stbtt__csctx_rline_to updates the current context position by adding the specified increments in the x and y directions and then draws a vertical line to the new position.\n>>> stbtt__csctx_rline_to(ctx, 2.0, 3.0) *\/ \nvoid stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy) { *\/"
    }

    {
        "file_name":"imstb_truetype_function_6.cpp",
        "line_count":6,
        "code":"stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor];\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the next unsigned 8-bit integer from the buffer if available.\n   >>> stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b) *\/",
        "query_nlx":"\/* Define a function that retrieves the next unsigned 8-bit integer from a buffer if the cursor position is within the buffer size.\n   >>> stbtt__buf_peek8(buffer) returns the next unsigned 8-bit integer from the buffer if the cursor position is valid, otherwise returns 0. *\/ \nstbtt_uint8 stbtt__buf_peek8(stbtt__buf *b) { *\/"
    }

    {
        "file_name":"imstb_truetype_function_70.cpp",
        "line_count":11,
        "code":"int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)\n{\n   int xAdvance = 0;\n\n   if (info->gpos)\n      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);\n   else if (info->kern)\n      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);\n\n   return xAdvance;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the advance width between two glyphs based on font information.\n   >>> int stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2) { *\/",
        "query_nlx":"        \/* Function stbtt_GetGlyphKernAdvance calculates the kerning advance between two glyphs in a font using the provided font information.\n        >>> stbtt_GetGlyphKernAdvance(info, g1, g2) returns the kerning advance between glyphs g1 and g2 based on the font information provided in 'info'. *\/ \n        int stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2) { "
    }

    {
        "file_name":"imstb_truetype_function_71.cpp",
        "line_count":6,
        "code":"int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)\n{\n   if (!info->kern && !info->gpos) \/\/ if no kerning table, don't waste time looking up both codepoint->glyphs\n      return 0;\n   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));\n}",
        "mark":8.0,
        "query_nsx":"        \/* Determine the kerning advance between two specified characters in a font.\n        >>> int stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2) { *\/",
        "query_nlx":"        \/* Function stbtt_GetCodepointKernAdvance calculates the kerning advance between two given codepoints in a font using the provided font information.\n        >>> stbtt_GetCodepointKernAdvance(info, ch1, ch2) int *\/"
    }

    {
        "file_name":"imstb_truetype_function_72.cpp",
        "line_count":4,
        "code":"void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)\n{\n   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve horizontal metrics (advance width and left side bearing) for a given codepoint in a font. \n>>> void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing) { *\/",
        "query_nlx":"\/* Retrieve the horizontal metrics (advance width and left side bearing) for a given codepoint in a font using the provided font information.\n   >>> stbtt_GetCodepointHMetrics(info, codepoint, &advanceWidth, &leftSideBearing) *\/ \nvoid stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing) { "
    }

    {
        "file_name":"imstb_truetype_function_73.cpp",
        "line_count":6,
        "code":"void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)\n{\n   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);\n   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);\n   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the vertical metrics of a font including ascent, descent, and line gap values.\n   >>> stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap) *\/",
        "query_nlx":"\/* Query: Define a function that retrieves the vertical metrics of a font given its information, including the ascent, descent, and line gap values.\n   >>> stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap){ *\/"
    }

    {
        "file_name":"imstb_truetype_function_74.cpp",
        "line_count":10,
        "code":"int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)\n{\n   int tab = stbtt__find_table(info->data, info->fontstart, \"OS\/2\");\n   if (!tab)\n      return 0;\n   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);\n   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);\n   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);\n   return 1;\n}",
        "mark":8.0,
        "query_nsx":"        \/* Retrieve font vertical metrics information from the OS\/2 table.\n        >>> int stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap) { *\/",
        "query_nlx":"        \/* Function named stbtt_GetFontVMetricsOS2 retrieves the vertical metrics information for a font from the OS\/2 table.\n        >>> stbtt_GetFontVMetricsOS2(info, typoAscent, typoDescent, typoLineGap) returns 1 if successful, 0 if the OS\/2 table is not found.\n        >>> The function populates the typoAscent, typoDescent, and typoLineGap values with the corresponding metrics from the font data. *\/ \n        int stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap) { "
    }

    {
        "file_name":"imstb_truetype_function_8.cpp",
        "line_count":4,
        "code":"void stbtt__buf_skip(stbtt__buf *b, int o)\n{\n   stbtt__buf_seek(b, b->cursor + o);\n}",
        "mark":8.0,
        "query_nsx":"            \/* Skip a specified number of bytes in the buffer.\n            >>> void stbtt__buf_skip(stbtt__buf *b, int o) *\/",
        "query_nlx":"\/* Function named stbtt__buf_skip moves the cursor position in a buffer by a specified offset amount.\n>>> stbtt__buf_skip(buffer, 10) moves the cursor position in the buffer forward by 10 units.\n>>> stbtt__buf_skip(buffer, -5) moves the cursor position in the buffer backward by 5 units. *\/ \nvoid stbtt__buf_skip(stbtt__buf *b, int o) {  \/\/ Function signature\n    \/\/ Function body omitted\n} \/\/ End of function"
    }

    {
        "file_name":"imstb_truetype_function_80.cpp",
        "line_count":4,
        "code":"int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)\n{\n   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the SVG representation of a specified Unicode codepoint using the provided font information.\n   >>> int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg) { *\/",
        "query_nlx":"\/* Function named stbtt_GetCodepointSVG retrieves the SVG representation of a given Unicode codepoint from a font information structure.\n>>> stbtt_GetCodepointSVG(info, unicode_codepoint, svg) returns the SVG representation of the glyph corresponding to the Unicode codepoint in the font information.\n*\/ \nint stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg) { *\/"
    }

    {
        "file_name":"imstb_truetype_function_82.cpp",
        "line_count":4,
        "code":"void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the bounding box of the glyph bitmap based on the provided font information, glyph index, and scaling factors.\n   >>> stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1) *\/",
        "query_nlx":"\/* Define a function that retrieves the bounding box of a glyph in a font based on the provided scaling factors. \n   The function takes the font information, glyph index, scaling factors for x and y axes, and pointers to integers for the bounding box coordinates as input parameters. \n   It internally calls another function to calculate the glyph bitmap box with subpixel precision. \n   The function signature is as follows: *\/\nvoid stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1) { \n    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1); \n} \n*\/"
    }

    {
        "file_name":"imstb_truetype_function_83.cpp",
        "line_count":4,
        "code":"void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the bounding box of the bitmap for a specified codepoint with subpixel positioning.\n   >>> stbtt_GetCodepointBitmapBoxSubpixel(const font, codepoint, scale_x, scale_y, shift_x, shift_y, ix0, iy0, ix1, iy1) *\/",
        "query_nlx":"\/* Define a function that calculates the bounding box of a bitmap for a given codepoint in a font with subpixel positioning.\n   The function takes the font information, codepoint, scaling factors for x and y axes, shift values for x and y axes, and pointers to integers for the output bounding box coordinates.\n   The function internally calls another function to retrieve the glyph bitmap box with subpixel precision.\n   >>> stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y, shift_x, shift_y, &ix0, &iy0, &ix1, &iy1) *\/ \nvoid stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1) { "
    }

    {
        "file_name":"imstb_truetype_function_84.cpp",
        "line_count":4,
        "code":"void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\n{\n   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the bounding box of the bitmap for a specific codepoint in a font scaled by the given factors.\n>>> void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1) *\/",
        "query_nlx":"\/* Define a function that retrieves the bounding box of the bitmap for a given codepoint in a font, taking into account scaling factors in both x and y directions. The function delegates the task to another function that includes subpixel precision.\n>>> stbtt_GetCodepointBitmapBox(font, codepoint, scale_x, scale_y, ix0, iy0, ix1, iy1) *\/ \nvoid stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1) { "
    }

    {
        "file_name":"imstb_truetype_function_86.cpp",
        "line_count":9,
        "code":"void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)\n{\n   stbtt__hheap_chunk *c = hh->head;\n   while (c) {\n      stbtt__hheap_chunk *n = c->next;\n      STBTT_free(c, userdata);\n      c = n;\n   }\n}",
        "mark":8.0,
        "query_nsx":"\/* Clean up a heap data structure by freeing memory allocated for each chunk.\n   >>> stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata) *\/",
        "query_nlx":"\/* Function stbtt__hheap_cleanup deallocates memory used by a custom heap structure by iterating through its chunks and freeing them one by one.\n>>> stbtt__hheap_cleanup(hh, userdata) *\/ \nvoid stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata) { "
    }

    {
        "file_name":"imstb_truetype_function_9.cpp",
        "line_count":9,
        "code":"stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)\n{\n   stbtt_uint32 v = 0;\n   int i;\n   STBTT_assert(n >= 1 && n <= 4);\n   for (i = 0; i < n; i++)\n      v = (v << 8) | stbtt__buf_get8(b);\n   return v;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a 32-bit unsigned integer value from a buffer by combining 1 to 4 bytes.\n>>> stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n) *\/",
        "query_nlx":"\/* Define a function that reads a specified number of bytes from a buffer and combines them into a single 32-bit unsigned integer value.\n   >>> stbtt__buf_get(buffer, num_bytes) \n   where buffer is the input buffer and num_bytes is the number of bytes to read from the buffer. \n   The function returns the combined 32-bit unsigned integer value. *\/ \nstbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n) { "
    }

    {
        "file_name":"imstb_truetype_function_95.cpp",
        "line_count":6,
        "code":"float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)\n{\n   STBTT_assert(top_width >= 0);\n   STBTT_assert(bottom_width >= 0);\n   return (top_width + bottom_width) \/ 2.0f * height;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the area of a trapezoid given its height, top width, and bottom width.\n>>> float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width) { *\/",
        "query_nlx":"\/* Calculate the area of a trapezoid given its height, top width, and bottom width.\n   >>> stbtt__sized_trapezoid_area(5.0, 3.0, 7.0) returns 25.0\n   >>> stbtt__sized_trapezoid_area(8.0, 4.5, 4.5) returns 36.0 *\/ \nfloat stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width) { "
    }

    {
        "file_name":"imstb_truetype_function_97.cpp",
        "line_count":4,
        "code":"float stbtt__sized_triangle_area(float height, float width)\n{\n   return height * width \/ 2;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the area of a triangle given its height and width.\n>>> float stbtt__sized_triangle_area(float height, float width) { *\/",
        "query_nlx":"\/* Function named stbtt__sized_triangle_area calculates the area of a triangle given its height and width. \n>>> stbtt__sized_triangle_area(5.0, 10.0) 25.0 \n>>> stbtt__sized_triangle_area(3.5, 7.0) 12.25 *\/ \nfloat stbtt__sized_triangle_area(float height, float width) {"
    }

    {
        "file_name":"inputtino_common_function_1.cpp",
        "line_count":4,
        "code":"float\n  deg2rad(float degree) {\n    return degree * (M_PI \/ 180.f);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert degrees to radians.\n   >>> deg2rad(float degree) { *\/",
        "query_nlx":"\/* Function named deg2rad converts a given angle in degrees to radians using the formula: angle in radians = angle in degrees * (π \/ 180). \n>>> deg2rad(90) returns 1.5708 \n>>> deg2rad(45) returns 0.7854 *\/ \nfloat deg2rad(float degree) {"
    }

    {
        "file_name":"input_function_53.cpp",
        "line_count":4,
        "code":"else if (config::input.gamepad == \"ds4\"sv) {\n      BOOST_LOG(info) << \"Gamepad \" << id.globalIndex << \" will be DualShock 4 controller (manual selection)\"sv;\n      selectedGamepadType = DualShock4Wired;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine the selected gamepad type based on the configuration input.\n   >>> determine_selected_gamepad_type(config::input.gamepad) *\/ \n  #include<iostream>\n  #include \"boost\/log\/core.hpp\"\n   #include \"boost\/log\/trivial.hpp\"\n   #include \"boost\/log\/expressions.hpp\"\n   using namespace std;\n   void determine_selected_gamepad_type(string gamepad) { ",
        "query_nlx":"\/* Determine the selected gamepad type based on the configuration input. If the gamepad is set to \"ds4\", then set the selected gamepad type to DualShock 4 wired controller.\n   >>> selectedGamepadType = DualShock4Wired *\/ \nelse if (config::input.gamepad == \"ds4\"sv) { "
    }

    {
        "file_name":"InstallNitro_function_2.cpp",
        "line_count":5,
        "code":"void install(jsi::Runtime& runtime) {\n  \/\/ Installs global.NitroModulesProxy\n  auto proxy = std::make_shared<HybridNitroModulesProxy>();\n  runtime.global().setProperty(runtime, \"NitroModulesProxy\", proxy->toObject(runtime));\n}",
        "mark":8.0,
        "query_nsx":"        \/* Install global NitroModulesProxy object in the runtime environment.\n        >>> void install(jsi::Runtime& runtime) { *\/",
        "query_nlx":"        \/* Function named install sets up a global property named NitroModulesProxy in the runtime environment using a HybridNitroModulesProxy object.\n        >>> install(runtime) *\/ \n        void install(jsi::Runtime& runtime) {"
    }

    {
        "file_name":"io_control_function_1.cpp",
        "line_count":4,
        "code":"void set(std::size_t value)\n  {\n    value_ = static_cast<detail::ioctl_arg_type>(value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the value of a variable to the specified size.\n   >>> void set(std::size_t value) *\/",
        "query_nlx":"\/* Define a function named set that takes a single parameter of type size_t and assigns it to a variable value_ after converting it to a specific type. *\/\nvoid set(std::size_t value) { "
    }

    {
        "file_name":"io_uring_file_service_function_4.cpp",
        "line_count":4,
        "code":"void destroy(implementation_type& impl)\n  {\n    descriptor_service_.destroy(impl);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Destroy the implementation type using the descriptor service.\n   >>> destroy(impl_type& impl) *\/",
        "query_nlx":"\/* Function named destroy takes an implementation type object and destroys it using the descriptor service.\n>>> destroy(impl_type) *\/ \nvoid destroy(implementation_type& impl) {"
    }

    {
        "file_name":"io_uring_file_service_function_6.cpp",
        "line_count":4,
        "code":"void set_is_stream(implementation_type& impl, bool is_stream)\n  {\n    impl.is_stream_ = is_stream;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag indicating whether the implementation is a stream or not.\n   >>> void set_is_stream(implementation_type& impl, bool is_stream) { *\/",
        "query_nlx":"\/* Function named set_is_stream modifies the is_stream attribute of a given implementation object to the provided boolean value.\n>>> set_is_stream(impl, true) sets the is_stream attribute of the implementation object to true.\n>>> set_is_stream(impl, false) sets the is_stream attribute of the implementation object to false. *\/ \nvoid set_is_stream(implementation_type& impl, bool is_stream) { "
    }

    {
        "file_name":"io_uring_service_function_1.cpp",
        "line_count":1,
        "code":"void set_result(int r) { task_result_ = static_cast<unsigned>(r); }",
        "mark":8.0,
        "query_nsx":"\/* Set the result of a task to the given integer value. \n   >>> set_result(5) *\/ \nvoid set_result(int r) { ",
        "query_nlx":"\/* Define a function named set_result that takes an integer input and sets the task result to that integer value. \n   >>> set_result(5) *\/ \nvoid set_result(int r) { "
    }

    {
        "file_name":"io_uring_socket_service_base_function_1.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle(base_implementation_type& impl)\n  {\n    return impl.socket_;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the native handle associated with the base implementation type.\n   >>> native_handle_type native_handle(base_implementation_type& impl) *\/",
        "query_nlx":"\/* Retrieve the native handle from the base implementation type, returning the socket value.\n   >>> native_handle(base_implementation_type& impl) \n*\/"
    }

    {
        "file_name":"io_uring_socket_service_function_6.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    return impl.socket_;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the underlying socket handle from the implementation for further use.\n   >>> native_handle_type native_handle(implementation_type& impl) { *\/",
        "query_nlx":"\/* Retrieve the native handle from the implementation type and return it.\n   >>> native_handle(implementation_type& impl) \n*\/"
    }

    {
        "file_name":"iprogs_mutex_function_1.cpp",
        "line_count":4,
        "code":"void lock()\n  {\n    mutex_.lock();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Ensure exclusive access to a shared resource by acquiring a lock.\n   >>> lock() *\/ \nvoid lock() { ",
        "query_nlx":"\/* Define a function that locks a resource using a mutex.\n   >>> lock() *\/ \nvoid lock() {"
    }

    {
        "file_name":"iprogs_mutex_function_2.cpp",
        "line_count":4,
        "code":"void unlock()\n  {\n    mutex_.unlock();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Unlock a mutex to allow other threads to access shared resources. \n   >>> unlock() *\/ \nvoid unlock();",
        "query_nlx":"\/* Define a function that unlocks a mutex.\n   >>> unlock() *\/ \nvoid unlock() {"
    }

    {
        "file_name":"iprogs_thread_function_1.cpp",
        "line_count":5,
        "code":"void join()\n  {\n    if (thread_.joinable())\n      thread_.join();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Ensure that the current thread has finished executing before proceeding. \n>>> void join() { *\/",
        "query_nlx":"\/* Function named join checks if a thread is joinable and if so, joins the thread. \n>>> join() *\/"
    }

    {
        "file_name":"JAnyMap_function_1.cpp",
        "line_count":3,
        "code":"bool contains(const std::string& key) {\n    return _map->contains(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a specific key is contained in the data structure. \n>>> bool contains(const std::string& key); *\/",
        "query_nlx":"\/* Function named contains checks if a given key exists in a map data structure.\n   >>> contains(\"example_key\") true\n   >>> contains(\"nonexistent_key\") false *\/ \nbool contains(const std::string& key) {"
    }

    {
        "file_name":"JAnyMap_function_10.cpp",
        "line_count":3,
        "code":"bool isObject(const std::string& key) {\n    return _map->isObject(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a key exists in the map as an object.\n   >>> isObject(const std::string& key) *\/",
        "query_nlx":"\/* Function named isObject checks if a given key corresponds to an object in a map.\n   >>> isObject(\"key\") returns true\n   >>> isObject(\"nonexistent_key\") returns false *\/\nbool isObject(const std::string& key) { "
    }

    {
        "file_name":"JAnyMap_function_11.cpp",
        "line_count":3,
        "code":"double getDouble(const std::string& key) {\n    return _map->getDouble(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a double value associated with a given key from a map.\n   >>> getDouble(const std::string& key) *\/",
        "query_nlx":"\/* Function named getDouble retrieves a double value associated with a given key from a map.\n   >>> getDouble(\"height\") 5.6\n   >>> getDouble(\"width\") 10.2 *\/ \ndouble getDouble(const std::string& key) { "
    }

    {
        "file_name":"JAnyMap_function_12.cpp",
        "line_count":3,
        "code":"bool getBoolean(const std::string& key) {\n    return _map->getBoolean(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a boolean value associated with a specific key from a map.\n   >>> getBoolean(key: string) bool *\/",
        "query_nlx":"\/* Function named getBoolean retrieves a boolean value associated with a given key from a map.\n   >>> getBoolean(\"is_valid\") true\n   >>> getBoolean(\"has_error\") false *\/ \nbool getBoolean(const std::string& key) { "
    }

    {
        "file_name":"JAnyMap_function_15.cpp",
        "line_count":3,
        "code":"void setNull(const std::string& key) {\n    _map->setNull(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the value associated with a specific key to null.\n   >>> setNull(const std::string& key) *\/",
        "query_nlx":"\/* Define a function that sets a given key in a map to a null value.\n   >>> setNull(\"example_key\") *\/ \nvoid setNull(const std::string& key) {"
    }

    {
        "file_name":"JAnyMap_function_16.cpp",
        "line_count":3,
        "code":"void setDouble(const std::string& key, double value) {\n    _map->setDouble(key, value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a double value associated with a given key in a map.\n   >>> void setDouble(const std::string& key, double value) { *\/",
        "query_nlx":"\/* Function named setDouble assigns a double value to a specific key in a map.\n>>> setDouble(\"temperature\", 25.5) *\/ \nvoid setDouble(const std::string& key, double value) {"
    }

    {
        "file_name":"JAnyMap_function_17.cpp",
        "line_count":3,
        "code":"void setBoolean(const std::string& key, bool value) {\n    _map->setBoolean(key, value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a boolean value for a specific key in a map.\n   >>> void setBoolean(const std::string& key, bool value); *\/",
        "query_nlx":"\/* Function named setBoolean sets a boolean value for a given key in a map.\n   >>> setBoolean(\"is_active\", true) \n   >>> setBoolean(\"has_permission\", false *\/ \nvoid setBoolean(const std::string& key, bool value) { "
    }

    {
        "file_name":"JAnyMap_function_18.cpp",
        "line_count":3,
        "code":"void setBigInt(const std::string& key, int64_t value) {\n    _map->setBigInt(key, value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a big integer value associated with a given key in a map.\n   >>> void setBigInt(const std::string& key, int64_t value) { *\/",
        "query_nlx":"\/* Define a function that sets a large integer value associated with a given key in a data structure. \n>>> setBigInt(\"example_key\", 1000000000) *\/ \nvoid setBigInt(const std::string& key, int64_t value) {"
    }

    {
        "file_name":"JAnyMap_function_19.cpp",
        "line_count":3,
        "code":"void setString(const std::string& key, const std::string& value) {\n    _map->setString(key, value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a string value associated with a given key in a map-like structure. \n>>> void setString(const string& key, const string& value) { *\/",
        "query_nlx":"\/* Function named setString assigns a value to a specific key in a map data structure.\n>>> setString(\"name\", \"John Doe\") *\/ \nvoid setString(const std::string& key, const std::string& value) {"
    }

    {
        "file_name":"JAnyMap_function_20.cpp",
        "line_count":10,
        "code":"void setAnyArray(const std::string& key, jni::alias_ref<JAnyArray> value) {\n    std::vector<AnyValue> vector;\n    size_t size = value->size();\n    vector.reserve(size);\n    for (size_t i = 0; i < size; i++) {\n      auto anyValue = value->getElement(i);\n      vector.push_back(anyValue->cthis()->getValue());\n    }\n    _map->setArray(key, vector);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set an array of values associated with a specific key in a map.\n   >>> void setAnyArray(const std::string& key, jni::alias_ref<JAnyArray> value) { *\/",
        "query_nlx":"        \/* Function named setAnyArray takes a key and a JAnyArray value, extracts AnyValue elements from the JAnyArray, and stores them in a vector. \n        >>> setAnyArray(\"example_key\", example_JAnyArray) *\/ \n        void setAnyArray(const std::string& key, jni::alias_ref<JAnyArray> value) {"
    }

    {
        "file_name":"JAnyMap_function_22.cpp",
        "line_count":33,
        "code":"void registerNatives() {\n    registerHybrid({\n        \/\/ init\n        makeNativeMethod(\"initHybrid\", JAnyMap::initHybrid),\n        \/\/ helpers\n        makeNativeMethod(\"contains\", JAnyMap::contains),\n        makeNativeMethod(\"remove\", JAnyMap::remove),\n        makeNativeMethod(\"clear\", JAnyMap::clear),\n        \/\/ is\n        makeNativeMethod(\"isNull\", JAnyMap::isNull),\n        makeNativeMethod(\"isDouble\", JAnyMap::isDouble),\n        makeNativeMethod(\"isBoolean\", JAnyMap::isBoolean),\n        makeNativeMethod(\"isBigInt\", JAnyMap::isBigInt),\n        makeNativeMethod(\"isString\", JAnyMap::isString),\n        makeNativeMethod(\"isArray\", JAnyMap::isArray),\n        makeNativeMethod(\"isObject\", JAnyMap::isObject),\n        \/\/ get\n        makeNativeMethod(\"getDouble\", JAnyMap::getDouble),\n        makeNativeMethod(\"getBoolean\", JAnyMap::getBoolean),\n        makeNativeMethod(\"getBigInt\", JAnyMap::getBigInt),\n        makeNativeMethod(\"getString\", JAnyMap::getString),\n        makeNativeMethod(\"getAnyArray\", JAnyMap::getAnyArray),\n        makeNativeMethod(\"getAnyObject\", JAnyMap::getAnyObject),\n        \/\/ set\n        makeNativeMethod(\"setNull\", JAnyMap::setNull),\n        makeNativeMethod(\"setDouble\", JAnyMap::setDouble),\n        makeNativeMethod(\"setBoolean\", JAnyMap::setBoolean),\n        makeNativeMethod(\"setBigInt\", JAnyMap::setBigInt),\n        makeNativeMethod(\"setString\", JAnyMap::setString),\n        makeNativeMethod(\"setAnyArray\", JAnyMap::setAnyArray),\n        makeNativeMethod(\"setAnyObject\", JAnyMap::setAnyObject),\n    });\n  }",
        "mark":8.0,
        "query_nsx":"\/* Register native methods for interacting with a generic map data structure.\n   >>> registerNatives() *\/ \nvoid registerNatives() {",
        "query_nlx":"\/* Register native methods for a hybrid data structure that can store various types of data. Methods include initialization, checking for existence, removal, clearing, type checking, retrieval, and setting of different data types. \n   >>> registerNatives() *\/ \nvoid registerNatives() {"
    }

    {
        "file_name":"JAnyMap_function_3.cpp",
        "line_count":3,
        "code":"void clear() {\n    _map->clear();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Clear the map by removing all elements.\n   >>> clear() *\/ \nvoid clear();",
        "query_nlx":"\/* Function named clear that clears the contents of a map. \n>>> clear() *\/ \nvoid clear() {"
    }

    {
        "file_name":"JAnyMap_function_4.cpp",
        "line_count":3,
        "code":"bool isNull(const std::string& key) {\n    return _map->isNull(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a value associated with a given key is null in a data structure. \n>>> bool isNull(const std::string& key) { *\/",
        "query_nlx":"\/* Function named isNull checks if a given key in a map is null or not.\n   >>> isNull(\"example_key\") true\n   >>> isNull(\"another_key\") false *\/ \nbool isNull(const std::string& key) {"
    }

    {
        "file_name":"JAnyMap_function_5.cpp",
        "line_count":3,
        "code":"bool isDouble(const std::string& key) {\n    return _map->isDouble(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a value associated with a given key is of type double.\n   >>> bool isDouble(const std::string& key); *\/",
        "query_nlx":"\/* Function named isDouble checks if a given key in a map corresponds to a double value.\n   >>> isDouble(\"age\") true\n   >>> isDouble(\"name\") false *\/ \nbool isDouble(const std::string& key) {"
    }

    {
        "file_name":"JAnyMap_function_6.cpp",
        "line_count":3,
        "code":"bool isBoolean(const std::string& key) {\n    return _map->isBoolean(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a boolean value exists for a given key in a map.\n   >>> bool isBoolean(const std::string& key); *\/",
        "query_nlx":"\/* Function named isBoolean checks if a given key in a map corresponds to a boolean value.\n   >>> isBoolean(\"key\") returns true if the value associated with \"key\" is a boolean, false otherwise *\/ \nbool isBoolean(const std::string& key) {"
    }

    {
        "file_name":"JAnyMap_function_7.cpp",
        "line_count":3,
        "code":"bool isBigInt(const std::string& key) {\n    return _map->isBigInt(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a specified key corresponds to a large integer value in a map.\n   >>> bool isBigInt(const std::string& key); *\/",
        "query_nlx":"\/* Function named isBigInt determines if a given key corresponds to a large integer value in a map data structure.\n>>> isBigInt(\"key123\") true\n>>> isBigInt(\"value456\") false *\/ \nbool isBigInt(const std::string& key) {"
    }

    {
        "file_name":"JAnyMap_function_8.cpp",
        "line_count":3,
        "code":"bool isString(const std::string& key) {\n    return _map->isString(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given key is a string in the map.\n   >>> bool isString(const std::string& key); *\/",
        "query_nlx":"\/* Function named isString checks if a given key is a string in the map data structure.\n   >>> isString(\"key1\") true\n   >>> isString(\"key2\") false *\/ \nbool isString(const std::string& key) { "
    }

    {
        "file_name":"JAnyMap_function_9.cpp",
        "line_count":3,
        "code":"bool isArray(const std::string& key) {\n    return _map->isArray(key);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a value associated with a given key is an array.\n   >>> isArray(\"example_key\") true\n   >>> isArray(\"another_key\") false *\/ \nbool isArray(const std::string& key) {",
        "query_nlx":"\/* Function named isArray checks if a given key corresponds to an array in a data structure.\n   >>> isArray(\"example_key\") true\n   >>> isArray(\"another_key\") false *\/ \nbool isArray(const std::string& key) {"
    }

    {
        "file_name":"JAnyValue_function_1.cpp",
        "line_count":3,
        "code":"bool isNull() {\n    return std::holds_alternative<std::monostate>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if the value stored in the object is null.\n   >>> bool isNull() { *\/",
        "query_nlx":"\/* Function named isNull checks if the current value stored in a variant type is of type monostate, indicating a null value.\n>>> isNull() returns true if the current value is null, false otherwise. *\/ \nbool isNull() {"
    }

    {
        "file_name":"JAnyValue_function_10.cpp",
        "line_count":3,
        "code":"int64_t asBigInt() {\n    return std::get<int64_t>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a large integer value stored in a data structure and return it.\n   >>> asBigInt() *\/ \nint64_t asBigInt();",
        "query_nlx":"\/* Define a function that converts a given value to a large integer.\n   >>> asBigInt() returns the value as a large integer *\/ \nint64_t asBigInt() {"
    }

    {
        "file_name":"JAnyValue_function_2.cpp",
        "line_count":3,
        "code":"bool isDouble() {\n    return std::holds_alternative<double>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the stored value is of type double.\n>>> bool isDouble() { *\/",
        "query_nlx":"\/* Function named isDouble checks if the stored value is of type double.\n   >>> isDouble() returns true if the stored value is of type double, false otherwise *\/ \nbool isDouble() {"
    }

    {
        "file_name":"JAnyValue_function_3.cpp",
        "line_count":3,
        "code":"bool isBoolean() {\n    return std::holds_alternative<bool>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the value stored in the function is a boolean type.\n>>> bool isBoolean() { *\/",
        "query_nlx":"\/* Function named isBoolean checks if the stored value is of boolean type.\n>>> isBoolean() returns true if the stored value is of boolean type, false otherwise. *\/ \nbool isBoolean() { "
    }

    {
        "file_name":"JAnyValue_function_4.cpp",
        "line_count":3,
        "code":"bool isBigInt() {\n    return std::holds_alternative<int64_t>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the value stored is a large integer.\n>>> bool isBigInt() { *\/",
        "query_nlx":"\/* Function named isBigInt determines if the stored value is a large integer by checking if it is of type int64_t.\n>>> isBigInt() true\n>>> isBigInt() false *\/ \nbool isBigInt() {"
    }

    {
        "file_name":"JAnyValue_function_5.cpp",
        "line_count":3,
        "code":"bool isString() {\n    return std::holds_alternative<std::string>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the value stored is a string type.\n>>> bool isString() { *\/",
        "query_nlx":"\/* Function named isString checks if the current value held by a variant type is a string.\n   >>> isString() returns true if the current value is a string, false otherwise *\/ \nbool isString() {"
    }

    {
        "file_name":"JAnyValue_function_6.cpp",
        "line_count":3,
        "code":"bool isAnyArray() {\n    return std::holds_alternative<AnyArray>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the value stored is an array of any type.\n   >>> bool isAnyArray() { *\/",
        "query_nlx":"\/* Function named isAnyArray checks if the current value is of type AnyArray using a variant type.\n   >>> isAnyArray() returns true if the current value is of type AnyArray, otherwise false *\/ \nbool isAnyArray() { "
    }

    {
        "file_name":"JAnyValue_function_7.cpp",
        "line_count":3,
        "code":"bool isAnyObject() {\n    return std::holds_alternative<AnyObject>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the value stored in the function is of type AnyObject.\n>>> bool isAnyObject() { *\/",
        "query_nlx":"\/* Function named isAnyObject checks if the current value is of type AnyObject using a variant type.\n   >>> isAnyObject() returns true if the current value is of type AnyObject, false otherwise *\/ \nbool isAnyObject() { "
    }

    {
        "file_name":"JAnyValue_function_8.cpp",
        "line_count":3,
        "code":"double asDouble() {\n    return std::get<double>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert the stored value to a double data type.\n   >>> double asDouble() { *\/",
        "query_nlx":"\/* Define a function that converts a value stored in a variable to a double data type.\n   >>> asDouble() *\/ \ndouble asDouble() {"
    }

    {
        "file_name":"JAnyValue_function_9.cpp",
        "line_count":3,
        "code":"bool asBoolean() {\n    return std::get<bool>(_value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the stored value is a boolean type.\n>>> bool asBoolean() { *\/",
        "query_nlx":"\/* Function named asBoolean returns the boolean value stored in the internal variable _value.\n   >>> asBoolean() true\n   >>> asBoolean() false *\/ \nbool asBoolean() { "
    }

    {
        "file_name":"JArrayBuffer_function_1.cpp",
        "line_count":4,
        "code":"bool getIsByteBuffer() {\n    auto byteBufferArrayBuffer = std::dynamic_pointer_cast<ByteBufferArrayBuffer>(_arrayBuffer);\n    return byteBufferArrayBuffer != nullptr;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if the given object is a byte buffer.\n>>> bool getIsByteBuffer() { *\/",
        "query_nlx":"\/* Function named getIsByteBuffer checks if the _arrayBuffer can be dynamically cast to a ByteBufferArrayBuffer and returns true if successful.\n   >>> getIsByteBuffer() returns true if _arrayBuffer can be cast to a ByteBufferArrayBuffer, false otherwise *\/"
    }

    {
        "file_name":"JArrayBuffer_function_2.cpp",
        "line_count":3,
        "code":"bool getIsOwner() {\n    return _arrayBuffer->isOwner();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the current object is the owner based on internal state.\n   >>> getIsOwner() *\/ \nbool getIsOwner() {",
        "query_nlx":"\/* Function named getIsOwner checks if the current object has ownership of a specific resource.\n>>> getIsOwner() returns a boolean value indicating whether the object is the owner of the resource or not. *\/ \nbool getIsOwner() { "
    }

    {
        "file_name":"JArrayBuffer_function_3.cpp",
        "line_count":3,
        "code":"int getBufferSize() {\n    return static_cast<int>(_arrayBuffer->size());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the size of the buffer array.\n>>> int getBufferSize() { *\/",
        "query_nlx":"\/* Function named getBufferSize returns the size of an array buffer as an integer value.\n   >>> getBufferSize()  *\/ \nint getBufferSize() {"
    }

    {
        "file_name":"JFunc_void_function_2.cpp",
        "line_count":3,
        "code":"void registerNatives() {\n      registerHybrid({makeNativeMethod(\"call\", JFunc_void::call)});\n    }",
        "mark":8.0,
        "query_nsx":"\/* Register native methods for hybrid functionality.\n   >>> registerNatives() *\/ \nvoid registerNatives();",
        "query_nlx":"\/* Register a native method named \"call\" with a void return type. \n   >>> registerNatives() void registerNatives() { registerHybrid({makeNativeMethod(\"call\", JFunc_void::call)}); *\/"
    }

    {
        "file_name":"JFunc_void_std__string_function_2.cpp",
        "line_count":3,
        "code":"void registerNatives() {\n      registerHybrid({makeNativeMethod(\"call\", JFunc_void_std__string::call)});\n    }",
        "mark":8.0,
        "query_nsx":"\/* Register native methods for hybrid functionality.\n   >>> registerNatives() *\/ \nvoid registerNatives();",
        "query_nlx":"        \/* Register a native method named \"call\" that takes no arguments and returns void.\n        >>> registerNatives() registers a hybrid function with the native method \"call\" implemented by the JFunc_void_std__string::call function *\/ \n        void registerNatives() { "
    }

    {
        "file_name":"JNIOnLoad_function_1.cpp",
        "line_count":13,
        "code":"JNICALL JNI_OnLoad(JavaVM* vm, void*) {\n  return facebook::jni::initialize(vm, [] {\n    \/\/ 1. Initialize all core Nitro Java bindings\n    JHybridObjectRegistry::registerNatives();\n    JArrayBuffer::registerNatives();\n    JAnyMap::registerNatives();\n    JAnyValue::registerNatives();\n    JPromise::registerNatives();\n\n    \/\/ 2. Initialize the React Native TurboModule C++ part\n    JNitroModules::registerNatives();\n  });\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize core Java bindings and React Native TurboModule C++ part\n>>> JNICALL JNI_OnLoad(JavaVM* vm, void*) { *\/",
        "query_nlx":"\/* Initialize all core Nitro Java bindings and the React Native TurboModule C++ part.\n   >>> JNICALL JNI_OnLoad(JavaVM* vm, void*) { *\/"
    }

    {
        "file_name":"JPromise_function_3.cpp",
        "line_count":9,
        "code":"void addOnResolvedListener(OnResolvedFunc&& onResolved) {\n    if (_result != nullptr) {\n      \/\/ Promise is already resolved! Call the callback immediately\n      onResolved(_result);\n    } else {\n      \/\/ Promise is not yet resolved, put the listener in our queue.\n      _onResolvedListeners.push_back(std::move(onResolved));\n    }\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Add a listener function to be called when a promise is resolved or put it in a queue if the promise is not yet resolved.\n        >>> void addOnResolvedListener(OnResolvedFunc&& onResolved) { *\/",
        "query_nlx":"        \/* Define a function that adds a listener to be called when a promise is resolved or immediately if the promise is already resolved.\n        >>> addOnResolvedListener(OnResolvedFunc&& onResolved) *\/"
    }

    {
        "file_name":"JPromise_function_4.cpp",
        "line_count":9,
        "code":"void addOnRejectedListener(OnRejectedFunc&& onRejected) {\n    if (_error != nullptr) {\n      \/\/ Promise is already rejected! Call the callback immediately\n      onRejected(_error);\n    } else {\n      \/\/ Promise is not yet rejected, put the listener in our queue.\n      _onRejectedListeners.push_back(std::move(onRejected));\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Add a listener function to be called when a promise is rejected or immediately if already rejected.\n>>> void addOnRejectedListener(OnRejectedFunc&& onRejected); *\/",
        "query_nlx":"        \/* Define a function that adds a listener for when a promise is rejected. If the promise is already rejected, the listener's callback function is called immediately with the error. Otherwise, the listener is added to the queue of listeners to be executed when the promise is rejected.\n        >>> addOnRejectedListener(OnRejectedFunc&& onRejected) *\/ \n        void addOnRejectedListener(OnRejectedFunc&& onRejected) {"
    }

    {
        "file_name":"JPromise_function_5.cpp",
        "line_count":7,
        "code":"void registerNatives() {\n    registerHybrid({\n        makeNativeMethod(\"initHybrid\", JPromise::initHybrid),\n        makeNativeMethod(\"nativeResolve\", JPromise::resolve),\n        makeNativeMethod(\"nativeReject\", JPromise::reject),\n    });\n  }",
        "mark":8.0,
        "query_nsx":"\/* Register native methods for initializing, resolving, and rejecting promises.\n   >>> registerNatives()\n*\/ \nvoid registerNatives() {",
        "query_nlx":"        \/* Define a function that registers native methods for a hybrid object by calling the registerHybrid function with specific method names and corresponding functions.\n        >>> registerNatives() *\/ \n        void registerNatives() {"
    }

    {
        "file_name":"JSIConverter+AnyMap_function_3.cpp",
        "line_count":3,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    return JSIConverter<AnyValue::variant>::canConvert(runtime, value);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a value can be converted using a runtime and a given value.\n   >>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"\/* Function named canConvert determines if a given value can be converted using a runtime and a converter.\n   >>> canConvert(runtime, value) returns a boolean value indicating if the conversion is possible. *\/ \nbool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { "
    }

    {
        "file_name":"JSIConverter+AnyMap_function_4.cpp",
        "line_count":9,
        "code":"Value toJSI(jsi::Runtime& runtime, std::shared_ptr<AnyMap> map) {\n    jsi::Object object(runtime);\n    for (const auto& item : map->getMap()) {\n      jsi::String key = jsi::String::createFromUtf8(runtime, item.first);\n      jsi::Value value = JSIConverter<AnyValue>::toJSI(runtime, item.second);\n      object.setProperty(runtime, std::move(key), std::move(value));\n    }\n    return object;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given map of key-value pairs to a JavaScript object.\n   >>> Value toJSI(Runtime& runtime, shared_ptr<AnyMap> map) { *\/",
        "query_nlx":"        \/* Function named toJSI converts a given map of key-value pairs into a JavaScript object in the runtime environment. \n        >>> toJSI(runtime, {\"key1\": value1, \"key2\": value2}) returns a JavaScript object with properties \"key1\" and \"key2\" containing corresponding values. *\/ \n        Value toJSI(jsi::Runtime& runtime, std::shared_ptr<AnyMap> map) { "
    }

    {
        "file_name":"JSIConverter+AnyMap_function_5.cpp",
        "line_count":18,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (!value.isObject()) {\n      return false;\n    }\n    jsi::Object object = value.getObject(runtime);\n    if (!isPlainObject(runtime, object)) {\n      return false;\n    }\n    jsi::Array properties = object.getPropertyNames(runtime);\n    size_t size = properties.size(runtime);\n    for (size_t i = 0; i < size; i++) {\n      bool canConvertProp = JSIConverter<AnyValue>::canConvert(runtime, properties.getValueAtIndex(runtime, i));\n      if (!canConvertProp) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given object can be converted to another data type.\n   >>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"\n\/* Function named canConvert checks if a given value can be converted to another data type.\n   >>> canConvert(runtime, value) true\n   >>> canConvert(runtime, value) false *\/\nbool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {"
    }

    {
        "file_name":"JSIConverter+ArrayBuffer_function_2.cpp",
        "line_count":7,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (value.isObject()) {\n      jsi::Object object = value.getObject(runtime);\n      return object.isArrayBuffer(runtime);\n    }\n    return false;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given value can be converted to an array buffer object.\n   >>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"        \/* Function named canConvert checks if a given value can be converted to an array buffer object.\n        >>> canConvert(Runtime& runtime, Value& value) true\n        >>> canConvert(Runtime& runtime, Value& value) false *\/ \n        bool canConvert(Runtime& runtime, Value& value) { "
    }

    {
        "file_name":"JSIConverter+HostObject_function_3.cpp",
        "line_count":7,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (value.isObject()) {\n      jsi::Object object = value.getObject(runtime);\n      return object.isHostObject<TPointee>(runtime);\n    }\n    return false;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given value can be converted to a specific type of object.\n   >>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"\/* Function named canConvert checks if a given value can be converted to a host object of type TPointee in the runtime environment.\n   >>> canConvert(jsi::Runtime& runtime, const jsi::Value& value) true\n   >>> canConvert(jsi::Runtime& runtime, const jsi::Value& value) false *\/"
    }

    {
        "file_name":"JSIConverter+HybridObject_function_4.cpp",
        "line_count":7,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (value.isObject()) {\n      jsi::Object object = value.getObject(runtime);\n      return object.hasNativeState<TPointee>(runtime);\n    }\n    return false;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given value can be converted to a specific type.\n   >>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"\/* Function named canConvert checks if a given value can be converted to a native state of a specific type.\n   >>> canConvert(jsi::Runtime& runtime, const jsi::Value& value) returns true if the value is an object with native state of type TPointee, otherwise false. *\/ \nbool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { "
    }

    {
        "file_name":"JSIConverter+Optional_function_1.cpp",
        "line_count":7,
        "code":"Value toJSI(jsi::Runtime& runtime, const std::optional<TInner>& arg) {\n    if (arg == std::nullopt) {\n      return jsi::Value::undefined();\n    } else {\n      return JSIConverter<TInner>::toJSI(runtime, arg.value());\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert an optional value to a JSI value using a runtime object.\n   >>> Value toJSI(jsi::Runtime& runtime, const std::optional<TInner>& arg) { *\/",
        "query_nlx":"        \/* Function to convert an optional inner value to a JSI value using a given runtime.\n        >>> toJSI(runtime, std::nullopt) returns undefined\n        >>> toJSI(runtime, 5) returns JSIConverter::toJSI(runtime, 5) *\/ \n        Value toJSI(jsi::Runtime& runtime, const std::optional<TInner>& arg) {"
    }

    {
        "file_name":"JSIConverter+Promise_function_2.cpp",
        "line_count":5,
        "code":"if constexpr (std::is_void_v<TResult>) {\n              \/\/ it's returning void, just return undefined to JS\n              sharedFuture->get();\n              promise->resolve(runtime, jsi::Value::undefined());\n            }",
        "mark":8.0,
        "query_nsx":"\/* If the return type of the function is void, resolve a promise with an undefined value to JavaScript.\n   >>> if constexpr (std::is_void_v<TResult>) { *\/",
        "query_nlx":"\/* If the result type is void, wait for the shared future to be ready and then resolve the promise with an undefined value.\n   >>> if constexpr (std::is_void_v<TResult>) { *\/"
    }

    {
        "file_name":"JSIConverter+UnorderedMap_function_1.cpp",
        "line_count":8,
        "code":"Value toJSI(jsi::Runtime& runtime, const std::unordered_map<std::string, ValueType>& map) {\n    jsi::Object object(runtime);\n    for (const auto& pair : map) {\n      jsi::Value value = JSIConverter<ValueType>::toJSI(runtime, pair.second);\n      object.setProperty(runtime, pair.first.c_str(), std::move(value));\n    }\n    return object;\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Convert a given map of values to a JavaScript object.\n        >>> Value toJSI(Runtime& runtime, const unordered_map<string, ValueType>& map) { *\/",
        "query_nlx":"        \/* Function named toJSI takes a runtime and a map of string-value pairs, converts the values to JSI format using a converter, and sets them as properties in an object.\n        >>> toJSI(runtime, {\"key1\": value1, \"key2\": value2}) returns an object with properties \"key1\" and \"key2\" containing the converted values *\/\n        Value toJSI(Runtime& runtime, const unordered_map<string, ValueType>& map) { *\/"
    }

    {
        "file_name":"JSIConverter+UnorderedMap_function_2.cpp",
        "line_count":18,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (!value.isObject()) {\n      return false;\n    }\n    jsi::Object object = value.getObject(runtime);\n    if (!isPlainObject(runtime, object)) {\n      return false;\n    }\n    jsi::Array properties = object.getPropertyNames(runtime);\n    size_t size = properties.size(runtime);\n    for (size_t i = 0; i < size; i++) {\n      bool canConvertProp = JSIConverter<ValueType>::canConvert(runtime, properties.getValueAtIndex(runtime, i));\n      if (!canConvertProp) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if the given object can be converted to a specific format based on its properties.\n>>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"\/* Function named canConvert checks if a given value can be converted to another type by inspecting its properties.\n   >>> canConvert({object}, runtime) true\n   >>> canConvert({array}, runtime) false *\/ \nbool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {"
    }

    {
        "file_name":"JSIConverter+Variant_function_1.cpp",
        "line_count":4,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    \/\/ Check each type in `Types...` to make sure we can convert `jsi::Value` to one of those.\n    return (JSIConverter<Types>::canConvert(runtime, value) || ...);\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Check if a value can be converted to any of the specified types.\n        >>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value); *\/",
        "query_nlx":"\/* Function named canConvert checks if a given jsi::Value can be converted to any of the types specified in the Types template parameter pack using JSIConverter.\n   >>> canConvert(jsi::Runtime& runtime, const jsi::Value& value) *\/\nbool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { "
    }

    {
        "file_name":"JSIConverter_function_10.cpp",
        "line_count":3,
        "code":"double fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return arg.asNumber();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given value to a double data type.\n>>> double fromJSI(Runtime&, const Value& arg); *\/",
        "query_nlx":"        \/* Function named fromJSI converts a given value to a double data type.\n        >>> fromJSI(Runtime&, const Value&) returns a double value *\/ \n        double fromJSI(jsi::Runtime&, const jsi::Value& arg) {"
    }

    {
        "file_name":"JSIConverter_function_12.cpp",
        "line_count":3,
        "code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isNumber();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given value can be converted to a number type.\n   >>> canConvert(value) \n   >>> canConvert(value) *\/ \nbool canConvert(Runtime&, const Value& value) { ",
        "query_nlx":"\/* Function named canConvert determines if a given value can be converted to a number type.\n   >>> canConvert(\"Hello\") false\n   >>> canConvert(42) true *\/ \nbool canConvert(jsi::Runtime&, const jsi::Value& value) { "
    }

    {
        "file_name":"JSIConverter_function_13.cpp",
        "line_count":3,
        "code":"float fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return static_cast<float>(arg.asNumber());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given value to a floating-point number.\n   >>> float fromJSI(Runtime&, const Value& arg); *\/",
        "query_nlx":"        \/* Convert a given value to a floating-point number.\n        >>> fromJSI(Runtime&, Value) returns a floating-point number *\/ \n        float fromJSI(Runtime&, const Value& arg) {"
    }

    {
        "file_name":"JSIConverter_function_15.cpp",
        "line_count":3,
        "code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isNumber();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given value can be converted to a number type.\n   >>> canConvert(value) *\/\nbool canConvert(Runtime&, const Value& value) {",
        "query_nlx":"\/* Function named canConvert checks if a given value can be converted to a number type.\n   >>> canConvert(42) true\n   >>> canConvert(\"hello\") false *\/ \nbool canConvert(Runtime&, const Value& value) {"
    }

    {
        "file_name":"JSIConverter_function_17.cpp",
        "line_count":3,
        "code":"Value toJSI(jsi::Runtime& runtime, int64_t arg) {\n    return jsi::BigInt::fromInt64(runtime, arg);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given integer value to a big integer representation.\n   >>> Value toJSI(Runtime& runtime, int64_t arg) *\/",
        "query_nlx":"\/* Function to convert an integer argument to a BigInt object using the provided runtime.\n   >>> toJSI(runtime, 123) returns a BigInt object representing the integer 123\n   >>> toJSI(runtime, -456) returns a BigInt object representing the integer -456 *\/ \nValue toJSI(jsi::Runtime& runtime, int64_t arg) {"
    }

    {
        "file_name":"JSIConverter_function_20.cpp",
        "line_count":3,
        "code":"Value toJSI(jsi::Runtime& runtime, uint64_t arg) {\n    return jsi::BigInt::fromUint64(runtime, arg);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given unsigned integer value to a big integer value using the provided runtime environment.\n   >>> Value toJSI(jsi::Runtime& runtime, uint64_t arg) { *\/",
        "query_nlx":"\/* Function named toJSI converts a given unsigned 64-bit integer value to a BigInt using the provided runtime.\n   >>> toJSI(runtime, 123456789) returns a BigInt representing the value 123456789\n   >>> toJSI(runtime, 987654321) returns a BigInt representing the value 987654321 *\/ \nValue toJSI(jsi::Runtime& runtime, uint64_t arg) { "
    }

    {
        "file_name":"JSIConverter_function_22.cpp",
        "line_count":3,
        "code":"bool fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return arg.asBool();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Extract a boolean value from a runtime and a given value.\n   >>> fromJSI(runtime, value) \n*\/ \nbool fromJSI(jsi::Runtime&, const jsi::Value& arg) {",
        "query_nlx":"\/* Function named fromJSI takes a runtime and a value as input and returns a boolean value based on the input value.\n   >>> fromJSI(runtime, value) true\n   >>> fromJSI(runtime, value) false *\/ \nbool fromJSI(jsi::Runtime&, const jsi::Value& arg) {"
    }

    {
        "file_name":"JSIConverter_function_24.cpp",
        "line_count":3,
        "code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isBool();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the provided value can be converted to a boolean type.\n   >>> canConvert(value: any) -> bool *\/",
        "query_nlx":"\/* Function named canConvert checks if a given value can be converted to a boolean type.\n   >>> canConvert(true) true\n   >>> canConvert(42) false\n   >>> canConvert(\"hello\") false *\/ \nbool canConvert(Runtime&, const Value& value) { "
    }

    {
        "file_name":"JSIConverter_function_25.cpp",
        "line_count":3,
        "code":"string fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {\n    return arg.asString(runtime).utf8(runtime);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Extracts a UTF-8 string representation from a given runtime value.\n   >>> string fromJSI(Runtime& runtime, const Value& arg) { *\/",
        "query_nlx":"        \/* Function named fromJSI takes a runtime and a value as input and converts the value to a UTF-8 encoded string using the provided runtime.\n        >>> fromJSI(runtime, value) returns a UTF-8 encoded string representation of the input value using the given runtime *\/ \n        string fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {"
    }

    {
        "file_name":"JSIConverter_function_26.cpp",
        "line_count":3,
        "code":"Value toJSI(jsi::Runtime& runtime, const std::string& arg) {\n    return jsi::String::createFromUtf8(runtime, arg);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given string to a JSI string value.\n   >>> Value toJSI(jsi::Runtime& runtime, const std::string& arg) { *\/",
        "query_nlx":"\/* Function named toJSI converts a given string argument to a JSI string object using the provided runtime.\n   >>> toJSI(runtime, \"hello\") returns a JSI string object containing the text \"hello\"\n   >>> toJSI(runtime, \"123\") returns a JSI string object containing the text \"123\" *\/ \nValue toJSI(jsi::Runtime& runtime, const std::string& arg) { "
    }

    {
        "file_name":"JSIConverter_function_27.cpp",
        "line_count":3,
        "code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isString();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given value can be converted to a specific type. \n>>> canConvert(Runtime&, const Value& value) *\/",
        "query_nlx":"\/* Function named canConvert determines if a given value can be converted to a string type.\n   >>> canConvert(123) false\n   >>> canConvert(\"Hello\") true *\/ \nbool canConvert(jsi::Runtime&, const jsi::Value& value) { "
    }

    {
        "file_name":"JSIConverter_function_4.cpp",
        "line_count":3,
        "code":"int fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return static_cast<int>(arg.asNumber());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given value to an integer type.\n   >>> int fromJSI(Runtime&, const Value& arg) { *\/",
        "query_nlx":"\/* Function named fromJSI converts a given value to an integer by casting it as a number.\n   >>> fromJSI(3.14) 3\n   >>> fromJSI(10.5) 10\n*\/ \nint fromJSI(jsi::Runtime&, const jsi::Value& arg) {"
    }

    {
        "file_name":"JSIConverter_function_6.cpp",
        "line_count":3,
        "code":"bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isNumber();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given value can be converted to a number type.\n   >>> canConvert(value) \n   >>> canConvert(value) *\/ \nbool canConvert(jsi::Runtime&, const jsi::Value& value) { ",
        "query_nlx":"\/* Function named canConvert determines if a given value can be converted to a number type.\n   >>> canConvert(\"abc\") false\n   >>> canConvert(123) true *\/ \nbool canConvert(jsi::Runtime&, const jsi::Value& value) { "
    }

    {
        "file_name":"JSIHelpers_function_1.cpp",
        "line_count":18,
        "code":"bool isPlainObject(jsi::Runtime& runtime, const jsi::Object& object) {\n  if (object.isArray(runtime)) {\n    return false;\n  }\n  if (object.isArrayBuffer(runtime)) {\n    return false;\n  }\n  if (object.isFunction(runtime)) {\n    return false;\n  }\n  if (object.isHostObject(runtime)) {\n    return false;\n  }\n  if (object.hasNativeState(runtime)) {\n    return false;\n  }\n  return true;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the provided object is a plain object without any special characteristics.\n>>> bool isPlainObject(jsi::Runtime& runtime, const jsi::Object& object) { *\/",
        "query_nlx":"\/* Determine if the given object is a plain object by checking if it is not an array, array buffer, function, host object, or has native state.\n   >>> isPlainObject(Runtime& runtime, const Object& object) *\/\nbool isPlainObject(jsi::Runtime& runtime, const jsi::Object& object) {"
    }

    {
        "file_name":"JSIHelpers_function_2.cpp",
        "line_count":4,
        "code":"string getRuntimeId(jsi::Runtime& runtime) {\n  std::string threadName = ThreadUtils::getThreadName();\n  return runtime.description() + std::string(\" (\") + threadName + std::string(\")\");\n}",
        "mark":8.0,
        "query_nsx":"\/* Get the runtime identifier by combining the description of the runtime with the name of the current thread.\n>>> string getRuntimeId(jsi::Runtime& runtime) { *\/",
        "query_nlx":"\/* Function named getRuntimeId takes a runtime object as input and returns a string that combines the description of the runtime with the name of the current thread. \n>>> getRuntimeId(runtime) \n*\/ \nstring getRuntimeId(jsi::Runtime& runtime) { "
    }

    {
        "file_name":"JsonTokenizerTest_function_5.cpp",
        "line_count":1,
        "code":"void runSerializationJsonTokenizerTest(SC::TestReport& report) { JsonTokenizerTest test(report); }",
        "mark":8.0,
        "query_nsx":"\/* Run a test for serialization using JSON Tokenizer.\n   >>> void runSerializationJsonTokenizerTest(SC::TestReport& report); *\/",
        "query_nlx":"\/* Function named runSerializationJsonTokenizerTest initializes a test object for JSON tokenization and runs the test to generate a test report. \n>>> runSerializationJsonTokenizerTest(report) void *\/"
    }

    {
        "file_name":"json_function_107.cpp",
        "line_count":4,
        "code":"adapter_type create(IteratorType first, IteratorType last)\n    {\n        return adapter_type(std::move(first), std::move(last));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Create an adapter using the provided iterators.\n   >>> create(first, last) adapter_type *\/",
        "query_nlx":"\/* Create an adapter object using the provided iterators by moving their contents into the adapter.\n   >>> create({1, 2, 3}, {4, 5, 6}) *\/ \nadapter_type create(IteratorType first, IteratorType last) { *\/"
    }

    {
        "file_name":"json_function_109.cpp",
        "line_count":5,
        "code":"adapter_type input_adapter(IteratorType first, IteratorType last)\n{\n    using factory_type = iterator_input_adapter_factory<IteratorType>;\n    return factory_type::create(first, last);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an input adapter using the provided iterators. \n>>> adapter_type input_adapter(IteratorType first, IteratorType last) { *\/",
        "query_nlx":"\/* Create an adapter type function that takes a range defined by two iterators and returns an input adapter using a factory specific to the iterator type.\n>>> input_adapter(IteratorType first, IteratorType last) adapter_type *\/"
    }

    {
        "file_name":"json_function_110.cpp",
        "line_count":4,
        "code":"adapter_type create(const ContainerType& container)\n{\n    return input_adapter(begin(container), end(container));\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an adapter of a specific type using the elements from a given container.\n   >>> create({1, 2, 3, 4}) adapter_type *\/",
        "query_nlx":"\/* Create an adapter of a specified type using the elements of a given container.\n   >>> create({1, 2, 3, 4}) returns an adapter of the specified type using the elements of the container\n   >>> create({\"apple\", \"banana\", \"orange\"}) returns an adapter of the specified type using the elements of the container *\/ \nadapter_type create(const ContainerType& container) { "
    }

    {
        "file_name":"json_function_111.cpp",
        "line_count":4,
        "code":"adapter_type input_adapter(const ContainerType& container)\n{\n    return container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);\n}",
        "mark":8.0,
        "query_nsx":"\/* Create an adapter for input data from a given container type.\n   >>> adapter_type input_adapter(const ContainerType& container); *\/",
        "query_nlx":"\/* Create an input adapter for a given container type using a factory implementation.\n   >>> input_adapter(const ContainerType& container) \n*\/"
    }

    {
        "file_name":"json_function_123.cpp",
        "line_count":11,
        "code":"bool start_object(std::size_t len)\n    {\n        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));\n\n        if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))\n        {\n            JSON_THROW(out_of_range::create(408, concat(\"excessive object size: \", std::to_string(len)), ref_stack.back()));\n        }\n\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if a new object can be started with a specified size limit.\n   >>> bool start_object(std::size_t len) *\/",
        "query_nlx":"\/* Function named start_object takes a size parameter and initializes a new object in a stack.\n>>> start_object(100) true\n>>> start_object(500) true *\/ \nbool start_object(std::size_t len) {"
    }

    {
        "file_name":"json_function_125.cpp",
        "line_count":9,
        "code":"bool end_object()\n    {\n        JSON_ASSERT(!ref_stack.empty());\n        JSON_ASSERT(ref_stack.back()->is_object());\n\n        ref_stack.back()->set_parents();\n        ref_stack.pop_back();\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the current object in the JSON structure has been fully processed and can be closed. \n>>> bool end_object() { *\/",
        "query_nlx":"\/* Function named end_object checks if the current object being processed in a JSON structure has been fully parsed and sets the necessary parent references before moving to the next object.\n>>> end_object() true *\/ \nbool end_object() { "
    }

    {
        "file_name":"json_function_151.cpp",
        "line_count":4,
        "code":"bool end_object()\n    {\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the current object has reached its end.\n   >>> end_object() true *\/",
        "query_nlx":"\/* Function named end_object determines if a certain condition is met and returns a boolean value accordingly.\n>>> end_object() true\n>>> end_object() true *\/ \nbool end_object() {"
    }

    {
        "file_name":"json_function_152.cpp",
        "line_count":4,
        "code":"bool end_array()\n    {\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the array has reached its end.\n   >>> end_array() true *\/ \nbool end_array();",
        "query_nlx":"\/* Function named end_array checks if the end of an array has been reached.\n>>> end_array() true\n*\/ \nbool end_array() {"
    }

    {
        "file_name":"json_function_173.cpp",
        "line_count":8,
        "code":"void skip_whitespace()\n    {\n        do\n        {\n            get();\n        }\n        while (current == ' ' || current == '\\t' || current == '\\n' || current == '\\r');\n    }",
        "mark":8.0,
        "query_nsx":"\/* Skip over any whitespace characters in the input stream.\n    >>> void skip_whitespace() { *\/",
        "query_nlx":"\/* Define a function that continuously reads characters until it encounters a non-whitespace character (space, tab, newline, carriage return).\n   >>> skip_whitespace() *\/ \nvoid skip_whitespace() {"
    }

    {
        "file_name":"json_function_211.cpp",
        "line_count":106,
        "code":"bool get_msgpack_binary(binary_t& result)\n    {\n        \/\/ helper function to set the subtype\n        auto assign_and_return_true = [&result](std::int8_t subtype)\n        {\n            result.set_subtype(static_cast<std::uint8_t>(subtype));\n            return true;\n        };\n\n        switch (current)\n        {\n            case 0xC4: \/\/ bin 8\n            {\n                std::uint8_t len{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_binary(input_format_t::msgpack, len, result);\n            }\n\n            case 0xC5: \/\/ bin 16\n            {\n                std::uint16_t len{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_binary(input_format_t::msgpack, len, result);\n            }\n\n            case 0xC6: \/\/ bin 32\n            {\n                std::uint32_t len{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_binary(input_format_t::msgpack, len, result);\n            }\n\n            case 0xC7: \/\/ ext 8\n            {\n                std::uint8_t len{};\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, len, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xC8: \/\/ ext 16\n            {\n                std::uint16_t len{};\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, len, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xC9: \/\/ ext 32\n            {\n                std::uint32_t len{};\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, len) &&\n                       get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, len, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD4: \/\/ fixext 1\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 1, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD5: \/\/ fixext 2\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 2, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD6: \/\/ fixext 4\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 4, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD7: \/\/ fixext 8\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 8, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            case 0xD8: \/\/ fixext 16\n            {\n                std::int8_t subtype{};\n                return get_number(input_format_t::msgpack, subtype) &&\n                       get_binary(input_format_t::msgpack, 16, result) &&\n                       assign_and_return_true(subtype);\n            }\n\n            default:           \/\/ LCOV_EXCL_LINE\n                return false;  \/\/ LCOV_EXCL_LINE\n        }\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Extract binary data from a message pack format and set the subtype if applicable.\n        >>> bool get_msgpack_binary(binary_t& result) { *\/",
        "query_nlx":"\/* Define a function that retrieves a binary message pack and sets the subtype accordingly based on the message pack format.\n   >>> get_msgpack_binary(binary_t& result) *\/"
    }

    {
        "file_name":"json_function_212.cpp",
        "line_count":17,
        "code":"bool get_msgpack_array(const std::size_t len)\n    {\n        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))\n        {\n            return false;\n        }\n\n        for (std::size_t i = 0; i < len; ++i)\n        {\n            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))\n            {\n                return false;\n            }\n        }\n\n        return sax->end_array();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a message pack array of a specified length can be successfully parsed.\n>>> bool get_msgpack_array(const std::size_t len) { *\/",
        "query_nlx":"\/* Function named get_msgpack_array checks if a given message pack array of a specified length can be successfully parsed and ends the array parsing process.\n>>> get_msgpack_array(5) true\n>>> get_msgpack_array(0) false *\/ \nbool get_msgpack_array(const std::size_t len) { "
    }

    {
        "file_name":"json_function_236.cpp",
        "line_count":9,
        "code":"void pop_back()\n    {\n        if (JSON_HEDLEY_UNLIKELY(empty()))\n        {\n            JSON_THROW(detail::out_of_range::create(405, \"JSON pointer has no parent\", nullptr));\n        }\n\n        reference_tokens.pop_back();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove the last element from a collection of items.\n>>> void pop_back() { *\/",
        "query_nlx":"\/* Function named pop_back removes the last element from a collection of items unless the collection is empty. If the collection is empty, it throws an exception indicating that the JSON pointer has no parent.\n>>> pop_back()\n*\/ \nvoid pop_back() {"
    }

    {
        "file_name":"json_function_237.cpp",
        "line_count":4,
        "code":"void push_back(const string_t& token)\n    {\n        reference_tokens.push_back(token);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Add a token to the end of the reference tokens list.\n    >>> push_back(const string_t& token) *\/",
        "query_nlx":"\/* Define a function that adds a given string token to a collection of reference tokens.\n   >>> push_back(\"example_token\") *\/ \nvoid push_back(const string_t& token) { "
    }

    {
        "file_name":"json_function_238.cpp",
        "line_count":4,
        "code":"void push_back(string_t&& token)\n    {\n        reference_tokens.push_back(std::move(token));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Add a token to the end of the list of reference tokens.\n   >>> push_back(string_t&& token) *\/",
        "query_nlx":"\/* Define a function named push_back that takes a single argument, a string token passed by rvalue reference, and adds it to a container of reference tokens by moving it.\n   >>> push_back(\"example_token\") *\/ \nvoid push_back(string_t&& token) { \n    \/\/ Function body omitted \n}"
    }

    {
        "file_name":"json_function_239.cpp",
        "line_count":36,
        "code":"size_type array_index(const string_t& s)\n    {\n        using size_type = typename BasicJsonType::size_type;\n\n        \/\/ error condition (cf. RFC 6901, Sect. 4)\n        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))\n        {\n            JSON_THROW(detail::parse_error::create(106, 0, detail::concat(\"array index '\", s, \"' must not begin with '0'\"), nullptr));\n        }\n\n        \/\/ error condition (cf. RFC 6901, Sect. 4)\n        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))\n        {\n            JSON_THROW(detail::parse_error::create(109, 0, detail::concat(\"array index '\", s, \"' is not a number\"), nullptr));\n        }\n\n        const char* p = s.c_str();\n        char* p_end = nullptr;\n        errno = 0; \/\/ strtoull doesn't reset errno\n        const unsigned long long res = std::strtoull(p, &p_end, 10); \/\/ NOLINT(runtime\/int)\n        if (p == p_end \/\/ invalid input or empty string\n                || errno == ERANGE \/\/ out of range\n                || JSON_HEDLEY_UNLIKELY(static_cast<std::size_t>(p_end - p) != s.size())) \/\/ incomplete read\n        {\n            JSON_THROW(detail::out_of_range::create(404, detail::concat(\"unresolved reference token '\", s, \"'\"), nullptr));\n        }\n\n        \/\/ only triggered on special platforms (like 32bit), see also\n        \/\/ https:\/\/github.com\/nlohmann\/json\/pull\/2203\n        if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))  \/\/ NOLINT(runtime\/int)\n        {\n            JSON_THROW(detail::out_of_range::create(410, detail::concat(\"array index \", s, \" exceeds size_type\"), nullptr));   \/\/ LCOV_EXCL_LINE\n        }\n\n        return static_cast<size_type>(res);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Parse a string representing an array index and convert it to a size type value.\n   >>> size_type array_index(const string_t& s); *\/",
        "query_nlx":"\/* Define a function named array_index that takes a string parameter and returns a size_type value representing an array index.\n   The function validates the input string to ensure it represents a valid array index according to RFC 6901, Sect. 4 rules.\n   It checks if the string is not empty, does not start with '0', and is a numeric value within the range of size_type.\n   If the input string is invalid or out of range, appropriate exceptions are thrown.\n   The function then converts the string to an unsigned long long integer and checks if it exceeds the maximum size_type value.\n   If the conversion is successful and within bounds, the integer value is cast to size_type and returned. *\/\nsize_type array_index(const string_t& s) { *\/"
    }

    {
        "file_name":"json_function_261.cpp",
        "line_count":4,
        "code":"void write_bson_null(const string_t& name)\n    {\n        write_bson_entry_header(name, 0x0A);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Write a function that creates a BSON entry with a null value for the given name.\n>>> write_bson_null(const string_t& name) *\/",
        "query_nlx":"\/* Function named write_bson_null writes a null entry with a given name to a BSON document.\n>>> write_bson_null(\"example_name\") *\/ \nvoid write_bson_null(const string_t& name) { "
    }

    {
        "file_name":"json_function_262.cpp",
        "line_count":6,
        "code":"size_t calc_bson_integer_size(const std::int64_t value)\n    {\n        return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()\n               ? sizeof(std::int32_t)\n               : sizeof(std::int64_t);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of the integer data type needed to store a given value.\n   >>> calc_bson_integer_size(123456789) 8\n   >>> calc_bson_integer_size(-100) 4 *\/ \nsize_t calc_bson_integer_size(const std::int64_t value) {",
        "query_nlx":"\/* Determine the size of the integer data type required to store a given 64-bit integer value based on its range.\n   >>> calc_bson_integer_size(123456789) 4\n   >>> calc_bson_integer_size(-987654321) 4\n   >>> calc_bson_integer_size(123456789012345) 8\n   >>> calc_bson_integer_size(-987654321098765) 8 *\/ \nsize_t calc_bson_integer_size(const std::int64_t value) { "
    }

    {
        "file_name":"json_function_272.cpp",
        "line_count":10,
        "code":"size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)\n    {\n        const std::size_t document_size = std::accumulate(value.begin(), value.end(), static_cast<std::size_t>(0),\n                                          [](size_t result, const typename BasicJsonType::object_t::value_type & el)\n        {\n            return result += calc_bson_element_size(el.first, el.second);\n        });\n\n        return sizeof(std::int32_t) + document_size + 1ul;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the size of a BSON object based on the provided key-value pairs.\n   >>> size_t calc_bson_object_size(const typename BasicJsonType::object_t& value); *\/",
        "query_nlx":"        \/* Calculate the size of a BSON object based on the key-value pairs it contains.\n        >>> calc_bson_object_size({\"key1\": value1, \"key2\": value2}) returns size_t\n        >>> calc_bson_object_size({\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}) returns size_t *\/ \n        size_t calc_bson_object_size(const typename BasicJsonType::object_t& value) { "
    }

    {
        "file_name":"json_function_314.cpp",
        "line_count":4,
        "code":"bool is_negative_number(NumberType x)\n    {\n        return x < 0;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given number is negative.\n>>> bool is_negative_number(NumberType x) { *\/",
        "query_nlx":"\/* Function named is_negative_number determines if a given number is negative or not.\n>>> is_negative_number(5) false\n>>> is_negative_number(-3) true *\/ \nbool is_negative_number(NumberType x) {"
    }

    {
        "file_name":"json_function_32.cpp",
        "line_count":7,
        "code":"OutStringType concat(Args && ... args)\n{\n    OutStringType str;\n    str.reserve(concat_length(args...));\n    concat_into(str, std::forward<Args>(args)...);\n    return str;\n}",
        "mark":8.0,
        "query_nsx":"\/* Concatenate multiple input arguments into a single string and return the result.\n   >>> OutStringType concat(Args && ... args) *\/",
        "query_nlx":"\/* Function named concat takes in a variable number of arguments and concatenates them into a single string.\n>>> concat(\"Hello\", \" \", \"World\") returns \"Hello World\"\n>>> concat(\"The\", \" \", \"quick\", \" \", \"brown\", \" \", \"fox\") returns \"The quick brown fox\" *\/ \nOutStringType concat(Args && ... args) {"
    }

    {
        "file_name":"json_function_325.cpp",
        "line_count":4,
        "code":"iterator erase(iterator pos)\n    {\n        return erase(pos, std::next(pos));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from a collection at the specified position.\n    >>> iterator erase(iterator pos) *\/",
        "query_nlx":"\/* Define an iterator function that removes an element at a specified position and returns the iterator to the next element in the sequence.\n>>> erase(iterator pos) *\/"
    }

    {
        "file_name":"json_function_329.cpp",
        "line_count":7,
        "code":"void insert(InputIt first, InputIt last)\n    {\n        for (auto it = first; it != last; ++it)\n        {\n            insert(*it);\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert each element from the input range into the data structure. \n    >>> void insert(InputIt first, InputIt last) *\/",
        "query_nlx":"\/* Function named insert takes a range of elements defined by two iterators and inserts each element into a data structure. \n>>> insert({1, 2, 3, 4, 5}) \n*\/ \nvoid insert(InputIt first, InputIt last) { *\/"
    }

    {
        "file_name":"json_function_330.cpp",
        "line_count":4,
        "code":"allocator_type get_allocator()\n    {\n        return allocator_type();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Describe the type of allocator used by the function.\n>>> allocator_type get_allocator() *\/",
        "query_nlx":"        \/* Query: Define a function that returns an allocator_type object.\n           >>> get_allocator() returns an allocator_type object *\/ \n        allocator_type get_allocator() {"
    }

    {
        "file_name":"json_function_331.cpp",
        "line_count":62,
        "code":"basic_json meta()\n    {\n        basic_json result;\n\n        result[\"copyright\"] = \"(C) 2013-2022 Niels Lohmann\";\n        result[\"name\"] = \"JSON for Modern C++\";\n        result[\"url\"] = \"https:\/\/github.com\/nlohmann\/json\";\n        result[\"version\"][\"string\"] =\n            detail::concat(std::to_string(NLOHMANN_JSON_VERSION_MAJOR), '.',\n                           std::to_string(NLOHMANN_JSON_VERSION_MINOR), '.',\n                           std::to_string(NLOHMANN_JSON_VERSION_PATCH));\n        result[\"version\"][\"major\"] = NLOHMANN_JSON_VERSION_MAJOR;\n        result[\"version\"][\"minor\"] = NLOHMANN_JSON_VERSION_MINOR;\n        result[\"version\"][\"patch\"] = NLOHMANN_JSON_VERSION_PATCH;\n\n#ifdef _WIN32\n        result[\"platform\"] = \"win32\";\n#elif defined __linux__\n        result[\"platform\"] = \"linux\";\n#elif defined __APPLE__\n        result[\"platform\"] = \"apple\";\n#elif defined __unix__\n        result[\"platform\"] = \"unix\";\n#else\n        result[\"platform\"] = \"unknown\";\n#endif\n\n#if defined(__ICC) || defined(__INTEL_COMPILER)\n        result[\"compiler\"] = {{\"family\", \"icc\"}, {\"version\", __INTEL_COMPILER}};\n#elif defined(__clang__)\n        result[\"compiler\"] = {{\"family\", \"clang\"}, {\"version\", __clang_version__}};\n#elif defined(__GNUC__) || defined(__GNUG__)\n        result[\"compiler\"] = {{\"family\", \"gcc\"}, {\"version\", detail::concat(\n                    std::to_string(__GNUC__), '.',\n                    std::to_string(__GNUC_MINOR__), '.',\n                    std::to_string(__GNUC_PATCHLEVEL__))\n            }\n        };\n#elif defined(__HP_cc) || defined(__HP_aCC)\n        result[\"compiler\"] = \"hp\"\n#elif defined(__IBMCPP__)\n        result[\"compiler\"] = {{\"family\", \"ilecpp\"}, {\"version\", __IBMCPP__}};\n#elif defined(_MSC_VER)\n        result[\"compiler\"] = {{\"family\", \"msvc\"}, {\"version\", _MSC_VER}};\n#elif defined(__PGI)\n        result[\"compiler\"] = {{\"family\", \"pgcpp\"}, {\"version\", __PGI}};\n#elif defined(__SUNPRO_CC)\n        result[\"compiler\"] = {{\"family\", \"sunpro\"}, {\"version\", __SUNPRO_CC}};\n#else\n        result[\"compiler\"] = {{\"family\", \"unknown\"}, {\"version\", \"unknown\"}};\n#endif\n\n\n#if defined(_MSVC_LANG)\n        result[\"compiler\"][\"c++\"] = std::to_string(_MSVC_LANG);\n#elif defined(__cplusplus)\n        result[\"compiler\"][\"c++\"] = std::to_string(__cplusplus);\n#else\n        result[\"compiler\"][\"c++\"] = \"unknown\";\n#endif\n        return result;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Create a JSON object containing information about the library, including copyright, name, URL, version, platform, and compiler details.\n   >>> basic_json meta() { *\/",
        "query_nlx":"\/* Generate a JSON object containing metadata information such as copyright, name, URL, version, platform, and compiler details.\n   The metadata includes copyright \"(C) 2013-2022 Niels Lohmann\", name \"JSON for Modern C++\", URL \"https:\/\/github.com\/nlohmann\/json\", version with major, minor, and patch numbers, platform based on the operating system, and compiler information.\n   Return the constructed JSON object.\n   >>> meta() \n*\/ \nbasic_json meta() { "
    }

    {
        "file_name":"json_function_342.cpp",
        "line_count":7,
        "code":"basic_json binary(const typename binary_t::container_type& init)\n    {\n        auto res = basic_json();\n        res.m_type = value_t::binary;\n        res.m_value = init;\n        return res;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Create a binary JSON value using the provided binary data.\n   >>> basic_json binary(const typename binary_t::container_type& init); *\/",
        "query_nlx":"\/* Function named binary creates a JSON object with a binary value initialized with the provided container data.\n   >>> binary({0x48, 0x65, 0x6C, 0x6C, 0x6F}) returns a JSON object with a binary value containing the hexadecimal bytes 48, 65, 6C, 6C, 6F *\/ \nbasic_json binary(const typename binary_t::container_type& init) { *\/"
    }

    {
        "file_name":"json_function_343.cpp",
        "line_count":7,
        "code":"basic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype)\n    {\n        auto res = basic_json();\n        res.m_type = value_t::binary;\n        res.m_value = binary_t(init, subtype);\n        return res;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Create a binary JSON value from the provided binary data and subtype.\n   >>> basic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype); *\/",
        "query_nlx":"\/* Create a function named binary that takes a container of binary data and a subtype, and returns a JSON object representing the binary data.\n   >>> binary({0x48, 0x65, 0x6C, 0x6C, 0x6F}, binary_t::subtype_type::base64) \n*\/ \nbasic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype) { "
    }

    {
        "file_name":"json_function_350.cpp",
        "line_count":5,
        "code":"ReferenceType get_ref()\n    {\n        \/\/ delegate call to get_ref_impl\n        return get_ref_impl<ReferenceType>(*this);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Retrieve a reference of a specific type by delegating the call to an internal implementation function.\n        >>> get_ref() ReferenceType *\/\n        ReferenceType get_ref();",
        "query_nlx":"\/* Retrieve a reference type by calling the get_ref_impl function with the current object as a parameter. \n   >>> get_ref() ReferenceType *\/ \nReferenceType get_ref() {"
    }

    {
        "file_name":"json_function_359.cpp",
        "line_count":16,
        "code":"size_type erase_internal(KeyType && key)\n    {\n        \/\/ this erase only works for objects\n        if (JSON_HEDLEY_UNLIKELY(!is_object()))\n        {\n            JSON_THROW(type_error::create(307, detail::concat(\"cannot use erase() with \", type_name()), this));\n        }\n\n        const auto it = m_value.object->find(std::forward<KeyType>(key));\n        if (it != m_value.object->end())\n        {\n            m_value.object->erase(it);\n            return 1;\n        }\n        return 0;\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Erase an object with a specified key from the data structure.\n        >>> size_type erase_internal(KeyType && key); *\/",
        "query_nlx":"        \/* Function named erase_internal removes an element from an object based on a given key. \n        >>> erase_internal(\"key\") returns the number of elements erased (0 or 1) *\/ \n        size_type erase_internal(KeyType && key) { "
    }

    {
        "file_name":"json_function_360.cpp",
        "line_count":6,
        "code":"size_type erase(const typename object_t::key_type& key)\n    {\n        \/\/ the indirection via erase_internal() is added to avoid making this\n        \/\/ function a template and thus de-rank it during overload resolution\n        return erase_internal(key);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Remove an element from the object using the provided key.\n        >>> size_type erase(const typename object_t::key_type& key) *\/",
        "query_nlx":"\/* Define a function named erase that removes an element from an object using a specified key.\n   >>> erase(\"example_key\") returns the size of the object after removing the element with the key \"example_key\" *\/ \nsize_type erase(const typename object_t::key_type& key) { "
    }

    {
        "file_name":"json_function_361.cpp",
        "line_count":4,
        "code":"size_type erase(KeyType && key)\n    {\n        return erase_internal(std::forward<KeyType>(key));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from a data structure based on a specified key.\n   >>> size_type erase(KeyType && key); *\/",
        "query_nlx":"\/* Define a function that removes an element from a data structure based on a given key and returns the size of the modified data structure.\n   >>> erase(\"example_key\") *\/ \nsize_type erase(KeyType && key) { "
    }

    {
        "file_name":"json_function_365.cpp",
        "line_count":22,
        "code":"void push_back(basic_json&& val)\n    {\n        \/\/ push_back only works for null objects or arrays\n        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))\n        {\n            JSON_THROW(type_error::create(308, detail::concat(\"cannot use push_back() with \", type_name()), this));\n        }\n\n        \/\/ transform null object into an array\n        if (is_null())\n        {\n            m_type = value_t::array;\n            m_value = value_t::array;\n            assert_invariant();\n        }\n\n        \/\/ add element to array (move semantics)\n        const auto old_capacity = m_value.array->capacity();\n        m_value.array->push_back(std::move(val));\n        set_parent(m_value.array->back(), old_capacity);\n        \/\/ if val is moved from, basic_json move constructor marks it null, so we do not call the destructor\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Add a new element to the end of an array or a null object.\n        >>> void push_back(basic_json&& val) *\/",
        "query_nlx":"        \/* Define a function that adds a new element to the end of a JSON object if it is null or an array.\n        >>> push_back(basic_json&& val) *\/"
    }

    {
        "file_name":"json_function_376.cpp",
        "line_count":22,
        "code":"void insert(const_iterator first, const_iterator last)\n    {\n        \/\/ insert only works for objects\n        if (JSON_HEDLEY_UNLIKELY(!is_object()))\n        {\n            JSON_THROW(type_error::create(309, detail::concat(\"cannot use insert() with \", type_name()), this));\n        }\n\n        \/\/ check if range iterators belong to the same JSON object\n        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))\n        {\n            JSON_THROW(invalid_iterator::create(210, \"iterators do not fit\", this));\n        }\n\n        \/\/ passed iterators must belong to objects\n        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))\n        {\n            JSON_THROW(invalid_iterator::create(202, \"iterators first and last must point to objects\", this));\n        }\n\n        m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Insert a range of objects into the current object.\n        >>> void insert(const_iterator first, const_iterator last) *\/",
        "query_nlx":"        \/* Define a function named insert that takes two constant iterators, first and last, as input parameters and inserts elements into an object. \n        >>> insert(const_iterator first, const_iterator last) *\/"
    }

    {
        "file_name":"json_function_377.cpp",
        "line_count":4,
        "code":"void update(const_reference j, bool merge_objects = false)\n    {\n        update(j.begin(), j.end(), merge_objects);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Update a collection of elements with an option to merge objects.\n   >>> void update(const_reference j, bool merge_objects = false) *\/",
        "query_nlx":"\/* Define a function called update that takes a constant reference to a parameter j and an optional boolean parameter merge_objects with a default value of false. This function internally calls another update function with the begin and end iterators of j and the merge_objects parameter. *\/\n>>> update(const_reference j, bool merge_objects = false) { *\/"
    }

    {
        "file_name":"json_function_38.cpp",
        "line_count":5,
        "code":"string position_string(const position_t& pos)\n    {\n        return concat(\" at line \", std::to_string(pos.lines_read + 1),\n                      \", column \", std::to_string(pos.chars_read_current_line));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Generate a string indicating the position in terms of line and column numbers.\n   >>> position_string(const position_t& pos) *\/",
        "query_nlx":"\/* Function position_string takes a position object as input and returns a concatenated string describing the position.\n   >>> position_string({lines_read: 5, chars_read_current_line: 10}) returns \"at line 6, column 10\" *\/ \nstring position_string(const position_t& pos) { "
    }

    {
        "file_name":"json_function_388.cpp",
        "line_count":4,
        "code":"void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o)\n    {\n        binary_writer<std::uint8_t>(o).write_cbor(j);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Convert a JSON object to a Concise Binary Object Representation (CBOR) format.\n        >>> void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o) { *\/",
        "query_nlx":"\/* Function named to_cbor converts a JSON object into a CBOR format and writes it to an output adapter. \n>>> to_cbor(json_object, output_adapter) *\/ \nvoid to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o) { "
    }

    {
        "file_name":"json_function_389.cpp",
        "line_count":4,
        "code":"void to_cbor(const basic_json& j, detail::output_adapter<char> o)\n    {\n        binary_writer<char>(o).write_cbor(j);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Convert a JSON object to its CBOR representation.\n        >>> void to_cbor(const basic_json& j, detail::output_adapter<char> o) { *\/",
        "query_nlx":"\/* Function named to_cbor converts a JSON object to its CBOR representation using an output adapter. \n   >>> to_cbor(json_object, output_adapter) *\/ \nvoid to_cbor(const basic_json& j, detail::output_adapter<char> o) { "
    }

    {
        "file_name":"json_function_390.cpp",
        "line_count":4,
        "code":"void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o)\n    {\n        binary_writer<std::uint8_t>(o).write_msgpack(j);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Convert a JSON object to a MessagePack format and write it to an output adapter. \n        >>> void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o) { *\/",
        "query_nlx":"\/* Function named to_msgpack converts a JSON object into a MessagePack format and writes it to an output adapter. \n>>> to_msgpack(json_object, output_adapter) *\/ \nvoid to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o) { "
    }

    {
        "file_name":"json_function_391.cpp",
        "line_count":4,
        "code":"void to_msgpack(const basic_json& j, detail::output_adapter<char> o)\n    {\n        binary_writer<char>(o).write_msgpack(j);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert a JSON object to a MessagePack format using the provided output adapter.\n   >>> void to_msgpack(const basic_json& j, detail::output_adapter<char> o) *\/",
        "query_nlx":"\/* Function named to_msgpack converts a JSON object into a MessagePack format and writes it using a binary writer.\n   >>> to_msgpack({\"key\": \"value\", \"array\": [1, 2, 3]}, output_adapter<char>) *\/ \nvoid to_msgpack(const basic_json& j, detail::output_adapter<char> o) { "
    }

    {
        "file_name":"json_function_396.cpp",
        "line_count":4,
        "code":"void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o)\n    {\n        binary_writer<std::uint8_t>(o).write_bson(j);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert a JSON object to BSON format and write it to an output adapter.\n   >>> void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o) { *\/",
        "query_nlx":"\/* Function named to_bson converts a JSON object into BSON format and writes it to an output adapter. \n>>> to_bson({\"key\": \"value\"}, output_adapter<uint8_t>) *\/ \nvoid to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o) { "
    }

    {
        "file_name":"json_function_422.cpp",
        "line_count":25,
        "code":"void merge_patch(const basic_json& apply_patch)\n    {\n        if (apply_patch.is_object())\n        {\n            if (!is_object())\n            {\n                *this = object();\n            }\n            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)\n            {\n                if (it.value().is_null())\n                {\n                    erase(it.key());\n                }\n                else\n                {\n                    operator[](it.key()).merge_patch(it.value());\n                }\n            }\n        }\n        else\n        {\n            *this = apply_patch;\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Merge the provided JSON patch with the current JSON object, updating values and removing null entries if necessary.\n>>> void merge_patch(const basic_json& apply_patch) *\/",
        "query_nlx":"        \/* Function named merge_patch updates the current JSON object by applying a patch JSON object. \n        >>> merge_patch({\"key1\": \"value1\", \"key2\": \"value2\"}) \n        >>> merge_patch({\"key1\": null, \"key3\": \"value3\"}) *\/ \n        void merge_patch(const basic_json& apply_patch) { "
    }

    {
        "file_name":"json_function_423.cpp",
        "line_count":4,
        "code":"string to_string(const NLOHMANN_BASIC_JSON_TPL& j)\n{\n    return j.dump();\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a JSON object to a string representation.\n   >>> string to_string(const NLOHMANN_BASIC_JSON_TPL& j) *\/",
        "query_nlx":"\/* Function named to_string converts a given JSON object into a string representation.\n   >>> to_string({\"key\": \"value\", \"array\": [1, 2, 3]}) returns \"{\\\"key\\\":\\\"value\\\",\\\"array\\\":[1,2,3]}\" *\/ \nstring to_string(const NLOHMANN_BASIC_JSON_TPL& j) { "
    }

    {
        "file_name":"json_function_43.cpp",
        "line_count":8,
        "code":"void from_json(const BasicJsonType& j, typename std::nullptr_t& n)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_null()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be null, but is \", j.type_name()), &j));\n    }\n    n = nullptr;\n}",
        "mark":8.0,
        "query_nsx":"\/* Parse a JSON object and assign a null value if the type is null.\n   >>> void from_json(const BasicJsonType& j, typename std::nullptr_t& n) *\/",
        "query_nlx":"\/* Function named from_json parses a JSON object and assigns a null pointer if the object is null.\n>>> from_json({\"key\": null}, nullptr) \n>>> from_json({\"key\": \"value\"}, nullptr) *\/ \nvoid from_json(const BasicJsonType& j, typename std::nullptr_t& n) { "
    }

    {
        "file_name":"json_function_48.cpp",
        "line_count":4,
        "code":"void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)\n{\n    get_arithmetic_value(j, val);\n}",
        "mark":8.0,
        "query_nsx":"\/* Extract a floating-point number value from a JSON object.\n>>> void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val) { *\/",
        "query_nlx":"\/* Function named from_json extracts a floating-point number value from a JSON object using arithmetic operations.\n>>> from_json({\"key\": 3.14}, value) *\/ \nvoid from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val) { "
    }

    {
        "file_name":"json_function_49.cpp",
        "line_count":4,
        "code":"void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)\n{\n    get_arithmetic_value(j, val);\n}",
        "mark":8.0,
        "query_nsx":"\/* Parse a JSON object to extract an unsigned number value.\n   >>> void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val) { *\/",
        "query_nlx":"\/* Function named from_json extracts an unsigned number value from a JSON object using the get_arithmetic_value function.\n>>> from_json({\"key\": 42}, val) *\/ \nvoid from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val) { "
    }

    {
        "file_name":"json_function_50.cpp",
        "line_count":4,
        "code":"void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)\n{\n    get_arithmetic_value(j, val);\n}",
        "mark":8.0,
        "query_nsx":"\/* Extract an arithmetic value from a JSON object.\n   >>> void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val) { *\/",
        "query_nlx":"\/* Function named from_json extracts an arithmetic value from a given JSON object and assigns it to the provided integer variable.\n>>> from_json({\"key\": 42}, val) *\/ \nvoid from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val) { "
    }

    {
        "file_name":"json_function_51.cpp",
        "line_count":6,
        "code":"void from_json(const BasicJsonType& j, EnumType& e)\n{\n    typename std::underlying_type<EnumType>::type val;\n    get_arithmetic_value(j, val);\n    e = static_cast<EnumType>(val);\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a JSON value to an enumeration type.\n>>> void from_json(const BasicJsonType& j, EnumType& e) { *\/",
        "query_nlx":"\/* Function named from_json converts an arithmetic value from a JSON object to an enumeration value.\n>>> from_json(const BasicJsonType& j, EnumType& e) *\/"
    }

    {
        "file_name":"json_function_52.cpp",
        "line_count":13,
        "code":"void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be array, but is \", j.type_name()), &j));\n    }\n    l.clear();\n    std::transform(j.rbegin(), j.rend(),\n                   std::front_inserter(l), [](const BasicJsonType & i)\n    {\n        return i.template get<T>();\n    });\n}",
        "mark":8.0,
        "query_nsx":"\/* Parse a JSON array and populate a forward list with its elements in reverse order.\n>>> void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l) { *\/",
        "query_nlx":"\/* Function named from_json parses a JSON array and populates a forward list with the elements in reverse order.\n   >>> from_json([1, 2, 3, 4], l) l = {4, 3, 2, 1}\n   >>> from_json([\"apple\", \"banana\", \"cherry\"], l) l = {\"cherry\", \"banana\", \"apple\"} *\/ \nvoid from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l) { "
    }

    {
        "file_name":"json_function_53.cpp",
        "line_count":13,
        "code":"void from_json(const BasicJsonType& j, std::valarray<T>& l)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be array, but is \", j.type_name()), &j));\n    }\n    l.resize(j.size());\n    std::transform(j.begin(), j.end(), std::begin(l),\n                   [](const BasicJsonType & elem)\n    {\n        return elem.template get<T>();\n    });\n}",
        "mark":8.0,
        "query_nsx":"\/* Parse a JSON array and populate a std::valarray with its elements.\n   >>> void from_json(const BasicJsonType& j, std::valarray<T>& l) *\/",
        "query_nlx":"        \/* Function named from_json converts a JSON array into a std::valarray of a specified type by resizing the valarray to match the size of the JSON array and transforming each element from the JSON array to the specified type.\n        >>> from_json([1, 2, 3], std::valarray<int>) \n        >>> from_json([\"apple\", \"banana\", \"cherry\"], std::valarray<string>) *\/ \n        void from_json(const BasicJsonType& j, std::valarray<T>& l) { "
    }

    {
        "file_name":"json_function_56.cpp",
        "line_count":9,
        "code":"void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be binary, but is \", j.type_name()), &j));\n    }\n\n    bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();\n}",
        "mark":8.0,
        "query_nsx":"\/* Extract binary data from a JSON object if the type is binary.\n   >>> void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin) { *\/",
        "query_nlx":"\/* Function named from_json takes a JSON object and a binary type, and assigns the binary value from the JSON object to the binary type if the JSON object represents a binary value.\n   >>> from_json({\"data\": [0, 1, 0, 1]}, binary_data) \n   >>> from_json({\"image\": [255, 0, 128]}, image_binary_data) *\/\nvoid from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin) { *\/"
    }

    {
        "file_name":"json_function_63.cpp",
        "line_count":8,
        "code":"void from_json(const BasicJsonType& j, std_fs::path& p)\n{\n    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))\n    {\n        JSON_THROW(type_error::create(302, concat(\"type must be string, but is \", j.type_name()), &j));\n    }\n    p = *j.template get_ptr<const typename BasicJsonType::string_t*>();\n}",
        "mark":8.0,
        "query_nsx":"        \/* Parse a JSON object to extract a string value and assign it to a file path.\n        >>> void from_json(const BasicJsonType& j, std_fs::path& p) { *\/",
        "query_nlx":"\/* Function named from_json parses a JSON value to extract a string and assigns it to a given filesystem path.\n>>> from_json(json_value, file_path) *\/ \nvoid from_json(const BasicJsonType& j, std_fs::path& p) { "
    }

    {
        "file_name":"json_function_64.cpp",
        "line_count":6,
        "code":"void int_to_string( string_type& target, std::size_t value )\n{\n    \/\/ For ADL\n    using std::to_string;\n    target = to_string(value);\n}",
        "mark":8.0,
        "query_nsx":"        \/* Convert an integer value to a string representation.\n        >>> void int_to_string( string_type& target, std::size_t value ) *\/",
        "query_nlx":"        \/* Function named int_to_string converts a given integer value to a string and stores it in the provided target string. \n        >>> int_to_string(target, 123) target = \"123\" \n        >>> int_to_string(target, 9876) target = \"9876\" *\/ \n        void int_to_string( string_type& target, std::size_t value ) { "
    }

    {
        "file_name":"json_function_89.cpp",
        "line_count":4,
        "code":"void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> \/*unused*\/)\n{\n    j = { std::get<Idx>(t)... };\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a tuple to a JSON object.\n>>> void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> { *\/",
        "query_nlx":"\/* Function named to_json_tuple_impl converts a tuple into a JSON object by assigning each element of the tuple to a key in the JSON object.\n>>> to_json_tuple_impl(j, t, index_sequence<Idx...> \/*unused*\/) *\/ \nvoid to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> \/*unused*\/) { "
    }

    {
        "file_name":"json_function_91.cpp",
        "line_count":4,
        "code":"void to_json(BasicJsonType& j, const std_fs::path& p)\n{\n    j = p.string();\n}",
        "mark":8.0,
        "query_nsx":"        \/* Convert a file path to a JSON string representation.\n        >>> void to_json(BasicJsonType& j, const std_fs::path& p) *\/",
        "query_nlx":"\/* Function named to_json converts a given file path to a JSON string representation.\n>>> to_json(\"\/path\/to\/file\") converts the file path to a JSON string *\/ \nvoid to_json(BasicJsonType& j, const std_fs::path& p) { "
    }

    {
        "file_name":"json_function_92.cpp",
        "line_count":86,
        "code":"size_t hash(const BasicJsonType& j)\n{\n    using string_t = typename BasicJsonType::string_t;\n    using number_integer_t = typename BasicJsonType::number_integer_t;\n    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;\n    using number_float_t = typename BasicJsonType::number_float_t;\n\n    const auto type = static_cast<std::size_t>(j.type());\n    switch (j.type())\n    {\n        case BasicJsonType::value_t::null:\n        case BasicJsonType::value_t::discarded:\n        {\n            return combine(type, 0);\n        }\n\n        case BasicJsonType::value_t::object:\n        {\n            auto seed = combine(type, j.size());\n            for (const auto& element : j.items())\n            {\n                const auto h = std::hash<string_t> {}(element.key());\n                seed = combine(seed, h);\n                seed = combine(seed, hash(element.value()));\n            }\n            return seed;\n        }\n\n        case BasicJsonType::value_t::array:\n        {\n            auto seed = combine(type, j.size());\n            for (const auto& element : j)\n            {\n                seed = combine(seed, hash(element));\n            }\n            return seed;\n        }\n\n        case BasicJsonType::value_t::string:\n        {\n            const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::boolean:\n        {\n            const auto h = std::hash<bool> {}(j.template get<bool>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::number_integer:\n        {\n            const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::number_unsigned:\n        {\n            const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::number_float:\n        {\n            const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());\n            return combine(type, h);\n        }\n\n        case BasicJsonType::value_t::binary:\n        {\n            auto seed = combine(type, j.get_binary().size());\n            const auto h = std::hash<bool> {}(j.get_binary().has_subtype());\n            seed = combine(seed, h);\n            seed = combine(seed, static_cast<std::size_t>(j.get_binary().subtype()));\n            for (const auto byte : j.get_binary())\n            {\n                seed = combine(seed, std::hash<std::uint8_t> {}(byte));\n            }\n            return seed;\n        }\n\n        default:                   \/\/ LCOV_EXCL_LINE\n            JSON_ASSERT(false); \/\/ NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE\n            return 0;              \/\/ LCOV_EXCL_LINE\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate a hash value for a given JSON object.\n>>> size_t hash(const BasicJsonType& j) *\/",
        "query_nlx":"\/* Define a hash function that calculates a hash value for a given JSON object based on its type and content.\n>>> hash(const BasicJsonType& j) *\/"
    }

    {
        "file_name":"Ktx1Reader_function_1.cpp",
        "line_count":55,
        "code":"T toCompressedFilamentEnum(uint32_t format) {\n        switch (format) {\n            case Ktx1Bundle::RGB_S3TC_DXT1: return T::DXT1_RGB;\n            case Ktx1Bundle::RGBA_S3TC_DXT1: return T::DXT1_RGBA;\n            case Ktx1Bundle::RGBA_S3TC_DXT3: return T::DXT3_RGBA;\n            case Ktx1Bundle::RGBA_S3TC_DXT5: return T::DXT5_RGBA;\n            case Ktx1Bundle::R_RGTC_BC4_UNORM: return T::RED_RGTC1;\n            case Ktx1Bundle::R_RGTC_BC4_SNORM: return T::SIGNED_RED_RGTC1;\n            case Ktx1Bundle::RG_RGTC_BC5_UNORM: return T::RED_GREEN_RGTC2;\n            case Ktx1Bundle::RG_RGTC_BC5_SNORM: return T::SIGNED_RED_GREEN_RGTC2;\n            case Ktx1Bundle::RGBA_BPTC_BC7: return T::RGBA_BPTC_UNORM;\n            case Ktx1Bundle::SRGB8_ALPHA8_BPTC_BC7: return T::SRGB_ALPHA_BPTC_UNORM;\n            case Ktx1Bundle::RGB_BPTC_BC6H_SNORM: return T::RGB_BPTC_SIGNED_FLOAT;\n            case Ktx1Bundle::RGB_BPTC_BC6H_UNORM: return T::RGB_BPTC_UNSIGNED_FLOAT;\n            case Ktx1Bundle::RGBA_ASTC_4x4: return T::RGBA_ASTC_4x4;\n            case Ktx1Bundle::RGBA_ASTC_5x4: return T::RGBA_ASTC_5x4;\n            case Ktx1Bundle::RGBA_ASTC_5x5: return T::RGBA_ASTC_5x5;\n            case Ktx1Bundle::RGBA_ASTC_6x5: return T::RGBA_ASTC_6x5;\n            case Ktx1Bundle::RGBA_ASTC_6x6: return T::RGBA_ASTC_6x6;\n            case Ktx1Bundle::RGBA_ASTC_8x5: return T::RGBA_ASTC_8x5;\n            case Ktx1Bundle::RGBA_ASTC_8x6: return T::RGBA_ASTC_8x6;\n            case Ktx1Bundle::RGBA_ASTC_8x8: return T::RGBA_ASTC_8x8;\n            case Ktx1Bundle::RGBA_ASTC_10x5: return T::RGBA_ASTC_10x5;\n            case Ktx1Bundle::RGBA_ASTC_10x6: return T::RGBA_ASTC_10x6;\n            case Ktx1Bundle::RGBA_ASTC_10x8: return T::RGBA_ASTC_10x8;\n            case Ktx1Bundle::RGBA_ASTC_10x10: return T::RGBA_ASTC_10x10;\n            case Ktx1Bundle::RGBA_ASTC_12x10: return T::RGBA_ASTC_12x10;\n            case Ktx1Bundle::RGBA_ASTC_12x12: return T::RGBA_ASTC_12x12;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_4x4: return T::SRGB8_ALPHA8_ASTC_4x4;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_5x4: return T::SRGB8_ALPHA8_ASTC_5x4;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_5x5: return T::SRGB8_ALPHA8_ASTC_5x5;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_6x5: return T::SRGB8_ALPHA8_ASTC_6x5;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_6x6: return T::SRGB8_ALPHA8_ASTC_6x6;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_8x5: return T::SRGB8_ALPHA8_ASTC_8x5;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_8x6: return T::SRGB8_ALPHA8_ASTC_8x6;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_8x8: return T::SRGB8_ALPHA8_ASTC_8x8;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_10x5: return T::SRGB8_ALPHA8_ASTC_10x5;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_10x6: return T::SRGB8_ALPHA8_ASTC_10x6;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_10x8: return T::SRGB8_ALPHA8_ASTC_10x8;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_10x10: return T::SRGB8_ALPHA8_ASTC_10x10;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_12x10: return T::SRGB8_ALPHA8_ASTC_12x10;\n            case Ktx1Bundle::SRGB8_ALPHA8_ASTC_12x12: return T::SRGB8_ALPHA8_ASTC_12x12;\n            case Ktx1Bundle::R11_EAC: return T::EAC_R11;\n            case Ktx1Bundle::SIGNED_R11_EAC: return T::EAC_R11_SIGNED;\n            case Ktx1Bundle::RG11_EAC: return T::EAC_RG11;\n            case Ktx1Bundle::SIGNED_RG11_EAC: return T::EAC_RG11_SIGNED;\n            case Ktx1Bundle::RGB8_ETC2: return T::ETC2_RGB8;\n            case Ktx1Bundle::SRGB8_ETC2: return T::ETC2_SRGB8;\n            case Ktx1Bundle::RGB8_ALPHA1_ETC2: return T::ETC2_RGB8_A1;\n            case Ktx1Bundle::SRGB8_ALPHA1_ETC: return T::ETC2_SRGB8_A1;\n            case Ktx1Bundle::RGBA8_ETC2_EAC: return T::ETC2_EAC_RGBA8;\n            case Ktx1Bundle::SRGB8_ALPHA8_ETC2_EAC: return T::ETC2_EAC_SRGBA8;\n        }\n        return (T) 0xffff;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Map different formats to compressed filament enums.\n   >>> T toCompressedFilamentEnum(uint32_t format); *\/",
        "query_nlx":"\/* Generate a function that maps a given format to a compressed filament enum value based on the format provided.\n   The function should return the corresponding compressed filament enum value for the input format.\n   Use the provided Ktx1Bundle enum values to determine the mapping.\n   If the input format does not match any of the predefined enum values, return 0xffff as the default value. *\/\n\nT toCompressedFilamentEnum(uint32_t format) { *\/"
    }

    {
        "file_name":"LinearImage_function_1.cpp",
        "line_count":1,
        "code":"void reset() { *this = LinearImage(); }",
        "mark":8.0,
        "query_nsx":"\/* Reset the current object to a new LinearImage instance.\n   >>> void reset() { *this = LinearImage(); } *\/",
        "query_nlx":"\/* Define a function named reset that resets the current object to a new LinearImage object.\n   >>> reset()\n*\/ \nvoid reset() { *this = LinearImage(); }"
    }

    {
        "file_name":"LocalSettings_function_1.cpp",
        "line_count":3,
        "code":"void SetToken(const std::string& str) {\n\t\tm_token = str;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set a token with the provided string input.\n>>> SetToken(\"example_token\") *\/ \nvoid SetToken(const std::string& str) {",
        "query_nlx":"\/* Function named SetToken sets a token with the provided string value.\n   >>> SetToken(\"example_token\") *\/ \nvoid SetToken(const std::string& str) {"
    }

    {
        "file_name":"LocalSettings_function_10.cpp",
        "line_count":3,
        "code":"void SetMinimizeToNotif(bool b) {\n\t\tm_bMinimizeToNotif = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to determine whether to minimize to notification area or not.\n   >>> SetMinimizeToNotif(true) \n   >>> SetMinimizeToNotif(false) *\/ \nvoid SetMinimizeToNotif(bool b) {",
        "query_nlx":"\/* Function named SetMinimizeToNotif sets a boolean variable to indicate whether to minimize to notification area or not.\n>>> SetMinimizeToNotif(true) \n>>> SetMinimizeToNotif(false) *\/ \nvoid SetMinimizeToNotif(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_11.cpp",
        "line_count":3,
        "code":"void SetMaximized(bool b) {\n\t\tm_bMaximized = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the maximized state to the given boolean value.\n   >>> SetMaximized(true) \n   >>> SetMaximized(false) *\/ \nvoid SetMaximized(bool b) {",
        "query_nlx":"\/* Function named SetMaximized sets a boolean variable to indicate whether a certain state is maximized or not.\n>>> SetMaximized(true) \n>>> SetMaximized(false) *\/ \nvoid SetMaximized(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_12.cpp",
        "line_count":3,
        "code":"void SetDiscordAPI(const std::string& str) {\n\t\tm_discordApi = str;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the Discord API to the provided string.\n>>> SetDiscordAPI(\"example_api_key\") *\/ \nvoid SetDiscordAPI(const std::string& str) {",
        "query_nlx":"\/* Define a function that sets a Discord API string.\n   >>> SetDiscordAPI(\"your_api_key_here\") *\/ \nvoid SetDiscordAPI(const std::string& str) {"
    }

    {
        "file_name":"LocalSettings_function_13.cpp",
        "line_count":3,
        "code":"void SetDiscordCDN(const std::string& str) {\n\t\tm_discordCdn = str;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the Discord CDN (Content Delivery Network) to the provided string.\n   >>> SetDiscordCDN(const std::string& str) *\/",
        "query_nlx":"\/* Function named SetDiscordCDN sets the Discord CDN URL to the provided string.\n   >>> SetDiscordCDN(\"https:\/\/cdn.discordapp.com\/\") *\/ \nvoid SetDiscordCDN(const std::string& str) { "
    }

    {
        "file_name":"LocalSettings_function_14.cpp",
        "line_count":4,
        "code":"void SetCheckUpdates(bool b) {\n\t\tm_bCheckUpdates = b;\n\t\tm_bAskToCheckUpdates = false;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to enable or disable automatic update checks. \n>>> SetCheckUpdates(true) \n>>> SetCheckUpdates(false) *\/ \nvoid SetCheckUpdates(bool b) {",
        "query_nlx":"\n\/* Function named SetCheckUpdates sets a boolean variable to control whether to check for updates and disables the prompt to check for updates.\n>>> SetCheckUpdates(true) \n>>> SetCheckUpdates(false) *\/ \nvoid SetCheckUpdates(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_15.cpp",
        "line_count":3,
        "code":"void SetEnableTLSVerification(bool b) {\n\t\tm_bEnableTLSVerification = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set whether TLS verification is enabled or disabled.\n   >>> SetEnableTLSVerification(true) \n   >>> SetEnableTLSVerification(false) *\/ \nvoid SetEnableTLSVerification(bool b) {",
        "query_nlx":"\/* Function named SetEnableTLSVerification sets a boolean value to enable or disable TLS verification.\n>>> SetEnableTLSVerification(true) \n>>> SetEnableTLSVerification(false) *\/ \nvoid SetEnableTLSVerification(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_16.cpp",
        "line_count":3,
        "code":"void SetAddExtraHeaders(bool b) {\n\t\tm_bAddExtraHeaders = b;\n\t}",
        "mark":9.0,
        "query_nsx":"\/* Set a flag to determine whether additional headers should be included in the output. \n>>> SetAddExtraHeaders(true) *\/ \nvoid SetAddExtraHeaders(bool b) {",
        "query_nlx":"\/* Function named SetAddExtraHeaders sets a boolean flag to determine whether extra headers should be added.\n>>> SetAddExtraHeaders(true) \n>>> SetAddExtraHeaders(false) *\/ \nvoid SetAddExtraHeaders(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_17.cpp",
        "line_count":3,
        "code":"void SetDisableFormatting(bool b) {\n\t\tm_bDisableFormatting = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to enable or disable formatting. \n>>> SetDisableFormatting(true) \n>>> SetDisableFormatting(false) *\/ \nvoid SetDisableFormatting(bool b) {",
        "query_nlx":"\/* Function named SetDisableFormatting sets a boolean variable to enable or disable formatting in the system.\n>>> SetDisableFormatting(true) \n>>> SetDisableFormatting(false) *\/ \nvoid SetDisableFormatting(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_18.cpp",
        "line_count":3,
        "code":"void SetShowScrollBarOnGuildList(bool b) {\n\t\tm_bShowScrollBarOnGuildList = b;\n\t}",
        "mark":10.0,
        "query_nsx":"\/* Set whether to show scroll bar on guild list.\n   >>> SetShowScrollBarOnGuildList(true) \n   >>> SetShowScrollBarOnGuildList(false) *\/ \nvoid SetShowScrollBarOnGuildList(bool b) {",
        "query_nlx":"\/* Function named SetShowScrollBarOnGuildList sets a boolean value to determine whether to show a scroll bar on the guild list.\n>>> SetShowScrollBarOnGuildList(true) \n>>> SetShowScrollBarOnGuildList(false) *\/ \nvoid SetShowScrollBarOnGuildList(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_19.cpp",
        "line_count":3,
        "code":"void SetImageBackgroundFileName(const std::string& fn) {\n\t\tm_imageBackgroundFileName = fn;\n\t}",
        "mark":9.0,
        "query_nsx":"\/* Set the filename for the background image.\n>>> SetImageBackgroundFileName(const std::string& fn) *\/",
        "query_nlx":"\/* Function named SetImageBackgroundFileName sets the file name for the background image to be used in the program. \n>>> SetImageBackgroundFileName(\"background.jpg\") *\/ \nvoid SetImageBackgroundFileName(const std::string& fn) {"
    }

    {
        "file_name":"LocalSettings_function_2.cpp",
        "line_count":3,
        "code":"void SetMessageStyle(eMessageStyle ms) {\n\t\tm_messageStyle = ms;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the message style to the specified type.\n   >>> SetMessageStyle(eMessageStyle ms) *\/",
        "query_nlx":"\/* Define a function that sets the message style to a specified value.\n   >>> SetMessageStyle(eMessageStyle ms) *\/"
    }

    {
        "file_name":"LocalSettings_function_20.cpp",
        "line_count":3,
        "code":"void SetImageAlignment(eImageAlignment align) {\n\t\tm_imageAlignment = align;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the alignment of an image to a specified value.\n   >>> SetImageAlignment(eImageAlignment align); *\/",
        "query_nlx":"\/* Function named SetImageAlignment sets the alignment of an image to the specified value.\n>>> SetImageAlignment(LEFT) \n>>> SetImageAlignment(CENTER) \n>>> SetImageAlignment(RIGHT) *\/ \nvoid SetImageAlignment(eImageAlignment align) {"
    }

    {
        "file_name":"LocalSettings_function_21.cpp",
        "line_count":3,
        "code":"void SetUserScale(int userScale) {\n\t\tm_userScale = userScale;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the user-defined scale value for the operation.\n   >>> SetUserScale(int userScale) *\/",
        "query_nlx":"\/* Define a function named SetUserScale that takes an integer parameter userScale and sets the internal variable m_userScale to the value of userScale. \n>>> SetUserScale(5) *\/ \nvoid SetUserScale(int userScale) {"
    }

    {
        "file_name":"LocalSettings_function_22.cpp",
        "line_count":3,
        "code":"void SetCompactMemberList(bool b) {\n\t\tm_bCompactMemberList = b;\n\t}",
        "mark":9.0,
        "query_nsx":"\/* Set a flag to determine if the member list should be displayed in a compact format or not.\n>>> SetCompactMemberList(bool b) *\/",
        "query_nlx":"\/* Function named SetCompactMemberList sets a boolean variable to indicate whether the member list should be compact or not.\n>>> SetCompactMemberList(true) \n>>> SetCompactMemberList(false) *\/ \nvoid SetCompactMemberList(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_23.cpp",
        "line_count":3,
        "code":"void SetShowAttachmentImages(bool b) {\n\t\tm_bShowAttachmentImages = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to show or hide attachment images.\n   >>> SetShowAttachmentImages(true) \n   >>> SetShowAttachmentImages(false) *\/ \nvoid SetShowAttachmentImages(bool b) {",
        "query_nlx":"\/* Function named SetShowAttachmentImages sets a boolean value to determine whether to display attachment images or not.\n>>> SetShowAttachmentImages(true) \n>>> SetShowAttachmentImages(false) *\/ \nvoid SetShowAttachmentImages(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_24.cpp",
        "line_count":3,
        "code":"void SetShowEmbedImages(bool b) {\n\t\tm_bShowEmbedImages = b;\n\t}",
        "mark":9.0,
        "query_nsx":"\/* Set a flag to show or hide embedded images.\n   >>> SetShowEmbedImages(true) \n   >>> SetShowEmbedImages(false) *\/ \nvoid SetShowEmbedImages(bool b) { ",
        "query_nlx":"\/* Function named SetShowEmbedImages sets a boolean variable to determine whether to display embedded images or not.\n>>> SetShowEmbedImages(true) \n>>> SetShowEmbedImages(false) *\/ \nvoid SetShowEmbedImages(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_25.cpp",
        "line_count":3,
        "code":"void SetShowEmbedContent(bool b) {\n\t\tm_bShowEmbedContent = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to show or hide embedded content.\n   >>> SetShowEmbedContent(true) \n   >>> SetShowEmbedContent(false) *\/ \nvoid SetShowEmbedContent(bool b) {",
        "query_nlx":"\/* Function named SetShowEmbedContent sets a boolean variable to determine whether to display embedded content or not.\n>>> SetShowEmbedContent(true) \n>>> SetShowEmbedContent(false) *\/ \nvoid SetShowEmbedContent(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_26.cpp",
        "line_count":3,
        "code":"void SetEnableNotifications(bool b) {\n\t\tm_bEnableNotifications = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set whether notifications are enabled or disabled.\n   >>> SetEnableNotifications(true) \n   >>> SetEnableNotifications(false) *\/ \nvoid SetEnableNotifications(bool b) {",
        "query_nlx":"\/* Function named SetEnableNotifications sets a boolean value to enable or disable notifications.\n>>> SetEnableNotifications(true) \n>>> SetEnableNotifications(false) *\/ \nvoid SetEnableNotifications(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_27.cpp",
        "line_count":3,
        "code":"void SetFlashOnNotification(bool b) {\n\t\tm_bFlashOnNotification = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set whether to enable flashing on notification.\n   >>> SetFlashOnNotification(true) \n   >>> SetFlashOnNotification(false) *\/ \nvoid SetFlashOnNotification(bool b) {",
        "query_nlx":"\/* Function named SetFlashOnNotification sets a boolean variable to indicate whether to enable or disable flashing on notification.\n>>> SetFlashOnNotification(true) \n>>> SetFlashOnNotification(false) *\/ \nvoid SetFlashOnNotification(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_3.cpp",
        "line_count":3,
        "code":"void SetReplyMentionByDefault(bool b) {\n\t\tm_bReplyMentionDefault = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set whether to reply by mentioning the default value for mentions.\n   >>> SetReplyMentionByDefault(true) *\/ \nvoid SetReplyMentionByDefault(bool b) {",
        "query_nlx":"\/* Function named SetReplyMentionByDefault sets the default value for whether to reply with a mention or not. \n>>> SetReplyMentionByDefault(true) \n>>> SetReplyMentionByDefault(false) *\/ \nvoid SetReplyMentionByDefault(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_6.cpp",
        "line_count":3,
        "code":"void SetSaveWindowSize(bool b) {\n\t\tm_bSaveWindowSize = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to indicate whether to save the window size or not.\n   >>> SetSaveWindowSize(true) \n   >>> SetSaveWindowSize(false) *\/ \nvoid SetSaveWindowSize(bool b) {",
        "query_nlx":"\/* Function named SetSaveWindowSize sets a boolean variable to indicate whether the window size should be saved or not.\n>>> SetSaveWindowSize(true) \n>>> SetSaveWindowSize(false) *\/ \nvoid SetSaveWindowSize(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_7.cpp",
        "line_count":3,
        "code":"void SetStartMaximized(bool b) {\n\t\tm_bStartMaximized = b;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set whether the application should start in a maximized state or not.\n   >>> SetStartMaximized(true) \n   >>> SetStartMaximized(false) *\/ \nvoid SetStartMaximized(bool b) {",
        "query_nlx":"\/* Function named SetStartMaximized sets a boolean value to determine if the application should start in a maximized state or not.\n>>> SetStartMaximized(true) \n>>> SetStartMaximized(false) *\/ \nvoid SetStartMaximized(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_8.cpp",
        "line_count":3,
        "code":"void SetOpenOnStartup(bool b) {\n\t\tm_bOpenOnStartup = b;\n\t}",
        "mark":9.0,
        "query_nsx":"\/* Set a flag to determine if the application should open on startup or not.\n   >>> SetOpenOnStartup(true) *\/ \nvoid SetOpenOnStartup(bool b) {",
        "query_nlx":"\/* Function named SetOpenOnStartup sets a boolean variable to indicate whether a program should open on startup or not.\n>>> SetOpenOnStartup(true) \n>>> SetOpenOnStartup(false) *\/ \nvoid SetOpenOnStartup(bool b) {"
    }

    {
        "file_name":"LocalSettings_function_9.cpp",
        "line_count":3,
        "code":"void SetStartMinimized(bool b) {\n\t\tm_bStartMinimized = b;\n\t}",
        "mark":9.0,
        "query_nsx":"\/* Set whether the application should start minimized or not.\n   >>> SetStartMinimized(true) \n   >>> SetStartMinimized(false) *\/ \nvoid SetStartMinimized(bool b) {",
        "query_nlx":"\/* Function named SetStartMinimized sets a boolean value to determine if a certain action should start in a minimized state. \n>>> SetStartMinimized(true) \n>>> SetStartMinimized(false) *\/ \nvoid SetStartMinimized(bool b) {"
    }

    {
        "file_name":"Logger_function_1.cpp",
        "line_count":48,
        "code":"bool InitializeConsole()\n{\n\t\/\/ Allocate a console for this app\n\tif (!AllocConsole()) \n\t\treturn false;\n\t\n\tFILE* pFile;\n\n\t\/\/ Redirect STDIN if the console has an input handle\n\tif (GetStdHandle(STD_INPUT_HANDLE) != INVALID_HANDLE_VALUE) \n\t{\n\t\tif (freopen_s(&pFile, \"CONIN$\", \"r\", stdin) != 0) \n\t\t\treturn false;\n\t}\n\n\t\/\/ Redirect STDOUT if the console has an output handle\n\tif (GetStdHandle(STD_OUTPUT_HANDLE) != INVALID_HANDLE_VALUE) \n\t{\n\t\tif (freopen_s(&pFile, \"CONOUT$\", \"w\", stdout) != 0) \n\t\t\treturn false;\n\t}\n\n\t\/\/ Redirect STDERR if the console has an error handle\n\tif (GetStdHandle(STD_ERROR_HANDLE) != INVALID_HANDLE_VALUE) \n\t{\n\t\tif (freopen_s(&pFile, \"CONOUT$\", \"w\", stderr) != 0) \n\t\t\treturn false;\n\t}\n\n\t\/\/ Clear the error state for each of the C++ standard streams\n\tstd::cin.clear();\n\tstd::cout.clear();\n\tstd::cerr.clear();\n\tstd::wcin.clear();\n\tstd::wcout.clear();\n\tstd::wcerr.clear();\n\n\t\/\/ Make C++ standard streams point to console as well.\n\tstd::ios::sync_with_stdio();\n\n\tif (Config::Instance()->DebugWait.value_or(false))\n\t{\n\t\tstd::cout << \"Press ENTER to continue...\" << std::endl;\n\t\tstd::cin.get();\n\t}\n\n\treturn true;\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize a console for the application, redirecting standard input, output, and error streams to the console if available, and clearing error states for C++ standard streams. \n>>> InitializeConsole() *\/",
        "query_nlx":"\/* Define a function that initializes the console for the application by redirecting standard input, output, and error streams to the console if available.\n   >>> InitializeConsole() bool *\/"
    }

    {
        "file_name":"Logger_function_3.cpp",
        "line_count":5,
        "code":"void CloseLogger()\n{\n\tspdlog::default_logger()->flush();\n\tspdlog::shutdown();\n}",
        "mark":8.0,
        "query_nsx":"\/* Close the logging system by flushing any pending log messages and shutting down the logging framework.\n   >>> CloseLogger() *\/ \nvoid CloseLogger() {",
        "query_nlx":"\/* CloseLogger function closes the logging system by flushing any pending log messages and shutting down the logger.\n>>> CloseLogger() *\/ \nvoid CloseLogger() {"
    }

    {
        "file_name":"LogonDialog_function_3.cpp",
        "line_count":4,
        "code":"bool LogonDialogShow()\n{\n\treturn DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DIALOG_LOGON), g_Hwnd, DialogProc) != IDCANCEL;\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the logon dialog should be displayed and return the result.\n   >>> LogonDialogShow() bool *\/",
        "query_nlx":"\/* Function LogonDialogShow checks if a logon dialog box should be displayed based on the result of calling DialogBox with specific parameters. \n>>> LogonDialogShow() returns true if the dialog box is shown and the user does not click the cancel button, otherwise false *\/ \nbool LogonDialogShow() { "
    }

    {
        "file_name":"Main_function_1.cpp",
        "line_count":4,
        "code":"int GetProfilePictureSize()\n{\n\treturn g_ProfilePictureSize;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the size of the profile picture.\n>>> int GetProfilePictureSize() *\/",
        "query_nlx":"\/* Function named GetProfilePictureSize retrieves the size of the profile picture.\n>>> GetProfilePictureSize() returns an integer value representing the size of the profile picture. *\/ \nint GetProfilePictureSize() { "
    }

    {
        "file_name":"Main_function_15.cpp",
        "line_count":7,
        "code":"void CloseCleanup(HWND hWnd)\n{\n\tKillImageViewer();\n\tProfilePopout::Dismiss();\n\tAutoComplete::DismissAutoCompleteWindowsIfNeeded(hWnd);\n\tg_pLoadingMessage->Hide();\n}",
        "mark":8.0,
        "query_nsx":"\/* Close all open windows and hide loading message.\n>>> void CloseCleanup(HWND hWnd) { *\/",
        "query_nlx":"\/* Function named CloseCleanup performs various cleanup tasks related to the user interface, such as closing image viewers, dismissing profile popouts, hiding loading messages, and dismissing auto-complete windows if needed.\n>>> CloseCleanup(HWND hWnd) *\/"
    }

    {
        "file_name":"Main_function_19.cpp",
        "line_count":3,
        "code":"void ResetTryAgainInTime() {\n\tg_tryAgainTimerElapse = 500;\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the timer to reset and try again after a specific time interval.\n>>> ResetTryAgainInTime() *\/ \nvoid ResetTryAgainInTime() {",
        "query_nlx":"\/* ResetTryAgainInTime sets the try-again timer elapse value to 500 milliseconds.\n>>> ResetTryAgainInTime()\n*\/ \nvoid ResetTryAgainInTime() { "
    }

    {
        "file_name":"Main_function_28.cpp",
        "line_count":5,
        "code":"CALLBACK OnHeartbeatTimer(HWND hWnd, UINT uInt, UINT_PTR uIntPtr, DWORD dWord)\n{\n\t\/\/ Don't care about the parameters, tell discord instance to send a heartbeat\n\tGetDiscordInstance()->SendHeartbeat();\n}",
        "mark":8.0,
        "query_nsx":"        \/* Send a heartbeat signal to the Discord instance.\n        >>> OnHeartbeatTimer(HWND hWnd, UINT uInt, UINT_PTR uIntPtr, DWORD dWord) *\/",
        "query_nlx":"\/* Instructs the system to call the Discord instance to send a heartbeat without considering the input parameters.\n>>> OnHeartbeatTimer(HWND hWnd, UINT uInt, UINT_PTR uIntPtr, DWORD dWord) *\/"
    }

    {
        "file_name":"Main_function_29.cpp",
        "line_count":18,
        "code":"void SetHeartbeatInterval(int timeMs)\n{\n\tif (g_HeartbeatTimerInterval == timeMs)\n\t\treturn;\n\n\tassert(timeMs > 100 || timeMs == 0);\n\n\tif (g_HeartbeatTimer != 0)\n\t{\n\t\tKillTimer(g_Hwnd, g_HeartbeatTimer);\n\t\tg_HeartbeatTimer = 0;\n\t}\n\n\tif (timeMs != 0)\n\t{\n\t\tg_HeartbeatTimer = SetTimer(g_Hwnd, 0, timeMs, OnHeartbeatTimer);\n\t}\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the interval for a heartbeat timer, ensuring it is not already set to the same value and handling timer management.\n>>> SetHeartbeatInterval(int timeMs) *\/",
        "query_nlx":"\/* Define a function that sets the interval for a heartbeat timer. The function should update the timer interval only if it is different from the current interval. If the provided time interval is less than or equal to 100 milliseconds, it should be set to 0. If the timer is already running, it should be stopped before setting a new interval. \n   >>> SetHeartbeatInterval(150) will update the heartbeat timer interval to 150 milliseconds.\n   >>> SetHeartbeatInterval(0) will stop the heartbeat timer.\n*\/ \nvoid SetHeartbeatInterval(int timeMs) { "
    }

    {
        "file_name":"Main_function_4.cpp",
        "line_count":4,
        "code":"string GetDiscordToken()\n{\n\treturn g_pDiscordInstance->GetToken();\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the Discord token from the Discord instance.\n   >>> GetDiscordToken() *\/\nstring GetDiscordToken();",
        "query_nlx":"\/* Function named GetDiscordToken retrieves the token associated with the Discord instance.\n>>> GetDiscordToken() returns the token of the Discord instance. *\/ \nstring GetDiscordToken() { "
    }

    {
        "file_name":"Main_function_5.cpp",
        "line_count":3,
        "code":"HBITMAP GetDefaultBitmap() {\n\treturn g_DefaultProfilePicture;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the default profile picture bitmap.\n>>> GetDefaultBitmap() HBITMAP *\/",
        "query_nlx":"\/* Retrieve the default profile picture bitmap.\n>>> GetDefaultBitmap() g_DefaultProfilePicture *\/ \nHBITMAP GetDefaultBitmap() {"
    }

    {
        "file_name":"Manipulator_function_1.cpp",
        "line_count":5,
        "code":"void init() {\n *         manip = CameraManipulator::Builder()\n *             .viewport(1024, 768)\n *             .build(camutils::Mode::ORBIT);\n *     }",
        "mark":8.0,
        "query_nsx":"        \/* Initialize a camera manipulator with specified viewport dimensions and orbit mode. \n         * >>> init() *\/ \n        void init();",
        "query_nlx":"        \/* Initialize a camera manipulator with a viewport size of 1024x768 and set the mode to ORBIT.\n         * The function signature is void init() { *\/\n        "
    }

    {
        "file_name":"match_results_function_10.cpp",
        "line_count":4,
        "code":"void  set_named_subs(std::shared_ptr<named_sub_type> subs)\n   {\n      m_named_subs = subs;\n   }",
        "mark":8.0,
        "query_nsx":"\/* Set the named substitutions for a specific type.\n   >>> set_named_subs(std::shared_ptr<named_sub_type> subs) *\/",
        "query_nlx":"\/* Function set_named_subs sets the shared pointer to a named sub-type object.\n   >>> set_named_subs(shared_ptr<named_sub_type> subs) *\/"
    }

    {
        "file_name":"match_results_function_11.cpp",
        "line_count":9,
        "code":"void raise_logic_error()\n   {\n      std::logic_error e(\"Attempt to access an uninitialized boost::match_results<> class.\");\n#ifndef BOOST_REGEX_STANDALONE\n      boost::throw_exception(e);\n#else\n      throw e;\n#endif\n   }",
        "mark":8.0,
        "query_nsx":"\/* Raise a logic error when attempting to access an uninitialized match_results class.\n   >>> void raise_logic_error() *\/",
        "query_nlx":"\/* Define a function that raises a logic error with a specific message when attempting to access an uninitialized match_results class. \n   >>> raise_logic_error() *\/ \nvoid raise_logic_error() {"
    }

    {
        "file_name":"match_results_function_13.cpp",
        "line_count":4,
        "code":"void swap(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b)\n{\n   a.swap(b);\n}",
        "mark":8.0,
        "query_nsx":"\/* Swap the contents of two match results objects.\n>>> void swap(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b) *\/",
        "query_nlx":"\/* Function named swap takes two match_results objects and swaps their contents.\n   >>> swap(match_results a, match_results b) *\/ \nvoid swap(match_results<BidiIterator, Allocator>& a, match_results<BidiIterator, Allocator>& b) { \n    a.swap(b); \n}"
    }

    {
        "file_name":"match_results_function_7.cpp",
        "line_count":4,
        "code":"void  set_base(BidiIterator pos)\n   {\n      m_base = pos;\n   }",
        "mark":8.0,
        "query_nsx":"\/* Set the base position using the given bidirectional iterator.\n   >>> set_base(BidiIterator pos) *\/",
        "query_nlx":"\/* Define a function called set_base that takes a bidirectional iterator as input and sets the base value of the iterator to the provided position. \n   >>> set_base(pos) *\/ \nvoid set_base(BidiIterator pos) { "
    }

    {
        "file_name":"MaterialInstance_function_1.cpp",
        "line_count":3,
        "code":"void setParameter(StringLiteral name, T const& value) {\n        setParameter<T>(name.data, name.size, value);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set a parameter with a given name and value. \n>>> void setParameter(StringLiteral name, T const& value) { *\/",
        "query_nlx":"        \/* Function named setParameter sets a parameter with a given name to a specific value. \n        >>> setParameter(\"example_name\", 42) *\/ \n        void setParameter(StringLiteral name, T const& value) { "
    }

    {
        "file_name":"MaterialInstance_function_10.cpp",
        "line_count":3,
        "code":"void setParameter(const char* UTILS_NONNULL name, RgbaType type, math::float4 color) {\n        setParameter(name, strlen(name), type, color);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set a parameter with a specified name, type, and color.\n    >>> setParameter(const char* name, RgbaType type, math::float4 color) *\/",
        "query_nlx":"\/* Define a function that sets a parameter with a given name, RGBA type, and color value.\n   The function takes a non-null character pointer as the name, an RGBA type, and a float4 color value as input parameters. \n   It then calls another function to set the parameter with the provided name, length of the name, RGBA type, and color value. *\/\nvoid setParameter(const char* UTILS_NONNULL name, RgbaType type, math::float4 color) { *\/"
    }

    {
        "file_name":"MaterialInstance_function_2.cpp",
        "line_count":3,
        "code":"void setParameter(const char* UTILS_NONNULL name, T const& value) {\n        setParameter<T>(name, strlen(name), value);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set a parameter with a given name and value.\n   >>> void setParameter(const char* UTILS_NONNULL name, T const& value) { *\/",
        "query_nlx":"\/* Function named setParameter sets a parameter with a given name to a specified value.\n>>> setParameter(\"example_name\", 10) *\/ \nvoid setParameter(const char* UTILS_NONNULL name, T const& value) {"
    }

    {
        "file_name":"MaterialInstance_function_3.cpp",
        "line_count":3,
        "code":"void setParameter(StringLiteral name, const T* UTILS_NONNULL values, size_t count) {\n        setParameter<T>(name.data, name.size, values, count);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set a parameter using a name and an array of values with a count.\n        >>> void setParameter(StringLiteral name, const T* UTILS_NONNULL values, size_t count) { *\/",
        "query_nlx":"        \/* Function named setParameter takes a string literal name, an array of values, and the count of values to set a parameter with the given name and values.\n        >>> setParameter(\"example\", {1, 2, 3, 4}, 4) *\/\n        void setParameter(StringLiteral name, const T* UTILS_NONNULL values, size_t count) { "
    }

    {
        "file_name":"MaterialInstance_function_7.cpp",
        "line_count":3,
        "code":"void setParameter(StringLiteral name, RgbType type, math::float3 color) {\n        setParameter(name.data, name.size, type, color);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set a parameter with a name, type, and color.\n        >>> void setParameter(StringLiteral name, RgbType type, math::float3 color) { *\/",
        "query_nlx":"        \/* Define a function that sets a parameter with a given name, type, and color.\n        >>> setParameter(\"example_name\", RGB, {0.5, 0.2, 0.8}) *\/ \n        void setParameter(StringLiteral name, RgbType type, math::float3 color) {"
    }

    {
        "file_name":"MaterialInstance_function_8.cpp",
        "line_count":3,
        "code":"void setParameter(const char* UTILS_NONNULL name, RgbType type, math::float3 color) {\n        setParameter(name, strlen(name), type, color);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set a parameter with a specified name, type, and color.\n>>> setParameter(const char* name, RgbType type, math::float3 color) *\/",
        "query_nlx":"\/* Define a function that sets a parameter with a given name, type, and color.\n   >>> setParameter(\"example_parameter\", RgbType::RED, {1.0, 0.0, 0.0}) *\/ \nvoid setParameter(const char* UTILS_NONNULL name, RgbType type, math::float3 color) { "
    }

    {
        "file_name":"MaterialInstance_function_9.cpp",
        "line_count":3,
        "code":"void setParameter(StringLiteral name, RgbaType type, math::float4 color) {\n        setParameter(name.data, name.size, type, color);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set a parameter with a name, type, and color value.\n        >>> void setParameter(StringLiteral name, RgbaType type, math::float4 color) { *\/",
        "query_nlx":"\/* Function named setParameter sets a parameter with a given name, RGBA type, and color value.\n>>> setParameter(\"exampleName\", RGBA, {0.5, 0.3, 0.8, 1.0})\n*\/ \nvoid setParameter(StringLiteral name, RgbaType type, math::float4 color) {"
    }

    {
        "file_name":"MemberList_function_1.cpp",
        "line_count":4,
        "code":"int GetProfileBorderSize()\n{\n\treturn ScaleByDPI(Supports32BitIcons() ? (PROFILE_PICTURE_SIZE_DEF + 12) : 64);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of the profile border based on the support for 32-bit icons and a default profile picture size.\n>>> int GetProfileBorderSize() *\/",
        "query_nlx":"\/* Determine the border size of a user profile picture based on whether the system supports 32-bit icons. If 32-bit icons are supported, the border size is the default profile picture size plus 12; otherwise, it is 64.\n>>> GetProfileBorderSize() int *\/"
    }

    {
        "file_name":"mem_block_cache_function_5.cpp",
        "line_count":4,
        "code":"void  put_mem_block(void* p)\n{\n   ::operator delete(p);\n}",
        "mark":8.0,
        "query_nsx":"\/* Deallocate memory block pointed to by the given pointer.\n>>> put_mem_block(void* p) *\/",
        "query_nlx":"\/* Function named put_mem_block deallocates the memory block pointed to by the input pointer.\n>>> put_mem_block(void* p) *\/"
    }

    {
        "file_name":"mem_block_cache_function_6.cpp",
        "line_count":4,
        "code":"void  put_mem_block(void* p)\n{\n   mem_block_cache::instance().put(p);\n}",
        "mark":8.0,
        "query_nsx":"\/* Store a memory block in the cache.\n>>> put_mem_block(void* p) *\/",
        "query_nlx":"\/* Define a function that puts a memory block into a cache.\n   >>> put_mem_block(void* p) *\/"
    }

    {
        "file_name":"mem_block_cache_function_7.cpp",
        "line_count":4,
        "code":"BOOST_REGEX_CALL get_mem_block()\n{\n   return mem_block_cache::instance().get();\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a memory block from the cache.\n   >>> get_mem_block() BOOST_REGEX_CALL *\/",
        "query_nlx":"\/* Retrieve a memory block from the cache using a function named get_mem_block.\n>>> get_mem_block() BOOST_REGEX_CALL *\/"
    }

    {
        "file_name":"mem_block_cache_function_8.cpp",
        "line_count":4,
        "code":"BOOST_REGEX_CALL put_mem_block(void* p)\n{\n   mem_block_cache::instance().put(p);\n}",
        "mark":8.0,
        "query_nsx":"\/* Store a memory block in the cache for future retrieval.\n>>> BOOST_REGEX_CALL put_mem_block(void* p) *\/",
        "query_nlx":"\/* Function named put_mem_block stores a memory block in a cache for future retrieval.\n>>> put_mem_block(void* p) *\/"
    }

    {
        "file_name":"MessageList_function_1.cpp",
        "line_count":5,
        "code":"void Clear() {\n\t\tfree(m_nameText);\n\t\tfree(m_sizeText);\n\t\tm_nameText = m_sizeText = NULL;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Clear allocated memory for name and size text variables.\n   >>> Clear() *\/ \nvoid Clear() {",
        "query_nlx":"\/* Define a function that clears the allocated memory for two text variables and sets them to NULL.\n   >>> Clear() *\/ \nvoid Clear() {"
    }

    {
        "file_name":"MessageList_function_11.cpp",
        "line_count":3,
        "code":"void SetManagedByOwner(bool bNew) {\n\t\tm_bManagedByOwner = bNew;\n\t}",
        "mark":9.0,
        "query_nsx":"\/* Set whether the object is managed by its owner or not.\n   >>> SetManagedByOwner(true) *\/ \nvoid SetManagedByOwner(bool bNew) {",
        "query_nlx":"\/* Function named SetManagedByOwner updates the status of an object to indicate whether it is managed by its owner or not.\n>>> SetManagedByOwner(true) sets the object to be managed by its owner.\n>>> SetManagedByOwner(false) sets the object to not be managed by its owner. *\/ \nvoid SetManagedByOwner(bool bNew) { "
    }

    {
        "file_name":"MessageList_function_12.cpp",
        "line_count":3,
        "code":"void SetTopDown (bool bNew) {\n\t\tm_bIsTopDown = bNew;\n\t}",
        "mark":10.0,
        "query_nsx":"\/* Set a flag to indicate whether the view is in top-down mode or not.\n>>> SetTopDown(true) \n>>> SetTopDown(false) *\/ \nvoid SetTopDown(bool bNew) {",
        "query_nlx":"\/* Define a function named SetTopDown that takes a boolean parameter and sets the internal state variable m_bIsTopDown to the value of the parameter.\n   >>> SetTopDown(true) \n   >>> SetTopDown(false) *\/ \nvoid SetTopDown(bool bNew) {"
    }

    {
        "file_name":"MessageList_function_4.cpp",
        "line_count":6,
        "code":"void ClearAttachmentDataRects() {\n\t\tfor (auto& att : m_attachmentData) {\n\t\t\tSetRectEmpty(&att.m_boxRect);\n\t\t\tSetRectEmpty(&att.m_textRect);\n\t\t}\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Clear all attachment data rectangles in the list.\n>>> void ClearAttachmentDataRects() { *\/",
        "query_nlx":"\/* Function named ClearAttachmentDataRects updates the boxRect and textRect properties of each attachment in the attachmentData vector to be empty. \n>>> ClearAttachmentDataRects() *\/ \nvoid ClearAttachmentDataRects() {"
    }

    {
        "file_name":"MessageList_function_5.cpp",
        "line_count":5,
        "code":"void ClearInteractableDataRects() {\n\t\tfor (auto& inte : m_interactableData) {\n\t\t\tSetRectEmpty(&inte.m_rect);\n\t\t}\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Clear all interactable data rectangles stored in the system.\n   >>> ClearInteractableDataRects() *\/",
        "query_nlx":"\/* Function named ClearInteractableDataRects iterates through a collection of interactable data elements and sets the rectangle associated with each element to be empty.\n>>> ClearInteractableDataRects() *\/ \nvoid ClearInteractableDataRects() {"
    }

    {
        "file_name":"MessageList_function_7.cpp",
        "line_count":3,
        "code":"void AddMessageStart(const Message& msg) {\n\t\tAddMessageInternal(msg, true, false);\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Add a message at the beginning with the provided content. \n>>> void AddMessageStart(const Message& msg) { *\/",
        "query_nlx":"\/* Define a function that adds a message at the start of a message queue.\n   >>> AddMessageStart(msg) *\/ \nvoid AddMessageStart(const Message& msg) {"
    }

    {
        "file_name":"MessageList_function_8.cpp",
        "line_count":3,
        "code":"void AddMessage(const Message& msg, bool updateLastViewedMessage = false) {\n\t\tAddMessageInternal(msg, false, updateLastViewedMessage);\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Add a message to the message system, optionally updating the last viewed message.\n>>> void AddMessage(const Message& msg, bool updateLastViewedMessage = false) { *\/",
        "query_nlx":"\/* Define a function called AddMessage that takes a message object and an optional boolean parameter to update the last viewed message. \n   >>> AddMessage(msg, updateLastViewedMessage) *\/ \nvoid AddMessage(const Message& msg, bool updateLastViewedMessage = false) {"
    }

    {
        "file_name":"MessageList_function_9.cpp",
        "line_count":3,
        "code":"void SetGuild(Snowflake sf) {\n\t\tm_guildID = sf;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the Snowflake ID for the guild.\n   >>> SetGuild(Snowflake sf) *\/",
        "query_nlx":"\/* Define a function named SetGuild that takes a Snowflake parameter and assigns it to the m_guildID variable. \n   >>> SetGuild(sf) *\/ \nvoid SetGuild(Snowflake sf) {"
    }

    {
        "file_name":"message_function_1.cpp",
        "line_count":3,
        "code":"void set_prepared(bool value) {\n        m_prepared = value;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to indicate if the object is prepared or not.\n   >>> set_prepared(true) *\/ \nvoid set_prepared(bool value) {",
        "query_nlx":"\/* Function named set_prepared sets a boolean value to indicate if an operation has been prepared or not.\n>>> set_prepared(true) \n>>> set_prepared(false) *\/ \nvoid set_prepared(bool value) {"
    }

    {
        "file_name":"message_function_10.cpp",
        "line_count":4,
        "code":"void append_payload(void const * payload, size_t len) {\n        m_payload.reserve(m_payload.size()+len);\n        m_payload.append(static_cast<char const *>(payload),len);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Append a payload of a certain length to the existing payload buffer.\n    >>> void append_payload(void const * payload, size_t len) { *\/",
        "query_nlx":"\/* Function named append_payload appends a given payload of a certain length to the existing payload in a container. \n>>> append_payload(\"Hello\", 5) *\/ \nvoid append_payload(void const * payload, size_t len) {"
    }

    {
        "file_name":"message_function_2.cpp",
        "line_count":3,
        "code":"void set_compressed(bool value) {\n        m_compressed = value;\n    }",
        "mark":9.0,
        "query_nsx":"\/* Set the compression status to the given value.\n   >>> set_compressed(true) \n   >>> set_compressed(false) *\/ \nvoid set_compressed(bool value) {",
        "query_nlx":"\/* Define a function that sets a boolean value to indicate whether a certain operation is compressed or not.\n   >>> set_compressed(true) \n   >>> set_compressed(false) *\/\nvoid set_compressed(bool value) {"
    }

    {
        "file_name":"message_function_3.cpp",
        "line_count":3,
        "code":"void set_terminal(bool value) {\n        m_terminal = value;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the value of a terminal variable to the given boolean value.\n>>> set_terminal(true) \n>>> set_terminal(false) *\/ \nvoid set_terminal(bool value) {",
        "query_nlx":"\/* Function named set_terminal sets the value of a terminal variable to the provided boolean value.\n   >>> set_terminal(true) \n   >>> set_terminal(false) *\/ \nvoid set_terminal(bool value) {"
    }

    {
        "file_name":"message_function_4.cpp",
        "line_count":3,
        "code":"void set_fin(bool value) {\n        m_fin = value;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to indicate if a certain condition is met.\n    >>> set_fin(true) *\/ \n    void set_fin(bool value) {",
        "query_nlx":"\/* Function named set_fin sets a boolean variable to a given value.\n   >>> set_fin(true) \n   >>> set_fin(false) *\/ \nvoid set_fin(bool value) {"
    }

    {
        "file_name":"message_function_5.cpp",
        "line_count":3,
        "code":"void set_opcode(frame::opcode::value op) {\n        m_opcode = op;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the opcode value to the given input value.\n   >>> set_opcode(frame::opcode::value op); *\/",
        "query_nlx":"\/* Define a function that sets the opcode value of a frame to a given input value.\n   >>> set_opcode(opcode_value) *\/ \nvoid set_opcode(frame::opcode::value op) {"
    }

    {
        "file_name":"message_function_6.cpp",
        "line_count":3,
        "code":"void set_header(std::string const & header) {\n        m_header = header;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the header of the document to the provided string.\n   >>> set_header(\"New Header\") *\/ \nvoid set_header(std::string const & header) {",
        "query_nlx":"\/* Define a function that sets a given string as the header value.\n   >>> set_header(\"Example Header\") *\/ \nvoid set_header(std::string const & header) {"
    }

    {
        "file_name":"message_function_7.cpp",
        "line_count":3,
        "code":"void set_payload(std::string const & payload) {\n        m_payload = payload;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the payload data to the provided input string.\n   >>> set_payload(\"example_payload\") *\/ \nvoid set_payload(std::string const & payload) {",
        "query_nlx":"\/* Define a function called set_payload that takes a constant reference to a string as input and sets the payload member variable to the value of the input string. *\/\nvoid set_payload(std::string const & payload) {"
    }

    {
        "file_name":"message_function_8.cpp",
        "line_count":5,
        "code":"void set_payload(void const * payload, size_t len) {\n        m_payload.reserve(len);\n        char const * pl = static_cast<char const *>(payload);\n        m_payload.assign(pl, pl + len);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the payload data with the given length.\n   >>> set_payload(void const * payload, size_t len) *\/",
        "query_nlx":"\/* Define a function named set_payload that takes a payload of arbitrary data and its length as input, then stores the payload in a data structure for later use.\n   >>> set_payload(\"Hello, World!\", 13) *\/ \nvoid set_payload(void const * payload, size_t len) {"
    }

    {
        "file_name":"message_function_9.cpp",
        "line_count":3,
        "code":"void append_payload(std::string const & payload) {\n        m_payload.append(payload);\n    }",
        "mark":9.0,
        "query_nsx":"\/* Append a payload to the existing payload string.\n   >>> void append_payload(std::string const & payload) { *\/",
        "query_nlx":"\/* Function named append_payload appends a given payload string to an existing payload string.\n>>> append_payload(\"new_payload\") *\/ \nvoid append_payload(std::string const & payload) {"
    }

    {
        "file_name":"misc_function_37.cpp",
        "line_count":5,
        "code":"optimizations\n    if (wlan_handle != nullptr) {\n      fn_WlanCloseHandle(wlan_handle, nullptr);\n      wlan_handle = nullptr;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if there is an open WLAN handle, and if so, close it.\n   >>> optimizations *\/ \nvoid optimizations() {",
        "query_nlx":"\/* When the WLAN handle is not equal to nullptr, the function fn_WlanCloseHandle is called with the WLAN handle and a nullptr parameter, and then the WLAN handle is set to nullptr.\n   >>> optimizations *\/ \nif (wlan_handle != nullptr) {\n  fn_WlanCloseHandle(wlan_handle, nullptr);\n  wlan_handle = nullptr;\n}"
    }

    {
        "file_name":"misc_function_60.cpp",
        "line_count":13,
        "code":"string ensureCrLf(const std::string& utf8Str) {\n    std::string result;\n    result.reserve(utf8Str.size() + utf8Str.size() \/ 2); \/\/ Reserve extra space\n\n    for (size_t i = 0; i < utf8Str.size(); ++i) {\n        if (utf8Str[i] == '\\n' && (i == 0 || utf8Str[i - 1] != '\\r')) {\n            result += '\\r'; \/\/ Add \\r before \\n if not present\n        }\n        result += utf8Str[i]; \/\/ Always add the current character\n    }\n\n    return result;\n}",
        "mark":8.0,
        "query_nsx":"\/* Ensure that each newline character in the input string is followed by a carriage return character if not already present.\n>>> string ensureCrLf(const string& utf8Str) { *\/",
        "query_nlx":"        \/* Create a function that ensures each newline character is preceded by a carriage return character in a given UTF-8 string.\n        >>> ensureCrLf(\"Hello\\nworld\\n\") \"Hello\\r\\nworld\\r\\n\" *\/ \n        string ensureCrLf(const std::string& utf8Str) {"
    }

    {
        "file_name":"misc_function_61.cpp",
        "line_count":27,
        "code":"wstring getClipboardData() {\n  if (!OpenClipboard(nullptr)) {\n    BOOST_LOG(warning) << \"Failed to open clipboard.\";\n    return L\"\";\n  }\n\n  HANDLE hData = GetClipboardData(CF_UNICODETEXT);\n  if (hData == nullptr) {\n    BOOST_LOG(warning) << \"No text data in clipboard or failed to get data.\";\n    CloseClipboard();\n    return L\"\";\n  }\n\n  wchar_t* pszText = static_cast<wchar_t*>(GlobalLock(hData));\n  if (pszText == nullptr) {\n    BOOST_LOG(warning) << \"Failed to lock clipboard data.\";\n    CloseClipboard();\n    return L\"\";\n  }\n\n  std::wstring ret = pszText;\n\n  GlobalUnlock(hData);\n  CloseClipboard();\n\n  return ret;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve text data from the system clipboard if available, otherwise return an empty string.\n   >>> getClipboardData() returns the text data from the clipboard or an empty string if no data is present. *\/",
        "query_nlx":"\/* Function named getClipboardData retrieves text data from the system clipboard if available, otherwise returns an empty string. \n>>> getClipboardData() \n*\/ \nwstring getClipboardData() {"
    }

    {
        "file_name":"mux_types_function_1.cpp",
        "line_count":5,
        "code":"void WebPDataInit(WebPData* webp_data) {\n  if (webp_data != NULL) {\n    memset(webp_data, 0, sizeof(*webp_data));\n  }\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize the WebP data structure by setting all its values to zero if the structure is not NULL.\n>>> void WebPDataInit(WebPData* webp_data) { *\/",
        "query_nlx":"\/* Function named WebPDataInit initializes the WebPData structure by setting all its elements to zero if the input WebPData pointer is not NULL.\n>>> WebPDataInit(webp_data) *\/ \nvoid WebPDataInit(WebPData* webp_data) {"
    }

    {
        "file_name":"mux_types_function_2.cpp",
        "line_count":6,
        "code":"void WebPDataClear(WebPData* webp_data) {\n  if (webp_data != NULL) {\n    WebPFree((void*)webp_data->bytes);\n    WebPDataInit(webp_data);\n  }\n}",
        "mark":8.0,
        "query_nsx":"\/* Clear the data stored in the WebPData structure if it is not empty.\n>>> WebPDataClear(WebPData* webp_data) *\/",
        "query_nlx":"\/* Function named WebPDataClear clears the data stored in a WebPData structure if it is not NULL by freeing the memory allocated for the bytes and initializing the WebPData structure.\n>>> WebPDataClear(webp_data) *\/ \nvoid WebPDataClear(WebPData* webp_data) {"
    }

    {
        "file_name":"mux_types_function_3.cpp",
        "line_count":11,
        "code":"int WebPDataCopy(const WebPData* src, WebPData* dst) {\n  if (src == NULL || dst == NULL) return 0;\n  WebPDataInit(dst);\n  if (src->bytes != NULL && src->size != 0) {\n    dst->bytes = (uint8_t*)WebPMalloc(src->size);\n    if (dst->bytes == NULL) return 0;\n    memcpy((void*)dst->bytes, src->bytes, src->size);\n    dst->size = src->size;\n  }\n  return 1;\n}",
        "mark":8.0,
        "query_nsx":"\/* Copy data from a source to a destination if both source and destination are valid.\n   >>> WebPDataCopy(const WebPData* src, WebPData* dst) *\/",
        "query_nlx":"\/* Function named WebPDataCopy copies data from a source WebPData structure to a destination WebPData structure if the source and destination are not NULL. \n>>> WebPDataCopy(src, dst) copies the data from the source WebPData structure to the destination WebPData structure if both src and dst are not NULL. *\/ \nint WebPDataCopy(const WebPData* src, WebPData* dst) {"
    }

    {
        "file_name":"NetworkerThread_function_2.cpp",
        "line_count":4,
        "code":"bool AddExtraHeaders()\n{\n\treturn GetLocalSettings()->AddExtraHeaders();\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if additional headers should be added based on local settings.\n>>> AddExtraHeaders() bool *\/",
        "query_nlx":"\/* Function named AddExtraHeaders checks if additional headers should be added based on the local settings.\n>>> AddExtraHeaders() returns a boolean value indicating whether extra headers should be added or not. *\/ \nbool AddExtraHeaders() { "
    }

    {
        "file_name":"network_function_1.cpp",
        "line_count":5,
        "code":"bool is_little_endian() {\n    short int val = 0x1;\n    char *ptr = reinterpret_cast<char *>(&val);\n    return (ptr[0] == 1);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the system is using little-endian byte order.\n>>> bool is_little_endian() { *\/",
        "query_nlx":"\/* Determine if the system architecture stores multi-byte data with the least significant byte at the lowest memory address. \n>>> is_little_endian() true *\/ \nbool is_little_endian() {"
    }

    {
        "file_name":"network_function_7.cpp",
        "line_count":4,
        "code":"string\n  addr_to_normalized_string(boost::asio::ip::address address) {\n    return normalize_address(address).to_string();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert an IP address to a normalized string format.\n   >>> addr_to_normalized_string(boost::asio::ip::address address) *\/",
        "query_nlx":"\/* Function named addr_to_normalized_string takes an IP address and returns a normalized string representation of it.\n>>> addr_to_normalized_string(boost::asio::ip::address address) *\/\n#include <boost\/asio\/ip\/address.hpp>\nstd::string addr_to_normalized_string(boost::asio::ip::address address) { "
    }

    {
        "file_name":"NitroHash_function_1.cpp",
        "line_count":11,
        "code":"uint64_t hashString(const char* str, size_t length) {\n  uint64_t hash = 14695981039346656037ull; \/\/ FNV offset basis\n  const uint64_t fnv_prime = 1099511628211ull;\n\n  for (size_t i = 0; i < length; ++i) {\n    hash ^= static_cast<uint64_t>(str[i]);\n    hash *= fnv_prime;\n  }\n\n  return hash;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate a hash value for a given string with a specified length.\n>>> uint64_t hashString(const char* str, size_t length) { *\/",
        "query_nlx":"\/* Function named hashString calculates the hash value of a given string using the FNV-1a hashing algorithm.\n>>> hashString(\"hello\", 5) 7038864197159728375\n>>> hashString(\"world\", 5) 14695981039346656037 *\/ \nuint64_t hashString(const char* str, size_t length) {"
    }

    {
        "file_name":"NitroLogger_function_4.cpp",
        "line_count":3,
        "code":"bool all_are_trivially_copyable() {\n    return (is_trivially_copyable<Args>() && ...);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if all types in the given list are trivially copyable.\n   >>> bool all_are_trivially_copyable() { *\/",
        "query_nlx":"\/* Function named all_are_trivially_copyable checks if all the types in a given list of types are trivially copyable.\n   >>> all_are_trivially_copyable() true\n   >>> all_are_trivially_copyable() false *\/ \nbool all_are_trivially_copyable() {"
    }

    {
        "file_name":"none_function_11.cpp",
        "line_count":6,
        "code":"error_code translate_ec(lib::error_code ec) {\n        \/\/ We don't know any more information about this error, but the error is\n        \/\/ the same type as the one we are translating to, so pass through\n        \/\/ untranslated.\n        return ec;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Translate a given error code to another error code if possible.\n   >>> error_code translate_ec(lib::error_code ec) { *\/",
        "query_nlx":"\/* Function named translate_ec takes an error code as input and returns the same error code without any translation.\n>>> translate_ec(lib::error_code ec) \n*\/"
    }

    {
        "file_name":"none_function_13.cpp",
        "line_count":3,
        "code":"void set_socket_init_handler(socket_init_handler h) {\n        m_socket_init_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler function for initializing a socket.\n   >>> void set_socket_init_handler(socket_init_handler h); *\/",
        "query_nlx":"\/* Define a function that sets a handler for initializing a socket connection.\n   >>> set_socket_init_handler(handler) *\/ \nvoid set_socket_init_handler(socket_init_handler h) {"
    }

    {
        "file_name":"none_function_2.cpp",
        "line_count":3,
        "code":"void set_socket_init_handler(socket_init_handler h) {\n        m_socket_init_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler function for initializing a socket.\n   >>> void set_socket_init_handler(socket_init_handler h); *\/",
        "query_nlx":"\/* Define a function that sets a handler for initializing a socket connection.\n   >>> set_socket_init_handler(handler) *\/ \nvoid set_socket_init_handler(socket_init_handler h) {"
    }

    {
        "file_name":"none_function_5.cpp",
        "line_count":10,
        "code":"void pre_init(init_handler callback) {\n        if (m_state != READY) {\n            callback(socket::make_error_code(socket::error::invalid_state));\n            return;\n        }\n\n        m_state = READING;\n\n        callback(lib::error_code());\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize a callback function before performing any operations. \n   >>> pre_init(init_handler callback) *\/",
        "query_nlx":"\/* Function named pre_init initializes a callback function and updates the state to READING if the current state is READY. \n>>> pre_init(callback) updates the state to READING and calls the callback function with no error if the current state is READY. *\/ \nvoid pre_init(init_handler callback) {"
    }

    {
        "file_name":"none_function_7.cpp",
        "line_count":3,
        "code":"void set_handle(connection_hdl hdl) {\n        m_hdl = hdl;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handle for a connection to a specified value. \n>>> set_handle(connection_hdl hdl) *\/",
        "query_nlx":"\/* Define a function that sets the handle to a given connection handle.\n   >>> set_handle(connection_hdl hdl) *\/"
    }

    {
        "file_name":"none_function_8.cpp",
        "line_count":5,
        "code":"error_code cancel_socket() {\n        lib::asio::error_code ec;\n        m_socket->cancel(ec);\n        return ec;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return an error code after canceling a socket operation. \n    >>> error_code cancel_socket() *\/",
        "query_nlx":"\/* Define a function named cancel_socket that cancels a socket operation and returns an error code if any.\n   >>> cancel_socket() error_code *\/"
    }

    {
        "file_name":"none_function_9.cpp",
        "line_count":5,
        "code":"void async_shutdown(socket::shutdown_handler h) {\n        lib::asio::error_code ec;\n        m_socket->shutdown(lib::asio::ip::tcp::socket::shutdown_both, ec);\n        h(ec);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Perform an asynchronous shutdown operation on a socket and invoke the provided handler upon completion.\n   >>> void async_shutdown(socket::shutdown_handler h); *\/",
        "query_nlx":"\/* Define an asynchronous function that shuts down a socket and calls a provided handler upon completion.\n   >>> async_shutdown(shutdown_handler h) *\/\nvoid async_shutdown(socket::shutdown_handler h) {"
    }

    {
        "file_name":"nvapi_function_2.cpp",
        "line_count":34,
        "code":"NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_VER1\n\n    DECLARE_INTERFACE(ID3DNvVRSHelper_V1)\n    {\n        BEGIN_INTERFACE\n\n        STDMETHOD_(ULONG, AddRef)\n        (THIS) PURE;\n        STDMETHOD_(ULONG, Release)\n        (THIS) PURE;\n\n        \/\/ Latches the latest gaze which will be used for subsequent foveated rendering. Recommended to be called once per frame before scene drawing begins.\n        STDMETHOD_(NvAPI_Status, LatchGaze)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_LATCH_GAZE_PARAMS * pLatchGazeParams) PURE;\n\n        \/\/ Enables VRS with sepcified content type and preset. This can be called per draw call.\n        STDMETHOD_(NvAPI_Status, Enable)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_ENABLE_PARAMS * pEnableParams) PURE;\n\n        \/\/ Disables VRS till re-enabled.\n        STDMETHOD_(NvAPI_Status, Disable)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_DISABLE_PARAMS * pDisableParams) PURE;\n\n        \/\/ Creates a 2D texture, copies the current shading rate pattern on it and returns the pointer to this texture.\n        \/\/ It also returns an array that conveys which value in the shading rate resource corresponds to which exact pixel shading rate.\n        STDMETHOD_(NvAPI_Status, GetShadingRateResource)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS * pGetShadingRateResourceParams) PURE;\n\n        \/\/ Destroys all internally created shading rate resources and views.\n        STDMETHOD_(NvAPI_Status, PurgeInternalShadingRateResources)\n        (THIS_ IUnknown * pContext, NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS * pPurgeParams) PURE;\n\n        END_INTERFACE\n    }",
        "mark":8.0,
        "query_nsx":"\/* Define an interface with methods to manage Variable Rate Shading (VRS) helper functions.\n   >>> NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_VER1 *\/ \nDECLARE_INTERFACE(ID3DNvVRSHelper_V1)\n{\n    STDMETHOD_(ULONG, AddRef)\n    (THIS) PURE;\n    STDMETHOD_(ULONG, Release)\n    (THIS) PURE;\n\n    STDMETHOD_(NvAPI_Status, LatchGaze)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_LATCH_GAZE_PARAMS * pLatchGazeParams) PURE;\n\n    STDMETHOD_(NvAPI_Status, Enable)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_ENABLE_PARAMS * pEnableParams) PURE;\n\n    STDMETHOD_(NvAPI_Status, Disable)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_DISABLE_PARAMS * pDisableParams) PURE;\n\n    STDMETHOD_(NvAPI_Status, GetShadingRateResource)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS * pGetShadingRateResourceParams) PURE;\n\n    STDMETHOD_(NvAPI_Status, PurgeInternalShadingRateResources)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS * pPurgeParams) PURE;\n}",
        "query_nlx":"\n\/* Define an interface for NVIDIA Variable Rate Shading (VRS) Helper version 1 with the following functions:\n   - AddRef: Increments the reference count.\n   - Release: Decrements the reference count.\n   - LatchGaze: Latches the latest gaze for foveated rendering.\n   - Enable: Enables VRS with specified content type and preset.\n   - Disable: Disables VRS until re-enabled.\n   - GetShadingRateResource: Creates a 2D texture with the current shading rate pattern.\n   - PurgeInternalShadingRateResources: Destroys all internally created shading rate resources and views. *\/\nDECLARE_INTERFACE(ID3DNvVRSHelper_V1)\n{\n    BEGIN_INTERFACE\n\n    STDMETHOD_(ULONG, AddRef)\n    (THIS) PURE;\n    STDMETHOD_(ULONG, Release)\n    (THIS) PURE;\n\n    STDMETHOD_(NvAPI_Status, LatchGaze)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_LATCH_GAZE_PARAMS * pLatchGazeParams) PURE;\n\n    STDMETHOD_(NvAPI_Status, Enable)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_ENABLE_PARAMS * pEnableParams) PURE;\n\n    STDMETHOD_(NvAPI_Status, Disable)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_DISABLE_PARAMS * pDisableParams) PURE;\n\n    STDMETHOD_(NvAPI_Status, GetShadingRateResource)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS * pGetShadingRateResourceParams) PURE;\n\n    STDMETHOD_(NvAPI_Status, PurgeInternalShadingRateResources)\n    (THIS_ IUnknown * pContext, NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS * pPurgeParams) PURE;\n\n    END_INTERFACE\n}"
    }

    {
        "file_name":"nvenc_utils_function_2.cpp",
        "line_count":19,
        "code":"NV_ENC_BUFFER_FORMAT\n  nvenc_format_from_sunshine_format(platf::pix_fmt_e format) {\n    switch (format) {\n      case platf::pix_fmt_e::nv12:\n        return NV_ENC_BUFFER_FORMAT_NV12;\n\n      case platf::pix_fmt_e::p010:\n        return NV_ENC_BUFFER_FORMAT_YUV420_10BIT;\n\n      case platf::pix_fmt_e::ayuv:\n        return NV_ENC_BUFFER_FORMAT_AYUV;\n\n      case platf::pix_fmt_e::yuv444p16:\n        return NV_ENC_BUFFER_FORMAT_YUV444_10BIT;\n\n      default:\n        return NV_ENC_BUFFER_FORMAT_UNDEFINED;\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Map platform-specific pixel formats to corresponding NVENC buffer formats.\n   >>> nvenc_format_from_sunshine_format(platf::pix_fmt_e format) *\/",
        "query_nlx":"\/* Function named nvenc_format_from_sunshine_format converts a platform-specific pixel format to an NVENC buffer format.\n>>> nvenc_format_from_sunshine_format(platf::pix_fmt_e format) \nConverts the given platform pixel format to the corresponding NVENC buffer format. Returns NV_ENC_BUFFER_FORMAT_NV12 for nv12, NV_ENC_BUFFER_FORMAT_YUV420_10BIT for p010, NV_ENC_BUFFER_FORMAT_AYUV for ayuv, NV_ENC_BUFFER_FORMAT_YUV444_10BIT for yuv444p16, and NV_ENC_BUFFER_FORMAT_UNDEFINED for any other format. *\/"
    }

    {
        "file_name":"NVNGX_DLSS_Dx11_function_10.cpp",
        "line_count":11,
        "code":"NVSDK_NGX_Result NVSDK_NGX_D3D11_PopulateParameters_Impl(NVSDK_NGX_Parameter* InParameters)\n{\n    LOG_FUNC();\n\n    if (InParameters == nullptr)\n        return NVSDK_NGX_Result_Fail;\n\n    InitNGXParameters(InParameters);\n\n    return NVSDK_NGX_Result_Success;\n}",
        "mark":8.0,
        "query_nsx":"\/* Populate NGX parameters with the given input parameters.\n   >>> NVSDK_NGX_Result NVSDK_NGX_D3D11_PopulateParameters_Impl(NVSDK_NGX_Parameter* InParameters) *\/",
        "query_nlx":"        \/* Function named NVSDK_NGX_D3D11_PopulateParameters_Impl initializes NGX parameters if provided with valid input parameters.\n        >>> NVSDK_NGX_D3D11_PopulateParameters_Impl(nullptr) NVSDK_NGX_Result_Fail\n        >>> NVSDK_NGX_D3D11_PopulateParameters_Impl(valid_parameters) NVSDK_NGX_Result_Success *\/"
    }

    {
        "file_name":"NVNGX_DLSS_Dx12_function_1.cpp",
        "line_count":9,
        "code":"int64_t GetTicks()\n{\n    LARGE_INTEGER ticks;\n\n    if (!QueryPerformanceCounter(&ticks))\n        return 0;\n\n    return ticks.QuadPart;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the current system time in ticks.\n>>> GetTicks() int64_t *\/",
        "query_nlx":"\/* Function named GetTicks retrieves the current system time in ticks. \n>>> GetTicks() returns the current system time in ticks. *\/ \nint64_t GetTicks() { "
    }

    {
        "file_name":"NVNGX_DLSS_Dx12_function_16.cpp",
        "line_count":11,
        "code":"NVSDK_NGX_Result NVSDK_NGX_D3D12_PopulateParameters_Impl(NVSDK_NGX_Parameter* InParameters)\n{\n    LOG_FUNC();\n\n    if (InParameters == nullptr)\n        return NVSDK_NGX_Result_Fail;\n\n    InitNGXParameters(InParameters);\n\n    return NVSDK_NGX_Result_Success;\n}",
        "mark":8.0,
        "query_nsx":"\/* Populate NGX parameters with initialization if provided parameters are valid.\n   >>> NVSDK_NGX_Result NVSDK_NGX_D3D12_PopulateParameters_Impl(NVSDK_NGX_Parameter* InParameters) *\/",
        "query_nlx":"        \/* Function named NVSDK_NGX_D3D12_PopulateParameters_Impl initializes NGX parameters if provided parameters are not null.\n        >>> NVSDK_NGX_D3D12_PopulateParameters_Impl(nullptr) NVSDK_NGX_Result_Fail\n        >>> NVSDK_NGX_D3D12_PopulateParameters_Impl(parameters) NVSDK_NGX_Result_Success *\/"
    }

    {
        "file_name":"NVNGX_DLSS_Vk_function_13.cpp",
        "line_count":11,
        "code":"NVSDK_NGX_Result NVSDK_NGX_VULKAN_PopulateParameters_Impl(NVSDK_NGX_Parameter* InParameters)\n{\n    LOG_FUNC();\n\n    if (InParameters == nullptr)\n        return NVSDK_NGX_Result_Fail;\n\n    InitNGXParameters(InParameters);\n\n    return NVSDK_NGX_Result_Success;\n}",
        "mark":8.0,
        "query_nsx":"\/* Populate NGX parameters with the given input parameters.\n>>> NVSDK_NGX_Result NVSDK_NGX_VULKAN_PopulateParameters_Impl(NVSDK_NGX_Parameter* InParameters) *\/",
        "query_nlx":"        \/* Function named NVSDK_NGX_VULKAN_PopulateParameters_Impl initializes NGX parameters if provided with valid input parameters.\n        >>> NVSDK_NGX_VULKAN_PopulateParameters_Impl(nullptr) NVSDK_NGX_Result_Fail\n        >>> NVSDK_NGX_VULKAN_PopulateParameters_Impl(valid_parameters) NVSDK_NGX_Result_Success *\/"
    }

    {
        "file_name":"NVNGX_Proxy_function_13.cpp",
        "line_count":4,
        "code":"bool IsNVNGXInited()\n    {\n        return _dll != nullptr && (_dx11Inited || _dx12Inited || _vulkanInited) && Config::Instance()->DLSSEnabled.value_or(true);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the initialization status for certain graphics APIs and a specific configuration setting meet the required criteria.\n>>> IsNVNGXInited() *\/",
        "query_nlx":"\/* Function named IsNVNGXInited checks if a certain condition is met based on the state of three variables (_dll, _dx11Inited, _dx12Inited, _vulkanInited) and a configuration setting (DLSSEnabled). \n>>> IsNVNGXInited() returns true if _dll is not nullptr and at least one of _dx11Inited, _dx12Inited, or _vulkanInited is true, and if the DLSSEnabled configuration setting is true or not explicitly set to false. *\/ \nbool IsNVNGXInited() {  *\/"
    }

    {
        "file_name":"NVNGX_Proxy_function_16.cpp",
        "line_count":4,
        "code":"void SetDx11Inited(bool value)\n    {\n        _dx11Inited = value;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the initialization status for DirectX 11.\n   >>> SetDx11Inited(true) *\/ \nvoid SetDx11Inited(bool value) {",
        "query_nlx":"\/* Function named SetDx11Inited sets the value of a boolean variable _dx11Inited to the provided input value.\n>>> SetDx11Inited(true) \n>>> SetDx11Inited(false) *\/ \nvoid SetDx11Inited(bool value) { "
    }

    {
        "file_name":"NVNGX_Proxy_function_17.cpp",
        "line_count":4,
        "code":"bool IsDx11Inited()\n    {\n        return _dx11Inited;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the DirectX 11 initialization status is true or false.\n>>> IsDx11Inited() *\/ \nbool IsDx11Inited();",
        "query_nlx":"\/* Function named IsDx11Inited checks if a DirectX 11 initialization flag is set.\n>>> IsDx11Inited() returns a boolean value indicating whether DirectX 11 has been initialized. *\/ \nbool IsDx11Inited() {"
    }

    {
        "file_name":"NVNGX_Proxy_function_33.cpp",
        "line_count":4,
        "code":"void SetDx12Inited(bool value)\n    {\n        _dx12Inited = value;\n    }",
        "mark":10.0,
        "query_nsx":"\/* Set the initialization status for DirectX 12.\n   >>> SetDx12Inited(true) *\/ \nvoid SetDx12Inited(bool value) { ",
        "query_nlx":"\/* Function named SetDx12Inited sets the value of a boolean variable _dx12Inited to the provided input value.\n   >>> SetDx12Inited(true) \n   >>> SetDx12Inited(false) *\/ \nvoid SetDx12Inited(bool value) { "
    }

    {
        "file_name":"NVNGX_Proxy_function_34.cpp",
        "line_count":4,
        "code":"bool IsDx12Inited()\n    {\n        return _dx12Inited;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the DirectX 12 initialization process has been completed.\n   >>> IsDx12Inited() \n   *\/ \n   bool IsDx12Inited();",
        "query_nlx":"\/* Function named IsDx12Inited checks if a boolean variable representing the initialization status of DirectX 12 is true or false.\n>>> IsDx12Inited() bool *\/ \n*\/ \nbool IsDx12Inited();"
    }

    {
        "file_name":"NVNGX_Proxy_function_50.cpp",
        "line_count":4,
        "code":"void SetVulkanInited(bool value)\n    {\n        _vulkanInited = value;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the status of Vulkan initialization.\n   >>> SetVulkanInited(bool value) *\/",
        "query_nlx":"        \/* Define a function named SetVulkanInited that takes a boolean value as input and sets the internal variable _vulkanInited to that value. \n        >>> SetVulkanInited(true) \n        >>> SetVulkanInited(false) *\/ \n        void SetVulkanInited(bool value) { \n            \/\/ Function body omitted \n        }"
    }

    {
        "file_name":"NVNGX_Proxy_function_51.cpp",
        "line_count":4,
        "code":"bool IsVulkanInited()\n    {\n        return _vulkanInited;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if Vulkan has been initialized.\n   >>> IsVulkanInited() \n*\/ \nbool IsVulkanInited();",
        "query_nlx":"        \/* Function named IsVulkanInited checks if the Vulkan initialization flag is set or not.\n        >>> IsVulkanInited() returns a boolean value indicating whether Vulkan has been initialized or not. *\/ \n        bool IsVulkanInited() {"
    }

    {
        "file_name":"OldEnum_function_1.cpp",
        "line_count":4,
        "code":"OldEnum fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {\n      int enumValue = JSIConverter<int>::fromJSI(runtime, arg);\n      return static_cast<OldEnum>(enumValue);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given value to an enumeration type using a runtime environment.\n   >>> OldEnum fromJSI(jsi::Runtime& runtime, const jsi::Value& arg); *\/",
        "query_nlx":"\/* Convert a given value from a runtime environment to an enumeration value of an old enum type.\n   >>> fromJSI(runtime, arg) converts the value in arg to an integer using a converter and then casts it to an old enum type. *\/ \nOldEnum fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {"
    }

    {
        "file_name":"OldEnum_function_2.cpp",
        "line_count":4,
        "code":"Value toJSI(jsi::Runtime& runtime, OldEnum arg) {\n      int enumValue = static_cast<int>(arg);\n      return JSIConverter<int>::toJSI(runtime, enumValue);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert an old enum value to a JSI value using a specified runtime.\n   >>> Value toJSI(jsi::Runtime& runtime, OldEnum arg) { *\/",
        "query_nlx":"\/* Convert an old enum value to a JSI value using a given runtime.\n   >>> toJSI(runtime, arg) returns the JSI value of the old enum argument *\/\nValue toJSI(jsi::Runtime& runtime, OldEnum arg) {"
    }

    {
        "file_name":"OldEnum_function_3.cpp",
        "line_count":13,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isNumber()) {\n        return false;\n      }\n      double integer;\n      double fraction = modf(value.getNumber(), &integer);\n      if (fraction != 0.0) {\n        \/\/ It is some kind of floating point number - our enums are ints.\n        return false;\n      }\n      \/\/ Check if we are within the bounds of the enum.\n      return integer >= 0 && integer <= 2;\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Determine if a given value can be converted to an integer within a specific range.\n        >>> bool canConvert(Runtime& runtime, const Value& value) { *\/",
        "query_nlx":"        \/* Function named canConvert checks if a given value can be converted to an integer within a specific range.\n        >>> canConvert(5.0) true\n        >>> canConvert(3.5) false *\/ \n        bool canConvert(Runtime& runtime, const Value& value) { "
    }

    {
        "file_name":"OptionsDialog_function_9.cpp",
        "line_count":4,
        "code":"int ShowOptionsDialog()\n{\n\treturn DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DIALOG_OPTIONS), g_Hwnd, DialogProc);\n}",
        "mark":8.0,
        "query_nsx":"\/* Show options dialog box using the specified dialog template and processing function.\n   >>> ShowOptionsDialog() returns an integer value. *\/",
        "query_nlx":"\/* Function ShowOptionsDialog displays a dialog box with options to the user.\n>>> ShowOptionsDialog() returns the result of displaying a dialog box with options to the user. *\/ \nint ShowOptionsDialog() { "
    }

    {
        "file_name":"OS_Common_function_8.cpp",
        "line_count":8,
        "code":"float3x4 LoadSamples(uint idx, uint Stride)\n{\n\tuint i0 = idx, i1 = idx+Stride, i2 = idx+2*Stride, i3=idx+3*Stride;\n\treturn float3x4(\n\t\tg_R[i0], g_R[i1], g_R[i2], g_R[i3],\n\t\tg_G[i0], g_G[i1], g_G[i2], g_G[i3],\n\t\tg_B[i0], g_B[i1], g_B[i2], g_B[i3]);\n}",
        "mark":8.5,
        "query_nsx":"\/* Load samples from different memory locations based on the given index and stride values.\n   >>> LoadSamples(uint idx, uint Stride) *\/",
        "query_nlx":"        \/* Function named LoadSamples takes an index and a stride value, and loads samples from three arrays (g_R, g_G, g_B) based on the given index and stride. \n        >>> LoadSamples(10, 2) returns a 3x4 matrix containing elements from g_R, g_G, and g_B arrays at indices 10, 12, 14, and 16, 11, 13, 15, and 17, and 12, 14, 16, and 18 respectively. *\/ \n        float3x4 LoadSamples(uint idx, uint Stride) {  *\/"
    }

    {
        "file_name":"OS_Dx11_function_1.cpp",
        "line_count":1,
        "code":"bool IsUpsampling() { return _upsample; }",
        "mark":9.0,
        "query_nsx":"\/* Determine if upsampling is enabled.\n   >>> IsUpsampling() true\n   >>> IsUpsampling() false *\/ \nbool IsUpsampling();",
        "query_nlx":"\/* Function named IsUpsampling checks if a certain condition for upsampling is true or false.\n   >>> IsUpsampling() true\n   >>> IsUpsampling() false *\/ \nbool IsUpsampling() { "
    }

    {
        "file_name":"OS_Dx12_function_1.cpp",
        "line_count":1,
        "code":"bool IsUpsampling() { return _upsample; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if upsampling is enabled.\n   >>> IsUpsampling() true\n   >>> IsUpsampling() false *\/ \nbool IsUpsampling() { ",
        "query_nlx":"\/* Function named IsUpsampling checks if a certain condition for upsampling is true or false.\n   >>> IsUpsampling() true\n   >>> IsUpsampling() false *\/ \nbool IsUpsampling() { "
    }

    {
        "file_name":"PAG_Dx12_function_4.cpp",
        "line_count":13,
        "code":"void SetResourceState(ID3D12GraphicsCommandList* InCommandList, ID3D12Resource* InResource, D3D12_RESOURCE_STATES InCurrentState, D3D12_RESOURCE_STATES InNewState)\n{\n    if (InCurrentState == InNewState)\n        return;\n\n    D3D12_RESOURCE_BARRIER barrier = {};\n    barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;\n    barrier.Transition.pResource = InResource;\n    barrier.Transition.StateBefore = InCurrentState;\n    barrier.Transition.StateAfter = InNewState;\n    barrier.Transition.Subresource = 0;\n    InCommandList->ResourceBarrier(1, &barrier);\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the state of a graphics resource to a new state if it is different from the current state.\n>>> void SetResourceState(ID3D12GraphicsCommandList* InCommandList, ID3D12Resource* InResource, D3D12_RESOURCE_STATES InCurrentState, D3D12_RESOURCE_STATES InNewState) { *\/",
        "query_nlx":"\/* Function named SetResourceState updates the state of a given resource to a new state if it is different from the current state.\n>>> SetResourceState(InCommandList, InResource, InCurrentState, InNewState) void *\/"
    }

    {
        "file_name":"Panic_function_1.cpp",
        "line_count":5,
        "code":"int main(int argc, char** argv) {\n *     ::testing::InitGoogleTest(&argc, argv);\n *     Panic::setMode(Panic::Mode::THROW);\n *     return RUN_ALL_TESTS();\n * }",
        "mark":8.0,
        "query_nsx":"\/* Initialize Google Test framework, set panic mode to throw exceptions, and run all tests.\n   >>> main(int argc, char** argv) *\/",
        "query_nlx":"\/* Initialize Google Test framework, set panic mode to throw exceptions, and run all available tests.\n   >>> main(argc=1, argv={\"test_program\"}) runs all tests and throws exceptions on panics *\/\nint main(int argc, char** argv) {"
    }

    {
        "file_name":"Path_function_1.cpp",
        "line_count":3,
        "code":"void setPath(const std::string& pathname) {\n        m_path = getCanonicalPath(pathname);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the canonical path for a given pathname.\n    >>> setPath(const string& pathname) *\/",
        "query_nlx":"\/* Define a function called setPath that takes a pathname as input and sets the internal path variable to the canonical path of the input pathname.\n   >>> setPath(\"\/home\/user\/documents\/file.txt\") *\/ \nvoid setPath(const std::string& pathname) {"
    }

    {
        "file_name":"Person_function_2.cpp",
        "line_count":6,
        "code":"Value toJSI(jsi::Runtime& runtime, const Person& arg) {\n      jsi::Object obj(runtime);\n      obj.setProperty(runtime, \"name\", JSIConverter<std::string>::toJSI(runtime, arg.name));\n      obj.setProperty(runtime, \"age\", JSIConverter<double>::toJSI(runtime, arg.age));\n      return obj;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Convert a Person object to a JavaScript object with 'name' and 'age' properties.\n   >>> Value toJSI(jsi::Runtime& runtime, const Person& arg) { *\/",
        "query_nlx":"        \/* Function to convert a Person object to a JavaScript Object with 'name' and 'age' properties.\n        >>> toJSI(runtime, arg) returns a JavaScript Object with 'name' property set to the name of the Person object and 'age' property set to the age of the Person object. *\/\n        Value toJSI(jsi::Runtime& runtime, const Person& arg) { "
    }

    {
        "file_name":"Person_function_3.cpp",
        "line_count":9,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isObject()) {\n        return false;\n      }\n      jsi::Object obj = value.getObject(runtime);\n      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, \"name\"))) return false;\n      if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"age\"))) return false;\n      return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given object can be converted based on the presence of specific properties.\n   >>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"        \/* Function named canConvert checks if a given object can be converted to specific data types based on the presence of \"name\" and \"age\" properties.\n        >>> canConvert({name: \"John\", age: 30}) true\n        >>> canConvert({title: \"Mr.\", age: 25}) false *\/ \n        bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {"
    }

    {
        "file_name":"PixelFormat_function_3.cpp",
        "line_count":14,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isString()) {\n        return false;\n      }\n      std::string unionValue = JSIConverter<std::string>::fromJSI(runtime, value);\n      switch (hashString(unionValue.c_str(), unionValue.size())) {\n        case hashString(\"rgb\"):\n        case hashString(\"yuv-8bit\"):\n        case hashString(\"yuv-10bit\"):\n          return true;\n        default:\n          return false;\n      }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if a given value can be converted based on specific criteria.\n        >>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"\n\/* Function named canConvert takes a runtime and a value as input and checks if the value can be converted to a specific set of strings. \n>>> canConvert(runtime, value) \n   - Returns true if the value is a string and matches one of the predefined strings (\"rgb\", \"yuv-8bit\", \"yuv-10bit\"), otherwise returns false. *\/ \nbool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {"
    }

    {
        "file_name":"PluginTest_function_1.cpp",
        "line_count":1,
        "code":"bool isPluginOriginal() { return true; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the plugin is an original creation or not.\n>>> isPluginOriginal() true\n*\/ \nbool isPluginOriginal();",
        "query_nlx":"\/* Function named isPluginOriginal checks if a plugin is original or not.\n   >>> isPluginOriginal() true\n   >>> isPluginOriginal() false *\/ \nbool isPluginOriginal() { "
    }

    {
        "file_name":"Powertrain_function_3.cpp",
        "line_count":14,
        "code":"bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n      if (!value.isString()) {\n        return false;\n      }\n      std::string unionValue = JSIConverter<std::string>::fromJSI(runtime, value);\n      switch (hashString(unionValue.c_str(), unionValue.size())) {\n        case hashString(\"electric\"):\n        case hashString(\"gas\"):\n        case hashString(\"hybrid\"):\n          return true;\n        default:\n          return false;\n      }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given value can be converted to a specific type based on predefined criteria.\n>>> bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { *\/",
        "query_nlx":"        \/* Function named canConvert takes a runtime and a value as input and checks if the value can be converted to a string representation of \"electric\", \"gas\", or \"hybrid\".\n        >>> canConvert(runtime, value) returns true if the value is a string representing \"electric\", \"gas\", or \"hybrid\", otherwise false *\/ \n        bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) { "
    }

    {
        "file_name":"Process_function_9.cpp",
        "line_count":1,
        "code":"void inheritParentEnvironmentVariables(bool inherit) { inheritEnv = inherit; }",
        "mark":8.0,
        "query_nsx":"\/* Set whether to inherit parent environment variables or not.\n   >>> inheritParentEnvironmentVariables(true) \n   >>> inheritParentEnvironmentVariables(false) *\/ \nvoid inheritParentEnvironmentVariables(bool inherit) {",
        "query_nlx":"\/* Define a function that controls whether child processes inherit environment variables from the parent process or not.\n   >>> inheritParentEnvironmentVariables(true) sets the child processes to inherit environment variables from the parent.\n   >>> inheritParentEnvironmentVariables(false) disables the inheritance of environment variables for child processes. *\/ \nvoid inheritParentEnvironmentVariables(bool inherit) { "
    }

    {
        "file_name":"ProfileView_function_1.cpp",
        "line_count":4,
        "code":"int GetProfileBorderSize()\n{\n\treturn ScaleByDPI(Supports32BitIcons() ? (PROFILE_PICTURE_SIZE_DEF + 12) : 64);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of the profile border based on the support for 32-bit icons and a default profile picture size.\n>>> int GetProfileBorderSize() *\/",
        "query_nlx":"\/* Function named GetProfileBorderSize calculates the size of the profile border based on whether the system supports 32-bit icons. If it does, the border size is the default profile picture size plus 12; otherwise, it is 64.\n>>> GetProfileBorderSize() 76 *\/"
    }

    {
        "file_name":"Protobuf_function_1.cpp",
        "line_count":4,
        "code":"uint64_t CombineFieldNumberAndTag(FieldNumber fieldNumber, int tag)\n\t{\n\t\treturn (fieldNumber << 3) | tag;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Combine a field number and a tag to create a unique identifier.\n   >>> uint64_t CombineFieldNumberAndTag(FieldNumber fieldNumber, int tag) *\/",
        "query_nlx":"\/* Function named CombineFieldNumberAndTag takes a field number and a tag as input and combines them to form a 64-bit unsigned integer value. \n>>> CombineFieldNumberAndTag(5, 2) returns 42 \n>>> CombineFieldNumberAndTag(10, 7) returns 87 *\/ \nuint64_t CombineFieldNumberAndTag(FieldNumber fieldNumber, int tag) { "
    }

    {
        "file_name":"Protobuf_function_4.cpp",
        "line_count":1,
        "code":"bool IsEmpty() { return true; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a data structure is empty or not.\n   >>> IsEmpty() true *\/",
        "query_nlx":"\/* Function named IsEmpty checks if a certain data structure is empty or not.\n>>> IsEmpty() true\n*\/ \nbool IsEmpty() { "
    }

    {
        "file_name":"Protobuf_function_6.cpp",
        "line_count":3,
        "code":"void MarkClean() {\n\t\t\tm_bIsDirty = false;\n\t\t}",
        "mark":8.0,
        "query_nsx":"\/* Mark an object as clean by setting a flag to false.\n   >>> MarkClean()\n*\/ \nvoid MarkClean() {",
        "query_nlx":"\/* Define a function called MarkClean that sets a boolean variable to indicate whether an object is dirty to false. \n>>> MarkClean() *\/ \nvoid MarkClean() {"
    }

    {
        "file_name":"Protobuf_function_7.cpp",
        "line_count":5,
        "code":"void MarkDirty() {\n\t\t\tm_bIsDirty = true;\n\t\t\tif (m_pParent)\n\t\t\t\tm_pParent->MarkDirty();\n\t\t}",
        "mark":8.0,
        "query_nsx":"\/* Mark the current object and its parent objects as dirty to indicate a change has occurred.\n   >>> MarkDirty() *\/",
        "query_nlx":"\/* Function named MarkDirty sets a flag to indicate that an object is dirty and recursively marks its parent as dirty if it has one. \n>>> MarkDirty() *\/"
    }

    {
        "file_name":"Protobuf_function_8.cpp",
        "line_count":3,
        "code":"void SetParent(ObjectBase* pMsg) {\n\t\t\tm_pParent = pMsg;\n\t\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the parent object for a given message.\n   >>> void SetParent(ObjectBase* pMsg); *\/",
        "query_nlx":"\/* Define a function named SetParent that takes an ObjectBase pointer as input and assigns it to the member variable m_pParent. \n   >>> SetParent(ObjectBase* pMsg) *\/"
    }

    {
        "file_name":"QuickSwitcher_function_1.cpp",
        "line_count":10,
        "code":"int GetIconFromChannel(Channel* pChan)\n{\n\tswitch (pChan->m_channelType)\n\t{\n\t\tcase Channel::DM:      return ICN_DM;\n\t\tcase Channel::GROUPDM: return ICN_GROUPDM;\n\t\tcase Channel::VOICE:   return ICN_VOICE;\n\t\tdefault:               return ICN_CHANNEL;\n\t}\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the corresponding icon based on the type of channel.\n   >>> int GetIconFromChannel(Channel* pChan); *\/",
        "query_nlx":"\/* Function named GetIconFromChannel determines the icon associated with a given channel based on its type.\n   >>> GetIconFromChannel(Channel* pChan) returns ICN_DM if the channel type is DM\n   >>> GetIconFromChannel(Channel* pChan) returns ICN_GROUPDM if the channel type is GROUPDM\n   >>> GetIconFromChannel(Channel* pChan) returns ICN_VOICE if the channel type is VOICE\n   >>> GetIconFromChannel(Channel* pChan) returns ICN_CHANNEL for any other channel type *\/ \nint GetIconFromChannel(Channel* pChan) { "
    }

    {
        "file_name":"RCAS_Dx11_function_1.cpp",
        "line_count":23,
        "code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n{\n    switch (format) {\n        case DXGI_FORMAT_R32G32B32A32_TYPELESS:\n            return DXGI_FORMAT_R32G32B32A32_FLOAT;\n        case DXGI_FORMAT_R32G32B32_TYPELESS:\n            return DXGI_FORMAT_R32G32B32_FLOAT;\n        case DXGI_FORMAT_R16G16B16A16_TYPELESS:\n            return DXGI_FORMAT_R16G16B16A16_FLOAT;\n        case DXGI_FORMAT_R10G10B10A2_TYPELESS:\n            return DXGI_FORMAT_R10G10B10A2_UINT;\n        case DXGI_FORMAT_R8G8B8A8_TYPELESS:\n            return DXGI_FORMAT_R8G8B8A8_UNORM;\n        case DXGI_FORMAT_B8G8R8A8_TYPELESS:\n            return DXGI_FORMAT_B8G8R8A8_UNORM;\n        case DXGI_FORMAT_R16G16_TYPELESS:\n            return DXGI_FORMAT_R16G16_FLOAT;\n        case DXGI_FORMAT_R32G32_TYPELESS:\n            return DXGI_FORMAT_R32G32_FLOAT;\n        default:\n            return format;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Translate typeless DXGI formats to their corresponding typed formats.\n   >>> DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format); *\/",
        "query_nlx":"\/* TranslateTypelessFormats function translates typeless DXGI formats to their corresponding non-typeless formats.\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R32G32B32A32_TYPELESS) returns DXGI_FORMAT_R32G32B32A32_FLOAT\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R16G16B16A16_TYPELESS) returns DXGI_FORMAT_R16G16B16A16_FLOAT\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R8G8B8A8_TYPELESS) returns DXGI_FORMAT_R8G8B8A8_UNORM\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R32G32_TYPELESS) returns DXGI_FORMAT_R32G32_FLOAT *\/ \nDXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format) { "
    }

    {
        "file_name":"RCAS_Dx12_function_1.cpp",
        "line_count":23,
        "code":"DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format)\n{\n\tswitch (format) {\n\t\tcase DXGI_FORMAT_R32G32B32A32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32B32A32_FLOAT;\n\t\tcase DXGI_FORMAT_R32G32B32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32B32_FLOAT;\n\t\tcase DXGI_FORMAT_R16G16B16A16_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R16G16B16A16_FLOAT;\n\t\tcase DXGI_FORMAT_R10G10B10A2_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R10G10B10A2_UINT;\n\t\tcase DXGI_FORMAT_R8G8B8A8_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R8G8B8A8_UNORM;\n\t\tcase DXGI_FORMAT_B8G8R8A8_TYPELESS:\n\t\t\treturn DXGI_FORMAT_B8G8R8A8_UNORM;\n\t\tcase DXGI_FORMAT_R16G16_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R16G16_FLOAT;\n\t\tcase DXGI_FORMAT_R32G32_TYPELESS:\n\t\t\treturn DXGI_FORMAT_R32G32_FLOAT;\n\t\tdefault:\n\t\t\treturn format;\n\t}\n}",
        "mark":8.0,
        "query_nsx":"\/* Translate typeless DXGI formats to their corresponding non-typeless formats.\n   >>> DXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format); *\/",
        "query_nlx":"\/* TranslateTypelessFormats function translates typeless DXGI formats to their corresponding non-typeless formats.\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R32G32B32A32_TYPELESS) returns DXGI_FORMAT_R32G32B32A32_FLOAT\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R10G10B10A2_TYPELESS) returns DXGI_FORMAT_R10G10B10A2_UINT\n   >>> TranslateTypelessFormats(DXGI_FORMAT_R16G16_TYPELESS) returns DXGI_FORMAT_R16G16_FLOAT *\/ \nDXGI_FORMAT TranslateTypelessFormats(DXGI_FORMAT format) {"
    }

    {
        "file_name":"ReflectionAutoAggregates_function_3.cpp",
        "line_count":1,
        "code":"TypeCategory getCategory() { return TypeCategory::TypeStruct; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the category type of the object as a struct.\n   >>> getCategory() TypeStruct *\/",
        "query_nlx":"\/* Function named getCategory returns the category of a specific type, which is a struct type.\n   >>> getCategory() TypeStruct *\/ \nTypeCategory getCategory() { "
    }

    {
        "file_name":"ReflectionAutoStructured_function_10.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 9)\n    {\n        auto& [a, b, c, d, e, f, g, h, i] = obj;\n        return func(a, b, c, d, e, f, g, h, i);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Execute a function with nine input parameters if the number of members is equal to 9.\n   >>> func(obj) *\/ \n   #include <iostream>\n   #include <tuple>\n   #include <functional>\n   using namespace std;\n   template<typename T>\n   auto execute_function(T obj) {\n       if constexpr (NumMembers == 9)\n       {\n           auto& [a, b, c, d, e, f, g, h, i] = obj;\n           return func(a, b, c, d, e, f, g, h, i);\n       }\n   }",
        "query_nlx":"\/* Check if the number of members in an object is 9, then extract the elements a, b, c, d, e, f, g, h, and i from the object and pass them to a function named func.\n   >>> if constexpr (NumMembers == 9) { auto& [a, b, c, d, e, f, g, h, i] = obj; return func(a, b, c, d, e, f, g, h, i); } *\/ \n*\/"
    }

    {
        "file_name":"ReflectionAutoStructured_function_11.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 10)\n    {\n        auto& [a, b, c, d, e, f, g, h, i, j] = obj;\n        return func(a, b, c, d, e, f, g, h, i, j);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Execute a function with 10 members if the condition is met.\n    >>> execute_function_with_10_members(obj) *\/ \nif constexpr (NumMembers == 10) { ",
        "query_nlx":"\/* Check if the number of members in an object is equal to 10, then extract the elements a, b, c, d, e, f, g, h, i, and j from the object and pass them as arguments to a function.\n    >>> extract_elements(obj) *\/ \nif constexpr (NumMembers == 10) { \n    auto& [a, b, c, d, e, f, g, h, i, j] = obj; "
    }

    {
        "file_name":"ReflectionAutoStructured_function_17.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 3)\n    {\n        auto& [a, b, c] = obj;\n        return ArgumentGet<N>(&a, &b, &c);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return the result of getting arguments from an object if it has exactly three members.\n   >>> ArgumentGet(obj, N) *\/ \nif constexpr (NumMembers == 3) {",
        "query_nlx":"\/* Given an object with three members, extract the values of those members and pass them as arguments to the function ArgumentGet. \n   >>> if constexpr (NumMembers == 3)\n   >>> {\n   >>>     auto& [a, b, c] = obj;\n   >>>     return ArgumentGet<N>(&a, &b, &c);\n   >>> } *\/"
    }

    {
        "file_name":"ReflectionAutoStructured_function_20.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 6)\n    {\n        auto& [a, b, c, d, e, f] = obj;\n        return ArgumentGet<N>(&a, &b, &c, &d, &e, &f);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return the result of accessing and returning specific arguments from an object if the number of members is 6.\n>>> ArgumentGet<N>(&a, &b, &c, &d, &e, &f) *\/ \nif constexpr (NumMembers == 6) { ",
        "query_nlx":"\/* Given a constant value NumMembers equal to 6, this code snippet extracts references to variables a, b, c, d, e, and f from an object obj. It then calls the function ArgumentGet with pointers to these variables as arguments.\n   >>> Extract variables a, b, c, d, e, and f from obj and pass them as arguments to ArgumentGet function. *\/ \nif constexpr (NumMembers == 6) { *\/"
    }

    {
        "file_name":"ReflectionAutoStructured_function_21.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 7)\n    {\n        auto& [a, b, c, d, e, f, g] = obj;\n        return ArgumentGet<N>(&a, &b, &c, &d, &e, &f, &g);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return the result of obtaining arguments from an object if it has exactly 7 members.\n   >>> ArgumentGet<N>(&a, &b, &c, &d, &e, &f, &g) *\/ \nif constexpr (NumMembers == 7) { ",
        "query_nlx":"\/* Given an object with seven members, extract the references to those members and pass them as arguments to the ArgumentGet function.\n   >>> if constexpr (NumMembers == 7)\n   >>> {\n   >>>     auto& [a, b, c, d, e, f, g] = obj;\n   >>>     return ArgumentGet<N>(&a, &b, &c, &d, &e, &f, &g);\n   >>> } *\/"
    }

    {
        "file_name":"ReflectionAutoStructured_function_22.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 8)\n    {\n        auto& [a, b, c, d, e, f, g, h] = obj;\n        return ArgumentGet<N>(&a, &b, &c, &d, &e, &f, &g, &h);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the number of members is 8, then extract specific arguments from an object and return them.\n>>> extract_arguments(obj) *\/ \nif constexpr (NumMembers == 8) {",
        "query_nlx":"\/* Check if the number of members is equal to 8 in the object. If so, extract references to variables a, b, c, d, e, f, g, h from the object and return the result of calling the ArgumentGet function with pointers to these variables.\n    >>> Extract variables a, b, c, d, e, f, g, h from the object if the number of members is 8 and return the result of ArgumentGet function with pointers to these variables *\/ \nif constexpr (NumMembers == 8) { *\/"
    }

    {
        "file_name":"ReflectionAutoStructured_function_24.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 10)\n    {\n        auto& [a, b, c, d, e, f, g, h, i, j] = obj;\n        return ArgumentGet<N>(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return the result of obtaining arguments from an object if the number of members is 10.\n   >>> ArgumentGet<N>(&a, &b, &c, &d, &e, &f, &g, &h, &i, &j) *\/ \nif constexpr (NumMembers == 10) { ",
        "query_nlx":"\/* If the number of members in an object is exactly 10, extract references to each member (a, b, c, d, e, f, g, h, i, j) from the object and return the result of calling the ArgumentGet function with pointers to these members.\n   >>> Extract members a, b, c, d, e, f, g, h, i, j from the object and pass them as arguments to the ArgumentGet function *\/ \nif constexpr (NumMembers == 10) { *\/"
    }

    {
        "file_name":"ReflectionAutoStructured_function_33.cpp",
        "line_count":1,
        "code":"TypeCategory getCategory() { return TypeCategory::TypeStruct; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the category of the type as a struct.\n   >>> getCategory() TypeCategory::TypeStruct { *\/",
        "query_nlx":"\/* Function getCategory returns the category of a type as TypeStruct.\n   >>> getCategory() TypeCategory::TypeStruct *\/ \nTypeCategory getCategory() {"
    }

    {
        "file_name":"ReflectionAutoStructured_function_4.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 3)\n    {\n        auto& [a, b, c] = obj;\n        return func(a, b, c);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return the result of a function applied to three elements of an object if the object has exactly three members.\n    >>> func(obj) *\/ \nif constexpr (NumMembers == 3) {",
        "query_nlx":"\/* Given an object with three members, this function extracts the members a, b, and c from the object and calls a function with these three values as arguments.\n   >>> extract_and_call_func(obj) calls func(a, b, c) if obj has three members\n*\/ \nif constexpr (NumMembers == 3) { "
    }

    {
        "file_name":"ReflectionAutoStructured_function_6.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 5)\n    {\n        auto& [a, b, c, d, e] = obj;\n        return func(a, b, c, d, e);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Execute a function with five input parameters if the number of members is equal to 5.\n   >>> execute_function_with_five_parameters(obj) *\/ \nif constexpr (NumMembers == 5) {",
        "query_nlx":"\/* Given an object with five members, if the number of members is exactly 5, extract the values of those members into variables a, b, c, d, and e, then call a function with these variables as arguments.\n   >>> if constexpr (NumMembers == 5)\n   >>> {\n   >>>     auto& [a, b, c, d, e] = obj;\n   >>>     return func(a, b, c, d, e);\n   >>> } *\/"
    }

    {
        "file_name":"ReflectionAutoStructured_function_7.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 6)\n    {\n        auto& [a, b, c, d, e, f] = obj;\n        return func(a, b, c, d, e, f);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Execute a function with six input parameters if the number of members is equal to 6.\n   >>> execute_function_with_six_parameters(obj) *\/ \nif constexpr (NumMembers == 6) {",
        "query_nlx":"\/* Given an object with six members, this function extracts those members (a, b, c, d, e, f) and passes them as arguments to another function named func. \n   >>> extract_six_members_and_call_func(obj) *\/ \nif constexpr (NumMembers == 6) { "
    }

    {
        "file_name":"ReflectionAutoStructured_function_8.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 7)\n    {\n        auto& [a, b, c, d, e, f, g] = obj;\n        return func(a, b, c, d, e, f, g);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Execute a function with seven input parameters if the number of members is exactly seven.\n   >>> func(obj) *\/ \nif constexpr (NumMembers == 7) { ",
        "query_nlx":"\/* If the number of members in an object is exactly 7, extract references to variables a, b, c, d, e, f, and g from the object and pass them as arguments to the function func. \n>>> func(obj.a, obj.b, obj.c, obj.d, obj.e, obj.f, obj.g) *\/ \n#include<iostream> \n#include<vector> \nusing namespace std; \ntemplate<typename T> \nauto process_object(T obj) { *\/"
    }

    {
        "file_name":"ReflectionAutoStructured_function_9.cpp",
        "line_count":5,
        "code":"if constexpr (NumMembers == 8)\n    {\n        auto& [a, b, c, d, e, f, g, h] = obj;\n        return func(a, b, c, d, e, f, g, h);\n    }",
        "mark":8.0,
        "query_nsx":"\/* If the number of members in the object is 8, extract them and pass them as arguments to a function.\n   >>> func(obj) *\/ \nif constexpr (NumMembers == 8) { ",
        "query_nlx":"\/* If the number of members in an object is equal to 8, extract the elements a, b, c, d, e, f, g, and h from the object and pass them as arguments to the function func.\n   >>> extract_elements_if_8_members(obj, func) *\/ \nif constexpr (NumMembers == 8) {"
    }

    {
        "file_name":"ReflectionFoundation_function_1.cpp",
        "line_count":10,
        "code":"bool append(const ArrayWithSize<T, N2>& other)\n    {\n        if (size + other.size >= N)\n            return false;\n        for (uint32_t i = 0; i < other.size; ++i)\n        {\n            values[size++] = other.values[i];\n        }\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Append the values from another array to the current array if there is enough space available.\n   >>> bool append(const ArrayWithSize<T, N2>& other) *\/",
        "query_nlx":"\/* Function named append adds the elements from another array to the current array if there is enough space available.\n>>> append({1, 2, 3}, {4, 5, 6}) true\n>>> append({1, 2, 3, 4, 5}, {6, 7, 8}) false *\/ \nbool append(const ArrayWithSize<T, N2>& other) { "
    }

    {
        "file_name":"ReflectionFoundation_function_2.cpp",
        "line_count":9,
        "code":"bool push_back(const T& value)\n    {\n        if (size < N)\n        {\n            values[size++] = value;\n            return true;\n        }\n        return false;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if a value can be added to a collection without exceeding a certain limit.\n    >>> bool push_back(const T& value) *\/",
        "query_nlx":"\/* Function named push_back adds a value to a collection if the collection is not full.\n>>> push_back(5) true\n>>> push_back(10) true\n>>> push_back(15) true\n>>> push_back(20) true\n>>> push_back(25) false *\/"
    }

    {
        "file_name":"ReflectionFoundation_function_3.cpp",
        "line_count":10,
        "code":"bool writeAndAdvance(const Type& value)\n    {\n        if (iterator < iteratorEnd)\n        {\n            *iterator = value;\n            iterator++;\n            return true;\n        }\n        return false;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Write a function that attempts to store a value at the current iterator position and advances the iterator if possible.\n>>> writeAndAdvance(const Type& value) \n*\/",
        "query_nlx":"\/* Function named writeAndAdvance takes a value of a certain type and writes it to the current position of an iterator if the iterator has not reached its end. The iterator is then advanced to the next position.\n>>> writeAndAdvance(5) true\n>>> writeAndAdvance(8) true\n>>> writeAndAdvance(3) true\n>>> writeAndAdvance(2) false *\/"
    }

    {
        "file_name":"ReflectionFoundation_function_6.cpp",
        "line_count":1,
        "code":"TypeStringView get() { return TypeStringView(value.values, value.size); }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a view of a string type value from the current object's values with a specified size.\n   >>> get() TypeStringView *\/",
        "query_nlx":"\/* Retrieve a TypeStringView object containing the values stored in the 'value' variable with the specified size.\n   >>> get() TypeStringView(value.values, value.size) *\/ \nTypeStringView get() { "
    }

    {
        "file_name":"ReflectionSC_function_1.cpp",
        "line_count":1,
        "code":"bool build(MemberVisitor&) { return true; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a member can be successfully built by visiting it.\n   >>> build(MemberVisitor&) \n*\/ \nbool build(MemberVisitor&) {",
        "query_nlx":"\/* Function named build takes a MemberVisitor object as input and returns a boolean value indicating success.\n   >>> build(MemberVisitor&) true *\/"
    }

    {
        "file_name":"ReflectionSC_function_10.cpp",
        "line_count":1,
        "code":"auto size(const SC::Vector<T>& object) { return object.size(); }",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of the given vector.\n>>> size(const SC::Vector<T>& object) *\/",
        "query_nlx":"\/* Function named size takes a vector of elements and returns the number of elements in the vector.\n   >>> size({1, 2, 3, 4, 5}) 5\n   >>> size({\"apple\", \"banana\", \"orange\"}) 3 *\/ \nauto size(const Vector<T>& object) { "
    }

    {
        "file_name":"ReflectionSC_function_12.cpp",
        "line_count":4,
        "code":"bool resizeWithoutInitializing(SC::Vector<T>& object, size_t newSize)\n    {\n        return object.resizeWithoutInitializing(newSize);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Resize a vector without initializing its elements to a new specified size.\n        >>> bool resizeWithoutInitializing(Vector<T>& object, size_t newSize) *\/",
        "query_nlx":"        \/* Function named resizeWithoutInitializing resizes a given vector without initializing the new elements.\n        >>> resizeWithoutInitializing(object, 10) true\n        >>> resizeWithoutInitializing(object, 5) true *\/ \n        bool resizeWithoutInitializing(SC::Vector<T>& object, size_t newSize) { "
    }

    {
        "file_name":"ReflectionSC_function_13.cpp",
        "line_count":1,
        "code":"bool resize(SC::Vector<T>& object, size_t newSize) { return object.resize(newSize); }",
        "mark":8.0,
        "query_nsx":"\/* Resize a vector of elements to a specified new size.\n>>> bool resize(Vector<T>& object, size_t newSize) *\/",
        "query_nlx":"\/* Function named resize modifies the size of a given vector to a specified new size.\n>>> resize(object, 10) true\n>>> resize(object, 0) true\n*\/ \nbool resize(SC::Vector<T>& object, size_t newSize) { "
    }

    {
        "file_name":"ReflectionSC_function_2.cpp",
        "line_count":1,
        "code":"auto size(const SC::Array<T, N>& object) { return object.size(); }",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of the given array.\n>>> size(const SC::Array<T, N>& object) *\/",
        "query_nlx":"\/* Function named size takes an array object as input and returns the size of the array.\n>>> size({1, 2, 3, 4, 5}) 5\n>>> size({\"apple\", \"banana\", \"orange\"}) 3 *\/ \ntemplate<typename T, int N> \nauto size(const SC::Array<T, N>& object) { "
    }

    {
        "file_name":"ReflectionSC_function_4.cpp",
        "line_count":4,
        "code":"bool resizeWithoutInitializing(SC::Array<T, N>& object, size_t newSize)\n    {\n        return object.resizeWithoutInitializing(min(newSize, static_cast<size_t>(N)));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Resize an array without initializing its elements to a new specified size.\n   >>> bool resizeWithoutInitializing(Array<T, N>& object, size_t newSize); *\/",
        "query_nlx":"\/* Function named resizeWithoutInitializing modifies the size of an array object without initializing any new elements beyond the original size. \n>>> resizeWithoutInitializing(object, newSize) returns a boolean value indicating whether the resizing operation was successful or not. *\/ \ntemplate<typename T, size_t N> bool resizeWithoutInitializing(Array<T, N>& object, size_t newSize) { "
    }

    {
        "file_name":"ReflectionSC_function_5.cpp",
        "line_count":4,
        "code":"bool resize(SC::Array<T, N>& object, size_t newSize)\n    {\n        return object.resize(min(newSize, static_cast<size_t>(N)));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Resize an array to a specified size or the maximum size if the specified size exceeds the array's capacity.\n>>> bool resize(Array<T, N>& object, size_t newSize); *\/",
        "query_nlx":"\/* Function named resize modifies the size of an array to a specified new size, limiting it to the minimum of the new size and the original size of the array. \n>>> resize(object, newSize) bool *\/ \n#include <iostream> \n#include <array> \nusing namespace std; \ntemplate <typename T, size_t N> \nbool resize(array<T, N>& object, size_t newSize) { *\/"
    }

    {
        "file_name":"ReflectionSC_function_6.cpp",
        "line_count":1,
        "code":"TypeCategory getCategory() { return TypeCategory::TypeVector; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the category of the type as a vector. \n>>> getCategory() TypeVector *\/",
        "query_nlx":"\/* Function named getCategory returns the category of a specific type, which is a vector type.\n>>> getCategory() TypeCategory::TypeVector *\/ \nTypeCategory getCategory() {"
    }

    {
        "file_name":"ReflectionSC_function_8.cpp",
        "line_count":1,
        "code":"TypeCategory getCategory() { return TypeCategory::TypeVector; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the category of the type as a vector. \n>>> getCategory() TypeVector *\/",
        "query_nlx":"\/* Function named getCategory returns the category of a specific type, which is a vector type.\n   >>> getCategory() TypeCategory::TypeVector *\/ \nTypeCategory getCategory() { "
    }

    {
        "file_name":"ReflectionTestPrint_function_1.cpp",
        "line_count":22,
        "code":"StringView typeCategoryToStringView(Reflection::TypeCategory type)\n{\n    switch (type)\n    {\n    case Reflection::TypeCategory::TypeInvalid: return \"TypeInvalid \";\n    case Reflection::TypeCategory::TypeBOOL: return \"TypeBOOL   \";\n    case Reflection::TypeCategory::TypeUINT8: return \"TypeUINT8   \";\n    case Reflection::TypeCategory::TypeUINT16: return \"TypeUINT16  \";\n    case Reflection::TypeCategory::TypeUINT32: return \"TypeUINT32  \";\n    case Reflection::TypeCategory::TypeUINT64: return \"TypeUINT64  \";\n    case Reflection::TypeCategory::TypeINT8: return \"TypeINT8    \";\n    case Reflection::TypeCategory::TypeINT16: return \"TypeINT16   \";\n    case Reflection::TypeCategory::TypeINT32: return \"TypeINT32   \";\n    case Reflection::TypeCategory::TypeINT64: return \"TypeINT64   \";\n    case Reflection::TypeCategory::TypeFLOAT32: return \"TypeFLOAT32 \";\n    case Reflection::TypeCategory::TypeDOUBLE64: return \"TypeDOUBLE64\";\n    case Reflection::TypeCategory::TypeStruct: return \"TypeStruct  \";\n    case Reflection::TypeCategory::TypeArray: return \"TypeArray   \";\n    case Reflection::TypeCategory::TypeVector: return \"TypeVector  \";\n    }\n    Assert::unreachable();\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a given type category to a corresponding string view representation.\n   >>> StringView typeCategoryToStringView(Reflection::TypeCategory type); *\/",
        "query_nlx":"\/* Define a function that converts a given type category into a corresponding string view representation.\n   The function should return a string view based on the input type category, which can be one of the predefined type categories such as TypeInvalid, TypeBOOL, TypeUINT8, TypeUINT16, TypeUINT32, TypeUINT64, TypeINT8, TypeINT16, TypeINT32, TypeINT64, TypeFLOAT32, TypeDOUBLE64, TypeStruct, TypeArray, or TypeVector.\n   The function should handle each type category case and return the corresponding string view representation.\n   If the input type category does not match any of the predefined categories, the function should assert that it is unreachable.\n>>> typeCategoryToStringView(Reflection::TypeCategory::TypeUINT16) returns \"TypeUINT16  \"\n>>> typeCategoryToStringView(Reflection::TypeCategory::TypeStruct) returns \"TypeStruct  \"\n*\/ \nStringView typeCategoryToStringView(Reflection::TypeCategory type) {"
    }

    {
        "file_name":"Reflection_function_17.cpp",
        "line_count":1,
        "code":"TypeCategory getCategory() { return TypeCategory::TypeArray; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the category of the type as an array or collection.\n   >>> getCategory() TypeArray *\/",
        "query_nlx":"\/* Function named getCategory returns the category of a type, specifically indicating that the type is an array.\n   >>> getCategory() TypeCategory::TypeArray *\/ \nTypeCategory getCategory() { "
    }

    {
        "file_name":"Reflection_function_19.cpp",
        "line_count":1,
        "code":"TypeCategory getCategory() { return TypeCategory::TypeStruct; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the category of the type as a struct.\n   >>> getCategory() TypeCategory::TypeStruct { *\/",
        "query_nlx":"\/* Function getCategory returns the category of a type as TypeStruct.\n   >>> getCategory() TypeCategory::TypeStruct *\/ \nTypeCategory getCategory() {"
    }

    {
        "file_name":"Reflection_function_2.cpp",
        "line_count":7,
        "code":"bool setLinkIndex(ssize_t newLinkIndex)\n    {\n        if (newLinkIndex > static_cast<decltype(linkIndex)>(MaxValue()))\n            return false;\n        linkIndex = static_cast<decltype(linkIndex)>(newLinkIndex);\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set a new index for a link, ensuring it does not exceed the maximum value allowed. \n    >>> bool setLinkIndex(ssize_t newLinkIndex) { *\/",
        "query_nlx":"\/* Function named setLinkIndex takes a new link index as input and updates the link index if the new index is less than or equal to the maximum allowed value. \n>>> setLinkIndex(5) true \n>>> setLinkIndex(10) false *\/ \nbool setLinkIndex(ssize_t newLinkIndex) { "
    }

    {
        "file_name":"Reflection_function_3.cpp",
        "line_count":4,
        "code":"bool isPrimitiveCategory(TypeCategory category)\n    {\n        return category >= TypeCategory::TypeBOOL and category <= TypeCategory::TypeDOUBLE64;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the input belongs to a primitive data type category.\n>>> bool isPrimitiveCategory(TypeCategory category); *\/",
        "query_nlx":"\/* Function named isPrimitiveCategory checks if a given type category is within the range of TypeBOOL and TypeDOUBLE64.\n>>> isPrimitiveCategory(TypeCategory category) true\n>>> isPrimitiveCategory(TypeCategory::TypeSTRING) false *\/"
    }

    {
        "file_name":"Reflection_function_4.cpp",
        "line_count":4,
        "code":"bool build(TypeVisitor&)\n    {\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a type can be built using a visitor.\n>>> build(TypeVisitor&) true *\/",
        "query_nlx":"\/* Function named build takes a TypeVisitor object as input and returns a boolean value indicating success.\n   >>> build(TypeVisitor&) true *\/"
    }

    {
        "file_name":"Reflection_function_7.cpp",
        "line_count":1,
        "code":"auto getCategory(){return TypeCategory::TypeUINT16;}",
        "mark":8.0,
        "query_nsx":"\/* Determine the category of a type as an unsigned 16-bit integer value.\n   >>> auto getCategory() { *\/\n   \/\/ TypeCategory::TypeUINT16;",
        "query_nlx":"\/* Function getCategory returns the category of a data type, specifically returning the category for an unsigned 16-bit integer type.\n>>> getCategory() TypeCategory::TypeUINT16 *\/ \nauto getCategory(){return TypeCategory::TypeUINT16;}"
    }

    {
        "file_name":"Reflection_function_8.cpp",
        "line_count":1,
        "code":"auto getCategory(){return TypeCategory::TypeUINT32;}",
        "mark":8.0,
        "query_nsx":"\/* Determine the category type as an unsigned 32-bit integer.\n   >>> auto getCategory(){return TypeCategory::TypeUINT32;} *\/",
        "query_nlx":"\/* Function getCategory returns the category of a data type, specifically returning TypeUINT32.\n   >>> getCategory() TypeUINT32 *\/ \nauto getCategory(){return TypeCategory::TypeUINT32;}"
    }

    {
        "file_name":"Reflection_function_9.cpp",
        "line_count":1,
        "code":"auto getCategory(){return TypeCategory::TypeUINT64;}",
        "mark":8.0,
        "query_nsx":"\/* Determine the category type as an unsigned 64-bit integer.\n   >>> auto getCategory(){return TypeCategory::TypeUINT64;} *\/",
        "query_nlx":"\/* Function getCategory returns the category of a type, specifically returning TypeUINT64.\n   >>> getCategory() TypeUINT64 *\/ \nauto getCategory(){return TypeCategory::TypeUINT64;}"
    }

    {
        "file_name":"Renderer_function_1.cpp",
        "line_count":9,
        "code":"void renderLoop(Renderer* renderer, SwapChain* swapChain) {\n     *     do {\n     *         \/\/ typically we wait for VSYNC and user input events\n     *         if (renderer->beginFrame(swapChain)) {\n     *             renderer->render(mView);\n     *             renderer->endFrame();\n     *         }\n     *     } while (!quit());\n     * }",
        "mark":8.0,
        "query_nsx":"        \/* Implement a rendering loop that continuously renders frames until a quit condition is met.\n         * The loop waits for synchronization signals and user input events before rendering each frame.\n         * The loop utilizes a renderer to begin, render, and end frames using a given swap chain.\n         *\/ \n        void renderLoop(Renderer* renderer, SwapChain* swapChain) {",
        "query_nlx":"        \/* Define a function called renderLoop that continuously renders frames using a given renderer and swap chain until a quit condition is met.\n        >>> renderLoop(Renderer* renderer, SwapChain* swapChain) *\/"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_10.cpp",
        "line_count":3,
        "code":"void setIntensity(float intensity) {\n    this->intensity = intensity;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the intensity value for a certain operation.\n   >>> void setIntensity(float intensity); *\/",
        "query_nlx":"\/* Define a function that sets the intensity value to a given float value.\n   >>> setIntensity(0.5) \n   >>> setIntensity(1.0) *\/ \nvoid setIntensity(float intensity) {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_12.cpp",
        "line_count":3,
        "code":"void setBilateralThreshold(float bilateralThreshold) {\n    this->bilateralThreshold = bilateralThreshold;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the bilateral threshold value for a certain operation.\n   >>> void setBilateralThreshold(float bilateralThreshold) { *\/",
        "query_nlx":"\/* Define a function that sets the bilateral threshold value to the provided input value.\n   >>> setBilateralThreshold(0.5) *\/ \nvoid setBilateralThreshold(float bilateralThreshold) {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_19.cpp",
        "line_count":3,
        "code":"bool getEnabled() {\n    return enabled;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the feature is currently enabled or disabled.\n    >>> getEnabled() *\/",
        "query_nlx":"\/* Function named getEnabled returns a boolean value indicating whether a certain feature is enabled or not.\n   >>> getEnabled() true\n   >>> getEnabled() false *\/ \nbool getEnabled() {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_2.cpp",
        "line_count":3,
        "code":"void setRadius(float radius) {\n    this->radius = radius;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the radius value for a geometric shape.\n   >>> void setRadius(float radius); *\/",
        "query_nlx":"\/* Define a function that sets the radius of a shape to a given value.\n   >>> setRadius(float radius) *\/"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_20.cpp",
        "line_count":3,
        "code":"void setEnabled(bool enabled) {\n    this->enabled = enabled;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the enabled status to the given value.\n   >>> setEnabled(bool enabled) *\/",
        "query_nlx":"\/* Define a function that sets a boolean variable to a given value.\n   >>> setEnabled(true) \n   >>> setEnabled(false) *\/\nvoid setEnabled(bool enabled) {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_21.cpp",
        "line_count":3,
        "code":"bool getBentNormals() {\n    return bentNormals;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if bent normals are enabled or disabled.\n   >>> getBentNormals() \n   bool getBentNormals() { *\/",
        "query_nlx":"\/* Function named getBentNormals returns a boolean value indicating whether bent normals are enabled or not.\n   >>> getBentNormals() true\n   >>> getBentNormals() false *\/ \nbool getBentNormals() {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_22.cpp",
        "line_count":3,
        "code":"void setBentNormals(bool bentNormals) {\n    this->bentNormals = bentNormals;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set whether bent normals should be used in the rendering process.\n   >>> setBentNormals(true) \n   >>> setBentNormals(false) *\/ \nvoid setBentNormals(bool bentNormals) {",
        "query_nlx":"\/* Function named setBentNormals sets a boolean value to determine whether bent normals should be used or not.\n>>> setBentNormals(true) \n>>> setBentNormals(false) *\/ \nvoid setBentNormals(bool bentNormals) {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_23.cpp",
        "line_count":3,
        "code":"float getMinHorizonAngleRad() {\n    return minHorizonAngleRad;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the minimum angle in radians for the horizon.\n   >>> getMinHorizonAngleRad() float { *\/",
        "query_nlx":"\/* Retrieve the minimum horizon angle in radians.\n   >>> getMinHorizonAngleRad()  *\/ \nfloat getMinHorizonAngleRad() {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_24.cpp",
        "line_count":3,
        "code":"void setMinHorizonAngleRad(float minHorizonAngleRad) {\n    this->minHorizonAngleRad = minHorizonAngleRad;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the minimum angle of the horizon in radians.\n   >>> setMinHorizonAngleRad(float minHorizonAngleRad) *\/",
        "query_nlx":"\/* Define a function that sets the minimum angle of the horizon in radians.\n   >>> setMinHorizonAngleRad(0.5) *\/ \nvoid setMinHorizonAngleRad(float minHorizonAngleRad) {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_4.cpp",
        "line_count":3,
        "code":"void setPower(float power) {\n    this->power = power;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the power value to the given input value. \n>>> void setPower(float power) { *\/",
        "query_nlx":"\/* Define a function that sets the power value to a given input float value.\n   >>> setPower(5.0) *\/ \nvoid setPower(float power) {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_6.cpp",
        "line_count":3,
        "code":"void setBias(float bias) {\n    this->bias = bias;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the bias value for a certain operation.\n   >>> void setBias(float bias) { *\/",
        "query_nlx":"\/* Define a function that sets a bias value for a certain operation. The function should take a single parameter representing the bias value to be set.\n>>> setBias(0.5) *\/ \nvoid setBias(float bias) {"
    }

    {
        "file_name":"RNFAmbientOcclusionOptionsWrapper_function_8.cpp",
        "line_count":3,
        "code":"void setResolution(float resolution) {\n    this->resolution = resolution;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the resolution value for a certain operation. \n>>> void setResolution(float resolution) { *\/",
        "query_nlx":"\/* Define a function that sets the resolution value to a given floating-point number.\n>>> setResolution(0.01) *\/ \nvoid setResolution(float resolution) {"
    }

    {
        "file_name":"RNFAnimatorWrapper_function_1.cpp",
        "line_count":7,
        "code":"void assertAnimationIndexSmallerThan(int animationIndex, int max) {\n  if (animationIndex >= max || animationIndex < 0) {\n    [[unlikely]];\n    throw std::invalid_argument(\"Animation index out of range! Expected <\" + std::to_string(max) + \", received \" +\n                                std::to_string(animationIndex));\n  }\n}",
        "mark":8.0,
        "query_nsx":"\/* Ensure that the animation index is within the valid range of indices.\n>>> assertAnimationIndexSmallerThan(3, 5) \n>>> assertAnimationIndexSmallerThan(-1, 4) *\/ \nvoid assertAnimationIndexSmallerThan(int animationIndex, int max) {",
        "query_nlx":"\/* Function named assertAnimationIndexSmallerThan checks if the given animation index is within the valid range of 0 to a specified maximum value (exclusive).\n>>> assertAnimationIndexSmallerThan(3, 5) No exception thrown\n>>> assertAnimationIndexSmallerThan(6, 5) Exception thrown with message \"Animation index out of range! Expected <5, received 6\" *\/ \nvoid assertAnimationIndexSmallerThan(int animationIndex, int max) {"
    }

    {
        "file_name":"RNFAnimatorWrapper_function_2.cpp",
        "line_count":7,
        "code":"void assertAnimatorNotNull(Animator* animator) {\n  if (animator == nullptr) {\n    [[unlikely]];\n    throw std::runtime_error(\"Failed to call animator method, as the internal animator was null. You probably tried to access the animator \"\n                             \"after calling .release()\");\n  }\n}",
        "mark":8.0,
        "query_nsx":"\/* Ensure that the provided animator object is not null before calling any methods on it.\n>>> assertAnimatorNotNull(Animator* animator) *\/",
        "query_nlx":"\/* Function named assertAnimatorNotNull checks if the provided animator pointer is not null before proceeding with any operations. If the animator pointer is null, it throws a runtime error indicating that an attempt was made to access the animator after releasing it.\n>>> assertAnimatorNotNull(Animator* animator) *\/"
    }

    {
        "file_name":"RNFAnimatorWrapper_function_3.cpp",
        "line_count":7,
        "code":"void assertInstanceNotNull(FilamentInstance* instance) {\n  if (instance == nullptr) {\n    [[unlikely]];\n    throw std::runtime_error(\"Failed to call animator method, as the internal instance was null. You probably tried to access the animator \"\n                             \"after calling .release()\");\n  }\n}",
        "mark":8.0,
        "query_nsx":"\/* Ensure that the provided instance is not null before proceeding with the animator method call. \n>>> assertInstanceNotNull(FilamentInstance* instance) *\/",
        "query_nlx":"\/* Function named assertInstanceNotNull checks if the provided instance is not null and throws a runtime error with a specific message if it is. \n>>> assertInstanceNotNull(instance) \n*\/ \nvoid assertInstanceNotNull(FilamentInstance* instance) {"
    }

    {
        "file_name":"RNFCameraFovEnum_function_1.cpp",
        "line_count":8,
        "code":"void convertJSUnionToEnum(const std::string& inUnion, Camera::Fov* outEnum) {\n    if (inUnion == \"horizontal\")\n      *outEnum = Camera::Fov::HORIZONTAL;\n    else if (inUnion == \"vertical\")\n      *outEnum = Camera::Fov::VERTICAL;\n    else\n      throw invalidUnion(inUnion);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a string representation of a camera field of view (FOV) type to an enum value.\n   >>> void convertJSUnionToEnum(const std::string& inUnion, Camera::Fov* outEnum) { *\/",
        "query_nlx":"\/* Function named convertJSUnionToEnum converts a given string representing a union type to an enumeration type for Camera field of view.\n>>> convertJSUnionToEnum(\"horizontal\", &outEnum) sets outEnum to Camera::Fov::HORIZONTAL\n>>> convertJSUnionToEnum(\"vertical\", &outEnum) sets outEnum to Camera::Fov::VERTICAL\n>>> convertJSUnionToEnum(\"unknown\", &outEnum) throws an invalidUnion exception *\/ \nvoid convertJSUnionToEnum(const std::string& inUnion, Camera::Fov* outEnum) { "
    }

    {
        "file_name":"RNFConverter_function_1.cpp",
        "line_count":7,
        "code":"float3 VecToFloat3(std::vector<double> vec) {\n    if (vec.size() != 3) {\n      throw std::invalid_argument(\"Point must have 3 elements\");\n    }\n\n    return math::float3(vec[0], vec[1], vec[2]);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a vector of three double values into a float3 structure.\n   >>> float3 VecToFloat3(std::vector<double> vec); *\/",
        "query_nlx":"\/* Function named VecToFloat3 converts a vector of three double values into a float3 structure. \n>>> VecToFloat3({1.0, 2.0, 3.0}) returns a float3 structure with x=1.0, y=2.0, z=3.0 \n>>> VecToFloat3({4.5, 6.7}) throws an invalid_argument exception as the input vector must have exactly 3 elements *\/ \nfloat3 VecToFloat3(std::vector<double> vec) {"
    }

    {
        "file_name":"RNFCullingModeEnum_function_2.cpp",
        "line_count":18,
        "code":"void convertEnumToJSUnion(backend::CullingMode inEnum, std::string* outUnion) {\n    switch (inEnum) {\n      case backend::CullingMode::NONE:\n        *outUnion = \"none\";\n        break;\n      case backend::CullingMode::BACK:\n        *outUnion = \"back\";\n        break;\n      case backend::CullingMode::FRONT:\n        *outUnion = \"front\";\n        break;\n      case backend::CullingMode::FRONT_AND_BACK:\n        *outUnion = \"frontAndBack\";\n        break;\n      default:\n        throw invalidEnum(inEnum);\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert an enumeration value representing culling mode to a corresponding JavaScript union string. \n>>> void convertEnumToJSUnion(backend::CullingMode inEnum, std::string* outUnion) { *\/",
        "query_nlx":"\/* Function named convertEnumToJSUnion converts an input enum value representing a culling mode to a corresponding string representation in JavaScript union format.\n>>> convertEnumToJSUnion(CullingMode::NONE, &outputString) sets outputString to \"none\"\n>>> convertEnumToJSUnion(CullingMode::BACK, &outputString) sets outputString to \"back\"\n>>> convertEnumToJSUnion(CullingMode::FRONT, &outputString) sets outputString to \"front\"\n>>> convertEnumToJSUnion(CullingMode::FRONT_AND_BACK, &outputString) sets outputString to \"frontAndBack\" *\/ \nvoid convertEnumToJSUnion(backend::CullingMode inEnum, std::string* outUnion) { "
    }

    {
        "file_name":"RNFDynamicResolutionOptions_function_1.cpp",
        "line_count":14,
        "code":"void loadHybridMethods() {\n    registerHybridGetter(\"minScale\", &DynamicResolutionOptionsWrapper::getMinScale, this);\n    registerHybridSetter(\"minScale\", &DynamicResolutionOptionsWrapper::setMinScale, this);\n    registerHybridGetter(\"maxScale\", &DynamicResolutionOptionsWrapper::getMaxScale, this);\n    registerHybridSetter(\"maxScale\", &DynamicResolutionOptionsWrapper::setMaxScale, this);\n    registerHybridGetter(\"sharpness\", &DynamicResolutionOptionsWrapper::getSharpness, this);\n    registerHybridSetter(\"sharpness\", &DynamicResolutionOptionsWrapper::setSharpness, this);\n    registerHybridGetter(\"enabled\", &DynamicResolutionOptionsWrapper::getEnabled, this);\n    registerHybridSetter(\"enabled\", &DynamicResolutionOptionsWrapper::setEnabled, this);\n    registerHybridGetter(\"homogeneousScaling\", &DynamicResolutionOptionsWrapper::getHomogeneousScaling, this);\n    registerHybridSetter(\"homogeneousScaling\", &DynamicResolutionOptionsWrapper::setHomogeneousScaling, this);\n    registerHybridGetter(\"quality\", &DynamicResolutionOptionsWrapper::getQuality, this);\n    registerHybridSetter(\"quality\", &DynamicResolutionOptionsWrapper::setQuality, this);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Register hybrid getter and setter methods for various dynamic resolution options.\n   >>> loadHybridMethods() *\/ \nvoid loadHybridMethods() { ",
        "query_nlx":"        \/* Load hybrid methods for accessing and setting various properties of dynamic resolution options using getter and setter functions.\n        >>> loadHybridMethods() *\/ \n        void loadHybridMethods() {"
    }

    {
        "file_name":"RNFDynamicResolutionOptions_function_2.cpp",
        "line_count":5,
        "code":"void setMinScale(const std::vector<float>& scale) {\n    if (scale.size() != 2)\n      throw std::invalid_argument(\"Expected exactly two values for scale.\");\n    minScale = {scale[0], scale[1]};\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the minimum scale values based on the input vector of two values.\n   >>> setMinScale(const std::vector<float>& scale) *\/",
        "query_nlx":"\/* Define a function that sets the minimum scale values based on a provided vector of floats. \n   The function should throw an exception if the input vector does not contain exactly two values. \n   The minimum scale values should be updated to the first two values in the input vector. \n   >>> setMinScale({0.5, 0.7}) \n   >>> setMinScale({1.0, 2.0, 3.0}) *\/ \nvoid setMinScale(const std::vector<float>& scale) {"
    }

    {
        "file_name":"RNFDynamicResolutionOptions_function_3.cpp",
        "line_count":5,
        "code":"void setMaxScale(const std::vector<float>& scale) {\n    if (scale.size() != 2)\n      throw std::invalid_argument(\"Expected exactly two values for scale.\");\n    maxScale = {scale[0], scale[1]};\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the maximum scale values based on the input vector of two values.\n   >>> setMaxScale({1.5, 2.0}) *\/ \nvoid setMaxScale(const std::vector<float>& scale) { ",
        "query_nlx":"\/* Define a function that sets the maximum scale values based on a provided vector of floats. \n   The function should throw an exception if the input vector does not contain exactly two values. \n   The function signature should be: void setMaxScale(const std::vector<float>& scale) { *\/"
    }

    {
        "file_name":"RNFDynamicResolutionOptions_function_5.cpp",
        "line_count":3,
        "code":"void setSharpness(float sharpnessValue) {\n    sharpness = sharpnessValue;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the sharpness value to the given input value. \n>>> void setSharpness(float sharpnessValue) { *\/",
        "query_nlx":"\/* Define a function that sets the sharpness value to a given input value.\n   >>> setSharpness(0.5) \n   >>> setSharpness(1.2) *\/ \nvoid setSharpness(float sharpnessValue) {"
    }

    {
        "file_name":"RNFDynamicResolutionOptions_function_6.cpp",
        "line_count":3,
        "code":"bool getEnabled() {\n    return enabled;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the feature is currently enabled or disabled.\n>>> getEnabled() *\/",
        "query_nlx":"\/* Function named getEnabled returns a boolean value indicating whether a certain feature or setting is currently enabled or not. \n>>> getEnabled() true \n>>> getEnabled() false *\/ \nbool getEnabled() {"
    }

    {
        "file_name":"RNFDynamicResolutionOptions_function_7.cpp",
        "line_count":3,
        "code":"void setEnabled(bool enable) {\n    enabled = enable;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the enabled status to the given value.\n   >>> setEnabled(true) \n   >>> setEnabled(false) *\/ \nvoid setEnabled(bool enable) {",
        "query_nlx":"\/* Define a function that sets a boolean variable to a given value.\n   >>> setEnabled(true) \n   >>> setEnabled(false) *\/\nvoid setEnabled(bool enable) {"
    }

    {
        "file_name":"RNFDynamicResolutionOptions_function_8.cpp",
        "line_count":3,
        "code":"bool getHomogeneousScaling() {\n    return homogeneousScaling;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if homogeneous scaling is enabled or not.\n>>> getHomogeneousScaling() true\n>>> getHomogeneousScaling() false *\/ \nbool getHomogeneousScaling() {",
        "query_nlx":"\/* Function named getHomogeneousScaling returns a boolean value indicating whether homogeneous scaling is enabled or not.\n   >>> getHomogeneousScaling() true\n   >>> getHomogeneousScaling() false *\/ \nbool getHomogeneousScaling() {"
    }

    {
        "file_name":"RNFDynamicResolutionOptions_function_9.cpp",
        "line_count":3,
        "code":"void setHomogeneousScaling(bool homogeneous) {\n    homogeneousScaling = homogeneous;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to enable or disable homogeneous scaling.\n   >>> void setHomogeneousScaling(bool homogeneous); *\/",
        "query_nlx":"\/* Function named setHomogeneousScaling sets a boolean variable to indicate whether homogeneous scaling should be applied or not.\n   >>> setHomogeneousScaling(true) \n   >>> setHomogeneousScaling(false) *\/ \nvoid setHomogeneousScaling(bool homogeneous) {"
    }

    {
        "file_name":"RNFEngineBackendEnum_function_1.cpp",
        "line_count":12,
        "code":"void convertJSUnionToEnum(const std::string& inUnion, Engine::Backend* outEnum) {\n    if (inUnion == \"default\")\n      *outEnum = Engine::Backend::DEFAULT;\n    else if (inUnion == \"metal\")\n      *outEnum = Engine::Backend::METAL;\n    else if (inUnion == \"opengl\")\n      *outEnum = Engine::Backend::OPENGL;\n    else if (inUnion == \"vulkan\")\n      *outEnum = Engine::Backend::VULKAN;\n    else\n      throw invalidUnion(inUnion);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a string representation of a graphics backend to an enum representation.\n   >>> convertJSUnionToEnum(\"metal\", &backend) \n   >>> convertJSUnionToEnum(\"opengl\", &backend) \n   >>> convertJSUnionToEnum(\"vulkan\", &backend *\/ \nvoid convertJSUnionToEnum(const std::string& inUnion, Engine::Backend* outEnum) { ",
        "query_nlx":"\/* Function named convertJSUnionToEnum converts a given string representing a union to an enum value of a specified backend engine.\n>>> convertJSUnionToEnum(\"default\", &outEnum) sets outEnum to the DEFAULT backend enum value.\n>>> convertJSUnionToEnum(\"metal\", &outEnum) sets outEnum to the METAL backend enum value.\n>>> convertJSUnionToEnum(\"opengl\", &outEnum) sets outEnum to the OPENGL backend enum value.\n>>> convertJSUnionToEnum(\"vulkan\", &outEnum) sets outEnum to the VULKAN backend enum value.\n>>> convertJSUnionToEnum(\"invalid\", &outEnum) throws an invalidUnion exception. *\/ \nvoid convertJSUnionToEnum(const std::string& inUnion, Engine::Backend* outEnum) { *\/"
    }

    {
        "file_name":"RNFEngineBackendEnum_function_2.cpp",
        "line_count":18,
        "code":"void convertEnumToJSUnion(Engine::Backend inEnum, std::string* outUnion) {\n    switch (inEnum) {\n      case Engine::Backend::DEFAULT:\n        *outUnion = \"default\";\n        break;\n      case Engine::Backend::METAL:\n        *outUnion = \"metal\";\n        break;\n      case Engine::Backend::OPENGL:\n        *outUnion = \"opengl\";\n        break;\n      case Engine::Backend::VULKAN:\n        *outUnion = \"vulkan\";\n        break;\n      default:\n        throw invalidEnum(inEnum);\n    }\n  }",
        "mark":8.0,
        "query_nsx":"            \/* Convert an enum value to a corresponding string representation. \n            >>> convertEnumToJSUnion(Engine::Backend inEnum, std::string* outUnion) *\/",
        "query_nlx":"\/* Function named convertEnumToJSUnion converts an input enum value representing a backend engine into a corresponding string representation. The function takes an enum value and a pointer to a string where the converted string representation will be stored. \n>>> convertEnumToJSUnion(Engine::Backend::DEFAULT, &outUnion) outUnion = \"default\"\n>>> convertEnumToJSUnion(Engine::Backend::METAL, &outUnion) outUnion = \"metal\"\n>>> convertEnumToJSUnion(Engine::Backend::OPENGL, &outUnion) outUnion = \"opengl\"\n>>> convertEnumToJSUnion(Engine::Backend::VULKAN, &outUnion) outUnion = \"vulkan\"\n*\/ \nvoid convertEnumToJSUnion(Engine::Backend inEnum, std::string* outUnion) { "
    }

    {
        "file_name":"RNFFilamentAssetWrapper_function_1.cpp",
        "line_count":3,
        "code":"int getEntityCount() {\n    return pointee()->getEntityCount();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the total count of entities from the underlying data structure.\n   >>> getEntityCount() int *\/",
        "query_nlx":"\/* Function getEntityCount returns the count of entities obtained by calling the getEntityCount method on the object pointed to by the current object. \n>>> getEntityCount() int *\/ \nint getEntityCount() { "
    }

    {
        "file_name":"RNFFilamentAssetWrapper_function_2.cpp",
        "line_count":3,
        "code":"int getRenderableEntityCount() {\n    return pointee()->getRenderableEntityCount();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the count of renderable entities from the current object.\n   >>> getRenderableEntityCount() *\/",
        "query_nlx":"\/* Function named getRenderableEntityCount returns the number of renderable entities accessible through the current object's pointer. \n>>> getRenderableEntityCount() *\/ \nint getRenderableEntityCount() {"
    }

    {
        "file_name":"RNFFilamentRecorder_function_1.cpp",
        "line_count":3,
        "code":"int getWidth() {\n    return _width;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the width value stored in the system.\n   >>> getWidth() *\/ \nint getWidth() {",
        "query_nlx":"\/* Function named getWidth returns the width value stored in the object.\n   >>> getWidth()  *\/ \nint getWidth() {"
    }

    {
        "file_name":"RNFFilamentRecorder_function_2.cpp",
        "line_count":3,
        "code":"int getHeight() {\n    return _height;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the height value stored in the system. \n>>> int getHeight() { *\/",
        "query_nlx":"\/* Define a function that retrieves the height value stored in a variable.\n   >>> getHeight() returns the height value stored in the variable *\/ \nint getHeight() {"
    }

    {
        "file_name":"RNFFilamentRecorder_function_3.cpp",
        "line_count":3,
        "code":"int getFps() {\n    return _fps;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the frames per second (fps) value.\n   >>> getFps() int { *\/",
        "query_nlx":"\/* Function named getFps retrieves the frames per second value stored in a variable and returns it. \n>>> getFps()  *\/ \nint getFps() {"
    }

    {
        "file_name":"RNFHybridObject_function_2.cpp",
        "line_count":5,
        "code":"if constexpr (std::is_same_v<ReturnType, jsi::Value>) {\n        \/\/ If the return type is a jsi::Value, we assume the user wants full JSI code control.\n        \/\/ The signature must be identical to jsi::HostFunction (jsi::Runtime&, jsi::Value& this, ...)\n        return (derivedInstance->*method)(runtime, thisVal, args, count);\n      }",
        "mark":8.0,
        "query_nsx":"        \/* Check if the return type is a jsi::Value to provide full JSI code control.\n        >>> If the return type is jsi::Value, assume the user wants complete JSI code control. *\/ \n        if constexpr (std::is_same_v<ReturnType, jsi::Value>) { ",
        "query_nlx":"\/* If the return type is a jsi::Value, assume the user wants full JSI code control. The function must have the same signature as jsi::HostFunction (jsi::Runtime&, jsi::Value& this, ...).\n>>> if constexpr (std::is_same_v<ReturnType, jsi::Value>) { *\/"
    }

    {
        "file_name":"RNFJSIConverter_function_10.cpp",
        "line_count":3,
        "code":"Value toJSI(jsi::Runtime& runtime, int64_t arg) {\n    return jsi::BigInt::fromInt64(runtime, arg);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given integer value to a big integer value using the provided runtime environment.\n   >>> Value toJSI(jsi::Runtime& runtime, int64_t arg) { *\/",
        "query_nlx":"\/* Function to convert a given integer argument to a BigInt value using the provided runtime.\n   >>> toJSI(runtime, 123) returns a BigInt value representing the integer 123\n   >>> toJSI(runtime, -456) returns a BigInt value representing the integer -456 *\/ \nValue toJSI(jsi::Runtime& runtime, int64_t arg) {"
    }

    {
        "file_name":"RNFJSIConverter_function_12.cpp",
        "line_count":3,
        "code":"Value toJSI(jsi::Runtime& runtime, uint64_t arg) {\n    return jsi::BigInt::fromUint64(runtime, arg);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given unsigned integer value to a big integer value using the provided runtime environment.\n   >>> Value toJSI(jsi::Runtime& runtime, uint64_t arg) { *\/",
        "query_nlx":"\/* Function named toJSI converts a given unsigned 64-bit integer value to a BigInt using the provided runtime.\n   >>> toJSI(runtime, 123456789) returns a BigInt representation of the value 123456789\n   >>> toJSI(runtime, 0) returns a BigInt representation of the value 0 *\/ \nValue toJSI(jsi::Runtime& runtime, uint64_t arg) { *\/"
    }

    {
        "file_name":"RNFJSIConverter_function_13.cpp",
        "line_count":3,
        "code":"bool fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return arg.asBool();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Extract a boolean value from a runtime and a given value.\n   >>> fromJSI(runtime, value) \n*\/ \nbool fromJSI(Runtime&, const Value&);",
        "query_nlx":"\/* Function named fromJSI takes a runtime and a value as input and returns a boolean value extracted from the input value.\n   >>> fromJSI(runtime, value) \n*\/ \nbool fromJSI(jsi::Runtime&, const jsi::Value& arg) {"
    }

    {
        "file_name":"RNFJSIConverter_function_15.cpp",
        "line_count":3,
        "code":"string fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {\n    return arg.asString(runtime).utf8(runtime);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Extracts a UTF-8 string representation from a given runtime value.\n   >>> string fromJSI(Runtime& runtime, const Value& arg) { *\/",
        "query_nlx":"\/* Function named fromJSI takes a runtime object and a value as input and returns a string representation of the value in UTF-8 format.\n   >>> fromJSI(runtime, value) \"string\" *\/"
    }

    {
        "file_name":"RNFJSIConverter_function_16.cpp",
        "line_count":3,
        "code":"Value toJSI(jsi::Runtime& runtime, const std::string& arg) {\n    return jsi::String::createFromUtf8(runtime, arg);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given string to a JSI string value.\n   >>> Value toJSI(jsi::Runtime& runtime, const std::string& arg) { *\/",
        "query_nlx":"\/* Function to convert a given string to a jsi::String object using the provided jsi::Runtime object.\n   >>> toJSI(jsi::Runtime& runtime, const std::string& arg) \n*\/"
    }

    {
        "file_name":"RNFJSIConverter_function_17.cpp",
        "line_count":7,
        "code":"Value toJSI(jsi::Runtime& runtime, const std::optional<TInner>& arg) {\n    if (arg == std::nullopt) {\n      return jsi::Value::undefined();\n    } else {\n      return JSIConverter<TInner>::toJSI(runtime, arg.value());\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert an optional value to a JSI value using a runtime environment.\n   >>> Value toJSI(jsi::Runtime& runtime, const std::optional<TInner>& arg) { *\/",
        "query_nlx":"        \/* Function to convert an optional value to a JSI value using a given runtime.\n        >>> toJSI(runtime, arg) converts the optional value arg to a JSI value using the provided runtime.\n        >>> If arg is empty, it returns an undefined JSI value.\n        >>> If arg has a value, it converts that value to a JSI value using JSIConverter.\n        *\/ \n        Value toJSI(jsi::Runtime& runtime, const std::optional<TInner>& arg) {"
    }

    {
        "file_name":"RNFJSIConverter_function_21.cpp",
        "line_count":5,
        "code":"if constexpr (std::is_same_v<TResult, void>) {\n              \/\/ it's returning void, just return undefined to JS\n              sharedFuture->get();\n              promise->resolve(jsi::Value::undefined());\n            }",
        "mark":8.0,
        "query_nsx":"\/* If the result type is void, the function returns undefined to JavaScript.\n   >>> function_name(parameters) *\/ \nif constexpr (std::is_same_v<TResult, void>) {",
        "query_nlx":"\/* If the result type is void, the function should wait for a shared future, then resolve a promise with an undefined value.\n   >>> if constexpr (std::is_same_v<TResult, void>) { sharedFuture->get(); promise->resolve(jsi::Value::undefined()); *\/"
    }

    {
        "file_name":"RNFJSIConverter_function_22.cpp",
        "line_count":4,
        "code":"if constexpr (std::is_same_v<ReturnType, void>) {\n        \/\/ it is a void function (returns undefined)\n        return;\n      }",
        "mark":8.0,
        "query_nsx":"\/* Check if the function returns void or not.\n   >>> is_void_function() *\/ \nif constexpr (std::is_same_v<ReturnType, void>) {",
        "query_nlx":"\/* Check if the return type is void, and if so, return without any further processing.\n   >>> if the return type is void, return without any further processing *\/\nif constexpr (std::is_same_v<ReturnType, void>) {"
    }

    {
        "file_name":"RNFJSIConverter_function_25.cpp",
        "line_count":9,
        "code":"Value toJSI(jsi::Runtime& runtime, const std::unordered_map<std::string, ValueType>& map) {\n    jsi::Object object(runtime);\n    for (const auto& pair : map) {\n      jsi::Value value = JSIConverter<ValueType>::toJSI(runtime, pair.second);\n      jsi::String key = jsi::String::createFromUtf8(runtime, pair.first);\n      object.setProperty(runtime, key, std::move(value));\n    }\n    return object;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given map of key-value pairs to a JavaScript object.\n   >>> Value toJSI(jsi::Runtime& runtime, const std::unordered_map<std::string, ValueType>& map) { *\/",
        "query_nlx":"        \/* Function named toJSI converts a given map of string-value pairs into a jsi object in the runtime environment. \n        >>> toJSI({ \"key1\": 10, \"key2\": true, \"key3\": \"value\" }) \n        *\/ \n        Value toJSI(Runtime& runtime, const unordered_map<string, ValueType>& map) {"
    }

    {
        "file_name":"RNFJSIConverter_function_27.cpp",
        "line_count":3,
        "code":"string invalidTypeErrorMessage(const std::string& typeDescription, const std::string& reason) {\n    return \"Cannot convert \\\"\" + typeDescription + \"\\\" to HostObject<\" + getFriendlyTypename() + \">! \" + reason;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Generate an error message indicating the inability to convert a specific type to a HostObject type with a given reason.\n   >>> string invalidTypeErrorMessage(const string& typeDescription, const string& reason) { *\/",
        "query_nlx":"\/* Create a function that generates an error message stating that a conversion from a given type description to a HostObject with a friendly typename is not possible, providing a reason for the failure.\n>>> invalidTypeErrorMessage(const string& typeDescription, const string& reason) \n*\/"
    }

    {
        "file_name":"RNFJSIConverter_function_3.cpp",
        "line_count":3,
        "code":"int fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return static_cast<int>(arg.asNumber());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given value to an integer type.\n   >>> int fromJSI(Runtime&, const Value& arg) { *\/",
        "query_nlx":"\/* Define a function that converts a given value to an integer.\n   >>> fromJSI(Runtime&, Value&) returns an integer value based on the input value provided. *\/ \nint fromJSI(jsi::Runtime&, const jsi::Value& arg) {"
    }

    {
        "file_name":"RNFJSIConverter_function_32.cpp",
        "line_count":3,
        "code":"string invalidTypeErrorMessage(const std::string& typeDescription, const std::string& reason) {\n    return \"Cannot convert \\\"\" + typeDescription + \"\\\" to NativeState<\" + getFriendlyTypename() + \">! \" + reason;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Create an error message indicating the inability to convert a specific type to a certain state, including the reason for the failure.\n>>> string invalidTypeErrorMessage(const string& typeDescription, const string& reason) { *\/",
        "query_nlx":"\/* Create a function that generates an error message for when a conversion from a given type description to a specific NativeState type is not possible.\n   The function takes two parameters: typeDescription (a string describing the type) and reason (a string explaining the reason for the conversion failure). \n   It should return an error message in the format: \"Cannot convert 'typeDescription' to NativeState<friendlyTypename>! reason\" *\/\nstring invalidTypeErrorMessage(const std::string& typeDescription, const std::string& reason) { *\/"
    }

    {
        "file_name":"RNFJSIConverter_function_5.cpp",
        "line_count":3,
        "code":"double fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return arg.asNumber();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given value to a double data type.\n>>> double fromJSI(Runtime&, const Value& arg); *\/",
        "query_nlx":"        \/* Function named fromJSI converts a given value to a double data type.\n        >>> fromJSI(Runtime&, Value&) returns a double value *\/ \n        double fromJSI(jsi::Runtime&, const jsi::Value& arg) {"
    }

    {
        "file_name":"RNFJSIConverter_function_7.cpp",
        "line_count":3,
        "code":"float fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return static_cast<float>(arg.asNumber());\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given value to a floating-point number.\n>>> float fromJSI(Runtime&, const Value& arg); *\/",
        "query_nlx":"        \/* Function named fromJSI converts a given value to a floating-point number.\n        >>> fromJSI(Runtime, Value) returns the input value as a float *\/ \n        float fromJSI(Runtime&, const Value& arg) {"
    }

    {
        "file_name":"RNFLightEnum_function_1.cpp",
        "line_count":14,
        "code":"void convertJSUnionToEnum(const std::string& inUnion, LightManager::Type* outEnum) {\n    if (inUnion == \"directional\")\n      *outEnum = LightManager::Type::DIRECTIONAL;\n    else if (inUnion == \"spot\")\n      *outEnum = LightManager::Type::SPOT;\n    else if (inUnion == \"point\")\n      *outEnum = LightManager::Type::POINT;\n    else if (inUnion == \"focused_sport\")\n      *outEnum = LightManager::Type::FOCUSED_SPOT;\n    else if (inUnion == \"sun\")\n      *outEnum = LightManager::Type::SUN;\n    else\n      throw invalidUnion(inUnion);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a string representation of a light type to an enum value.\n   >>> convertJSUnionToEnum(\"directional\", &outEnum)\n   >>> convertJSUnionToEnum(\"spot\", &outEnum)\n   >>> convertJSUnionToEnum(\"point\", &outEnum)\n   >>> convertJSUnionToEnum(\"focused_sport\", &outEnum)\n   >>> convertJSUnionToEnum(\"sun\", &outEnum) *\/ \nvoid convertJSUnionToEnum(const std::string& inUnion, LightManager::Type* outEnum) {",
        "query_nlx":"        \/* Function named convertJSUnionToEnum converts a given string representing a type of light source into an enumeration type.\n        >>> convertJSUnionToEnum(\"directional\", &outEnum)\n        >>> convertJSUnionToEnum(\"spot\", &outEnum)\n        >>> convertJSUnionToEnum(\"point\", &outEnum)\n        >>> convertJSUnionToEnum(\"focused_sport\", &outEnum)\n        >>> convertJSUnionToEnum(\"sun\", &outEnum) *\/ \n        void convertJSUnionToEnum(const std::string& inUnion, LightManager::Type* outEnum) { "
    }

    {
        "file_name":"RNFListenerManager_function_2.cpp",
        "line_count":5,
        "code":"bool getHasListeners() {\n    std::unique_lock lock(_mutex);\n\n    return _listeners.size() > 0;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if there are any listeners registered.\n>>> bool getHasListeners() { *\/",
        "query_nlx":"\/* Define a function that determines if there are any listeners attached to an object. \n   >>> getHasListeners() \n   - Returns true if there are listeners attached, false otherwise *\/ \nbool getHasListeners() {"
    }

    {
        "file_name":"RNFPointerHolder_function_1.cpp",
        "line_count":9,
        "code":"void release() {\n    std::unique_lock lock(_mutex);\n\n    if (_pointer == nullptr) {\n      throw std::runtime_error(\"Pointer \" + _name + \" has already been manually released!\");\n    }\n    Logger::log(TAG, \"Manually releasing %s... (PointerHolder::release())\", _name.c_str());\n    _pointer = nullptr;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Manually release a pointer if it has not already been released.\n   >>> void release() { *\/",
        "query_nlx":"        \/* Define a function that releases a resource held by a pointer if it has not already been manually released. \n        >>> release() *\/ \n        void release() { "
    }

    {
        "file_name":"RNFPointerHolder_function_2.cpp",
        "line_count":5,
        "code":"bool getIsValid() {\n    std::unique_lock lock(_mutex);\n\n    return _pointer != nullptr;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a valid pointer exists within the current context.\n   >>> getIsValid() *\/\nbool getIsValid() {",
        "query_nlx":"\/* Define a function that returns a boolean value indicating whether a certain condition is met based on the presence of a non-null pointer.\n   >>> getIsValid() true\n   >>> getIsValid() false *\/ \nbool getIsValid() {"
    }

    {
        "file_name":"RNFQualityLevel_function_1.cpp",
        "line_count":12,
        "code":"void convertJSUnionToEnum(const std::string& inUnion, QualityLevel* outEnum) {\n    if (inUnion == \"low\")\n      *outEnum = QualityLevel::LOW;\n    else if (inUnion == \"medium\")\n      *outEnum = QualityLevel::MEDIUM;\n    else if (inUnion == \"high\")\n      *outEnum = QualityLevel::HIGH;\n    else if (inUnion == \"ultra\")\n      *outEnum = QualityLevel::ULTRA;\n    else\n      throw invalidUnion(inUnion);\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Convert a string representation of quality level to an enum value. \n        >>> convertJSUnionToEnum(\"low\", &outEnum) \n        >>> convertJSUnionToEnum(\"high\", &outEnum) *\/ \n        void convertJSUnionToEnum(const std::string& inUnion, QualityLevel* outEnum) {",
        "query_nlx":"\/* Function named convertJSUnionToEnum converts a given string representation of a quality level into an enum representation. The function takes a string input representing a quality level and a pointer to an enum output. If the input string is \"low\", the output enum is set to LOW. If the input string is \"medium\", the output enum is set to MEDIUM. If the input string is \"high\", the output enum is set to HIGH. If the input string is \"ultra\", the output enum is set to ULTRA. If the input string does not match any of these options, an exception is thrown.\n>>> convertJSUnionToEnum(\"low\", &outEnum) sets outEnum to LOW\n>>> convertJSUnionToEnum(\"medium\", &outEnum) sets outEnum to MEDIUM\n>>> convertJSUnionToEnum(\"high\", &outEnum) sets outEnum to HIGH\n>>> convertJSUnionToEnum(\"ultra\", &outEnum) sets outEnum to ULTRA\n>>> convertJSUnionToEnum(\"invalid\", &outEnum) throws an invalidUnion exception *\/ \nvoid convertJSUnionToEnum(const std::string& inUnion, QualityLevel* outEnum) {"
    }

    {
        "file_name":"RNFQualityLevel_function_2.cpp",
        "line_count":18,
        "code":"void convertEnumToJSUnion(QualityLevel inEnum, std::string* outUnion) {\n    switch (inEnum) {\n      case QualityLevel::LOW:\n        *outUnion = \"low\";\n        break;\n      case QualityLevel::MEDIUM:\n        *outUnion = \"medium\";\n        break;\n      case QualityLevel::HIGH:\n        *outUnion = \"high\";\n        break;\n      case QualityLevel::ULTRA:\n        *outUnion = \"ultra\";\n        break;\n      default:\n        throw invalidEnum(inEnum);\n    }\n  }",
        "mark":8.25,
        "query_nsx":"\/* Convert enum values representing quality levels to corresponding strings. \n   >>> void convertEnumToJSUnion(QualityLevel inEnum, std::string* outUnion) { *\/",
        "query_nlx":"\/* Function named convertEnumToJSUnion converts a given quality level enum to a corresponding JavaScript union string representation.\n>>> convertEnumToJSUnion(LOW, &outUnion) outUnion = \"low\"\n>>> convertEnumToJSUnion(MEDIUM, &outUnion) outUnion = \"medium\"\n>>> convertEnumToJSUnion(HIGH, &outUnion) outUnion = \"high\"\n>>> convertEnumToJSUnion(ULTRA, &outUnion) outUnion = \"ultra\" *\/ \nvoid convertEnumToJSUnion(QualityLevel inEnum, std::string* outUnion) {"
    }

    {
        "file_name":"RNFTestEnum_function_2.cpp",
        "line_count":15,
        "code":"void convertEnumToJSUnion(TestEnum inEnum, std::string* outUnion) {\n    switch (inEnum) {\n      case TestEnum::FIRST:\n        *outUnion = \"first\";\n        break;\n      case TestEnum::SECOND:\n        *outUnion = \"second\";\n        break;\n      case TestEnum::THIRD:\n        *outUnion = \"third\";\n        break;\n      default:\n        throw invalidEnum(inEnum);\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert an enum value to a corresponding string representation. \n   >>> void convertEnumToJSUnion(TestEnum inEnum, std::string* outUnion) { *\/",
        "query_nlx":"\/* Function named convertEnumToJSUnion converts an input enum value to a corresponding string representation in JavaScript union format.\n>>> convertEnumToJSUnion(TestEnum::FIRST, &outUnion) outUnion = \"first\"\n>>> convertEnumToJSUnion(TestEnum::SECOND, &outUnion) outUnion = \"second\"\n>>> convertEnumToJSUnion(TestEnum::THIRD, &outUnion) outUnion = \"third\"\n>>> convertEnumToJSUnion(TestEnum::INVALID, &outUnion) throws invalidEnum exception *\/ \nvoid convertEnumToJSUnion(TestEnum inEnum, std::string* outUnion) { "
    }

    {
        "file_name":"RNFTestHybridObject_function_2.cpp",
        "line_count":3,
        "code":"void setInt(int newValue) {\n    _int = newValue;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the integer value to a new input value.\n   >>> setInt(int newValue) *\/",
        "query_nlx":"\/* Define a function that sets a new integer value to a private variable.\n   >>> setInt(newValue) *\/ \nvoid setInt(int newValue) {"
    }

    {
        "file_name":"RNFTestHybridObject_function_4.cpp",
        "line_count":3,
        "code":"void setString(const std::string& newValue) {\n    _string = newValue;\n  }",
        "mark":9.0,
        "query_nsx":"\/* Set a new string value for the object.\n   >>> setString(const string& newValue) *\/",
        "query_nlx":"\/* Function named setString assigns a new value to a string variable.\n   >>> setString(\"Hello, World!\") *\/ \nvoid setString(const std::string& newValue) {"
    }

    {
        "file_name":"RNFTestHybridObject_function_5.cpp",
        "line_count":3,
        "code":"void setEnum(TestEnum testEnum) {\n    _enum = testEnum;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the enum value to the given input.\n   >>> setEnum(TestEnum testEnum) *\/",
        "query_nlx":"\/* Define a function that sets an enum value to a given input.\n   >>> setEnum(testEnum) *\/ \nvoid setEnum(TestEnum testEnum) {"
    }

    {
        "file_name":"RNFTestHybridObject_function_7.cpp",
        "line_count":3,
        "code":"void setNullableString(std::optional<std::string> string) {\n    _nullableString = string;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a nullable string value.\n   >>> void setNullableString(std::optional<std::string> string); *\/",
        "query_nlx":"\/* Define a function called setNullableString that takes an optional string as input and assigns it to a variable _nullableString. \n   >>> setNullableString(std::optional<std::string> string) *\/"
    }

    {
        "file_name":"RNFTestHybridObject_function_8.cpp",
        "line_count":20,
        "code":"uint64_t calculateFibonacci(int count) {\n    if (count < 0)\n      throw std::invalid_argument(\"Cannot calculate fibonacci for \" + std::to_string(count) + \" - it needs to be at least 0!\");\n    if (count == 0)\n      return 0;\n    if (count == 1)\n      return 1;\n    if (count >= 94)\n      throw std::invalid_argument(\"Cannot calculate fibonacci for \" + std::to_string(count) +\n                                  \" - it needs to be 94 at max, the number will overflow!\");\n\n    uint64_t prev = 0;\n    uint64_t current = 1;\n    for (unsigned int i = 2; i <= count; ++i) {\n      uint64_t next = prev + current;\n      prev = current;\n      current = next;\n    }\n    return current;\n  }",
        "mark":8.25,
        "query_nsx":"\/* Calculate the nth Fibonacci number within the limits of the data type used.\n>>> uint64_t calculateFibonacci(int count) { *\/",
        "query_nlx":"\/* Function named calculateFibonacci computes the Fibonacci number at a given position in the sequence.\n   >>> calculateFibonacci(10) 55\n   >>> calculateFibonacci(20) 6765\n   >>> calculateFibonacci(93) 12200160415121876738 *\/ \nuint64_t calculateFibonacci(int count) {"
    }

    {
        "file_name":"RNFTMat44Wrapper_function_1.cpp",
        "line_count":3,
        "code":"mat4f getMat() {\n    return _matrix;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a 4x4 matrix from the function. \n>>> getMat() mat4f *\/",
        "query_nlx":"\/* Define a function that retrieves a 4x4 matrix. \n   >>> getMat() returns a 4x4 matrix *\/ \nmat4f getMat() {"
    }

    {
        "file_name":"RNFTransparencyModeEnum_function_1.cpp",
        "line_count":10,
        "code":"void convertJSUnionToEnum(const std::string& inUnion, TransparencyMode* outEnum) {\n    if (inUnion == \"default\")\n      *outEnum = TransparencyMode::DEFAULT;\n    else if (inUnion == \"twoPassesOneSide\")\n      *outEnum = TransparencyMode::TWO_PASSES_ONE_SIDE;\n    else if (inUnion == \"twoPassesTwoSides\")\n      *outEnum = TransparencyMode::TWO_PASSES_TWO_SIDES;\n    else\n      throw invalidUnion(inUnion);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Convert a given string representation of a transparency mode to an enum value. \n>>> convertJSUnionToEnum(\"default\", &transparencyMode) \n>>> convertJSUnionToEnum(\"twoPassesOneSide\", &transparencyMode) \n>>> convertJSUnionToEnum(\"twoPassesTwoSides\", &transparencyMode) *\/ \nvoid convertJSUnionToEnum(const std::string& inUnion, TransparencyMode* outEnum) { ",
        "query_nlx":"        \/* Function named convertJSUnionToEnum converts a given string representation of a union to an enum value based on specific mappings.\n        >>> convertJSUnionToEnum(\"default\", &transparencyMode) transparencyMode = DEFAULT\n        >>> convertJSUnionToEnum(\"twoPassesOneSide\", &transparencyMode) transparencyMode = TWO_PASSES_ONE_SIDE\n        >>> convertJSUnionToEnum(\"twoPassesTwoSides\", &transparencyMode) transparencyMode = TWO_PASSES_TWO_SIDES\n        >>> convertJSUnionToEnum(\"invalidUnion\", &transparencyMode) throws invalidUnion exception *\/ \n        void convertJSUnionToEnum(const std::string& inUnion, TransparencyMode* outEnum) { "
    }

    {
        "file_name":"RNFWorkletRuntimeCollector_function_1.cpp",
        "line_count":5,
        "code":"void install(jsi::Runtime& rt) {\n    auto collector = std::make_shared<WorkletRuntimeCollector>(rt);\n    auto object = jsi::Object::createFromHostObject(rt, collector);\n    rt.global().setProperty(rt, \"__workletRuntimeCollector\", object);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Create and set up a runtime collector object for worklets.\n   >>> install(rt) *\/ \nvoid install(jsi::Runtime& rt) {",
        "query_nlx":"\/* Create a function named install that sets up a worklet runtime collector object in the provided runtime environment.\n   >>> install(rt) creates a WorkletRuntimeCollector object using the given runtime and assigns it to a global property named \"__workletRuntimeCollector\". *\/"
    }

    {
        "file_name":"RNFWorkletRuntimeRegistry_function_1.cpp",
        "line_count":4,
        "code":"void registerRuntime(jsi::Runtime& runtime) {\n    std::lock_guard<std::mutex> lock(mutex_);\n    registry_.insert(&runtime);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Register a runtime instance in the registry with thread safety.\n   >>> registerRuntime(jsi::Runtime& runtime); *\/",
        "query_nlx":"\/* Register a runtime object in a thread-safe manner by acquiring a lock using a mutex and adding the runtime object to a registry.\n   >>> registerRuntime(runtime) *\/ \nvoid registerRuntime(jsi::Runtime& runtime) {"
    }

    {
        "file_name":"RNFWorkletRuntimeRegistry_function_2.cpp",
        "line_count":4,
        "code":"void unregisterRuntime(jsi::Runtime& runtime) {\n    std::lock_guard<std::mutex> lock(mutex_);\n    registry_.erase(&runtime);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Unregister a runtime from the registry.\n   >>> void unregisterRuntime(jsi::Runtime& runtime) { *\/",
        "query_nlx":"\/* Function named unregisterRuntime removes a specific runtime from a registry using a mutex lock to ensure thread safety.\n>>> unregisterRuntime(jsi::Runtime& runtime) *\/"
    }

    {
        "file_name":"RNFWorkletRuntimeRegistry_function_3.cpp",
        "line_count":5,
        "code":"bool isRuntimeAlive(jsi::Runtime* runtime) {\n    assert(runtime != nullptr);\n    std::lock_guard<std::mutex> lock(mutex_);\n    return registry_.find(runtime) != registry_.end();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Check if a runtime instance is currently active in the registry.\n   >>> bool isRuntimeAlive(jsi::Runtime* runtime); *\/",
        "query_nlx":"\/* Function named isRuntimeAlive checks if a given runtime object is currently active in the system. \n>>> isRuntimeAlive(runtime) true \n>>> isRuntimeAlive(nullptr) false *\/ \nbool isRuntimeAlive(jsi::Runtime* runtime) {"
    }

    {
        "file_name":"RoleList_function_1.cpp",
        "line_count":5,
        "code":"LPTSTR GetText() {\n\t\tif (!m_text)\n\t\t\tm_text = ConvertCppStringToTString(m_role.m_name);\n\t\treturn m_text;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the text data to be displayed, converting it if necessary.\n   >>> GetText() LPTSTR *\/",
        "query_nlx":"\/* Function named GetText retrieves a text value. If the current text value is empty, it converts the name of a role to a text string and assigns it to the text value before returning it.\n>>> GetText() *\/ \nLPTSTR GetText() {"
    }

    {
        "file_name":"SC-package_function_4.cpp",
        "line_count":13,
        "code":"Result downloadFileMD5(StringView remoteURL, StringView localFile, StringView localFileMD5)\n{\n    FileSystem fs;\n    SC_TRY(fs.init(\".\"));\n    if (not fs.existsAndIsFile(localFile) or not checkFileMD5(localFile, localFileMD5))\n    {\n        Process process;\n        SC_TRY(process.exec({\"curl\", \"-L\", \"-o\", localFile, remoteURL}));\n        SC_TRY_MSG(process.getExitStatus() == 0, \"Cannot download file\");\n        SC_TRY(checkFileMD5(localFile, localFileMD5));\n    }\n    return Result(true);\n}",
        "mark":8.0,
        "query_nsx":"\/* Download a file from a remote URL and verify its integrity using MD5 checksum.\n>>> Result downloadFileMD5(StringView remoteURL, StringView localFile, StringView localFileMD5) *\/",
        "query_nlx":"\/* Function named downloadFileMD5 downloads a file from a remote URL to a local directory and verifies its integrity using MD5 checksum.\n>>> downloadFileMD5(\"https:\/\/example.com\/file.txt\", \"local_file.txt\", \"expected_md5_checksum\") Result(true) *\/"
    }

    {
        "file_name":"SCExample_function_8.cpp",
        "line_count":20,
        "code":"void drawToolbar()\n    {\n        ImGui::SetNextWindowPos(ImVec2(0, 0));\n        ImGui::SetNextWindowSize(ImVec2(ImGui::GetIO().DisplaySize.x, ToolbarHeight));\n        constexpr auto flags = ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar |\n                               ImGuiWindowFlags_NoScrollbar;\n        if (ImGui::Begin(\"Toolbar\", nullptr, flags))\n        {\n            if (ImGui::Button(\"Settings...\"))\n            {\n                viewState.page = ApplicationPage::Settings;\n            }\n            HotReloadView view{system.hotReloadSystem, system.hotReloadSystem.state, viewState.exampleViewState};\n            if (view.drawToolbar())\n            {\n                viewState.page = ApplicationPage::Examples;\n            }\n        }\n        ImGui::End();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Draw a toolbar at the top of the screen with specific functionalities.\n>>> void drawToolbar() { *\/",
        "query_nlx":"        \/* Define a function that draws a toolbar at the top of the screen with specific properties and buttons that trigger different actions.\n        >>> drawToolbar() *\/"
    }

    {
        "file_name":"SCExample_function_9.cpp",
        "line_count":12,
        "code":"void drawSettings()\n    {\n        if (ImGui::CollapsingHeader(\"SC::Async\", ImGuiTreeNodeFlags_DefaultOpen))\n        {\n            drawSettingsAsync();\n        }\n        if (ImGui::CollapsingHeader(\"SC::Plugin\", ImGuiTreeNodeFlags_DefaultOpen))\n        {\n            HotReloadView view{system.hotReloadSystem, system.hotReloadSystem.state, viewState.exampleViewState};\n            view.drawSettings();\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Draw settings for different sections based on collapsible headers.\n   >>> drawSettings() *\/ \nvoid drawSettings() {",
        "query_nlx":"\n\/* Define a function called drawSettings that utilizes GUI elements to display collapsible headers for \"SC::Async\" and \"SC::Plugin\". \nThe \"SC::Async\" header should trigger the drawSettingsAsync function when expanded, while the \"SC::Plugin\" header should create a HotReloadView object with specific parameters and call its drawSettings method when expanded. *\/\nvoid drawSettings() {"
    }

    {
        "file_name":"Segment_function_3.cpp",
        "line_count":1,
        "code":"void setSize(size_t newSize) { sizeBytes = static_cast<SizeType>(newSize * sizeof(T)); }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the size in bytes based on the new size provided and the data type of the elements.\n>>> void setSize(size_t newSize) { *\/",
        "query_nlx":"\/* Define a function named setSize that takes a new size value as input and updates the sizeBytes variable based on the size of the data type T multiplied by the new size value.\n>>> setSize(10) *\/ \nvoid setSize(size_t newSize) { "
    }

    {
        "file_name":"SerializationBinaryBuffer_function_5.cpp",
        "line_count":7,
        "code":"bool advanceBytes(size_t numBytes)\n    {\n        if (readPosition + numBytes > memory.sizeInBytes())\n            return false;\n        readPosition += numBytes;\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if it is possible to advance a certain number of bytes in memory without exceeding the memory size limit.\n>>> advanceBytes(size_t numBytes) *\/",
        "query_nlx":"\/* Function named advanceBytes checks if it is possible to move the read position in memory by a specified number of bytes without exceeding the total memory size in bytes.\n>>> advanceBytes(10) true\n>>> advanceBytes(100) false *\/ \nbool advanceBytes(size_t numBytes) { "
    }

    {
        "file_name":"SerializationBinaryTypeErasedTest_function_1.cpp",
        "line_count":1,
        "code":"void runSerializationBinaryTypeErasedTest(SC::TestReport& report) { SerializationBinaryTypeErasedTest test(report); }",
        "mark":8.0,
        "query_nsx":"\/* Create and run a test for serialization using binary type erasure.\n   >>> void runSerializationBinaryTypeErasedTest(SC::TestReport& report); *\/",
        "query_nlx":"\/* Create a function that runs a test for serialization using binary type erasure, which takes a TestReport object as a parameter. \n   >>> runSerializationBinaryTypeErasedTest(SC::TestReport& report); *\/"
    }

    {
        "file_name":"SerializationBinaryTypeErased_function_1.cpp",
        "line_count":10,
        "code":"bool write(const T& object, Vector<uint8_t>& buffer, size_t* numberOfWrites = nullptr)\n    {\n        SerializationBinaryBufferWriter         binaryBuffer(buffer);\n        SerializationBinaryTypeErasedWriteExact writer;\n        if (not writer.write(object, binaryBuffer))\n            return false;\n        if (numberOfWrites)\n            *numberOfWrites = binaryBuffer.numberOfOperations;\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Serialize an object into a binary buffer and return the success status along with the number of write operations performed.\n>>> bool write(const T& object, Vector<uint8_t>& buffer, size_t* numberOfWrites = nullptr) { *\/",
        "query_nlx":"\/* Function named write serializes an object into a binary buffer using a type-erased writer and returns a boolean value indicating success. If the optional parameter numberOfWrites is provided, it will store the number of write operations performed.\n>>> write(object, buffer, &numberOfWrites) true\n>>> write(object, buffer) true *\/ \n#include<vector>\n#include<cstdint>\nusing namespace std;\ntemplate<typename T>\nbool write(const T& object, vector<uint8_t>& buffer, size_t* numberOfWrites = nullptr) { "
    }

    {
        "file_name":"SerializationBinaryTypeErased_function_2.cpp",
        "line_count":10,
        "code":"bool loadExact(T& object, Span<const uint8_t> buffer, size_t* numberOfReads = nullptr)\n    {\n        SerializationBinaryBufferReader        bufferReader(buffer);\n        SerializationBinaryTypeErasedReadExact reader;\n        if (not reader.loadExact(object, bufferReader))\n            return false;\n        if (numberOfReads)\n            *numberOfReads = bufferReader.numberOfOperations;\n        return bufferReader.positionIsAtEnd();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Load an object from a binary buffer with the exact number of reads and check if the buffer position is at the end.\n   >>> bool loadExact(T& object, Span<const uint8_t> buffer, size_t* numberOfReads = nullptr); *\/",
        "query_nlx":"\/* Function named loadExact reads a binary buffer to load an object using a type-erased reader and returns whether the operation was successful. It also optionally updates the number of reads performed and checks if the buffer reader is at the end.\n>>> loadExact(object, buffer) bool\n>>> loadExact(object, buffer, &numberOfReads) bool *\/"
    }

    {
        "file_name":"SerializationBinaryTypeErased_function_7.cpp",
        "line_count":9,
        "code":"bool copySourceSink(Span<const uint8_t> source, Span<uint8_t> other)\n{\n    if (other.sizeInBytes() >= source.sizeInBytes())\n    {\n        memcpy(other.data(), source.data(), source.sizeInBytes());\n        return true;\n    }\n    return false;\n}",
        "mark":8.0,
        "query_nsx":"\/* Copy data from one memory location to another if the destination has enough space available.\n>>> copySourceSink(source, other) true\n>>> copySourceSink(source, other) false *\/",
        "query_nlx":"        \/* Function named copySourceSink copies the data from one memory location to another if the destination memory has enough space to accommodate the source data.\n        >>> copySourceSink({0x12, 0x34, 0x56}, {0x00, 0x00, 0x00, 0x00, 0x00}) true\n        >>> copySourceSink({0xAB, 0xCD}, {0x00, 0x00}) false *\/ \n        bool copySourceSink(Span<const uint8_t> source, Span<uint8_t> other) { "
    }

    {
        "file_name":"SerializationBinary_function_1.cpp",
        "line_count":10,
        "code":"bool write(T& value, Vector<uint8_t>& buffer, size_t* numberOfWrites = nullptr)\n    {\n        SerializationBinaryBufferWriter writer(buffer);\n        using Writer = Serialization::SerializerBinaryReadWriteExact<SerializationBinaryBufferWriter, T>;\n        if (not Writer::serialize(value, writer))\n            return false;\n        if (numberOfWrites)\n            *numberOfWrites = writer.numberOfOperations;\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Serialize a value into a binary buffer and track the number of write operations.\n   >>> bool write(T& value, Vector<uint8_t>& buffer, size_t* numberOfWrites = nullptr) *\/",
        "query_nlx":"\/* Function named write serializes a given value into a binary buffer using a specific writer and returns a boolean value indicating success. If the optional parameter numberOfWrites is provided, it will store the number of write operations performed.\n>>> write(value, buffer) true\n>>> write(value, buffer, &numberOfWrites) true *\/ \n#include <vector>\n#include <cstdint>\n#include \"serialization.h\"\nusing namespace Serialization;\n\ntemplate<typename T>\nbool write(T& value, Vector<uint8_t>& buffer, size_t* numberOfWrites = nullptr) { "
    }

    {
        "file_name":"SerializationBinary_function_2.cpp",
        "line_count":10,
        "code":"bool loadExact(T& value, Span<const uint8_t> buffer, size_t* numberOfReads = nullptr)\n    {\n        SerializationBinaryBufferReader bufferReader(buffer);\n        using Reader = Serialization::SerializerBinaryReadWriteExact<SerializationBinaryBufferReader, T>;\n        if (not Reader::serialize(value, bufferReader))\n            return false;\n        if (numberOfReads)\n            *numberOfReads = bufferReader.numberOfOperations;\n        return bufferReader.positionIsAtEnd();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Deserialize a value from a binary buffer and determine if the buffer has been fully read.\n   >>> bool loadExact(T& value, Span<const uint8_t> buffer, size_t* numberOfReads = nullptr) { *\/",
        "query_nlx":"\/* Function named loadExact reads a value from a binary buffer using exact serialization and returns whether the operation was successful. It also optionally updates the number of reads performed.\n    >>> loadExact(value, buffer) true\n    >>> loadExact(value, buffer, &numberOfReads) true *\/ \nbool loadExact(T& value, Span<const uint8_t> buffer, size_t* numberOfReads = nullptr) { "
    }

    {
        "file_name":"SerializationExample_function_1.cpp",
        "line_count":1,
        "code":"TypeCategory getCategory() { return TypeCategory::TypeVector; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the category of the type as a vector. \n>>> getCategory() TypeVector *\/",
        "query_nlx":"\/* Function named getCategory returns the category of a specific type, which is a vector type.\n   >>> getCategory() TypeCategory::TypeVector *\/ \nTypeCategory getCategory() {"
    }

    {
        "file_name":"SerializationExample_function_18.cpp",
        "line_count":1,
        "code":"bool init() { return view.init(); }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the initialization of a view is successful or not.\n>>> bool init() { *\/",
        "query_nlx":"\/* Function named init checks if the view can be initialized successfully.\n   >>> init() returns a boolean value indicating if the view initialization was successful or not. *\/ \nbool init() { "
    }

    {
        "file_name":"SerializationExample_function_20.cpp",
        "line_count":1,
        "code":"void draw() { view.draw(model); }",
        "mark":8.0,
        "query_nsx":"\/* Draw the model using the view. \n   >>> draw() void draw() { view.draw(model); } *\/",
        "query_nlx":"\/* Function named draw calls the draw function of a view object with the model object as a parameter. \n>>> draw() void *\/"
    }

    {
        "file_name":"SerializationExample_function_3.cpp",
        "line_count":1,
        "code":"int  size(const ImVector<T>& object) { return object.size(); }",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of the given object.\n>>> int size(const ImVector<T>& object); *\/",
        "query_nlx":"\/* Function named size calculates the number of elements in a given vector object.\n   >>> size({1, 2, 3, 4, 5}) 5\n   >>> size({\"apple\", \"banana\", \"orange\"}) 3 *\/ \nint size(const ImVector<T>& object) { "
    }

    {
        "file_name":"SerializationExample_function_9.cpp",
        "line_count":6,
        "code":"Result loadFromBinaryFile(const StringView fileName)\n    {\n        Vector<uint8_t> buffer;\n        SC_TRY(FileSystem().read(fileName, buffer));\n        return loadFromBinary(buffer.toSpanConst());\n    }",
        "mark":8.0,
        "query_nsx":"\/* Load data from a binary file and return the result.\n   >>> Result loadFromBinaryFile(const StringView fileName) *\/",
        "query_nlx":"\/* Function named loadFromBinaryFile reads binary data from a file specified by the input fileName, and then loads and returns the data as a Result object. \n>>> loadFromBinaryFile(\"data.bin\") Result \n*\/ \nResult loadFromBinaryFile(const StringView fileName) { "
    }

    {
        "file_name":"SerializationJson_function_2.cpp",
        "line_count":5,
        "code":"bool loadExact(T& object, StringView text)\n    {\n        Reader stream(text);\n        return Serialization::SerializationTextReadWriteExact<Reader, T>::serialize(0, object, stream);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Load an object from a text representation with exact serialization. \n   >>> bool loadExact(T& object, StringView text); *\/",
        "query_nlx":"\/* Define a function named loadExact that takes an object of type T and a text string as input, and returns a boolean value.\n   The function uses a Reader object initialized with the provided text string and then calls a serialization function to serialize the object using exact text read and write operations.\n   The function returns the result of the serialization operation.\n   >>> loadExact(object, \"text\") bool *\/"
    }

    {
        "file_name":"SerializationJson_function_3.cpp",
        "line_count":5,
        "code":"bool loadVersioned(T& object, StringView text)\n    {\n        Reader stream(text);\n        return Serialization::SerializationTextReadVersioned<Reader, T>::loadVersioned(0, object, stream);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Load a versioned object from a text input using serialization.\n   >>> bool loadVersioned(T& object, StringView text); *\/",
        "query_nlx":"\/* Define a function that loads a versioned object from a given text input using serialization.\n   The function takes a reference to an object of type T and a StringView text input.\n   It initializes a Reader stream with the text input and uses SerializationTextReadVersioned to load the versioned object.\n   The function returns a boolean value indicating the success of the operation.\n*\/ \nbool loadVersioned(T& object, StringView text) { "
    }

    {
        "file_name":"SerializationJson_function_7.cpp",
        "line_count":1,
        "code":"bool onSerializationStart() { return true; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the serialization process has started successfully.\n>>> onSerializationStart() true *\/",
        "query_nlx":"\/* Function named onSerializationStart returns true when serialization process starts.\n   >>> onSerializationStart() true *\/ \nbool onSerializationStart() { "
    }

    {
        "file_name":"SerializationJson_function_8.cpp",
        "line_count":1,
        "code":"bool onSerializationEnd() { return true; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the serialization process has ended successfully.\n>>> onSerializationEnd() true *\/",
        "query_nlx":"            \/* Function named onSerializationEnd returns true when serialization process is completed successfully. \n            >>> onSerializationEnd() true *\/ \n            bool onSerializationEnd() { "
    }

    {
        "file_name":"SerializationSuiteTest_function_2.cpp",
        "line_count":108,
        "code":"void runSameVersionTests()\n    {\n        size_t numWriteOperations = 0;\n        size_t numReadOperations  = 0;\n        if (test_section(\"Primitive Structure Write\"))\n        {\n            PrimitiveStruct objectToSerialize;\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n\n            \/\/ Verification\n            SC_TEST_EXPECT(numWriteOperations == 1);\n            uint32_t index = 0;\n            for (uint32_t i = 0; i < 4; ++i)\n            {\n                SC_TEST_EXPECT(readPrimitive<uint8_t>(buffer, index) == objectToSerialize.arrayValue[i]);\n            }\n            SC_TEST_EXPECT(readPrimitive<float>(buffer, index) == objectToSerialize.floatValue);\n            SC_TEST_EXPECT(readPrimitive<int64_t>(buffer, index) == objectToSerialize.int64Value);\n        }\n        if (test_section(\"PrimitiveStruct\"))\n        {\n            PrimitiveStruct objectToSerialize;\n            PrimitiveStruct deserializedObject;\n            memset(&deserializedObject, 0, sizeof(deserializedObject));\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n            SC_TEST_EXPECT(numWriteOperations == 1);\n\n            \/\/ Deserialization\n            SC_TEST_EXPECT(SerializerReader::loadExact(deserializedObject, buffer.toSpanConst(), &numReadOperations));\n            SC_TEST_EXPECT(numReadOperations == numWriteOperations);\n\n            \/\/ Verification\n            SC_TEST_EXPECT(not(objectToSerialize != deserializedObject));\n        }\n        if (test_section(\"TopLevelStruct\"))\n        {\n            TopLevelStruct objectToSerialize;\n            TopLevelStruct deserializedObject;\n            memset(&deserializedObject, 0, sizeof(deserializedObject));\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n            SC_TEST_EXPECT(numWriteOperations == 3);\n\n            \/\/ Deserialization\n            SC_TEST_EXPECT(SerializerReader::loadExact(deserializedObject, buffer.toSpanConst(), &numReadOperations));\n            SC_TEST_EXPECT(numReadOperations == numWriteOperations);\n\n            \/\/ Verification\n            SC_TEST_EXPECT(not(objectToSerialize != deserializedObject));\n        }\n        if (test_section(\"VectorStructSimple\"))\n        {\n            VectorStructSimple objectToSerialize;\n            SC_TRUST_RESULT(objectToSerialize.vectorOfInts.push_back(1));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfInts.push_back(2));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfInts.push_back(3));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfInts.push_back(4));\n            VectorStructSimple deserializedObject;\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n            SC_TEST_EXPECT(numWriteOperations == 4);\n\n            \/\/ Deserialization\n            SC_TEST_EXPECT(SerializerReader::loadExact(deserializedObject, buffer.toSpanConst(), &numReadOperations));\n            SC_TEST_EXPECT(numReadOperations == numWriteOperations);\n\n            \/\/ Verification\n            SC_TEST_EXPECT(deserializedObject.emptyVector.size() == 0);\n            SC_TEST_EXPECT(deserializedObject.vectorOfInts.size() == 4);\n            for (size_t idx = 0; idx < objectToSerialize.vectorOfInts.size(); ++idx)\n            {\n                SC_TEST_EXPECT(objectToSerialize.vectorOfInts[idx] == deserializedObject.vectorOfInts[idx]);\n            }\n        }\n        if (test_section(\"VectorStructComplex\"))\n        {\n            VectorStructComplex objectToSerialize;\n            SC_TRUST_RESULT(objectToSerialize.vectorOfStrings.push_back(\"asdasdasd1\"));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfStrings.push_back(\"asdasdasd2\"));\n            SC_TRUST_RESULT(objectToSerialize.vectorOfStrings.push_back(\"asdasdasd3\"));\n            VectorStructComplex deserializedObject;\n\n            \/\/ Serialization\n            SmallVector<uint8_t, 256> buffer;\n            SC_TEST_EXPECT(SerializerWriter::write(objectToSerialize, buffer, &numWriteOperations));\n            SC_TEST_EXPECT(numWriteOperations == 10);\n\n            \/\/ Deserialization\n            SC_TEST_EXPECT(SerializerReader::loadExact(deserializedObject, buffer.toSpanConst(), &numReadOperations));\n            SC_TEST_EXPECT(numReadOperations == numWriteOperations);\n\n            \/\/ Verification\n            SC_TEST_EXPECT(deserializedObject.vectorOfStrings.size() == 3);\n            SC_TEST_EXPECT(deserializedObject.vectorOfStrings[0] == \"asdasdasd1\");\n            SC_TEST_EXPECT(deserializedObject.vectorOfStrings[1] == \"asdasdasd2\");\n            SC_TEST_EXPECT(deserializedObject.vectorOfStrings[2] == \"asdasdasd3\");\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Run tests for serializing and deserializing different types of structures including primitive, top-level, and vector structures. \n>>> runSameVersionTests() *\/",
        "query_nlx":"\/* The function runSameVersionTests runs a series of tests on serialization and deserialization of different data structures. \n>>> runSameVersionTests() *\/"
    }

    {
        "file_name":"SerializationTextReadVersioned_function_3.cpp",
        "line_count":4,
        "code":"bool loadVersioned(uint32_t index, T& object, SerializerStream& stream)\n    {\n        return stream.serialize(index, object);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Load a versioned object from a serializer stream based on the provided index.\n   >>> bool loadVersioned(uint32_t index, T& object, SerializerStream& stream) *\/",
        "query_nlx":"        \/* Function named loadVersioned takes an index, an object of type T, and a SerializerStream as input parameters and returns a boolean value. It serializes the object using the provided index and stream.\n        >>> loadVersioned(5, obj, stream) true\n        >>> loadVersioned(10, data, serializer) false *\/ \n        uint32_t index, T& object, SerializerStream& stream;"
    }

    {
        "file_name":"SerializationTextReadVersioned_function_5.cpp",
        "line_count":4,
        "code":"bool loadVersioned(uint32_t index, String& object, SerializerStream& stream)\n    {\n        return stream.serialize(index, object);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Serialize and load a versioned object using the provided index, object, and stream.\n   >>> bool loadVersioned(uint32_t index, String& object, SerializerStream& stream) *\/",
        "query_nlx":"\/* Define a function that loads a versioned object from a stream based on the provided index.\n   The function takes an index, a string object, and a serializer stream as input parameters and returns a boolean value.\n   The function should serialize the object from the stream using the provided index.\n   >>> loadVersioned(5, \"example_object\", example_stream) true\n   >>> loadVersioned(10, \"data\", data_stream) false *\/ \nbool loadVersioned(uint32_t index, String& object, SerializerStream& stream) { *\/"
    }

    {
        "file_name":"SerializationTextReadWriteExact_function_1.cpp",
        "line_count":8,
        "code":"bool serialize(uint32_t index, T& object, TextStream& stream)\n    {\n        if (not stream.startObject(index))\n            return false;\n        if (not Reflection::Reflect<T>::visit(MemberIterator{stream, object}))\n            return false;\n        return stream.endObject();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Serialize an object of a specific type to a text stream with a given index.\n   >>> bool serialize(uint32_t index, T& object, TextStream& stream) *\/",
        "query_nlx":"\/* Function named serialize takes an index, an object of type T, and a TextStream as input parameters. It serializes the object into the provided stream by starting an object with the given index, reflecting the object's members using Reflection, and then ending the object.\n>>> serialize(5, myObject, myStream) true\n>>> serialize(10, anotherObject, anotherStream) false *\/ \nuint32_t index, T& object, TextStream& stream { "
    }

    {
        "file_name":"SerializationTextReadWriteExact_function_2.cpp",
        "line_count":4,
        "code":"bool serialize(uint32_t index, T& object, TextStream& stream)\n    {\n        return stream.serialize(index, object);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Serialize an object at a specified index to a text stream.\n   >>> serialize(index, object, stream) returns a boolean value *\/ \nbool serialize(uint32_t index, T& object, TextStream& stream) { ",
        "query_nlx":"\/* Function named serialize takes an index, an object of type T, and a TextStream, and serializes the object using the index and the stream. \n>>> serialize(5, myObject, myStream) true \n>>> serialize(10, anotherObject, anotherStream) true *\/ \nuint32_t index, T& object, TextStream& stream;"
    }

    {
        "file_name":"SerializationTextReadWriteExact_function_4.cpp",
        "line_count":4,
        "code":"bool serialize(uint32_t index, String& object, TextStream& stream)\n    {\n        return stream.serialize(index, object);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Serialize an object at a specified index to a text stream.\n   >>> bool serialize(uint32_t index, String& object, TextStream& stream) *\/",
        "query_nlx":"\/* Function named serialize takes an unsigned 32-bit integer index, a String object, and a TextStream object as input parameters and returns a boolean value. It serializes the String object using the index and the TextStream object.\n>>> serialize(5, \"example\", stream1) true\n>>> serialize(10, \"data\", stream2) true *\/ \nbool serialize(uint32_t index, String& object, TextStream& stream) { "
    }

    {
        "file_name":"Shared_function_6.cpp",
        "line_count":1,
        "code":"void _DebugSetMute() { shared.DebugSetMute(); }",
        "mark":8.0,
        "query_nsx":"\/* Set the mute status for debugging purposes.\n   >>> _DebugSetMute() *\/ \nvoid _DebugSetMute();",
        "query_nlx":"\/* Function named _DebugSetMute calls a shared function to set the mute status for debugging purposes.\n>>> _DebugSetMute() void *\/"
    }

    {
        "file_name":"SmallVectorTest_function_1.cpp",
        "line_count":7,
        "code":"void checkItems(Container& container, size_t numItems)\n    {\n        for (size_t idx = 0; idx < numItems; ++idx)\n        {\n            SC_TEST_EXPECT(container[idx] == static_cast<int>(idx));\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the items in the container match their respective indices.\n    >>> void checkItems(Container& container, size_t numItems) { *\/",
        "query_nlx":"        \/* Function named checkItems verifies if the elements in a given container match their respective indices after being cast to integers.\n        >>> checkItems(container, 5) *\/ \n        void checkItems(Container& container, size_t numItems) {"
    }

    {
        "file_name":"SocketDescriptor_function_1.cpp",
        "line_count":1,
        "code":"AddressFamily getAddressFamily() { return addressFamily; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the address family associated with the current network address.\n   >>> getAddressFamily() IPv4\n   >>> getAddressFamily() IPv6 *\/ \nAddressFamily getAddressFamily();",
        "query_nlx":"\/* Retrieve the address family associated with a network address.\n   >>> getAddressFamily() IPv4\n   >>> getAddressFamily() IPv6 *\/ \nAddressFamily getAddressFamily() { "
    }

    {
        "file_name":"StringIterator_function_6.cpp",
        "line_count":1,
        "code":"StringEncoding getEncoding() { return StringEncoding::Ascii; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the encoding type used for string representation.\n   >>> getEncoding() Ascii *\/",
        "query_nlx":"\/* Retrieve the type of string encoding used, which is ASCII.\n>>> getEncoding() Ascii *\/ \nStringEncoding getEncoding() { "
    }

    {
        "file_name":"StringIterator_function_8.cpp",
        "line_count":1,
        "code":"StringEncoding getEncoding() { return StringEncoding::Utf16; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the encoding type used for string representation.\n   >>> getEncoding() Utf16 *\/",
        "query_nlx":"\/* Function getEncoding returns the type of string encoding used, which is UTF-16.\n   >>> getEncoding() Utf16 *\/ \nStringEncoding getEncoding() {"
    }

    {
        "file_name":"StringIterator_function_9.cpp",
        "line_count":1,
        "code":"StringEncoding getEncoding() { return StringEncoding::Utf8; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the encoding used for string manipulation.\n   >>> getEncoding() Utf8 *\/",
        "query_nlx":"\/* Function getEncoding returns the encoding type used for strings, which is UTF-8.\n   >>> getEncoding() Utf8 *\/ \nStringEncoding getEncoding() { "
    }

    {
        "file_name":"StringView_function_1.cpp",
        "line_count":1,
        "code":"bool tokenizeNextLine() { return tokenizeNext({'\\n'}); }",
        "mark":8.0,
        "query_nsx":"\/* Tokenize the next line based on a specified delimiter.\n   >>> tokenizeNextLine() *\/\nbool tokenizeNextLine();",
        "query_nlx":"\/* Function named tokenizeNextLine checks if the next character to be tokenized is a newline character.\n>>> tokenizeNextLine() returns true if the next character to be tokenized is a newline character, otherwise false *\/ \nbool tokenizeNextLine() { "
    }

    {
        "file_name":"StructureOfArrays_function_11.cpp",
        "line_count":5,
        "code":"void forEach(F&& f, ARGS&& ... args) {\n        for_each(mArrays, [&](size_t, auto* p) {\n            f(p, std::forward<ARGS>(args)...);\n        });\n    }",
        "mark":8.0,
        "query_nsx":"\/* Apply a given function to each element in an array of arrays with additional arguments.\n   >>> void forEach(F&& f, ARGS&& ... args) { *\/",
        "query_nlx":"\/* Define a function named forEach that takes a callable object f and a variable number of arguments args. \n   The function iterates over an array mArrays and applies the callable object f to each element along with the provided arguments.\n   >>> forEach(f, arg1, arg2, arg3)\n*\/ \nvoid forEach(F&& f, ARGS&& ... args) {"
    }

    {
        "file_name":"TaggedUnionTest_function_1.cpp",
        "line_count":24,
        "code":"void taggedUnionUsageSnippet(Console& console)\n{\n    \/\/ Create the tagged union on the TestUnion definition\n    TaggedUnion<TestUnion> test; \/\/ default initialized to first type (String)\n\n    \/\/ Access \/ Change type\n    String* ptr = test.field<TypeString>();\n    if (ptr) \/\/ If TypeString is not active type, ptr will be == nullptr\n    {\n        *ptr = \"SomeValue\";\n    }\n    test.changeTo<TypeInt>() = 2; \/\/ Change active type to TypeInt (compile time known)\n\n    \/\/ Switch on currently active type (TypeInt)\n    switch (test.getType())\n    {\n    case TypeString: console.print(\"String = {}\", *test.field<TypeString>()); break;\n    case TypeInt: console.print(\"Int = {}\", *test.field<TypeInt>()); break;\n    }\n\n    \/\/ Set current active type at runtime back to TypeString\n    test.setType(TypeString);\n    *test.field<TypeString>() = \"Some new string\";\n}",
        "mark":8.0,
        "query_nsx":"        \/* Implement a function that demonstrates the usage of a tagged union to store and switch between different types of data.\n        >>> taggedUnionUsageSnippet(Console& console) *\/",
        "query_nlx":"        \/* Create a tagged union that can hold different types of data and switch between them. Access and modify the data stored within the union based on the active type.\n        >>> taggedUnionUsageSnippet(Console& console) *\/"
    }

    {
        "file_name":"TaggedUnion_function_6.cpp",
        "line_count":4,
        "code":"auto visit(Visitor&& visitor, Arguments&&... args)\n    {\n        return RuntimeEnumVisit<Visitor>::visit(forward<Visitor>(visitor), type, *this, forward<Arguments>(args)...);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that allows a visitor to visit an element with optional arguments.\n   >>> auto visit(Visitor&& visitor, Arguments&&... args); *\/",
        "query_nlx":"\/* Define a function named visit that takes a visitor and a variable number of arguments, then calls a templated function to visit the elements with the provided visitor and arguments.\n   >>> visit(visitor, args...) *\/ \nauto visit(Visitor&& visitor, Arguments&&... args) {"
    }

    {
        "file_name":"TestPluginChild_function_1.cpp",
        "line_count":1,
        "code":"int multiply(int value) { return value * 2; }",
        "mark":8.0,
        "query_nsx":"\/* Define a function that multiplies the input integer value by 2.\n>>> int multiply(int value) { *\/",
        "query_nlx":"\/* Function named multiply takes an integer value and returns the result of multiplying that value by 2. \n>>> multiply(5) 10 \n>>> multiply(-3) -6 *\/ \nint multiply(int value) {"
    }

    {
        "file_name":"TestPluginChild_function_2.cpp",
        "line_count":1,
        "code":"float divide(float value) { return value \/ 2; }",
        "mark":8.0,
        "query_nsx":"\/* Divide the given value by 2. \n>>> float divide(float value) { *\/",
        "query_nlx":"\/* Function named divide takes a single floating-point value as input and returns the result of dividing that value by 2. \n>>> divide(10.0) 5.0 \n>>> divide(6.0) 3.0 *\/ \nfloat divide(float value) { "
    }

    {
        "file_name":"TestPluginChild_function_4.cpp",
        "line_count":1,
        "code":"bool close() { return true; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the operation to close the current session was successful.\n   >>> close() true *\/ \nbool close();",
        "query_nlx":"\/* Function named close checks if a certain condition is met and returns a boolean value accordingly.\n   >>> close() true *\/ \nbool close() {"
    }

    {
        "file_name":"TestPluginChild_function_5.cpp",
        "line_count":1,
        "code":"bool isPluginOriginal() { return true; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the plugin is original or not.\n>>> isPluginOriginal() true\n*\/ \nbool isPluginOriginal();",
        "query_nlx":"\/* Function named isPluginOriginal checks if a plugin is original or not.\n   >>> isPluginOriginal() true\n   >>> isPluginOriginal() false *\/ \nbool isPluginOriginal() { "
    }

    {
        "file_name":"TextInterface_function_1.cpp",
        "line_count":6,
        "code":"void Clear() {\n\t\tif (m_content)\n\t\t\tdelete[] m_content;\n\n\t\tm_content = NULL;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Clear the content stored in a variable, if any, and set it to NULL.\n   >>> Clear()\n*\/ \nvoid Clear() {",
        "query_nlx":"\/* Define a function named Clear that, if the content pointer is not null, deletes the content array and sets the content pointer to null. *\/\nvoid Clear() {"
    }

    {
        "file_name":"TextInterface_function_3.cpp",
        "line_count":3,
        "code":"void Clear() {\n\t\tm_content = \"\";\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Define a function that clears the content stored in a variable. \n>>> Clear() *\/ \nvoid Clear() {",
        "query_nlx":"\/* Define a function named Clear that sets the content of a variable to an empty string.\n>>> Clear()\n*\/ \nvoid Clear() {"
    }

    {
        "file_name":"TextInterface_function_4.cpp",
        "line_count":3,
        "code":"void Set(const std::string& text) {\n\t\tm_content = text;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the content of an object with the provided text.\n   >>> Set(\"example text\") *\/ \nvoid Set(const std::string& text) {",
        "query_nlx":"\/* Define a function that sets the content of an object to the provided text string.\n   >>> Set(\"Hello, World!\") *\/ \nvoid Set(const std::string& text) {"
    }

    {
        "file_name":"TextInterface_Win32_function_1.cpp",
        "line_count":3,
        "code":"void SetBackgroundColor(COLORREF cr) {\n\t\tm_bkColor = cr;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set the background color to the specified color value.\n   >>> SetBackgroundColor(COLORREF cr) *\/",
        "query_nlx":"\/* Define a function that sets the background color to a specified color value.\n   >>> SetBackgroundColor(color_value) *\/ \nvoid SetBackgroundColor(COLORREF cr) {"
    }

    {
        "file_name":"TextInterface_Win32_function_2.cpp",
        "line_count":3,
        "code":"void SetInvertTextColor(bool invert) {\n\t\tm_bInvertTextColor = invert;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Set whether to invert text color.\n   >>> SetInvertTextColor(true) \n   >>> SetInvertTextColor(false) *\/ \nvoid SetInvertTextColor(bool invert) {",
        "query_nlx":"\/* Function named SetInvertTextColor sets a boolean flag to determine whether text color should be inverted or not.\n>>> SetInvertTextColor(true) \n>>> SetInvertTextColor(false) *\/ \nvoid SetInvertTextColor(bool invert) {"
    }

    {
        "file_name":"TextInterface_Win32_function_3.cpp",
        "line_count":5,
        "code":"COLORREF InvertIfNeeded(COLORREF cr) {\n\t\tif (m_bInvertTextColor)\n\t\t\tcr ^= 0xffffff;\n\t\treturn cr;\n\t}",
        "mark":8.0,
        "query_nsx":"\/* Check if the color needs to be inverted based on a certain condition.\n>>> COLORREF InvertIfNeeded(COLORREF cr) { *\/",
        "query_nlx":"\/* Function named InvertIfNeeded takes a color reference as input and inverts it if a certain condition is met.\n>>> InvertIfNeeded(cr) returns the inverted color reference if m_bInvertTextColor is true, otherwise returns the original color reference *\/"
    }

    {
        "file_name":"TextInterface_Win32_function_4.cpp",
        "line_count":4,
        "code":"RECT RectToNative(const Rect& rc) {\n\tRECT rcNative{ rc.left, rc.top, rc.right, rc.bottom };\n\treturn rcNative;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a given rectangle structure to a native rectangle format.\n>>> RECT RectToNative(const Rect& rc) { *\/",
        "query_nlx":"\/* Function named RectToNative converts a given rectangle structure to a native rectangle structure by extracting the left, top, right, and bottom coordinates from the input rectangle.\n>>> RectToNative({10, 20, 30, 40}) {10, 20, 30, 40}\n>>> RectToNative({5, 10, 15, 25}) {5, 10, 15, 25} *\/ \nRECT RectToNative(const Rect& rc) {"
    }

    {
        "file_name":"TextInterface_Win32_function_9.cpp",
        "line_count":4,
        "code":"int MdGetQuoteIndentSize()\n{\n\treturn ScaleByDPI(SIZE_QUOTE_INDENT);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the size of the quote indent scaled by DPI.\n>>> MdGetQuoteIndentSize() int *\/",
        "query_nlx":"\/* Function MdGetQuoteIndentSize returns the size of the quote indent scaled by the DPI value.\n>>> MdGetQuoteIndentSize()  *\/ \nint MdGetQuoteIndentSize() { "
    }

    {
        "file_name":"ThreadPool_function_1_1.cpp",
        "line_count":5,
        "code":"task\n            if (task != nullptr)\n            {\n                task->function();\n            }",
        "mark":8.0,
        "query_nsx":"\/* Execute the function associated with a task if it is not a null pointer.\n   >>> execute_task(task) *\/ \nvoid execute_task(Task* task) {",
        "query_nlx":"\/* Check if a task object is not null, then call its function.\n   >>> task->function() *\/ \nif (task != nullptr) { "
    }

    {
        "file_name":"TMatHelpers_function_26.cpp",
        "line_count":3,
        "code":"constexpr TMatTransform() {\n        static_assert(BASE<T>::NUM_ROWS == 3 || BASE<T>::NUM_ROWS == 4, \"3x3 or 4x4 matrices only\");\n    }",
        "mark":8.0,
        "query_nsx":"\/* Ensure that the matrix transformation function only accepts 3x3 or 4x4 matrices.\n   >>> constexpr TMatTransform() { *\/",
        "query_nlx":"\/* Ensure that the template matrix transformation class TMatTransform can only be instantiated with matrices of size 3x3 or 4x4.\n   >>> TMatTransform() *\/\nconstexpr TMatTransform() { \n    static_assert(BASE<T>::NUM_ROWS == 3 || BASE<T>::NUM_ROWS == 4, \"3x3 or 4x4 matrices only\");\n}"
    }

    {
        "file_name":"TMatHelpers_function_6.cpp",
        "line_count":9,
        "code":"T determinant(Matrix<T, 3> in) {\n        return\n            in[0][0] * in[1][1] * in[2][2] +\n            in[1][0] * in[2][1] * in[0][2] +\n            in[2][0] * in[0][1] * in[1][2] -\n            in[2][0] * in[1][1] * in[0][2] -\n            in[1][0] * in[0][1] * in[2][2] -\n            in[0][0] * in[2][1] * in[1][2];\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the determinant of a 3x3 matrix.\n   >>> determinant(Matrix<T, 3> in) *\/",
        "query_nlx":"        \/* Function named determinant calculates the determinant of a 3x3 matrix by performing specific mathematical operations on its elements.\n        >>> determinant(Matrix<T, 3> in) *\/\n    "
    }

    {
        "file_name":"TMatHelpers_function_7.cpp",
        "line_count":3,
        "code":"T determinant(Matrix<T, 2> in) {\n        return in[0][0] * in[1][1] - in[0][1] * in[1][0];\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the determinant of a 2x2 matrix.\n   >>> determinant(Matrix<T, 2> in) *\/",
        "query_nlx":"        \/* Function named determinant calculates the determinant of a 2x2 matrix by multiplying the top-left and bottom-right elements and subtracting the product of the top-right and bottom-left elements.\n        >>> determinant(Matrix<T, 2> in) *\/\n        *\/"
    }

    {
        "file_name":"TQuatHelpers_function_16.cpp",
        "line_count":3,
        "code":"MATH_PURE lerp(const QUATERNION<T>& p, const QUATERNION<T>& q, T t) {\n        return ((1 - t) * p) + (t * q);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Calculate the linear interpolation between two quaternion values based on a given parameter value.\n        >>> lerp(const QUATERNION<T>& p, const QUATERNION<T>& q, T t) *\/\n        *\/",
        "query_nlx":"\/* Function named lerp calculates the linear interpolation between two quaternions p and q based on a given parameter t. \n>>> lerp(p, q, 0.5) returns the result of linear interpolation between quaternions p and q at t=0.5 \n>>> lerp(p, q, 0.2) returns the result of linear interpolation between quaternions p and q at t=0.2 *\/ \nMATH_PURE lerp(const QUATERNION<T>& p, const QUATERNION<T>& q, T t) { *\/"
    }

    {
        "file_name":"TQuatHelpers_function_17.cpp",
        "line_count":3,
        "code":"MATH_PURE nlerp(const QUATERNION<T>& p, const QUATERNION<T>& q, T t) {\n        return normalize(lerp(p, q, t));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the normalized linear interpolation between two quaternions.\n   >>> nlerp(const QUATERNION<T>& p, const QUATERNION<T>& q, T t) *\/",
        "query_nlx":"\/* Function named nlerp calculates the normalized linear interpolation between two quaternions p and q at a given interpolation factor t.\n   >>> nlerp(const QUATERNION<T>& p, const QUATERNION<T>& q, T t) \n*\/"
    }

    {
        "file_name":"TQuatHelpers_function_18.cpp",
        "line_count":3,
        "code":"MATH_PURE positive(const QUATERNION<T>& q) {\n        return q.w < 0 ? -q : q;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the input quaternion has a positive scalar component.\n   >>> positive(const QUATERNION<T>& q) *\/",
        "query_nlx":"\/* Function named positive takes a quaternion number as input and returns the quaternion itself if the real part is positive, otherwise returns the negation of the quaternion. \n>>> positive({0.5, 0.3, 0.2, -0.1}) {0.5, 0.3, 0.2, -0.1} \n>>> positive({-0.5, 0.3, 0.2, -0.1}) {-0.5, -0.3, -0.2, 0.1} *\/ \nMATH_PURE positive(const QUATERNION<T>& q) { *\/"
    }

    {
        "file_name":"TQuatHelpers_function_2.cpp",
        "line_count":3,
        "code":"MATH_PURE norm(const QUATERNION<T>& q) {\n        return std::sqrt(dot(q, q));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the norm (magnitude) of a quaternion.\n   >>> norm(const QUATERNION<T>& q) *\/",
        "query_nlx":"\/* Function norm calculates the norm of a quaternion by taking the square root of the dot product of the quaternion with itself.\n>>> norm({q.w, q.x, q.y, q.z}) q.w^2 + q.x^2 + q.y^2 + q.z^2 *\/ \nMATH_PURE norm(const QUATERNION<T>& q) { *\/"
    }

    {
        "file_name":"TQuatHelpers_function_3.cpp",
        "line_count":3,
        "code":"MATH_PURE length(const QUATERNION<T>& q) {\n        return norm(q);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the length of a quaternion.\n   >>> length(const QUATERNION<T>& q) *\/",
        "query_nlx":"\/* Function named length calculates the magnitude of a quaternion by returning the norm of the given quaternion.\n>>> length({q}) norm(q) *\/ \nMATH_PURE length(const QUATERNION<T>& q) { "
    }

    {
        "file_name":"TQuatHelpers_function_4.cpp",
        "line_count":3,
        "code":"MATH_PURE length2(const QUATERNION<T>& q) {\n        return dot(q, q);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the squared length of a quaternion.\n>>> length2(const QUATERNION<T>& q) \n*\/",
        "query_nlx":"\/* Function named length2 calculates the squared length of a quaternion by taking the dot product of the quaternion with itself. \n>>> length2({q.w, q.x, q.y, q.z}) dot(q, q) *\/ \nMATH_PURE length2(const QUATERNION<T>& q) {"
    }

    {
        "file_name":"TQuatHelpers_function_6.cpp",
        "line_count":3,
        "code":"MATH_PURE conj(const QUATERNION<T>& q) {\n        return QUATERNION<T>(q.w, -q.x, -q.y, -q.z);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Create a new quaternion by conjugating the input quaternion.\n   >>> MATH_PURE conj(const QUATERNION<T>& q){ *\/",
        "query_nlx":"        \/* Function named MATH_PURE conj takes a quaternion as input and returns a new quaternion with the conjugate values of the input quaternion. \n        >>> MATH_PURE conj(const QUATERNION<T>& q) *\/"
    }

    {
        "file_name":"TQuatHelpers_function_7.cpp",
        "line_count":3,
        "code":"MATH_PURE inverse(const QUATERNION<T>& q) {\n        return conj(q) * (T(1) \/ dot(q, q));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the inverse of a quaternion.\n   >>> inverse(const QUATERNION<T>& q) *\/",
        "query_nlx":"\/* Function named inverse calculates the inverse of a quaternion by taking the conjugate of the input quaternion and multiplying it by the reciprocal of the dot product of the quaternion with itself. \n>>> inverse({0.5, 0.3, 0.7, 0.9}) \n*\/ \nMATH_PURE inverse(const QUATERNION<T>& q) { *\/"
    }

    {
        "file_name":"TQuatHelpers_function_8.cpp",
        "line_count":3,
        "code":"MATH_PURE real(const QUATERNION<T>& q) {\n        return q.w;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return the real component of a quaternion.\n>>> real(const QUATERNION<T>& q) *\/\nMATH_PURE real(const QUATERNION<T>& q) {",
        "query_nlx":"        \/* Function named real extracts the real component of a quaternion and returns it.\n        >>> real({0.5, 0.3, 0.8, 0.2}) 0.5\n        >>> real({0.0, 0.0, 0.0, 1.0}) 0.0 *\/ \n        MATH_PURE real(const QUATERNION<T>& q) { "
    }

    {
        "file_name":"TVecHelpers_function_10.cpp",
        "line_count":3,
        "code":"MATH_PURE norm2(const VECTOR<T>& lv) {\n        return dot(lv, lv);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the squared Euclidean norm of a given vector.\n>>> norm2(const VECTOR<T>& lv) *\/",
        "query_nlx":"\/* Function norm2 calculates the squared Euclidean norm of a given vector by taking the dot product of the vector with itself.\n>>> norm2({1, 2, 3}) 14\n>>> norm2({-1, -2, -3}) 14\n*\/ \nMATH_PURE norm2(const VECTOR<T>& lv) { *\/"
    }

    {
        "file_name":"TVecHelpers_function_11.cpp",
        "line_count":3,
        "code":"MATH_PURE length2(const VECTOR<T>& lv) {\n        return norm2(lv);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the squared length of a given vector.\n   >>> length2(const VECTOR<T>& lv) *\/",
        "query_nlx":"\/* Function named length2 calculates the squared length of a given vector by calling the norm2 function.\n>>> length2({1.0, 2.0, 3.0}) 14.0\n>>> length2({-1.0, -2.0, -3.0}) 14.0 *\/ \nMATH_PURE length2(const VECTOR<T>& lv) { *\/"
    }

    {
        "file_name":"TVecHelpers_function_34.cpp",
        "line_count":3,
        "code":"MATH_PURE saturate(const VECTOR<T>& lv) {\n        return clamp(lv, T(0), T(1));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Given a vector of values, ensure that each value is within the range of 0 to 1. \n   >>> MATH_PURE saturate(const VECTOR<T>& lv) { *\/",
        "query_nlx":"\/* Function named saturate takes a vector of values and ensures that each value is clamped between 0 and 1. \n>>> saturate({0.2, 0.8, 1.5, -0.3, 0.9}) { \n*\/ \nMATH_PURE saturate(const VECTOR<T>& lv) {"
    }

    {
        "file_name":"TVecHelpers_function_43.cpp",
        "line_count":4,
        "code":"MATH_PURE smoothstep(T edge0, T edge1, VECTOR<T> v) {\n        VECTOR<T> t = saturate((v - edge0) \/ (edge1 - edge0));\n        return t * t * (T(3) - T(2) * t);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate a smooth interpolation value between two edges based on a given vector input.\n    >>> smoothstep(T edge0, T edge1, VECTOR<T> v) *\/",
        "query_nlx":"\/* Define a function named smoothstep that calculates a smooth interpolation between two edges for a given vector of values. \n   >>> smoothstep(0.0, 1.0, {0.2, 0.5, 0.8}) { \n*\/ \ntemplate<typename T> MATH_PURE smoothstep(T edge0, T edge1, VECTOR<T> v) {"
    }

    {
        "file_name":"TVecHelpers_function_8.cpp",
        "line_count":3,
        "code":"MATH_PURE norm(const VECTOR<T>& lv) {\n        return std::sqrt(dot(lv, lv));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Calculate the Euclidean norm of a given vector.\n>>> norm(const VECTOR<T>& lv) *\/",
        "query_nlx":"\/* Function norm calculates the norm of a given vector by taking the square root of the dot product of the vector with itself. \n>>> norm({1, 2, 3}) 3.7416573867739413 \n>>> norm({-1, -2, -3}) 3.7416573867739413 *\/ \nMATH_PURE norm(const VECTOR<T>& lv) { *\/"
    }

    {
        "file_name":"TypeInfo_function_1.cpp",
        "line_count":4,
        "code":"string replaceRegex(const std::string& original, const std::string& pattern, const std::string& replacement) {\n    std::regex re(pattern);\n    return std::regex_replace(original, re, replacement);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Replace all occurrences of a specified pattern in a given string with a replacement string.\n>>> string replaceRegex(const string& original, const string& pattern, const string& replacement) { *\/",
        "query_nlx":"\/* Function named replaceRegex takes an original string, a pattern string, and a replacement string, and returns the original string with all occurrences of the pattern string replaced by the replacement string using regular expressions. \n>>> replaceRegex(\"Hello, World!\", \"World\", \"Universe\") returns \"Hello, Universe!\" *\/ \n*\/"
    }

    {
        "file_name":"TypeInfo_function_3.cpp",
        "line_count":4,
        "code":"string getFriendlyTypename(const std::type_info& type, bool removeNamespace = false) {\n    std::string typeName = type.name();\n    return demangleName(typeName, removeNamespace);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a user-friendly type name from the provided type information, optionally removing the namespace.\n   >>> string getFriendlyTypename(const std::type_info& type, bool removeNamespace = false) { *\/",
        "query_nlx":"\/* Function named getFriendlyTypename retrieves a user-friendly name for a given type, potentially removing the namespace information.\n>>> getFriendlyTypename(const std::type_info& type, bool removeNamespace = false) string *\/"
    }

    {
        "file_name":"TypeInfo_function_4.cpp",
        "line_count":4,
        "code":"string getFriendlyTypename(const std::type_index& typeIndex, bool removeNamespace = false) {\n    std::string typeName = typeIndex.name();\n    return demangleName(typeName, removeNamespace);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a user-friendly type name from a given type index, optionally removing the namespace.\n   >>> string getFriendlyTypename(const std::type_index& typeIndex, bool removeNamespace = false) { *\/",
        "query_nlx":"\/* Function named getFriendlyTypename retrieves a user-friendly name for a given type index, optionally removing the namespace.\n   >>> getFriendlyTypename(std::type_index typeIndex, bool removeNamespace = false) *\/"
    }

    {
        "file_name":"UniqueHandle_function_3.cpp",
        "line_count":1,
        "code":"void detach() { handle = Invalid; }",
        "mark":8.0,
        "query_nsx":"\/* Detach the current handle from the object. \n>>> void detach() { *\/",
        "query_nlx":"\/* Define a function that sets the handle to an invalid value.\n   >>> detach() *\/ \nvoid detach() { "
    }

    {
        "file_name":"UploadDialog_function_12.cpp",
        "line_count":12,
        "code":"bool UploadDialogCheckHasUploadRights()\n{\n\tChannel* pChan = GetDiscordInstance()->GetCurrentChannel();\n\tif (!pChan)\n\t\treturn false;\n\t\n\tif (!pChan->HasPermission(PERM_SEND_MESSAGES) ||\n\t\t!pChan->HasPermission(PERM_ATTACH_FILES))\n\t\treturn false;\n\n\treturn true;\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the current channel allows uploading files and sending messages.\n>>> bool UploadDialogCheckHasUploadRights() { *\/",
        "query_nlx":"\/* Check if the current channel in the application has permission to send messages and attach files.\n   >>> UploadDialogCheckHasUploadRights() true\n   >>> UploadDialogCheckHasUploadRights() false *\/ \nbool UploadDialogCheckHasUploadRights() { "
    }

    {
        "file_name":"UploadDialog_function_16.cpp",
        "line_count":7,
        "code":"void UploadDialogShow()\n{\n\tif (!UploadDialogCheckHasUploadRights())\n\t\treturn;\n\n\tPostMessage(g_Hwnd, WM_SHOWUPLOADDIALOG, 0, 0);\n}",
        "mark":8.0,
        "query_nsx":"\/* Show upload dialog if user has upload rights.\n>>> UploadDialogShow() *\/",
        "query_nlx":"\/* Function named UploadDialogShow displays an upload dialog if the user has upload rights.\n   >>> UploadDialogShow() displays the upload dialog if the user has upload rights, otherwise does nothing *\/ \nvoid UploadDialogShow() { "
    }

    {
        "file_name":"UploadDialog_function_2.cpp",
        "line_count":4,
        "code":"void UploadDialogOnFileTooBig(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_TOO_BIG), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}",
        "mark":8.0,
        "query_nsx":"\/* Display an error message in a dialog box if the uploaded file is too big.\n>>> void UploadDialogOnFileTooBig(HWND hWnd) *\/",
        "query_nlx":"\/* Function named UploadDialogOnFileTooBig displays a message box with an error icon and an OK button when a file is too big to upload.\n>>> UploadDialogOnFileTooBig(hWnd) *\/ \nvoid UploadDialogOnFileTooBig(HWND hWnd) { "
    }

    {
        "file_name":"UploadDialog_function_3.cpp",
        "line_count":4,
        "code":"void UploadDialogOnEmptyFile(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_EMPTY), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}",
        "mark":8.0,
        "query_nsx":"\/* Display an error message in a message box if the file is empty.\n>>> void UploadDialogOnEmptyFile(HWND hWnd) { *\/",
        "query_nlx":"\/* Function named UploadDialogOnEmptyFile displays an error message dialog box with a specific message when a file is empty.\n>>> UploadDialogOnEmptyFile(HWND hWnd) *\/"
    }

    {
        "file_name":"UploadDialog_function_4.cpp",
        "line_count":4,
        "code":"void UploadDialogOutOfMemory(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_OUT_OF_MEMORY), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}",
        "mark":8.0,
        "query_nsx":"\/* Display an error message dialog indicating that the file upload operation failed due to insufficient memory.\n>>> void UploadDialogOutOfMemory(HWND hWnd) { *\/",
        "query_nlx":"\/* Function named UploadDialogOutOfMemory displays a message box with an error icon and an OK button, showing the message \"Out of memory\" related to a specific program. \n>>> UploadDialogOutOfMemory(HWND hWnd) *\/"
    }

    {
        "file_name":"UploadDialog_function_5.cpp",
        "line_count":4,
        "code":"void UploadDialogCantReadFile(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_NO_READ), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}",
        "mark":8.0,
        "query_nsx":"\/* Display an error message in a dialog window when unable to read a file.\n>>> void UploadDialogCantReadFile(HWND hWnd) { *\/",
        "query_nlx":"\/* Function named UploadDialogCantReadFile displays a message box with an error icon stating that the program cannot read a file. \n>>> UploadDialogCantReadFile(hWnd) *\/ \nvoid UploadDialogCantReadFile(HWND hWnd) { "
    }

    {
        "file_name":"UploadDialog_function_6.cpp",
        "line_count":4,
        "code":"void UploadDialogCantOpenFile(HWND hWnd)\n{\n\tMessageBox(hWnd, TmGetTString(IDS_FILE_NO_OPEN), TmGetTString(IDS_PROGRAM_NAME), MB_OK | MB_ICONERROR);\n}",
        "mark":8.0,
        "query_nsx":"\/* Display an error message in a message box indicating that a file cannot be opened.\n>>> UploadDialogCantOpenFile(HWND hWnd) *\/",
        "query_nlx":"\/* Create a function that displays an error message in a dialog window when attempting to open a file fails.\n   >>> UploadDialogCantOpenFile(HWND hWnd) *\/"
    }

    {
        "file_name":"UploadDialog_function_7.cpp",
        "line_count":4,
        "code":"int FailAndClose(HANDLE hFile, int errorCode) {\n\tCloseHandle(hFile);\n\treturn errorCode;\n}",
        "mark":8.0,
        "query_nsx":"\/* Close the file handle and return the error code.\n>>> int FailAndClose(HANDLE hFile, int errorCode) *\/",
        "query_nlx":"\/* Function named FailAndClose closes a file handle and returns an error code.\n>>> FailAndClose(hFile, errorCode) \n*\/ \nint FailAndClose(HANDLE hFile, int errorCode) {"
    }

    {
        "file_name":"UploadDialog_function_8.cpp",
        "line_count":5,
        "code":"int FailDeallocAndClose(HANDLE hFile, BYTE*& pbFileData, int errorCode) {\n\tdelete[] pbFileData;\n\tpbFileData = NULL;\n\treturn FailAndClose(hFile, errorCode);\n}",
        "mark":8.0,
        "query_nsx":"\/* Deallocate memory and close a file handle after encountering an error.\n>>> int FailDeallocAndClose(HANDLE hFile, BYTE*& pbFileData, int errorCode) *\/",
        "query_nlx":"\n\/* Function named FailDeallocAndClose deallocates memory pointed to by pbFileData, sets it to NULL, and then calls another function FailAndClose with the given parameters. \n>>> FailDeallocAndClose(hFile, pbFileData, errorCode) *\/ \nint FailDeallocAndClose(HANDLE hFile, BYTE*& pbFileData, int errorCode) {"
    }

    {
        "file_name":"Util_function_11.cpp",
        "line_count":9,
        "code":"int StringCompareCaseInsens(const char* s1, const char* s2)\n{\n\twhile (tolower(*s1) == tolower(*s2)) {\n\t\tif (*s1 == '\\0') break;\n\t\ts1++, s2++;\n\t}\n\n\treturn tolower(*s1) - tolower(*s2);\n}",
        "mark":8.0,
        "query_nsx":"\/* Compare two strings case-insensitively and return the result of the comparison.\n>>> int StringCompareCaseInsens(const char* s1, const char* s2) { *\/",
        "query_nlx":"\/* Function named StringCompareCaseInsens compares two strings case-insensitively and returns the difference between the first differing characters. \n>>> StringCompareCaseInsens(\"hello\", \"Hello\") 0 \n>>> StringCompareCaseInsens(\"abc\", \"def\") -3 *\/ \nint StringCompareCaseInsens(const char* s1, const char* s2) {"
    }

    {
        "file_name":"Util_function_14.cpp",
        "line_count":7,
        "code":"bool BeginsWithCaseInsens(const std::string& what, const std::string& with)\n{\n\tif (what.size() < with.size())\n\t\treturn false;\n\n\treturn StringCompareCaseInsensLimited(what.c_str(), with.c_str(), with.size()) == 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if a string begins with another string in a case-insensitive manner.\n>>> bool BeginsWithCaseInsens(const std::string& what, const std::string& with) { *\/",
        "query_nlx":"\/* Function checks if a given string starts with another string in a case-insensitive manner.\n>>> BeginsWithCaseInsens(\"Hello World\", \"hello\") true\n>>> BeginsWithCaseInsens(\"programming\", \"gram\") false *\/ \nbool BeginsWithCaseInsens(const std::string& what, const std::string& with) { "
    }

    {
        "file_name":"Util_function_17.cpp",
        "line_count":10,
        "code":"bool IsPotentiallyDangerousDownload(const std::string& filename)\n{\n\treturn\n\t\tEndsWithCaseInsens(filename, \".exe\") ||\n\t\tEndsWithCaseInsens(filename, \".bat\") ||\n\t\tEndsWithCaseInsens(filename, \".com\") ||\n\t\tEndsWithCaseInsens(filename, \".vbs\") ||\n\t\tEndsWithCaseInsens(filename, \".cmd\") ||\n\t\tEndsWithCaseInsens(filename, \".scr\");\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if a given filename is potentially dangerous based on its extension.\n   >>> bool IsPotentiallyDangerousDownload(const std::string& filename) *\/",
        "query_nlx":"\/* Determine if a given filename is potentially dangerous based on its extension.\n>>> IsPotentiallyDangerousDownload(\"example.exe\") true\n>>> IsPotentiallyDangerousDownload(\"document.pdf\") false *\/ \nbool IsPotentiallyDangerousDownload(const std::string& filename) { "
    }

    {
        "file_name":"Util_function_18.cpp",
        "line_count":4,
        "code":"int64_t ExtractTimestamp(Snowflake sf)\n{\n\treturn (sf >> 22) + 1420070400000;\n}",
        "mark":8.0,
        "query_nsx":"\/* Extract timestamp from a given Snowflake value.\n>>> int64_t ExtractTimestamp(Snowflake sf) *\/",
        "query_nlx":"\/* Function named ExtractTimestamp calculates the timestamp value from a given Snowflake value by shifting it by 22 bits to the right and adding 1420070400000.\n>>> ExtractTimestamp(Snowflake sf) int64_t { *\/"
    }

    {
        "file_name":"Util_function_2.cpp",
        "line_count":4,
        "code":"string GetBasePath()\n{\n\treturn g_BasePath;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the base path where the current file or directory is located.\n>>> GetBasePath() \n*\/",
        "query_nlx":"\/* Function named GetBasePath returns the base path stored in a variable.\n>>> GetBasePath() \"\/path\/to\/base\"\n*\/ \nstring GetBasePath() {"
    }

    {
        "file_name":"Util_function_22.cpp",
        "line_count":7,
        "code":"string GetGlobalName(const nlohmann::json& j)\n{\n\tif (j.contains(\"global_name\") && !j[\"global_name\"].is_null())\n\t\treturn GetFieldSafe(j, \"global_name\");\n\telse\n\t\treturn GetFieldSafe(j, \"username\");\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the global name from a JSON object if available; otherwise, fallback to the username field.\n>>> string GetGlobalName(const nlohmann::json& j) *\/",
        "query_nlx":"\/* Function named GetGlobalName retrieves the global name from a JSON object if it exists; otherwise, it returns the username field.\n>>> GetGlobalName({\"global_name\": \"John Doe\"}) returns \"John Doe\"\n>>> GetGlobalName({\"username\": \"Jane Smith\"}) returns \"Jane Smith\"\n*\/ \nstring GetGlobalName(const nlohmann::json& j) { "
    }

    {
        "file_name":"Util_function_23.cpp",
        "line_count":10,
        "code":"string GetUsername(const nlohmann::json& j)\n{\n\tstd::string username = GetFieldSafe(j, \"username\");\n\tint discrim = int(GetIntFromString(GetFieldSafe(j, \"discriminator\")));\n\n\tif (discrim > 0)\n\t\tusername += \"#\" + FormatDiscrim(discrim);\n\n\treturn username;\n}",
        "mark":8.0,
        "query_nsx":"\/* Extract and format a username from a JSON object, including a discriminator if it is greater than zero.\n>>> string GetUsername(const nlohmann::json& j) { *\/",
        "query_nlx":"\/* Function named GetUsername extracts a username from a JSON object and formats it with a discriminator if it is greater than zero.\n>>> GetUsername({\"username\": \"john_doe\", \"discriminator\": \"1234\"}) returns \"john_doe#1234\"\n>>> GetUsername({\"username\": \"jane_smith\", \"discriminator\": \"0\"}) returns \"jane_smith\" *\/ \nstring GetUsername(const nlohmann::json& j) {"
    }

    {
        "file_name":"Util_function_3.cpp",
        "line_count":4,
        "code":"string GetCachePath()\n{\n\treturn g_BasePath + \"\\\\cache\";\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the path where the cache is stored.\n>>> GetCachePath() \n*\/",
        "query_nlx":"\/* Define a function that returns the path to the cache directory by appending the base path with a subdirectory named \"cache\".\n>>> GetCachePath() \"g_BasePath + \"\\\\cache\"\" *\/ \nstring GetCachePath() {  \/\/ Function signature."
    }

    {
        "file_name":"Util_function_37.cpp",
        "line_count":4,
        "code":"float GetAppVersion()\n{\n\treturn 1.07f;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the current version number of the application.\n>>> GetAppVersion() 1.07 *\/",
        "query_nlx":"\/* Retrieve the application version number as a floating-point value.\n>>> GetAppVersion() 1.07 *\/ \nfloat GetAppVersion() { "
    }

    {
        "file_name":"Util_function_38.cpp",
        "line_count":4,
        "code":"string GetAppVersionString()\n{\n\treturn \"V1.07\";\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the version string of the application.\n   >>> GetAppVersionString() \"V1.07\" *\/",
        "query_nlx":"\/* Retrieve the application version string that is \"V1.07\".\n>>> GetAppVersionString() \"V1.07\" *\/ \nstring GetAppVersionString() { "
    }

    {
        "file_name":"Util_function_39.cpp",
        "line_count":39,
        "code":"string FormatDuration(int seconds)\n{\n\tint minutes = seconds \/ 60;\n\tseconds %= 60;\n\tint hours   = minutes \/ 60;\n\tminutes %= 60;\n\tint days    = hours \/ 24;\n\thours %= 24;\n\n\tstd::string result;\n\tif (days) {\n\t\tresult += std::to_string(days);\n\t\tif (days == 1) result += \" day\";\n\t\telse           result += \" days\";\n\t}\n\tif (hours) {\n\t\tif (!result.empty()) result += \", \";\n\t\tresult += std::to_string(hours);\n\t\tif (hours == 1) result += \" hr\";\n\t\telse            result += \" hrs\";\n\t}\n\tif (minutes) {\n\t\tif (!result.empty()) result += \", \";\n\t\tresult += std::to_string(minutes);\n\t\tif (minutes == 1) result += \" min\";\n\t\telse              result += \" mins\";\n\t}\n\tif (seconds) {\n\t\tif (!result.empty()) result += \", \";\n\t\tresult += std::to_string(seconds);\n\t\tif (seconds == 1) result += \" sec\";\n\t\telse              result += \" secs\";\n\t}\n\tif (result.empty()) {\n\t\tresult = \"0 secs\";\n\t}\n\n\treturn result;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a given number of seconds into a human-readable duration format including days, hours, minutes, and seconds.\n>>> string FormatDuration(int seconds) *\/",
        "query_nlx":"\/* Function named FormatDuration converts a given number of seconds into a human-readable duration format. \n   >>> FormatDuration(3661) \"1 hr, 1 min, 1 sec\"\n   >>> FormatDuration(60) \"1 min\"\n   >>> FormatDuration(86400) \"1 day\" *\/"
    }

    {
        "file_name":"Util_function_4.cpp",
        "line_count":9,
        "code":"long BitMix(uint64_t lol)\n{\n\tlol ^= lol >> 33;\n\tlol *= 0xff51afd7ed558ccdLL;\n\tlol ^= lol >> 33;\n\tlol *= 0xc4ceb9fe1a85ec53LL;\n\tlol ^= lol >> 33;\n\treturn lol;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate a mixed bit value based on the input unsigned 64-bit integer.\n   >>> BitMix(lol) *\/ \nuint64_t BitMix(uint64_t lol) { ",
        "query_nlx":"\/* Function named BitMix performs a series of bitwise operations on a given 64-bit unsigned integer to mix its bits effectively. \n>>> BitMix(123456789) 987654321 \n>>> BitMix(987654321) 123456789 *\/ \nuint64_t BitMix(uint64_t lol) { "
    }

    {
        "file_name":"VectorMap_function_2.cpp",
        "line_count":8,
        "code":"bool insertIfNotExists(Item&& item)\n    {\n        if (not contains(item.key))\n        {\n            return items.push_back(forward<Item>(item));\n        }\n        return false;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert an item into a collection if it does not already exist based on a key.\n>>> bool insertIfNotExists(Item&& item); *\/",
        "query_nlx":"\/* Function named insertIfNotExists inserts an item into a collection if it does not already exist based on the key of the item. \n>>> insertIfNotExists({key: \"A\", value: 10}) true \n>>> insertIfNotExists({key: \"B\", value: 20}) true \n>>> insertIfNotExists({key: \"A\", value: 30}) false *\/ \nbool insertIfNotExists(Item&& item) { "
    }

    {
        "file_name":"VectorMap_function_3.cpp",
        "line_count":12,
        "code":"bool contains(const ComparableToKey& key, Value*& outValue)\n    {\n        for (auto& item : items)\n        {\n            if (item.key == key)\n            {\n                outValue = &item.value;\n                return true;\n            }\n        }\n        return false;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the provided key exists in the collection and return its corresponding value if found.\n    >>> bool contains(const ComparableToKey& key, Value*& outValue) *\/",
        "query_nlx":"\/* Function named contains searches for a specific key in a collection of items and returns the corresponding value if found.\n   >>> contains(\"search_key\", value_ptr) true\n   >>> contains(\"non_existent_key\", value_ptr) false *\/ \nbool contains(const ComparableToKey& key, Value*& outValue) { "
    }

    {
        "file_name":"VectorSet_function_1.cpp",
        "line_count":4,
        "code":"bool contains(const ComparableToValue& value)\n    {\n        return items.contains(value);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the collection contains a value similar to the specified value.\n>>> bool contains(const ComparableToValue& value) { *\/",
        "query_nlx":"\/* Function named contains checks if a given value is present in a collection of items.\n   >>> contains(\"apple\") true\n   >>> contains(5) false *\/ \nbool contains(const ComparableToValue& value) {"
    }

    {
        "file_name":"VectorSet_function_3.cpp",
        "line_count":4,
        "code":"bool remove(const ComparableToValue& value)\n    {\n        return items.remove(value);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove the specified value from the collection if it exists.\n   >>> bool remove(const ComparableToValue& value); *\/",
        "query_nlx":"\/* Function named remove checks if a specific value can be removed from a collection of items.\n>>> remove(item1) true\n>>> remove(item2) false *\/ \nbool remove(const ComparableToValue& value) { "
    }

    {
        "file_name":"VectorTest_function_1.cpp",
        "line_count":5,
        "code":"void push(Operation operation)\n    {\n        SC_ASSERT_DEBUG(numSequences < MAX_SEQUENCES);\n        sequence[numSequences++] = operation;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Implement a function to add an operation to a sequence.\n   >>> void push(Operation operation) *\/",
        "query_nlx":"\/* Define a function that adds an operation to a sequence, ensuring that the number of sequences does not exceed a maximum limit.\n>>> push(Operation operation) *\/"
    }

    {
        "file_name":"VectorTest_function_2.cpp",
        "line_count":5,
        "code":"void reset()\n    {\n        numSequences     = 0;\n        numNextSequences = 0;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Reset the number of sequences and the number of next sequences to zero.\n   >>> reset() *\/ \nvoid reset() {",
        "query_nlx":"\/* Define a function named reset that sets the values of numSequences and numNextSequences to zero. \n   >>> reset() *\/ \nvoid reset() {"
    }

    {
        "file_name":"VectorTest_function_4.cpp",
        "line_count":9,
        "code":"size_t dataLength(const char* str)\n    {\n        size_t idx = 0;\n        while (str[idx] != 0)\n        {\n            ++idx;\n        }\n        return idx;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine the length of a given string.\n    >>> size_t dataLength(const char* str) *\/",
        "query_nlx":"\/* Function named dataLength calculates the length of a given string by iterating through its characters until reaching the null terminator.\n   >>> dataLength(\"hello\") returns 5\n   >>> dataLength(\"world\") returns 5 *\/ \nsize_t dataLength(const char* str) { "
    }

    {
        "file_name":"Vector_function_3.cpp",
        "line_count":1,
        "code":"bool push_back(const T& element) { return Operations::push_back(items, element); }",
        "mark":8.0,
        "query_nsx":"\/* Check if an element can be added to the end of a collection.\n   >>> push_back({1, 2, 3}, 4) true\n   >>> push_back({5, 6, 7}, 8) true *\/ \nbool push_back(const T& element) { ",
        "query_nlx":"\/* Function named push_back adds an element to the end of a collection and returns a boolean value indicating success or failure.\n>>> push_back({1, 2, 3}, 4) true\n>>> push_back({5, 6, 7}, 8) true *\/ \nbool push_back(const T& element) { "
    }

    {
        "file_name":"Vector_function_4.cpp",
        "line_count":1,
        "code":"bool push_back(T&& element) { return Operations::push_back(items, move(element)); }",
        "mark":8.0,
        "query_nsx":"\/* Add an element to the end of a collection and return a boolean indicating success.\n   >>> push_back(element: T) -> bool { *\/",
        "query_nlx":"\/* Define a function that adds an element to the end of a collection and returns a boolean value indicating success.\n   >>> push_back(element) adds the given element to the collection and returns true if successful, false otherwise *\/ \nbool push_back(T&& element) { "
    }

    {
        "file_name":"Vector_function_5.cpp",
        "line_count":1,
        "code":"bool pop_back() { return Operations::pop_back(items); }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the last element can be removed from a collection.\n>>> pop_back() *\/",
        "query_nlx":"\/* Function named pop_back checks if the last element in a collection can be removed successfully.\n>>> pop_back() true\n>>> pop_back() false *\/ \nbool pop_back() { "
    }

    {
        "file_name":"Vector_function_6.cpp",
        "line_count":1,
        "code":"bool pop_front() { return Operations::pop_front(items); }",
        "mark":8.0,
        "query_nsx":"\/* Remove the first element from a collection of items.\n>>> pop_front() *\/",
        "query_nlx":"\/* Function named pop_front checks if the first element can be removed from a collection of items using a specific operation.\n>>> pop_front() true\n>>> pop_front() false *\/ \nbool pop_front() { "
    }

    {
        "file_name":"Vector_function_7.cpp",
        "line_count":1,
        "code":"void clearWithoutInitializing() { (void)resizeWithoutInitializing(0); }",
        "mark":8.0,
        "query_nsx":"\/* Clear the content of a data structure without reinitializing it.\n>>> void clearWithoutInitializing() { *\/",
        "query_nlx":"\/* Define a function that clears a data structure without initializing its elements.\n   >>> clearWithoutInitializing() *\/ \nvoid clearWithoutInitializing() { (void)resizeWithoutInitializing(0); }"
    }

    {
        "file_name":"Vector_function_8.cpp",
        "line_count":1,
        "code":"bool shrink_to_fit() { return Operations::shrink_to_fit(items); }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the items in the collection can be reduced in size efficiently. \n>>> shrink_to_fit() true \n*\/",
        "query_nlx":"\/* Function named shrink_to_fit checks if the items in a collection can be reduced in size to fit the actual number of elements stored in it efficiently. \n>>> shrink_to_fit() true \n>>> shrink_to_fit() false *\/ \nbool shrink_to_fit() {"
    }

    {
        "file_name":"Vector_function_9.cpp",
        "line_count":1,
        "code":"bool removeAt(size_t index) { return Operations::removeAt(items, index); }",
        "mark":8.0,
        "query_nsx":"\/* Remove an item at the specified index from a collection.\n   >>> removeAt(index) \n*\/ \nbool removeAt(size_t index) { ",
        "query_nlx":"\/* Function named removeAt takes an index as input and removes the element at that index from a collection of items.\n>>> removeAt(2) true\n>>> removeAt(5) false *\/ \nbool removeAt(size_t index) { "
    }

    {
        "file_name":"ViewerGui_function_1.cpp",
        "line_count":1,
        "code":"void enableWireframe(bool b) { mEnableWireframe = b; }",
        "mark":9.0,
        "query_nsx":"\/* Enable or disable wireframe mode.\n>>> enableWireframe(true) \n>>> enableWireframe(false) *\/ \nvoid enableWireframe(bool b) { ",
        "query_nlx":"\/* Function named enableWireframe sets a boolean variable to enable or disable wireframe rendering.\n>>> enableWireframe(true) \n>>> enableWireframe(false) *\/ \nvoid enableWireframe(bool b) { "
    }

    {
        "file_name":"ViewerGui_function_2.cpp",
        "line_count":1,
        "code":"void enableSunlight(bool b) { mSettings.lighting.enableSunlight = b; }",
        "mark":9.0,
        "query_nsx":"\/* Enable or disable the sunlight in the lighting settings.\n   >>> enableSunlight(true) \n   >>> enableSunlight(false) *\/ \nvoid enableSunlight(bool b) { \/* function body omitted *\/ }",
        "query_nlx":"\/* Function named enableSunlight sets the enableSunlight property in the lighting settings to the provided boolean value.\n>>> enableSunlight(true) \n>>> enableSunlight(false) *\/ \nvoid enableSunlight(bool b) { "
    }

    {
        "file_name":"ViewerGui_function_3.cpp",
        "line_count":3,
        "code":"void enableDithering(bool b) {\n        mSettings.view.dithering = b ? Dithering::TEMPORAL : Dithering::NONE;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the dithering mode for the view to either temporal or none.\n   >>> enableDithering(true) \n   >>> enableDithering(false) *\/ \nvoid enableDithering(bool b) {",
        "query_nlx":"\/* Function named enableDithering sets the dithering mode of a view to either temporal or none based on a boolean input.\n>>> enableDithering(true) sets the dithering mode to temporal\n>>> enableDithering(false) sets the dithering mode to none *\/ \nvoid enableDithering(bool b) {"
    }

    {
        "file_name":"ViewerGui_function_4.cpp",
        "line_count":3,
        "code":"void enableFxaa(bool b) {\n        mSettings.view.antiAliasing = b ? AntiAliasing::FXAA : AntiAliasing::NONE;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Enable or disable FXAA anti-aliasing setting.\n   >>> enableFxaa(true) \n   >>> enableFxaa(false) *\/ \n   void enableFxaa(bool b) {",
        "query_nlx":"\/* Function named enableFxaa sets the anti-aliasing setting to FXAA if the input boolean is true, otherwise sets it to NONE.\n>>> enableFxaa(true) sets the anti-aliasing to FXAA\n>>> enableFxaa(false) sets the anti-aliasing to NONE *\/ \nvoid enableFxaa(bool b) {"
    }

    {
        "file_name":"ViewerGui_function_5.cpp",
        "line_count":4,
        "code":"void enableMsaa(bool b) {\n        mSettings.view.msaa.sampleCount = 4;\n        mSettings.view.msaa.enabled = b;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Enable or disable multisample anti-aliasing (MSAA) with a sample count of 4.\n   >>> enableMsaa(true) \n   >>> enableMsaa(false) *\/ \nvoid enableMsaa(bool b) {",
        "query_nlx":"        \/* Function named enableMsaa sets the MSAA sample count to 4 and enables or disables MSAA based on the input boolean value.\n        >>> enableMsaa(true) sets the MSAA sample count to 4 and enables MSAA\n        >>> enableMsaa(false) sets the MSAA sample count to 4 and disables MSAA *\/ \n        void enableMsaa(bool b) {"
    }

    {
        "file_name":"ViewerGui_function_6.cpp",
        "line_count":1,
        "code":"void enableSSAO(bool b) { mSettings.view.ssao.enabled = b; }",
        "mark":8.0,
        "query_nsx":"\/* Enable or disable screen space ambient occlusion (SSAO) effect in the view settings.\n>>> enableSSAO(true) \n>>> enableSSAO(false) *\/ \nvoid enableSSAO(bool b) { ",
        "query_nlx":"\/* Function named enableSSAO sets the SSAO (Screen Space Ambient Occlusion) feature to either enabled or disabled based on the boolean input parameter.\n>>> enableSSAO(true) sets SSAO enabled\n>>> enableSSAO(false) sets SSAO disabled *\/ \nvoid enableSSAO(bool b) { "
    }

    {
        "file_name":"ViewerGui_function_7.cpp",
        "line_count":1,
        "code":"void enableBloom(bool bloom) { mSettings.view.bloom.enabled = bloom; }",
        "mark":8.0,
        "query_nsx":"\/* Enable or disable the bloom effect in the view settings.\n>>> void enableBloom(bool bloom); *\/",
        "query_nlx":"\/* Function named enableBloom sets the bloom effect in the view settings to either enabled or disabled based on the input boolean value.\n>>> enableBloom(true) sets the bloom effect to enabled\n>>> enableBloom(false) sets the bloom effect to disabled *\/ \nvoid enableBloom(bool bloom) { "
    }

    {
        "file_name":"ViewerGui_function_8.cpp",
        "line_count":1,
        "code":"void setIBLIntensity(float brightness) { mSettings.lighting.iblIntensity = brightness; }",
        "mark":9.0,
        "query_nsx":"\/* Set the intensity of image-based lighting (IBL) to the specified brightness level.\n>>> void setIBLIntensity(float brightness) { *\/",
        "query_nlx":"\/* Function named setIBLIntensity sets the intensity of image-based lighting to a specified brightness level.\n>>> setIBLIntensity(0.8) \n*\/ \nvoid setIBLIntensity(float brightness) { "
    }

    {
        "file_name":"ViewerGui_function_9.cpp",
        "line_count":1,
        "code":"void stopAnimation() { mCurrentAnimation = -1; }",
        "mark":8.0,
        "query_nsx":"\/* Stop the current animation.\n   >>> void stopAnimation() { *\/",
        "query_nlx":"\/* Define a function that stops the current animation by setting the current animation index to -1. \n   >>> stopAnimation() *\/ \nvoid stopAnimation() { "
    }

    {
        "file_name":"WebServerExample_function_10.cpp",
        "line_count":1,
        "code":"bool close() { return true; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the operation to close the current session was successful.\n   >>> close() true *\/",
        "query_nlx":"\/* Function named close checks if a certain condition is met and returns a boolean value accordingly. \n>>> close() true *\/ \nbool close() {"
    }

    {
        "file_name":"WebServerExample_function_11.cpp",
        "line_count":5,
        "code":"Result initAsync(SC::AsyncEventLoop& eventLoop)\n    {\n        model.eventLoop = &eventLoop;\n        return SC::Result(true);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Initialize the event loop with the provided asynchronous event loop and return a successful result.\n   >>> Result initAsync(SC::AsyncEventLoop& eventLoop) *\/",
        "query_nlx":"\/* Initialize an asynchronous event loop by assigning the provided event loop to the model's event loop and return a successful result.\n   >>> initAsync(eventLoop) Result(true) *\/\nResult initAsync(SC::AsyncEventLoop& eventLoop) {"
    }

    {
        "file_name":"WebServerExample_function_9.cpp",
        "line_count":1,
        "code":"bool init() { return view.init(); }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the view is initialized or not.\n>>> bool init() { *\/",
        "query_nlx":"\/* Function named init checks if a view can be initialized successfully.\n>>> init() returns a boolean value indicating if the view was initialized successfully or not. *\/ \nbool init() { "
    }

    {
        "file_name":"Wininet_function_250.cpp",
        "line_count":1,
        "code":"void _ResumeSuspendedDownload() { wininet.ResumeSuspendedDownload(); }",
        "mark":8.0,
        "query_nsx":"\/* Resume a previously suspended download operation.\n>>> _ResumeSuspendedDownload() *\/ \nvoid _ResumeSuspendedDownload();",
        "query_nlx":"\/* Function named _ResumeSuspendedDownload calls a function named ResumeSuspendedDownload from a library named wininet to resume a download that was previously suspended. \n>>> _ResumeSuspendedDownload() *\/ \nvoid _ResumeSuspendedDownload() { "
    }

    {
        "file_name":"Wininet_function_267.cpp",
        "line_count":1,
        "code":"void _ShowClientAuthCerts() { wininet.ShowClientAuthCerts(); }",
        "mark":8.0,
        "query_nsx":"\/* Show client authentication certificates.\n>>> _ShowClientAuthCerts() *\/\nvoid _ShowClientAuthCerts();",
        "query_nlx":"\/* Function named _ShowClientAuthCerts calls a function to display client authentication certificates.\n>>> _ShowClientAuthCerts() void *\/"
    }

    {
        "file_name":"Winmm_function_167.cpp",
        "line_count":1,
        "code":"void _waveInStop() { winmm.waveInStop(); }",
        "mark":8.0,
        "query_nsx":"\/* Stop the wave input operation.\n>>> _waveInStop() *\/ \nvoid _waveInStop() {  }",
        "query_nlx":"\/* Function named _waveInStop stops the currently running audio input recording process.\n   >>> _waveInStop() *\/ \nvoid _waveInStop() {  \/\/ Function signature\n    winmm.waveInStop();  \/\/ Body omitted\n}  \/\/ End of function"
    }

    {
        "file_name":"Winmm_function_185.cpp",
        "line_count":1,
        "code":"void _waveOutReset() { winmm.waveOutReset(); }",
        "mark":8.0,
        "query_nsx":"\/* Reset the audio output device. \n>>> void _waveOutReset() { *\/",
        "query_nlx":"\/* Reset the audio output device to its initial state by calling the appropriate system function.\n   >>> _waveOutReset() *\/\nvoid _waveOutReset() {  }"
    }

    {
        "file_name":"Winmm_function_186.cpp",
        "line_count":1,
        "code":"void _waveOutRestart() { winmm.waveOutRestart(); }",
        "mark":8.0,
        "query_nsx":"\/* Restart the audio output. \n>>> void _waveOutRestart() { *\/",
        "query_nlx":"\/* Function named _waveOutRestart restarts the audio output device to resume playback.\n>>> _waveOutRestart() void *\/"
    }

    {
        "file_name":"Winmm_function_24.cpp",
        "line_count":1,
        "code":"void _joyConfigChanged() { winmm.joyConfigChanged(); }",
        "mark":8.0,
        "query_nsx":"\/* Invoke a function to handle changes in joystick configuration.\n>>> void _joyConfigChanged() { *\/",
        "query_nlx":"\/* Function _joyConfigChanged calls a function to handle changes in joystick configuration.\n   >>> _joyConfigChanged() calls the winmm.joyConfigChanged() function *\/ \nvoid _joyConfigChanged() {  \/\/ Function signature\n    winmm.joyConfigChanged();  \/\/ Function body (omitted)\n}  \/\/ End of function"
    }

    {
        "file_name":"Winmm_function_36.cpp",
        "line_count":1,
        "code":"void _mciDriverYield() { winmm.mciDriverYield(); }",
        "mark":8.0,
        "query_nsx":"\/* Execute a function that yields control to the driver for multimedia devices. \n>>> _mciDriverYield() *\/ \nvoid _mciDriverYield();",
        "query_nlx":"\/* Define a function that calls the driver yield function from the multimedia control interface library.\n   >>> _mciDriverYield() void *\/"
    }

    {
        "file_name":"Winmm_function_59.cpp",
        "line_count":1,
        "code":"void _midiInClose() { winmm.midiInClose(); }",
        "mark":8.0,
        "query_nsx":"\/* Close the MIDI input device. \n>>> void _midiInClose() { *\/",
        "query_nlx":"\/* Function named _midiInClose calls a function to close the MIDI input device.\n   >>> _midiInClose() *\/ \nvoid _midiInClose() {  }"
    }

    {
        "file_name":"Winmm_function_69.cpp",
        "line_count":1,
        "code":"void _midiInReset() { winmm.midiInReset(); }",
        "mark":8.0,
        "query_nsx":"\/* Reset the MIDI input device. \n>>> _midiInReset() *\/ \nvoid _midiInReset();",
        "query_nlx":"\/* Function named _midiInReset resets the MIDI input device.\n>>> _midiInReset() void *\/"
    }

    {
        "file_name":"Winmm_function_70.cpp",
        "line_count":1,
        "code":"void _midiInStart() { winmm.midiInStart(); }",
        "mark":8.0,
        "query_nsx":"\/* Start the MIDI input. \n>>> void _midiInStart() { *\/",
        "query_nlx":"\/* Function named _midiInStart calls a function to start MIDI input. \n>>> _midiInStart() void *\/"
    }

    {
        "file_name":"Winmm_function_71.cpp",
        "line_count":1,
        "code":"void _midiInStop() { winmm.midiInStop(); }",
        "mark":8.0,
        "query_nsx":"\/* Stop the MIDI input. \n>>> void _midiInStop() { *\/",
        "query_nlx":"\/* Function named _midiInStop stops the MIDI input process.\n>>> _midiInStop() winmm.midiInStop() *\/"
    }

    {
        "file_name":"Winmm_function_87.cpp",
        "line_count":1,
        "code":"void _midiOutReset() { winmm.midiOutReset(); }",
        "mark":8.0,
        "query_nsx":"\/* Reset the MIDI output device. \n>>> void _midiOutReset() { *\/",
        "query_nlx":"\/* Reset the MIDI output device to its initial state.\n   >>> _midiOutReset() *\/\nvoid _midiOutReset() {  }"
    }

    {
        "file_name":"Winmm_function_94.cpp",
        "line_count":1,
        "code":"void _midiStreamPause() { winmm.midiStreamPause(); }",
        "mark":8.0,
        "query_nsx":"\/* Pause the MIDI stream.\n>>> _midiStreamPause() *\/ \nvoid _midiStreamPause();",
        "query_nlx":"\/* Function named _midiStreamPause pauses the MIDI stream.\n>>> _midiStreamPause() void *\/"
    }

    {
        "file_name":"Winmm_function_97.cpp",
        "line_count":1,
        "code":"void _midiStreamRestart() { winmm.midiStreamRestart(); }",
        "mark":8.0,
        "query_nsx":"\/* Restart the MIDI stream.\n>>> void _midiStreamRestart() { *\/",
        "query_nlx":"\/* Function named _midiStreamRestart restarts the MIDI stream.\n>>> _midiStreamRestart() void *\/"
    }

    {
        "file_name":"Winmm_function_98.cpp",
        "line_count":1,
        "code":"void _midiStreamStop() { winmm.midiStreamStop(); }",
        "mark":8.0,
        "query_nsx":"\/* Stop the MIDI stream.\n>>> void _midiStreamStop() { *\/",
        "query_nlx":"\/* Function named _midiStreamStop stops the MIDI stream.\n>>> _midiStreamStop() void *\/"
    }

    {
        "file_name":"Winmm_function_99.cpp",
        "line_count":1,
        "code":"void _mixerClose() { winmm.mixerClose(); }",
        "mark":8.0,
        "query_nsx":"\/* Close the audio mixer. \n>>> void _mixerClose(); *\/",
        "query_nlx":"\/* Function named _mixerClose calls the mixerClose function from the winmm library to close the audio mixer. \n>>> _mixerClose() *\/ \nvoid _mixerClose() { \/* body omitted *\/ }"
    }

    {
        "file_name":"WinUtils_function_12.cpp",
        "line_count":12,
        "code":"void ResizeWindow(HWND hWnd, int diffX, int diffY, bool byLeft, bool byTop, bool bRepaint)\n{\n\tHWND hParWnd = GetParent(hWnd);\n\tRECT rc{};\n\n\tGetChildRect(hParWnd, hWnd, &rc);\n\tif (byLeft) rc.left   += diffX;\n\telse        rc.right  += diffX;\n\tif (byTop)  rc.top    += diffY;\n\telse        rc.bottom += diffY;\n\tMoveWindow(hWnd, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, bRepaint);\n}",
        "mark":8.0,
        "query_nsx":"\/* Resize a window by adjusting its position and size based on the provided differences and flags.\n   >>> ResizeWindow(HWND hWnd, int diffX, int diffY, bool byLeft, bool byTop, bool bRepaint) *\/",
        "query_nlx":"        \/* Function named ResizeWindow resizes a window based on the provided parameters such as the difference in X and Y coordinates, whether to resize by the left or top side, and whether to repaint the window after resizing.\n        >>> ResizeWindow(hWnd, diffX, diffY, byLeft, byTop, bRepaint) *\/"
    }

    {
        "file_name":"WinUtils_function_13.cpp",
        "line_count":5,
        "code":"void WindowScroll(HWND hWnd, int diffUpDown)\n{\n\tScrollWindowEx(hWnd, 0, -diffUpDown, NULL, NULL, NULL, NULL, SW_INVALIDATE);\n\tUpdateWindow(hWnd);\n}",
        "mark":8.0,
        "query_nsx":"\/* Scroll the window up or down by a specified amount.\n>>> WindowScroll(HWND hWnd, int diffUpDown) *\/",
        "query_nlx":"\/* Function named WindowScroll scrolls the window associated with the given handle up or down by a specified amount.\n>>> WindowScroll(handle, 50) scrolls the window associated with the given handle 50 units up.\n>>> WindowScroll(handle, -30) scrolls the window associated with the given handle 30 units down. *\/\nvoid WindowScroll(HWND handle, int diffUpDown) { *\/"
    }

    {
        "file_name":"WinUtils_function_14.cpp",
        "line_count":5,
        "code":"void WindowScrollXY(HWND hWnd, int diffLeftRight, int diffUpDown)\n{\n\tScrollWindowEx(hWnd, -diffLeftRight, -diffUpDown, NULL, NULL, NULL, NULL, SW_INVALIDATE);\n\tUpdateWindow(hWnd);\n}",
        "mark":8.0,
        "query_nsx":"\/* Scroll the window by a specified amount horizontally and vertically, then update the window.\n>>> WindowScrollXY(HWND hWnd, int diffLeftRight, int diffUpDown) *\/",
        "query_nlx":"\/* Function named WindowScrollXY scrolls the window in the specified horizontal and vertical directions by the given amounts.\n>>> WindowScrollXY(hWnd, 10, 20) scrolls the window 10 units to the left and 20 units upwards.\n>>> WindowScrollXY(hWnd, -5, 0) scrolls the window 5 units to the right.\n*\/\nvoid WindowScrollXY(HWND hWnd, int diffLeftRight, int diffUpDown) { *\/"
    }

    {
        "file_name":"WinUtils_function_15.cpp",
        "line_count":4,
        "code":"bool IsWindowActive(HWND hWnd)\n{\n\treturn IsWindowVisible(hWnd) && GetForegroundWindow() == hWnd;\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the window specified by the handle is currently active and visible.\n>>> IsWindowActive(HWND hWnd) *\/",
        "query_nlx":"\/* Function checks if a window with a given handle is both visible and currently active in the foreground.\n>>> IsWindowActive(HWND hWnd) *\/"
    }

    {
        "file_name":"WinUtils_function_18.cpp",
        "line_count":7,
        "code":"string GetStringFromHResult(HRESULT hr)\n{\n\tLPTSTR tstr = GetTStringFromHResult(hr);\n\tstd::string str = MakeStringFromTString(tstr);\n\tLocalFree(tstr);\n\treturn str;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert an HRESULT error code into a corresponding string message.\n   >>> string GetStringFromHResult(HRESULT hr) *\/",
        "query_nlx":"\/* Function named GetStringFromHResult converts an HRESULT error code into a corresponding string message. \n>>> GetStringFromHResult(0) returns an empty string \n>>> GetStringFromHResult(-2147024891) returns \"The system cannot find the file specified\" *\/ \n#include <windows.h> \n#include <string> \nusing namespace std; \nstring GetStringFromHResult(HRESULT hr) { *\/"
    }

    {
        "file_name":"WinUtils_function_36.cpp",
        "line_count":12,
        "code":"bool IsChildOf(HWND child, HWND of)\n{\n\twhile (child)\n\t{\n\t\tif (child == of)\n\t\t\treturn true;\n\n\t\tchild = GetParent(child);\n\t}\n\n\treturn false;\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the specified child window is a descendant of the given parent window.\n>>> bool IsChildOf(HWND child, HWND of) *\/",
        "query_nlx":"\/* Function named IsChildOf checks if a given window handle is a child of another window handle by iterating through the parent-child relationship hierarchy.\n>>> IsChildOf(child, of) \n   - Returns true if the 'child' window handle is a child of the 'of' window handle, otherwise false. *\/ \nbool IsChildOf(HWND child, HWND of) { "
    }

    {
        "file_name":"WinUtils_function_4.cpp",
        "line_count":4,
        "code":"void ForgetSystemDPI()\n{\n\tg_systemDPICache = 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Reset the system DPI cache value to zero.\n>>> ForgetSystemDPI() *\/",
        "query_nlx":"\n\/* Function named ForgetSystemDPI resets the system DPI cache value to zero.\n>>> ForgetSystemDPI() *\/ \nvoid ForgetSystemDPI() {"
    }

    {
        "file_name":"WinUtils_function_43.cpp",
        "line_count":40,
        "code":"int MapIconToOldIfNeeded(int iconID)\n{\n\t\/\/ No mapping if icon ID is supported.\n\tif (Supports32BitIcons())\n\t\treturn iconID;\n\n\tswitch (iconID)\n\t{\n\t\tcase IDI_PROFILE_BORDER_GOLD: return IDI_PROFILE_BORDER_GOLD_2K;\n\t\tcase IDI_CHANNEL_MENTIONED: return IDI_CHANNEL_MENTIONED_2K;\n\t\tcase IDI_CHANNEL_UNREAD: return IDI_CHANNEL_UNREAD_2K;\n\t\tcase IDI_PROFILE_BORDER: return IDI_PROFILE_BORDER_2K;\n\t\tcase IDI_TYPING_FRAME1: return IDI_TYPING_FRAME1_2K;\n\t\tcase IDI_TYPING_FRAME2: return IDI_TYPING_FRAME2_2K;\n\t\tcase IDI_TYPING_FRAME3: return IDI_TYPING_FRAME3_2K;\n\t\tcase IDI_NOTIFICATION: return IDI_NOTIFICATION_2K;\n\t\tcase IDI_REPLY_PIECE: return IDI_REPLY_PIECE_2K;\n\t\tcase IDI_SHIFT_RIGHT: return IDI_SHIFT_RIGHT_2K;\n\t\tcase IDI_NEW_INLINE: return IDI_NEW_INLINE_2K;\n\t\tcase IDI_SHIFT_LEFT: return IDI_SHIFT_LEFT_2K;\n\t\tcase IDI_CATEGORY: return IDI_CATEGORY_2K;\n\t\tcase IDI_CHANNEL: return IDI_CHANNEL_2K;\n\t\tcase IDI_MEMBERS: return IDI_MEMBERS_2K;\n\t\tcase IDI_GROUPDM: return IDI_GROUPDM_2K;\n\t\tcase IDI_SERVER: return IDI_SERVER_2K;\n\t\tcase IDI_BOOST: return IDI_BOOST_2K;\n\t\tcase IDI_VOICE: return IDI_VOICE_2K;\n\t\tcase IDI_FILE: return IDI_FILE_2K;\n\t\tcase IDI_JUMP: return IDI_JUMP_2K;\n\t\tcase IDI_SEND: return IDI_SEND_2K;\n\t\tcase IDI_ICON: return IDI_ICON_2K;\n\t\tcase IDI_BOT: return IDI_BOT_2K;\n\t\tcase IDI_NEW: return IDI_NEW_2K;\n\t\tcase IDI_PIN: return IDI_PIN_2K;\n\t\tcase IDI_DM: return IDI_DM_2K;\n\n\t\tdefault: \/\/ No mapping\n\t\t\treturn iconID;\n\t}\n}",
        "mark":8.0,
        "query_nsx":"\/* Map an icon ID to a potentially updated version if needed based on specific mappings.\n>>> int MapIconToOldIfNeeded(int iconID) *\/",
        "query_nlx":"\/* Function named MapIconToOldIfNeeded maps certain icon IDs to their corresponding 2K versions if needed.\n   >>> MapIconToOldIfNeeded(5) returns IDI_TYPING_FRAME1_2K\n   >>> MapIconToOldIfNeeded(20) returns 20 *\/ \nint MapIconToOldIfNeeded(int iconID) {"
    }

    {
        "file_name":"WinUtils_function_45.cpp",
        "line_count":10,
        "code":"void DrawIconInsideProfilePicture(HDC hdc, int xp, int yp, HICON icon)\n{\n\tint pfpSize = ScaleByDPI(PROFILE_PICTURE_SIZE_DEF);\n\tint iconSize = ScaleByDPI(16);\n\n\tint xb = xp + pfpSize - iconSize;\n\tint yb = yp + pfpSize - iconSize;\n\n\tDrawIconEx(hdc, xb, yb, icon, iconSize, iconSize, 0, NULL, DI_COMPAT | DI_NORMAL);\n}",
        "mark":8.0,
        "query_nsx":"\/* Draw an icon inside a profile picture at a specified position.\n   >>> DrawIconInsideProfilePicture(HDC hdc, int xp, int yp, HICON icon) *\/",
        "query_nlx":"\/* Function named DrawIconInsideProfilePicture draws an icon inside a profile picture at a specified position on the device context.\n>>> DrawIconInsideProfilePicture(HDC hdc, int xp, int yp, HICON icon){ *\/"
    }

    {
        "file_name":"WinUtils_function_46.cpp",
        "line_count":7,
        "code":"void DrawMentionStatus(HDC hdc, int x, int y, int mentionCount)\n{\n\tif (mentionCount < 1) return;\n\tmentionCount--;\n\tif (mentionCount > 9) mentionCount = 9;\n\tDrawIconInsideProfilePicture(hdc, x, y, g_MentionMarkerIcons[mentionCount]);\n}",
        "mark":8.0,
        "query_nsx":"\/* Draw a mention status icon inside a profile picture at a specified location based on the number of mentions.\n>>> DrawMentionStatus(HDC hdc, int x, int y, int mentionCount) *\/",
        "query_nlx":"\/* DrawMentionStatus function draws a mention status icon inside a profile picture at the specified coordinates on a canvas. The mentionCount parameter determines which icon to draw based on the index in the g_MentionMarkerIcons array. If mentionCount is less than 1, no icon is drawn. If mentionCount is greater than 9, the highest index icon is drawn instead.\n   >>> DrawMentionStatus(hdc, 100, 150, 5) will draw the 5th mention status icon at coordinates (100, 150) on the canvas *\/ \nvoid DrawMentionStatus(HDC hdc, int x, int y, int mentionCount) { "
    }

    {
        "file_name":"WinUtils_function_47.cpp",
        "line_count":4,
        "code":"void DrawActivityStatus(HDC hdc, int x, int y, eActiveStatus status)\n{\n\tDrawIconInsideProfilePicture(hdc, x, y, g_ProfileStatusIcons[int(status)]);\n}",
        "mark":8.0,
        "query_nsx":"\/* Draw the activity status icon at the specified coordinates on the screen.\n>>> void DrawActivityStatus(HDC hdc, int x, int y, eActiveStatus status) { *\/",
        "query_nlx":"\/* DrawActivityStatus function draws an icon representing the active status inside a profile picture at the specified coordinates on the screen. \n>>> DrawActivityStatus(hdc, x, y, status) void { \n\tDrawIconInsideProfilePicture(hdc, x, y, g_ProfileStatusIcons[int(status)]);\n} *\/"
    }

    {
        "file_name":"WinUtils_function_5.cpp",
        "line_count":4,
        "code":"void SetUserScale(int scale)\n{\n\tg_Scale = scale;\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the user-defined scale value for the application.\n>>> SetUserScale(5) *\/ \nvoid SetUserScale(int scale) {",
        "query_nlx":"\/* Define a function named SetUserScale that takes an integer parameter and sets the global variable g_Scale to that value. \n   >>> SetUserScale(5) *\/ \nvoid SetUserScale(int scale) { "
    }

    {
        "file_name":"WinUtils_function_57.cpp",
        "line_count":8,
        "code":"bool IsColorDark(COLORREF cr)\n{\n\tuint8_t c1 = cr & 0xFF; cr >>= 8;\n\tuint8_t c2 = cr & 0xFF; cr >>= 8;\n\tuint8_t c3 = cr & 0xFF;\n\tint avg = (c1 + c2 + c3) \/ 3;\n\treturn avg <= 128;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given color is dark based on its RGB components average value.\n>>> bool IsColorDark(COLORREF cr) *\/",
        "query_nlx":"\/* Determine if a given color is dark based on its RGB components.\n>>> IsColorDark(COLORREF cr) *\/\nuint8_t IsColorDark(COLORREF cr);"
    }

    {
        "file_name":"XeSSFeature_function_1.cpp",
        "line_count":22,
        "code":"string ResultToString(xess_result_t result)\n{\n\tswitch (result)\n\t{\n\tcase XESS_RESULT_WARNING_NONEXISTING_FOLDER: return \"Warning Nonexistent Folder\";\n\tcase XESS_RESULT_WARNING_OLD_DRIVER: return \"Warning Old Driver\";\n\tcase XESS_RESULT_SUCCESS: return \"Success\";\n\tcase XESS_RESULT_ERROR_UNSUPPORTED_DEVICE: return \"Unsupported Device\";\n\tcase XESS_RESULT_ERROR_UNSUPPORTED_DRIVER: return \"Unsupported Driver\";\n\tcase XESS_RESULT_ERROR_UNINITIALIZED: return \"Uninitialized\";\n\tcase XESS_RESULT_ERROR_INVALID_ARGUMENT: return \"Invalid Argument\";\n\tcase XESS_RESULT_ERROR_DEVICE_OUT_OF_MEMORY: return \"Device Out of Memory\";\n\tcase XESS_RESULT_ERROR_DEVICE: return \"Device Error\";\n\tcase XESS_RESULT_ERROR_NOT_IMPLEMENTED: return \"Not Implemented\";\n\tcase XESS_RESULT_ERROR_INVALID_CONTEXT: return \"Invalid Context\";\n\tcase XESS_RESULT_ERROR_OPERATION_IN_PROGRESS: return \"Operation in Progress\";\n\tcase XESS_RESULT_ERROR_UNSUPPORTED: return \"Unsupported\";\n\tcase XESS_RESULT_ERROR_CANT_LOAD_LIBRARY: return \"Cannot Load Library\";\n\tcase XESS_RESULT_ERROR_UNKNOWN:\n\tdefault: return \"Unknown\";\n\t}\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert the result of an operation to a human-readable string based on predefined codes.\n>>> string ResultToString(xess_result_t result) *\/",
        "query_nlx":"\/* Function ResultToString takes an input xess_result_t and returns a corresponding string message based on the result value.\n>>> ResultToString(XESS_RESULT_WARNING_NONEXISTING_FOLDER) returns \"Warning Nonexistent Folder\"\n>>> ResultToString(XESS_RESULT_ERROR_UNSUPPORTED_DEVICE) returns \"Unsupported Device\"\n>>> ResultToString(XESS_RESULT_ERROR_UNKNOWN) returns \"Unknown\" *\/ \nstring ResultToString(xess_result_t result) {"
    }

    {
        "file_name":"XeSS_Dx12_function_11.cpp",
        "line_count":15,
        "code":"xess_result_t xessDestroyContext(xess_context_handle_t hContext)\n{\n    LOG_DEBUG(\"\");\n\n    if (!_contexts.contains(hContext))\n        return XESS_RESULT_ERROR_INVALID_CONTEXT;\n\n    NVSDK_NGX_D3D12_ReleaseFeature(_contexts[hContext]);\n\n    _contexts.erase(hContext);\n    _nvParams.erase(hContext);\n    _initParams.erase(hContext);\n\n    return XESS_RESULT_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Destroy a context handle if it exists in the internal storage.\n   >>> xessDestroyContext(xess_context_handle_t hContext) *\/",
        "query_nlx":"        \/* Function named xessDestroyContext destroys a context handle if it exists in the internal context map, releasing associated resources.\n        >>> xessDestroyContext(xess_context_handle_t hContext) *\/"
    }

    {
        "file_name":"XeSS_Dx12_function_13.cpp",
        "line_count":22,
        "code":"xess_result_t xessD3D12GetInitParams(xess_context_handle_t hContext, xess_d3d12_init_params_t* pInitParams)\n{\n    LOG_DEBUG(\"\");\n\n    if (!_initParams.contains(hContext))\n        return XESS_RESULT_ERROR_INVALID_CONTEXT;\n\n    auto ip = &_initParams[hContext];\n\n    pInitParams->bufferHeapOffset = ip->bufferHeapOffset;\n    pInitParams->creationNodeMask = ip->creationNodeMask;\n    pInitParams->initFlags = ip->initFlags;\n    pInitParams->outputResolution = ip->outputResolution;\n    pInitParams->pPipelineLibrary = ip->pPipelineLibrary;\n    pInitParams->pTempBufferHeap = ip->pTempBufferHeap;\n    pInitParams->pTempTextureHeap = ip->pTempTextureHeap;\n    pInitParams->qualitySetting = ip->qualitySetting;\n    pInitParams->textureHeapOffset = ip->textureHeapOffset;\n    pInitParams->visibleNodeMask = ip->visibleNodeMask;\n\n    return XESS_RESULT_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve initialization parameters for a specific context handle.\n   >>> xessD3D12GetInitParams(xess_context_handle_t hContext, xess_d3d12_init_params_t* pInitParams) *\/",
        "query_nlx":"        \/* Function named xessD3D12GetInitParams retrieves the initialization parameters associated with a given context handle.\n        >>> xessD3D12GetInitParams(hContext, pInitParams) returns XESS_RESULT_SUCCESS if the context handle is valid and populates the provided initialization parameters struct with the corresponding values.\n        >>> xessD3D12GetInitParams(hContext, pInitParams) returns XESS_RESULT_ERROR_INVALID_CONTEXT if the context handle is not found in the initialization parameters map. *\/ \n        xess_result_t xessD3D12GetInitParams(xess_context_handle_t hContext, xess_d3d12_init_params_t* pInitParams) {  *\/"
    }

    {
        "file_name":"XeSS_Dx12_function_15.cpp",
        "line_count":12,
        "code":"xess_result_t xessGetExposureMultiplier(xess_context_handle_t hContext, float* pScale)\n{\n    LOG_DEBUG(\"\");\n\n    if (!_nvParams.contains(hContext))\n        return XESS_RESULT_ERROR_INVALID_CONTEXT;\n\n    if (_nvParams[hContext]->Get(NVSDK_NGX_Parameter_DLSS_Exposure_Scale, pScale) == NVSDK_NGX_Result_Success)\n        return XESS_RESULT_SUCCESS;\n\n    return XESS_RESULT_ERROR_UNKNOWN;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the exposure multiplier value associated with a given context handle.\n   >>> xessGetExposureMultiplier(xess_context_handle_t hContext, float* pScale) *\/",
        "query_nlx":"\/* Function named xessGetExposureMultiplier retrieves the exposure multiplier value associated with a given context handle if it exists in the parameters. \n>>> xessGetExposureMultiplier(hContext, pScale) returns XESS_RESULT_ERROR_INVALID_CONTEXT if the context handle is not found in the parameters. \n>>> xessGetExposureMultiplier(hContext, pScale) returns XESS_RESULT_SUCCESS with the exposure multiplier value stored in pScale if retrieval is successful. \n>>> xessGetExposureMultiplier(hContext, pScale) returns XESS_RESULT_ERROR_UNKNOWN if an unknown error occurs. *\/ \nxess_result_t xessGetExposureMultiplier(xess_context_handle_t hContext, float* pScale) { *\/"
    }

    {
        "file_name":"XeSS_Dx12_function_17.cpp",
        "line_count":11,
        "code":"xess_result_t xessGetIntelXeFXVersion(xess_context_handle_t hContext, xess_version_t* pVersion)\n{\n    LOG_DEBUG(\"\");\n\n    pVersion->major = XeSSProxy::Version().major;\n    pVersion->minor = XeSSProxy::Version().minor;\n    pVersion->patch = XeSSProxy::Version().patch;\n    pVersion->reserved = XeSSProxy::Version().reserved;\n\n    return XESS_RESULT_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the version information of the Intel XeFX hardware.\n   >>> xessGetIntelXeFXVersion(hContext, pVersion) *\/ \nxess_result_t xessGetIntelXeFXVersion(xess_context_handle_t hContext, xess_version_t* pVersion) {",
        "query_nlx":"\/* Retrieve the version information of an Intel XeFX device using the provided context handle and store it in the specified version structure.\n   >>> xessGetIntelXeFXVersion(hContext, pVersion) *\/ \nxess_result_t xessGetIntelXeFXVersion(xess_context_handle_t hContext, xess_version_t* pVersion) {"
    }

    {
        "file_name":"XeSS_Dx12_function_18.cpp",
        "line_count":9,
        "code":"xess_result_t xessGetJitterScale(xess_context_handle_t hContext, float* pX, float* pY)\n{\n    LOG_DEBUG(\"\");\n\n    *pX = 1.0f;\n    *pY = 1.0f;\n\n    return XESS_RESULT_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the scale of jitter for the X and Y coordinates in the context.\n>>> xessGetJitterScale(xess_context_handle_t hContext, float* pX, float* pY) *\/",
        "query_nlx":"        \/* Query: Define a function called xessGetJitterScale that sets the values of two given float pointers to 1.0 and returns XESS_RESULT_SUCCESS.\n           >>> xessGetJitterScale(xess_context_handle_t hContext, float* pX, float* pY) *\/"
    }

    {
        "file_name":"XeSS_Dx12_function_21.cpp",
        "line_count":5,
        "code":"xess_result_t xessSetJitterScale(xess_context_handle_t hContext, float x, float y)\n{\n    LOG_DEBUG(\"x: {}, y: {}\", x, y);\n    return XESS_RESULT_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the jitter scale values for a context handle.\n>>> xessSetJitterScale(hContext, x, y) *\/\nxess_result_t xessSetJitterScale(xess_context_handle_t hContext, float x, float y) {",
        "query_nlx":"\/* Function named xessSetJitterScale sets the jitter scale values for a given context handle, with specified x and y values. \n>>> xessSetJitterScale(hContext, 0.5, 0.8) XESS_RESULT_SUCCESS *\/"
    }

    {
        "file_name":"XeSS_Dx12_function_22.cpp",
        "line_count":11,
        "code":"xess_result_t xessSetExposureMultiplier(xess_context_handle_t hContext, float scale)\n{\n    LOG_DEBUG(\"\");\n\n    if (!_nvParams.contains(hContext))\n        return XESS_RESULT_ERROR_INVALID_CONTEXT;\n\n    _nvParams[hContext]->Set(NVSDK_NGX_Parameter_DLSS_Exposure_Scale, scale);\n\n    return XESS_RESULT_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"        \/* Set exposure multiplier for a given context handle.\n        >>> xessSetExposureMultiplier(hContext, scale) *\/ \n        xess_result_t xessSetExposureMultiplier(xess_context_handle_t hContext, float scale) {",
        "query_nlx":"\/* Function named xessSetExposureMultiplier sets the exposure multiplier for a given context handle to a specified scale value. \n>>> xessSetExposureMultiplier(hContext, scale) returns XESS_RESULT_ERROR_INVALID_CONTEXT if the context handle is not found in the parameters map. \n>>> xessSetExposureMultiplier(hContext, scale) sets the exposure scale parameter to the provided scale value for the context handle and returns XESS_RESULT_SUCCESS. *\/ \nxess_result_t xessSetExposureMultiplier(xess_context_handle_t hContext, float scale) { *\/"
    }

    {
        "file_name":"XeSS_Dx12_function_7.cpp",
        "line_count":11,
        "code":"xess_result_t xessGetVersion(xess_version_t* pVersion)\n{\n    LOG_DEBUG(\"\");\n\n    pVersion->major = XeSSProxy::Version().major;\n    pVersion->minor = XeSSProxy::Version().minor;\n    pVersion->patch = XeSSProxy::Version().patch;\n    pVersion->reserved = XeSSProxy::Version().reserved;\n\n    return XESS_RESULT_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"        \/* Retrieve the version information of a system component.\n        >>> xessGetVersion(xess_version_t* pVersion) *\/",
        "query_nlx":"        \/* Function named xessGetVersion retrieves the version information from a proxy and populates the provided version structure with the major, minor, patch, and reserved version numbers. \n        >>> xessGetVersion(&version) returns XESS_RESULT_SUCCESS *\/ \n        xess_result_t xessGetVersion(xess_version_t* pVersion) {"
    }

    {
        "file_name":"XeSS_Proxy_function_11.cpp",
        "line_count":1,
        "code":"PFN_xessSelectNetworkModel SelectNetworkModel() { return _xessSelectNetworkModel; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the selected network model for further processing.\n   >>> SelectNetworkModel() PFN_xessSelectNetworkModel *\/",
        "query_nlx":"\/* Retrieve the selected network model by calling the function SelectNetworkModel. \n   >>> SelectNetworkModel() returns the selected network model. *\/ \nPFN_xessSelectNetworkModel SelectNetworkModel();"
    }

    {
        "file_name":"XeSS_Proxy_function_14.cpp",
        "line_count":1,
        "code":"PFN_xessIsOptimalDriver IsOptimalDriver() { return _xessIsOptimalDriver; }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the driver is optimal based on a predefined function.\n   >>> IsOptimalDriver() PFN_xessIsOptimalDriver *\/",
        "query_nlx":"\/* Function named IsOptimalDriver returns the value of the _xessIsOptimalDriver variable, indicating whether the current driver is optimal or not.\n   >>> IsOptimalDriver() _xessIsOptimalDriver *\/ \nPFN_xessIsOptimalDriver IsOptimalDriver() { "
    }

    {
        "file_name":"XeSS_Proxy_function_16.cpp",
        "line_count":1,
        "code":"PFN_xessGetProperties GetProperties() { return _xessGetProperties; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the properties associated with a specific entity.\n   >>> GetProperties() returns the properties of the entity. *\/ \nPFN_xessGetProperties GetProperties() { return _xessGetProperties; }",
        "query_nlx":"\/* Retrieve the properties by calling the function GetProperties, which returns the properties using a specific function.\n>>> GetProperties() PFN_xessGetProperties *\/ \nPFN_xessGetProperties GetProperties();"
    }

    {
        "file_name":"XeSS_Proxy_function_20.cpp",
        "line_count":1,
        "code":"PFN_xessForceLegacyScaleFactors ForceLegacyScaleFactors() { return _xessForceLegacyScaleFactors; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the function responsible for handling legacy scale factors.\n   >>> ForceLegacyScaleFactors() *\/",
        "query_nlx":"\/* Function named ForceLegacyScaleFactors returns the xessForceLegacyScaleFactors object.\n   >>> ForceLegacyScaleFactors() PFN_xessForceLegacyScaleFactors *\/"
    }

    {
        "file_name":"Zydis_function_1.cpp",
        "line_count":13,
        "code":"int ZYAN_MEMCMP(const void* s1, const void* s2, ZyanUSize n)\n{\n    const ZyanU8* p1 = s1, *p2 = s2;\n    while (n--)\n    {\n        if (*p1 != *p2)\n        {\n            return *p1 - *p2;\n        }\n        p1++, p2++;\n    }\n    return 0;\n}",
        "mark":8.0,
        "query_nsx":"\/* Compare two memory blocks of a specified size and return the result.\n>>> ZYAN_MEMCMP(const void* s1, const void* s2, ZyanUSize n) *\/",
        "query_nlx":"        \/* Function named ZYAN_MEMCMP compares two memory blocks of a specified size byte by byte and returns the difference between the first differing bytes. If the memory blocks are identical, it returns 0.\n        >>> ZYAN_MEMCMP(\"hello\", \"world\", 5) -15\n        >>> ZYAN_MEMCMP(\"abc\", \"abc\", 3) 0 *\/ \n        int ZYAN_MEMCMP(const void* s1, const void* s2, ZyanUSize n) { "
    }

    {
        "file_name":"Zydis_function_102.cpp",
        "line_count":17,
        "code":"ZyanU8 ZydisGetUnsignedImmSize(ZyanU64 imm)\n{\n    if (imm <= ZYAN_UINT8_MAX)\n    {\n        return 8;\n    }\n    if (imm <= ZYAN_UINT16_MAX)\n    {\n        return 16;\n    }\n    if (imm <= ZYAN_UINT32_MAX)\n    {\n        return 32;\n    }\n\n    return 64;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of an unsigned immediate value based on its magnitude.\n>>> ZydisGetUnsignedImmSize(255) 8\n>>> ZydisGetUnsignedImmSize(65535) 16\n>>> ZydisGetUnsignedImmSize(4294967295) 32\n>>> ZydisGetUnsignedImmSize(18446744073709551615) 64 *\/",
        "query_nlx":"\n            \/* Determine the size of an unsigned immediate value based on its magnitude.\n            >>> ZydisGetUnsignedImmSize(255) returns 8\n            >>> ZydisGetUnsignedImmSize(65535) returns 16\n            >>> ZydisGetUnsignedImmSize(4294967295) returns 32\n            >>> ZydisGetUnsignedImmSize(18446744073709551615) returns 64 *\/\n            ZyanU8 ZydisGetUnsignedImmSize(ZyanU64 imm) { "
    }

    {
        "file_name":"Zydis_function_108.cpp",
        "line_count":14,
        "code":"ZyanBool ZydisIsScaleValid(ZyanU8 scale)\n{\n    switch (scale)\n    {\n    case 0:\n    case 1:\n    case 2:\n    case 4:\n    case 8:\n        return ZYAN_TRUE;\n    default:\n        return ZYAN_FALSE;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the given scale value is valid based on a predefined set of allowed values.\n>>> ZydisIsScaleValid(scale: ZyanU8) -> ZyanBool { *\/",
        "query_nlx":"\/* Function ZydisIsScaleValid determines if a given scale value is valid based on a predefined set of valid scale values. \n>>> ZydisIsScaleValid(3) false \n>>> ZydisIsScaleValid(8) true *\/ \nZyanBool ZydisIsScaleValid(ZyanU8 scale) { "
    }

    {
        "file_name":"Zydis_function_11.cpp",
        "line_count":10,
        "code":"void ZydisInputSkip(ZydisDecoderState* state, ZydisDecodedInstruction* instruction)\n{\n    ZYAN_ASSERT(state);\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(instruction->length < ZYDIS_MAX_INSTRUCTION_LENGTH);\n\n    ++instruction->length;\n    ++state->buffer;\n    --state->buffer_len;\n}",
        "mark":8.0,
        "query_nsx":"            \/* Increment the length of a decoded instruction and adjust the buffer accordingly.\n            >>> ZydisInputSkip(ZydisDecoderState* state, ZydisDecodedInstruction* instruction) *\/",
        "query_nlx":"\/* Function named ZydisInputSkip updates the length of a decoded instruction and adjusts the buffer and buffer length in the decoder state accordingly. \n>>> ZydisInputSkip(state, instruction) \n*\/ \nvoid ZydisInputSkip(ZydisDecoderState* state, ZydisDecodedInstruction* instruction) { "
    }

    {
        "file_name":"Zydis_function_115.cpp",
        "line_count":16,
        "code":"ZyanU8 ZydisEncodeMvexBroadcastMode(ZydisBroadcastMode broadcast)\n{\n    switch (broadcast)\n    {\n    case ZYDIS_BROADCAST_MODE_INVALID:\n        return 0;\n    case ZYDIS_BROADCAST_MODE_1_TO_16:\n    case ZYDIS_BROADCAST_MODE_1_TO_8:\n        return 1;\n    case ZYDIS_BROADCAST_MODE_4_TO_16:\n    case ZYDIS_BROADCAST_MODE_4_TO_8:\n        return 2;\n    default:\n        ZYAN_UNREACHABLE;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the encoding value based on the specified broadcast mode.\n   >>> ZydisEncodeMvexBroadcastMode(ZydisBroadcastMode broadcast) *\/",
        "query_nlx":"        \/* Function ZydisEncodeMvexBroadcastMode encodes the given broadcast mode into a corresponding value.\n        >>> ZydisEncodeMvexBroadcastMode(ZYDIS_BROADCAST_MODE_INVALID) returns 0\n        >>> ZydisEncodeMvexBroadcastMode(ZYDIS_BROADCAST_MODE_1_TO_16) returns 1\n        >>> ZydisEncodeMvexBroadcastMode(ZYDIS_BROADCAST_MODE_1_TO_8) returns 1\n        >>> ZydisEncodeMvexBroadcastMode(ZYDIS_BROADCAST_MODE_4_TO_16) returns 2\n        >>> ZydisEncodeMvexBroadcastMode(ZYDIS_BROADCAST_MODE_4_TO_8) returns 2 *\/ \n        ZyanU8 ZydisEncodeMvexBroadcastMode(ZydisBroadcastMode broadcast) { "
    }

    {
        "file_name":"Zydis_function_149.cpp",
        "line_count":4,
        "code":"ZyanStatus ZydisEmitByte(ZyanU8 byte, ZydisEncoderBuffer *buffer)\n{\n    return ZydisEmitUInt(byte, 1, buffer);\n}",
        "mark":8.0,
        "query_nsx":"\/* Emit a single byte to the encoder buffer.\n   >>> ZydisEmitByte(byte, buffer) \n*\/ \nZyanStatus ZydisEmitByte(ZyanU8 byte, ZydisEncoderBuffer *buffer) {",
        "query_nlx":"\n\/* Function named ZydisEmitByte takes a single byte value and appends it to an encoder buffer.\n   >>> ZydisEmitByte(0xAB, buffer) returns a status indicating the success of appending the byte to the buffer. *\/ \nZyanStatus ZydisEmitByte(ZyanU8 byte, ZydisEncoderBuffer *buffer) {"
    }

    {
        "file_name":"Zydis_function_172.cpp",
        "line_count":32,
        "code":"ZyanStatus ZydisEncoderNopFill(void *buffer, ZyanUSize length)\n{\n    if (!buffer)\n    {\n        return ZYAN_STATUS_INVALID_ARGUMENT;\n    }\n\n    \/\/ Intel SDM Vol. 2B \"Recommended Multi-Byte Sequence of NOP Instruction\"\n    static const ZyanU8 nops[9][9] =\n    {\n        { 0x90 },\n        { 0x66, 0x90 },\n        { 0x0F, 0x1F, 0x00 },\n        { 0x0F, 0x1F, 0x40, 0x00 },\n        { 0x0F, 0x1F, 0x44, 0x00, 0x00 },\n        { 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00 },\n        { 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00 },\n        { 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        { 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 },\n    };\n\n    ZyanU8 *output = (ZyanU8 *)buffer;\n    while (length)\n    {\n        ZyanUSize nop_size = (length > 9) ? 9 : length;\n        ZYAN_MEMCPY(output, nops[nop_size - 1], nop_size);\n        output += nop_size;\n        length -= nop_size;\n    }\n\n    return ZYAN_STATUS_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Fill the given buffer with multi-byte sequences of NOP instructions based on the specified length.\n   >>> ZydisEncoderNopFill(void *buffer, ZyanUSize length) *\/",
        "query_nlx":"\/* Implement a function that fills a buffer with NOP instructions based on the provided length.\n   The function should return an error if the buffer is invalid.\n   The NOP instructions to be used are based on the Intel SDM Vol. 2B \"Recommended Multi-Byte Sequence of NOP Instruction\".\n   The function should iterate through the buffer, copying the appropriate NOP sequence based on the remaining length.\n   The function should return a success status upon completion.\n   >>> ZydisEncoderNopFill(void *buffer, ZyanUSize length) *\/"
    }

    {
        "file_name":"Zydis_function_184.cpp",
        "line_count":11,
        "code":"ZyanStatus ZydisFormatterInit(ZydisFormatter* formatter, ZydisFormatterStyle style)\n{\n    if (!formatter || ((ZyanUSize)style > ZYDIS_FORMATTER_STYLE_MAX_VALUE))\n    {\n        return ZYAN_STATUS_INVALID_ARGUMENT;\n    }\n\n    ZYAN_MEMCPY(formatter, FORMATTER_PRESETS[style], sizeof(*formatter));\n\n    return ZYAN_STATUS_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize a Zydis formatter with a specific style preset.\n   >>> ZydisFormatterInit(ZydisFormatter* formatter, ZydisFormatterStyle style) *\/",
        "query_nlx":"\/* Function named ZydisFormatterInit initializes a ZydisFormatter with a given style.\n   It copies the preset formatter settings based on the provided style to the formatter.\n   If the formatter is NULL or the style exceeds the maximum allowed value, it returns an invalid argument status.\n   The function returns a success status after copying the formatter settings.\n   >>> ZydisFormatterInit(formatter, style) ZyanStatus *\/"
    }

    {
        "file_name":"Zydis_function_19.cpp",
        "line_count":11,
        "code":"void ZydisDecodeModRM(ZydisDecodedInstruction* instruction, ZyanU8 data)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(!(instruction->attributes & ZYDIS_ATTRIB_HAS_MODRM));\n    ZYAN_ASSERT(instruction->raw.modrm.offset == instruction->length - 1);\n\n    instruction->attributes   |= ZYDIS_ATTRIB_HAS_MODRM;\n    instruction->raw.modrm.mod = (data >> 6) & 0x03;\n    instruction->raw.modrm.reg = (data >> 3) & 0x07;\n    instruction->raw.modrm.rm  = (data >> 0) & 0x07;\n}",
        "mark":8.0,
        "query_nsx":"        \/* Update the attributes of a decoded instruction based on the ModRM byte extracted from the input data.\n        >>> ZydisDecodeModRM(ZydisDecodedInstruction* instruction, ZyanU8 data) *\/",
        "query_nlx":"        \/* Function named ZydisDecodeModRM decodes the ModRM byte of a ZydisDecodedInstruction structure using the provided data byte.\n        >>> ZydisDecodeModRM(instruction, data) *\/ \n        void ZydisDecodeModRM(ZydisDecodedInstruction* instruction, ZyanU8 data) {"
    }

    {
        "file_name":"Zydis_function_236.cpp",
        "line_count":11,
        "code":"ZydisRegisterWidth ZydisRegisterGetWidth(ZydisMachineMode mode, ZydisRegister reg)\n{\n    if ((ZyanUSize)reg >= ZYAN_ARRAY_LENGTH(REG_LOOKUP))\n    {\n        return 0;\n    }\n\n    return (mode == ZYDIS_MACHINE_MODE_LONG_64)\n        ? REG_LOOKUP[reg].width64\n        : REG_LOOKUP[reg].width;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the width of a register based on the machine mode and the register type.\n   >>> ZydisRegisterWidth ZydisRegisterGetWidth(ZydisMachineMode mode, ZydisRegister reg) *\/",
        "query_nlx":"\/* Function named ZydisRegisterGetWidth calculates the width of a register based on the machine mode and the register provided.\n>>> ZydisRegisterGetWidth(ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_REGISTER_RAX) returns the width of register RAX in 64-bit mode\n>>> ZydisRegisterGetWidth(ZYDIS_MACHINE_MODE_LONG_COMPAT_32, ZYDIS_REGISTER_EAX) returns the width of register EAX in 32-bit mode *\/ \nZydisRegisterWidth ZydisRegisterGetWidth(ZydisMachineMode mode, ZydisRegister reg) { "
    }

    {
        "file_name":"Zydis_function_260.cpp",
        "line_count":4,
        "code":"ZyanU64 ZydisGetVersion(void)\n{\n    return ZYDIS_VERSION;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the version number of the Zydis disassembler library.\n>>> ZydisGetVersion() ZyanU64 *\/",
        "query_nlx":"\/* Function named ZydisGetVersion returns the version number of the Zydis library.\n   >>> ZydisGetVersion() returns the version number of the Zydis library. *\/ \nZyanU64 ZydisGetVersion(void) { "
    }

    {
        "file_name":"Zydis_function_59.cpp",
        "line_count":19,
        "code":"ZyanStatus ZydisNodeHandlerVEX(const ZydisDecodedInstruction* instruction, ZyanU16* index)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(index);\n\n    switch (instruction->encoding)\n    {\n    case ZYDIS_INSTRUCTION_ENCODING_LEGACY:\n        *index = 0;\n        break;\n    case ZYDIS_INSTRUCTION_ENCODING_VEX:\n        ZYAN_ASSERT(instruction->attributes & ZYDIS_ATTRIB_HAS_VEX);\n        *index = instruction->raw.vex.m_mmmm + (instruction->raw.vex.pp << 2) + 1;\n        break;\n    default:\n        ZYAN_UNREACHABLE;\n    }\n    return ZYAN_STATUS_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the index of a node handler based on the encoding type of a decoded instruction.\n   >>> ZydisNodeHandlerVEX(const ZydisDecodedInstruction* instruction, ZyanU16* index) *\/",
        "query_nlx":"\n\/* Function named ZydisNodeHandlerVEX takes a ZydisDecodedInstruction pointer and a ZydisU16 pointer as input parameters. It determines the index based on the encoding type of the instruction and updates the index accordingly. \n>>> ZydisNodeHandlerVEX(const ZydisDecodedInstruction* instruction, ZydisU16* index) *\/"
    }

    {
        "file_name":"Zydis_function_63.cpp",
        "line_count":24,
        "code":"ZyanStatus ZydisNodeHandlerMode(const ZydisDecodedInstruction* instruction, ZyanU16* index)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(index);\n\n    switch (instruction->machine_mode)\n    {\n    case ZYDIS_MACHINE_MODE_LONG_COMPAT_16:\n    case ZYDIS_MACHINE_MODE_LEGACY_16:\n    case ZYDIS_MACHINE_MODE_REAL_16:\n        *index = 0;\n        break;\n    case ZYDIS_MACHINE_MODE_LONG_COMPAT_32:\n    case ZYDIS_MACHINE_MODE_LEGACY_32:\n        *index = 1;\n        break;\n    case ZYDIS_MACHINE_MODE_LONG_64:\n        *index = 2;\n        break;\n    default:\n        ZYAN_UNREACHABLE;\n    }\n    return ZYAN_STATUS_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the mode of operation for a given instruction and update the index accordingly.\n>>> ZydisNodeHandlerMode(const ZydisDecodedInstruction* instruction, ZydisU16* index) *\/",
        "query_nlx":"\/* Define a function that determines the mode of operation for a given decoded instruction and updates the index accordingly.\n   The function should handle different machine modes and set the index based on the mode as follows:\n   - For machine modes ZYDIS_MACHINE_MODE_LONG_COMPAT_16, ZYDIS_MACHINE_MODE_LEGACY_16, and ZYDIS_MACHINE_MODE_REAL_16, set index to 0.\n   - For machine modes ZYDIS_MACHINE_MODE_LONG_COMPAT_32 and ZYDIS_MACHINE_MODE_LEGACY_32, set index to 1.\n   - For machine mode ZYDIS_MACHINE_MODE_LONG_64, set index to 2.\n   - Return ZYAN_STATUS_SUCCESS upon successful completion.\n   - If an unknown machine mode is encountered, the function should not reach that point.\n*\/\nZyanStatus ZydisNodeHandlerMode(const ZydisDecodedInstruction* instruction, ZyanU16* index) { "
    }

    {
        "file_name":"Zydis_function_7.cpp",
        "line_count":9,
        "code":"ZyanUSize ZYAN_STRSPN(const char* s1, const char* s2)\n{\n    ZyanUSize ret = 0;\n    while (*s1 && ZYAN_STRCHR(s2, *s1++))\n    {\n        ret++;\n    }\n    return ret;\n}",
        "mark":8.0,
        "query_nsx":"\/* Calculate the length of the initial segment of a string that only contains characters from another string.\n>>> ZyanUSize ZYAN_STRSPN(const char* s1, const char* s2) *\/",
        "query_nlx":"\/* Define a function that calculates the length of the initial segment of a string that consists only of characters found in another string.\n   >>> ZYAN_STRSPN(\"hello\", \"heo\") returns 3\n   >>> ZYAN_STRSPN(\"world\", \"abc\") returns 0 *\/ \nZyanUSize ZYAN_STRSPN(const char* s1, const char* s2) { "
    }

    {
        "file_name":"Zydis_function_75.cpp",
        "line_count":10,
        "code":"ZyanStatus ZydisNodeHandlerEvexB(const ZydisDecodedInstruction* instruction, ZyanU16* index)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(index);\n\n    ZYAN_ASSERT(instruction->encoding == ZYDIS_INSTRUCTION_ENCODING_EVEX);\n    ZYAN_ASSERT(instruction->attributes & ZYDIS_ATTRIB_HAS_EVEX);\n    *index = instruction->raw.evex.b;\n    return ZYAN_STATUS_SUCCESS;\n}",
        "mark":8.5,
        "query_nsx":"\/* Extract and return the EVEX node handler index from the given decoded instruction.\n   >>> ZydisNodeHandlerEvexB(const ZydisDecodedInstruction* instruction, ZydisU16* index) *\/",
        "query_nlx":"        \/* Define a function that handles EVEX-encoded instructions and extracts the value of the 'b' field from the raw instruction data.\n        >>> ZydisNodeHandlerEvexB(const ZydisDecodedInstruction* instruction, ZydisU16* index) *\/"
    }

    {
        "file_name":"Zydis_function_76.cpp",
        "line_count":10,
        "code":"ZyanStatus ZydisNodeHandlerMvexE(const ZydisDecodedInstruction* instruction, ZyanU16* index)\n{\n    ZYAN_ASSERT(instruction);\n    ZYAN_ASSERT(index);\n\n    ZYAN_ASSERT(instruction->encoding == ZYDIS_INSTRUCTION_ENCODING_MVEX);\n    ZYAN_ASSERT(instruction->attributes & ZYDIS_ATTRIB_HAS_MVEX);\n    *index = instruction->raw.mvex.E;\n    return ZYAN_STATUS_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"        \/* Retrieve the index value from the decoded instruction related to MVEX encoding.\n        >>> ZydisNodeHandlerMvexE(const ZydisDecodedInstruction* instruction, ZydisU16* index) *\/",
        "query_nlx":"        \/* Query: Define a function that handles MVEX-encoded instructions by extracting the E field from the raw instruction data and returning a success status.\n           >>> ZydisNodeHandlerMvexE(const ZydisDecodedInstruction* instruction, ZydisU16* index) *\/\n           #include \"Zydis.h\"\n           ZyanStatus ZydisNodeHandlerMvexE(const ZydisDecodedInstruction* instruction, ZyanU16* index) { *\/"
    }

    {
        "file_name":"Zydis_function_89.cpp",
        "line_count":18,
        "code":"ZyanStatus ZydisDecoderEnableMode(ZydisDecoder* decoder, ZydisDecoderMode mode, ZyanBool enabled)\n{\n    if (!decoder || ((ZyanUSize)mode > ZYDIS_DECODER_MODE_MAX_VALUE))\n    {\n        return ZYAN_STATUS_INVALID_ARGUMENT;\n    }\n\n#ifdef ZYDIS_MINIMAL_MODE\n    if ((mode == ZYDIS_DECODER_MODE_MINIMAL) && !enabled)\n    {\n        return ZYAN_STATUS_INVALID_OPERATION;\n    }\n#endif\n\n    decoder->decoder_mode[mode] = enabled;\n\n    return ZYAN_STATUS_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Enable or disable a specific mode in the decoder.\n>>> ZydisDecoderEnableMode(ZydisDecoder* decoder, ZydisDecoderMode mode, ZyanBool enabled) *\/",
        "query_nlx":"\/* Define a function that enables or disables a specific mode in a decoder based on the provided arguments. \n   The function takes a decoder, a mode, and a boolean flag to enable or disable the mode. \n   If the decoder is invalid or the mode exceeds the maximum allowed value, it returns an invalid argument status. \n   If the minimal mode is enabled and an attempt is made to disable it, it returns an invalid operation status. \n   Otherwise, it sets the mode in the decoder to the provided enabled\/disabled state and returns a success status. *\/ \nZyanStatus ZydisDecoderEnableMode(ZydisDecoder* decoder, ZydisDecoderMode mode, ZyanBool enabled) { "
    }

    {
        "file_name":"Zydis_function_94.cpp",
        "line_count":14,
        "code":"ZydisEncodableEncoding ZydisGetEncodableEncoding(ZydisInstructionEncoding encoding)\n{\n    static const ZydisEncodableEncoding encoding_lookup[6] =\n    {\n        ZYDIS_ENCODABLE_ENCODING_LEGACY,\n        ZYDIS_ENCODABLE_ENCODING_3DNOW,\n        ZYDIS_ENCODABLE_ENCODING_XOP,\n        ZYDIS_ENCODABLE_ENCODING_VEX,\n        ZYDIS_ENCODABLE_ENCODING_EVEX,\n        ZYDIS_ENCODABLE_ENCODING_MVEX,\n    };\n    ZYAN_ASSERT((ZyanUSize)encoding <= ZYDIS_INSTRUCTION_ENCODING_MAX_VALUE);\n    return encoding_lookup[encoding];\n}",
        "mark":8.0,
        "query_nsx":"\n            \/* Determine the encodable encoding type based on the given instruction encoding.\n            >>> ZydisEncodableEncoding ZydisGetEncodableEncoding(ZydisInstructionEncoding encoding) { *\/",
        "query_nlx":"\/* Function named ZydisGetEncodableEncoding takes an input ZydisInstructionEncoding and returns the corresponding ZydisEncodableEncoding based on a static lookup table.\n   >>> ZydisGetEncodableEncoding(ZYDIS_INSTRUCTION_ENCODING_MAX_VALUE) returns ZYDIS_ENCODABLE_ENCODING_MVEX\n   >>> ZydisGetEncodableEncoding(ZYDIS_INSTRUCTION_ENCODING_LEGACY) returns ZYDIS_ENCODABLE_ENCODING_LEGACY *\/"
    }

    {
        "file_name":"Zydis_function_95.cpp",
        "line_count":17,
        "code":"ZyanU8 ZydisGetMachineModeWidth(ZydisMachineMode machine_mode)\n{\n    switch (machine_mode)\n    {\n    case ZYDIS_MACHINE_MODE_REAL_16:\n    case ZYDIS_MACHINE_MODE_LEGACY_16:\n    case ZYDIS_MACHINE_MODE_LONG_COMPAT_16:\n        return 16;\n    case ZYDIS_MACHINE_MODE_LEGACY_32:\n    case ZYDIS_MACHINE_MODE_LONG_COMPAT_32:\n        return 32;\n    case ZYDIS_MACHINE_MODE_LONG_64:\n        return 64;\n    default:\n        ZYAN_UNREACHABLE;\n    }\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the width in bits corresponding to the provided machine mode.\n   >>> ZydisGetMachineModeWidth(ZydisMachineMode machine_mode) *\/",
        "query_nlx":"\/* Function named ZydisGetMachineModeWidth determines the width in bits of a given machine mode in the Zydis library.\n   >>> ZydisGetMachineModeWidth(ZYDIS_MACHINE_MODE_REAL_16) returns 16\n   >>> ZydisGetMachineModeWidth(ZYDIS_MACHINE_MODE_LEGACY_32) returns 32\n   >>> ZydisGetMachineModeWidth(ZYDIS_MACHINE_MODE_LONG_64) returns 64 *\/ \nZyanU8 ZydisGetMachineModeWidth(ZydisMachineMode machine_mode) {"
    }

    {
        "file_name":"Zydis_function_96.cpp",
        "line_count":6,
        "code":"ZyanU8 ZydisGetAszFromHint(ZydisAddressSizeHint hint)\n{\n    ZYAN_ASSERT((ZyanUSize)hint <= ZYDIS_ADDRESS_SIZE_HINT_MAX_VALUE);\n    static const ZyanU8 lookup[ZYDIS_ADDRESS_SIZE_HINT_MAX_VALUE + 1] = { 0, 16, 32, 64 };\n    return lookup[hint];\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the address size based on the given hint value.\n   >>> ZydisGetAszFromHint(ZydisAddressSizeHint hint) *\/",
        "query_nlx":"\/* Function named ZydisGetAszFromHint retrieves the address size hint value from a lookup table based on the input hint value.\n   >>> ZydisGetAszFromHint(ZYDIS_ADDRESS_SIZE_HINT_MAX_VALUE) returns 64\n   >>> ZydisGetAszFromHint(ZYDIS_ADDRESS_SIZE_HINT_16) returns 16\n   >>> ZydisGetAszFromHint(ZYDIS_ADDRESS_SIZE_HINT_32) returns 32\n   >>> ZydisGetAszFromHint(ZYDIS_ADDRESS_SIZE_HINT_64) returns 64 *\/ \nZyanU8 ZydisGetAszFromHint(ZydisAddressSizeHint hint) { *\/"
    }

    {
        "file_name":"Zydis_function_97.cpp",
        "line_count":6,
        "code":"ZyanU8 ZydisGetOszFromHint(ZydisOperandSizeHint hint)\n{\n    ZYAN_ASSERT((ZyanUSize)hint <= ZYDIS_OPERAND_SIZE_HINT_MAX_VALUE);\n    static const ZyanU8 lookup[ZYDIS_OPERAND_SIZE_HINT_MAX_VALUE + 1] = { 0, 8, 16, 32, 64 };\n    return lookup[hint];\n}",
        "mark":8.0,
        "query_nsx":"\n\/* Retrieve the operand size hint from the given input and return the corresponding operand size value.\n>>> ZydisGetOszFromHint(ZydisOperandSizeHint hint) *\/",
        "query_nlx":"\/* Function named ZydisGetOszFromHint takes an operand size hint as input and returns the corresponding operand size in bytes based on a lookup table.\n   >>> ZydisGetOszFromHint(ZydisOperandSizeHint hint) \n*\/"
    }

    {
        "file_name":"nvhttp_function_32.cpp",
        "line_count":7,
        "code":"void stop_session(stream::session_t& session, bool graceful) {\n    if (graceful) {\n      stream::session::graceful_stop(session);\n    } else {\n      stream::session::stop(session);\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Stop a session either gracefully or abruptly based on the provided flag.\n   >>> void stop_session(stream::session_t& session, bool graceful) { *\/",
        "query_nlx":"\/* Function named stop_session manages the stopping of a session based on a boolean flag indicating whether to stop gracefully or abruptly.\n>>> stop_session(session, true) calls the graceful_stop function on the session object.\n>>> stop_session(session, false) calls the stop function on the session object. *\/ \nvoid stop_session(stream::session_t& session, bool graceful) {"
    }

    {
        "file_name":"nvhttp_function_33.cpp",
        "line_count":8,
        "code":"bool find_and_stop_session(const std::string& uuid, bool graceful) {\n    auto session = rtsp_stream::find_session(uuid);\n    if (session) {\n      stop_session(*session, graceful);\n      return true;\n    }\n    return false;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Find and stop a session with a specified UUID if it exists.\n   >>> bool find_and_stop_session(const std::string& uuid, bool graceful) { *\/",
        "query_nlx":"\/* Function named find_and_stop_session searches for a session with a given unique identifier and stops it if found, with an option for graceful termination.\n>>> find_and_stop_session(\"session_uuid_123\", true) true\n>>> find_and_stop_session(\"session_uuid_456\", false) false *\/ \nbool find_and_stop_session(const std::string& uuid, bool graceful) {"
    }

    {
        "file_name":"nvhttp_function_35.cpp",
        "line_count":8,
        "code":"bool find_and_udpate_session_info(const std::string& uuid, const std::string& name, const crypto::PERM newPerm) {\n    auto session = rtsp_stream::find_session(uuid);\n    if (session) {\n      update_session_info(*session, name, newPerm);\n      return true;\n    }\n    return false;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Find and update session information based on a unique identifier, name, and permission level.\n>>> bool find_and_udpate_session_info(const std::string& uuid, const std::string& name, const crypto::PERM newPerm) { *\/",
        "query_nlx":"\/* Function named find_and_update_session_info searches for a session with a given UUID, updates its information with a new name and permission, and returns true if the session is found and updated successfully, otherwise false.\n>>> find_and_update_session_info(\"example_uuid\", \"New Name\", crypto::PERM::READ_WRITE) true\n>>> find_and_update_session_info(\"non_existent_uuid\", \"Another Name\", crypto::PERM::READ_ONLY) false *\/ \nbool find_and_udpate_session_info(const std::string& uuid, const std::string& name, const crypto::PERM newPerm) { "
    }

    {
        "file_name":"nvsdk_ngx_helpers_vk_function_1.cpp",
        "line_count":13,
        "code":"NVSDK_NGX_Resource_VK NVSDK_NGX_Create_ImageView_Resource_VK(VkImageView imageView, VkImage image, VkImageSubresourceRange subresourceRange, VkFormat format, unsigned int width, unsigned int height, bool readWrite)\n{\n    NVSDK_NGX_Resource_VK resourceVK = {0};\n    resourceVK.Type = NVSDK_NGX_RESOURCE_VK_TYPE_VK_IMAGEVIEW;\n    resourceVK.Resource.ImageViewInfo.ImageView = imageView;\n    resourceVK.Resource.ImageViewInfo.Image = image;\n    resourceVK.Resource.ImageViewInfo.SubresourceRange = subresourceRange;\n    resourceVK.Resource.ImageViewInfo.Height = height;\n    resourceVK.Resource.ImageViewInfo.Width = width;\n    resourceVK.Resource.ImageViewInfo.Format = format;\n    resourceVK.ReadWrite = readWrite;\n    return resourceVK;\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a resource for an image view with specified parameters.\n>>> NVSDK_NGX_Create_ImageView_Resource_VK(VkImageView imageView, VkImage image, VkImageSubresourceRange subresourceRange, VkFormat format, unsigned int width, unsigned int height, bool readWrite) *\/",
        "query_nlx":"\/* Create a function that generates a resource for a Vulkan image view with specified parameters such as image view, image, subresource range, format, width, height, and read\/write access.\n   >>> NVSDK_NGX_Resource_VK NVSDK_NGX_Create_ImageView_Resource_VK(VkImageView imageView, VkImage image, VkImageSubresourceRange subresourceRange, VkFormat format, unsigned int width, unsigned int height, bool readWrite) *\/"
    }

    {
        "file_name":"nvsdk_ngx_helpers_vk_function_2.cpp",
        "line_count":9,
        "code":"NVSDK_NGX_Resource_VK NVSDK_NGX_Create_Buffer_Resource_VK(VkBuffer buffer, unsigned int sizeInBytes, bool readWrite)\n{\n    NVSDK_NGX_Resource_VK resourceVK = {0};\n    resourceVK.Type = NVSDK_NGX_RESOURCE_VK_TYPE_VK_BUFFER;\n    resourceVK.Resource.BufferInfo.Buffer = buffer;\n    resourceVK.Resource.BufferInfo.SizeInBytes = sizeInBytes;\n    resourceVK.ReadWrite = readWrite;\n    return resourceVK;\n}",
        "mark":8.0,
        "query_nsx":"\/* Create a resource for Vulkan buffer with specified size and access permissions.\n>>> NVSDK_NGX_Resource_VK NVSDK_NGX_Create_Buffer_Resource_VK(VkBuffer buffer, unsigned int sizeInBytes, bool readWrite) { *\/",
        "query_nlx":"        \/* Function named NVSDK_NGX_Create_Buffer_Resource_VK creates a resource for a Vulkan buffer with specified buffer, size in bytes, and read\/write access.\n        >>> NVSDK_NGX_Create_Buffer_Resource_VK(VkBuffer buffer, unsigned int sizeInBytes, bool readWrite) NVSDK_NGX_Resource_VK *\/"
    }

    {
        "file_name":"object_pool_function_1.cpp",
        "line_count":4,
        "code":"void destroy(Object* o)\n  {\n    delete o;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Destroy the given object by deallocating its memory. \n   >>> void destroy(Object* o) *\/",
        "query_nlx":"\/* Function named destroy takes an object pointer as input and deallocates the memory occupied by the object. \n>>> destroy(Object* o) *\/"
    }

    {
        "file_name":"object_pool_function_3.cpp",
        "line_count":9,
        "code":"void destroy_list(Object* list)\n  {\n    while (list)\n    {\n      Object* o = list;\n      list = object_pool_access::next(o);\n      object_pool_access::destroy(o);\n    }\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Destroy a linked list by iterating through and freeing each node.\n        >>> void destroy_list(Object* list) { *\/",
        "query_nlx":"\/* Function named destroy_list iterates through a list of objects, accessing each object from the object pool, destroying it, and moving to the next object until the entire list is destroyed. \n>>> destroy_list(list) *\/ \nvoid destroy_list(Object* list) { "
    }

    {
        "file_name":"overlapped_ptr_function_1.cpp",
        "line_count":4,
        "code":"void reset()\n  {\n    impl_.reset();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the internal state of the object.\n   >>> reset() *\/ \nvoid reset() { \n    \/\/ function body omitted\n}",
        "query_nlx":"\/* Reset function resets the internal state of the object by calling the reset function of the implementation object.\n>>> reset()\n*\/ \nvoid reset() {"
    }

    {
        "file_name":"parser_function_8.cpp",
        "line_count":3,
        "code":"void set_max_body_size(size_t value) {\n        m_body_bytes_max = value;\n    }",
        "mark":9.0,
        "query_nsx":"\/* Set the maximum size limit for the body content.\n   >>> set_max_body_size(1024) *\/ \nvoid set_max_body_size(size_t value) {",
        "query_nlx":"\/* Define a function that sets the maximum size of the body to a given value.\n   >>> set_max_body_size(1000) *\/ \nvoid set_max_body_size(size_t value) {"
    }

    {
        "file_name":"partial_promise_function_3.cpp",
        "line_count":1,
        "code":"void return_void() {}",
        "mark":8.0,
        "query_nsx":"\/* Define a function that does not return any value. \n   >>> return_void() *\/ \nvoid return_void() {",
        "query_nlx":"\/* Define a function that returns void and takes no input parameters.\n   >>> return_void() *\/ \nvoid return_void() {"
    }

    {
        "file_name":"pattern_except_function_1.cpp",
        "line_count":8,
        "code":"void raise_runtime_error(const E& ex)\n{\n#ifndef BOOST_REGEX_STANDALONE\n   ::boost::throw_exception(ex);\n#else\n   throw ex;\n#endif\n}",
        "mark":8.0,
        "query_nsx":"\/* Define a function that raises a runtime error with the given exception.\n   >>> raise_runtime_error(const E& ex) *\/",
        "query_nlx":"\/* Define a function that raises a runtime error with the given exception.\n   >>> raise_runtime_error(ex) void *\/"
    }

    {
        "file_name":"perl_matcher_function_14.cpp",
        "line_count":1,
        "code":"size_t get_count() { return count; }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the current count value stored in the system.\n   >>> get_count()  *\/\nsize_t get_count();",
        "query_nlx":"\/* Define a function that retrieves the current count value stored in the system.\n   >>> get_count() returns the current count value stored in the system *\/ \nsize_t get_count() {"
    }

    {
        "file_name":"perl_matcher_function_17.cpp",
        "line_count":2,
        "code":"void setf(match_flag_type f)\n   { m_match_flags |= f; }",
        "mark":8.0,
        "query_nsx":"\/* Set a specific match flag for the function.\n   >>> void setf(match_flag_type f) { *\/",
        "query_nlx":"\/* Function named setf updates the match flags by adding the provided flag value.\n   >>> setf(MATCH_CASE_INSENSITIVE) updates the match flags to include the case-insensitive flag.\n   >>> setf(MATCH_WHOLE_WORD) updates the match flags to include the whole word matching flag. *\/ \nvoid setf(match_flag_type f) {  *\/"
    }

    {
        "file_name":"perl_matcher_function_20.cpp",
        "line_count":2,
        "code":"void setf(match_flag_type f)\n   { m_match_flags |= f; }",
        "mark":8.0,
        "query_nsx":"\/* Set a specific match flag for the operation.\n   >>> void setf(match_flag_type f) { *\/",
        "query_nlx":"\/* Define a function that sets a given match flag type in the system.\n   >>> setf(MATCH_FLAG_TYPE) *\/ \nvoid setf(match_flag_type f) { "
    }

    {
        "file_name":"perl_matcher_function_21.cpp",
        "line_count":2,
        "code":"void unsetf(match_flag_type f)\n   { m_match_flags &= ~f; }",
        "mark":8.0,
        "query_nsx":"\/* Unset a specific match flag.\n   >>> unsetf(match_flag_type f) *\/",
        "query_nlx":"\/* Function named unsetf modifies the match flags by unsetting a specific flag indicated by the input match_flag_type.\n   >>> unsetf(MATCH_FLAG_TYPE) updates the match flags by removing the specified flag.\n*\/ \nvoid unsetf(match_flag_type f) { "
    }

    {
        "file_name":"perl_matcher_function_3.cpp",
        "line_count":4,
        "code":"bool can_start(char c, const unsigned char* map, unsigned char mask)\n{\n   return map[(unsigned char)c] & mask;\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if a specific character can be used to start an action based on a given map and mask.\n>>> bool can_start(char c, const unsigned char* map, unsigned char mask) { *\/",
        "query_nlx":"\/* Function named can_start determines if a specific character can be used to start an action based on a given map and mask. \n>>> can_start('A', {0, 1, 0, 1, 0}, 1) true \n>>> can_start('B', {1, 0, 1, 0, 1}, 2) false *\/ \nbool can_start(char c, const unsigned char* map, unsigned char mask) { "
    }

    {
        "file_name":"perl_matcher_function_5.cpp",
        "line_count":4,
        "code":"bool can_start(unsigned char c, const unsigned char* map, unsigned char mask)\n{\n   return map[c] & mask;\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if a specific character can be used to start a certain operation based on a provided map and mask.\n>>> bool can_start(unsigned char c, const unsigned char* map, unsigned char mask) *\/",
        "query_nlx":"\/* Function named can_start determines if a specific character can be used to start a process based on a given map and mask. \n>>> can_start('A', {0x00, 0xFF, 0x0F}, 0x0F) true \n>>> can_start('B', {0x00, 0xFF, 0x0F}, 0x0F) false *\/ \nbool can_start(unsigned char c, const unsigned char* map, unsigned char mask) { "
    }

    {
        "file_name":"posix_serial_port_service_function_4.cpp",
        "line_count":4,
        "code":"void destroy(implementation_type& impl)\n  {\n    descriptor_service_.destroy(impl);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Destroy the implementation object using the descriptor service.\n   >>> destroy(implementation_type& impl) *\/",
        "query_nlx":"\/* Function named destroy takes an implementation type object and destroys it using the descriptor service.\n   >>> destroy(impl) *\/ \nvoid destroy(implementation_type& impl) { \n    \/\/ body of the function is omitted\n}"
    }

    {
        "file_name":"posix_serial_port_service_function_7.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    return descriptor_service_.native_handle(impl);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the native handle associated with the implementation type provided.\n   >>> native_handle_type native_handle(implementation_type& impl){ *\/",
        "query_nlx":"\/* Function named native_handle takes an implementation_type object as input and returns the native handle associated with it using the descriptor_service_ member function. \n>>> native_handle(implementation_type& impl) native_handle_type { *\/"
    }

    {
        "file_name":"primary_transform_function_1.cpp",
        "line_count":15,
        "code":"unsigned count_chars(const S& s, charT c)\n{\n   \/\/\n   \/\/ Count how many occurrences of character c occur\n   \/\/ in string s: if c is a delimeter between collation\n   \/\/ fields, then this should be the same value for all\n   \/\/ sort keys:\n   \/\/\n   unsigned int count = 0;\n   for(unsigned pos = 0; pos < s.size(); ++pos)\n   {\n      if(s[pos] == c) ++count;\n   }\n   return count;\n}",
        "mark":8.0,
        "query_nsx":"\/* Count the number of occurrences of a specific character in a given string.\n   >>> unsigned count_chars(const S& s, charT c) *\/",
        "query_nlx":"        \/* Function named count_chars counts the occurrences of a specified character within a given string.\n        >>> count_chars(\"hello\", 'l') 2\n        >>> count_chars(\"world\", 'd') 1 *\/ \n        unsigned count_chars(const S& s, charT c) { "
    }

    {
        "file_name":"processor_function_4.cpp",
        "line_count":3,
        "code":"void set_max_message_size(size_t new_value) {\n        m_max_message_size = new_value;\n    }",
        "mark":9.0,
        "query_nsx":"\/* Set the maximum size of a message to a new value.\n>>> void set_max_message_size(size_t new_value); *\/",
        "query_nlx":"\/* Define a function that updates the maximum message size to a new specified value.\n   >>> set_max_message_size(100) *\/ \nvoid set_max_message_size(size_t new_value) {"
    }

    {
        "file_name":"process_function_15.cpp",
        "line_count":6,
        "code":"uint32_t\n  calculate_crc32(const std::string &input) {\n    boost::crc_32_type result;\n    result.process_bytes(input.data(), input.length());\n    return result.checksum();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Calculate CRC32 checksum for the given input string.\n   >>> calculate_crc32(\"hello world\") 123456789\n   >>> calculate_crc32(\"example input\") 987654321 *\/ \nuint32_t calculate_crc32(const std::string &input) {",
        "query_nlx":"\/* Function named calculate_crc32 computes the CRC-32 checksum of a given input string using a specific algorithm. \n>>> calculate_crc32(\"hello world\") 222957957 \n>>> calculate_crc32(\"example input\") 123456789 *\/ \nuint32_t calculate_crc32(const std::string &input) {"
    }

    {
        "file_name":"process_function_1_1.cpp",
        "line_count":4,
        "code":"void onVDisplayWatchdogFailed() {\n    vDisplayDriverStatus = VDISPLAY::DRIVER_STATUS::WATCHDOG_FAILED;\n    VDISPLAY::closeVDisplayDevice();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set the display driver status to WATCHDOG_FAILED and close the display device.\n   >>> void onVDisplayWatchdogFailed() { *\/",
        "query_nlx":"\/* Define a function that sets the driver status to WATCHDOG_FAILED and closes the display device.\n   >>> onVDisplayWatchdogFailed() *\/ \nvoid onVDisplayWatchdogFailed() {"
    }

    {
        "file_name":"promise_function_2.cpp",
        "line_count":1,
        "code":"allocator_type get_allocator() {return allocator;}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the allocator used by the container. \n>>> allocator_type get_allocator() { *\/",
        "query_nlx":"\/* Function named get_allocator retrieves the allocator used by the current object. \n>>> get_allocator() returns the allocator_type used by the object. *\/ \nallocator_type get_allocator() {"
    }

    {
        "file_name":"quat_function_1.cpp",
        "line_count":1,
        "code":"size_type size() { return SIZE; }",
        "mark":8.0,
        "query_nsx":"\/* Determine the size of the data structure.\n   >>> size_type size() { *\/",
        "query_nlx":"\/* Query: Define a function that returns the size of a data structure.\n   >>> size() returns the size of the data structure.\n*\/ \nsize_type size() { "
    }

    {
        "file_name":"reactive_socket_service_base_function_1.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle(base_implementation_type& impl)\n  {\n    return impl.socket_;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the native handle associated with the base implementation type.\n   >>> native_handle_type native_handle(base_implementation_type& impl) *\/",
        "query_nlx":"\/* Retrieve the native handle from the base implementation type, returning the socket.\n   >>> native_handle(base_implementation_type& impl) \n*\/"
    }

    {
        "file_name":"reactive_socket_service_function_6.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    return impl.socket_;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the underlying socket handle from the implementation for further use.\n   >>> native_handle_type native_handle(implementation_type& impl) { *\/",
        "query_nlx":"\/* Retrieve the native handle from the implementation type and return it.\n   >>> native_handle(implementation_type& impl) \n*\/"
    }

    {
        "file_name":"reactor_op_queue_function_1.cpp",
        "line_count":1,
        "code":"iterator begin() { return operations_.begin(); }",
        "mark":8.0,
        "query_nsx":"\/* Return the beginning iterator of a collection of operations.\n   >>> iterator begin() { *\/",
        "query_nlx":"\/* Retrieve an iterator that points to the beginning of a collection of operations.\n   >>> begin() iterator points to the start of the operations collection *\/ \niterator begin() { "
    }

    {
        "file_name":"reactor_op_queue_function_2.cpp",
        "line_count":1,
        "code":"iterator end() { return operations_.end(); }",
        "mark":8.0,
        "query_nsx":"\/* Return the end iterator of a collection of operations.\n   >>> iterator end()\n*\/",
        "query_nlx":"\/* Define an iterator function that returns the end iterator of a collection of operations.\n   >>> end() returns the end iterator of the operations collection. *\/ \niterator end() { "
    }

    {
        "file_name":"regex_format_function_14.cpp",
        "line_count":4,
        "code":"OutputIter do_format_string(const S& s, OutputIter i)\n   {\n      return std::copy(s.begin(), s.end(), i);\n   }",
        "mark":8.0,
        "query_nsx":"\/* Copy the elements of a given sequence to an output iterator. \n   >>> do_format_string(const S& s, OutputIter i){ *\/",
        "query_nlx":"\/* Function named do_format_string takes a string and an output iterator as input, and copies the elements of the string to the output iterator.\n   >>> do_format_string(\"example\", output_iterator) returns an output iterator with the elements of the string \"example\" copied to it. *\/ \nOutputIter do_format_string(const S& s, OutputIter i) { "
    }

    {
        "file_name":"regex_format_function_15.cpp",
        "line_count":10,
        "code":"OutputIter do_format_string(const S* s, OutputIter i)\n   {\n      while(s && *s)\n      {\n         *i = *s;\n         ++i;\n         ++s;\n      }\n      return i;\n   }",
        "mark":8.0,
        "query_nsx":"\/* Copy characters from a given string to an output iterator until the end of the string is reached. \n>>> OutputIter do_format_string(const S* s, OutputIter i) { *\/",
        "query_nlx":"\/* Function named do_format_string takes a pointer to a string and an output iterator, and iterates through the string to copy its characters to the output iterator until a null terminator is reached. \n>>> do_format_string(\"hello\", output_iterator) \n>>> do_format_string(\"12345\", output_iterator) *\/ \nOutputIter do_format_string(const S* s, OutputIter i) {"
    }

    {
        "file_name":"regex_raw_buffer_function_7.cpp",
        "line_count":6,
        "code":"void swap(raw_storage& that)\n   {\n      std::swap(start, that.start);\n      std::swap(end, that.end);\n      std::swap(last, that.last);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Swap the contents of two storage objects.\n   >>> void swap(raw_storage& that) *\/",
        "query_nlx":"\/* Function named swap takes a raw_storage object and swaps its internal data members with another raw_storage object.\n   >>> swap(raw_storage& that) *\/"
    }

    {
        "file_name":"regex_raw_buffer_function_9.cpp",
        "line_count":6,
        "code":"void swap(raw_storage& that)\n   {\n      std::swap(start, that.start);\n      std::swap(end, that.end);\n      std::swap(last, that.last);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Swap the contents of two storage objects.\n   >>> void swap(raw_storage& that) { *\/",
        "query_nlx":"\/* Function named swap takes a raw_storage object and swaps its internal start, end, and last values with another raw_storage object's corresponding values.\n   >>> swap(raw_storage& that) *\/"
    }

    {
        "file_name":"regex_traits_defaults_function_10.cpp",
        "line_count":10,
        "code":"ptrdiff_t global_length(const charT* p)\n{\n   std::ptrdiff_t n = 0;\n   while(*p)\n   {\n      ++p;\n      ++n;\n   }\n   return n;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine the length of a given string.\n>>> global_length(const charT* p) *\/",
        "query_nlx":"\/* Function named global_length calculates the length of a given string by counting the number of characters until the null terminator is reached. \n>>> global_length(\"hello\") 5 \n>>> global_length(\"world\") 5 *\/ \nptrdiff_t global_length(const charT* p) { "
    }

    {
        "file_name":"regex_traits_defaults_function_15.cpp",
        "line_count":4,
        "code":"wchar_t  do_global_lower(wchar_t c)\n{\n   return (std::towlower)(c);\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a given character to its lowercase equivalent.\n>>> wchar_t do_global_lower(wchar_t c) *\/",
        "query_nlx":"\/* Function named do_global_lower takes a wide character as input and returns the lowercase version of that character.\n>>> do_global_lower('A') 'a'\n>>> do_global_lower('z') 'z' *\/ \nwchar_t do_global_lower(wchar_t c) { "
    }

    {
        "file_name":"regex_workaround_function_2.cpp",
        "line_count":2,
        "code":"void pointer_construct(T* p, const T& t)\n{ new (p) T(t); }",
        "mark":8.0,
        "query_nsx":"\/* Construct a pointer to an object of a given type using the provided value.\n   >>> pointer_construct(p, t) *\/ \nvoid pointer_construct(T* p, const T& t) {",
        "query_nlx":"\/* Function named pointer_construct constructs a new object of type T at the memory location pointed to by pointer p by calling the copy constructor of type T with the provided reference t.\n>>> pointer_construct(&obj1, obj2)\n*\/ \nvoid pointer_construct(T* p, const T& t) {"
    }

    {
        "file_name":"robin_growth_policy_function_2.cpp",
        "line_count":3,
        "code":"bool is_power_of_two(std::size_t value) {\n        return value != 0 && (value & (value - 1)) == 0;\n    }",
        "mark":9.0,
        "query_nsx":"\/* Determine if the input value is a power of two.\n>>> bool is_power_of_two(std::size_t value) { *\/",
        "query_nlx":"\/* Function named is_power_of_two determines if a given positive integer is a power of two.\n   >>> is_power_of_two(16) true\n   >>> is_power_of_two(15) false *\/ \nbool is_power_of_two(std::size_t value) {"
    }

    {
        "file_name":"robin_hash_function_13.cpp",
        "line_count":3,
        "code":"size_type erase(const K& key) {\n        return erase(key, hash_key(key));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from a data structure based on a given key.\n   >>> size_type erase(const K& key) { *\/",
        "query_nlx":"\/* Define a function called erase that removes an element from a collection based on a given key. The function should return the size of the collection after the removal operation.\n   >>> erase(\"key\") *\/ \nsize_type erase(const K& key) {"
    }

    {
        "file_name":"robin_hash_function_15.cpp",
        "line_count":13,
        "code":"void swap(robin_hash& other) {\n        using std::swap;\n        \n        swap(static_cast<Hash&>(*this), static_cast<Hash&>(other));\n        swap(static_cast<KeyEqual&>(*this), static_cast<KeyEqual&>(other));\n        swap(static_cast<GrowthPolicy&>(*this), static_cast<GrowthPolicy&>(other));\n        swap(m_buckets, other.m_buckets);\n        swap(m_bucket_count, other.m_bucket_count);\n        swap(m_nb_elements, other.m_nb_elements);\n        swap(m_load_threshold, other.m_load_threshold);\n        swap(m_max_load_factor, other.m_max_load_factor);\n        swap(m_grow_on_next_insert, other.m_grow_on_next_insert);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Swap the contents of two hash objects including their internal data structures and configurations.\n        >>> void swap(robin_hash& other) { *\/",
        "query_nlx":"        \/* Define a function named swap that exchanges the contents of the current robin_hash object with another robin_hash object.\n        >>> swap(other) *\/ \n        void swap(robin_hash& other) {"
    }

    {
        "file_name":"robin_hash_function_16.cpp",
        "line_count":3,
        "code":"iterator find(const K& key) {\n        return find_impl(key, hash_key(key));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator pointing to the element with the specified key in a data structure. \n>>> iterator find(const K& key) { *\/",
        "query_nlx":"\/* Function named find searches for a key in a data structure and returns an iterator pointing to the element if found.\n   >>> find(\"example_key\") *\/ \niterator find(const K& key) {"
    }

    {
        "file_name":"robin_hash_function_17.cpp",
        "line_count":3,
        "code":"iterator find(const K& key, std::size_t hash) {\n        return find_impl(key, hash);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator associated with a given key and hash value.\n   >>> iterator find(const K& key, std::size_t hash) { *\/",
        "query_nlx":"\/* Function named find searches for an element with a specific key and hash value in a data structure and returns an iterator pointing to that element.\n   >>> find(\"example_key\", 123) *\/ \niterator find(const K& key, std::size_t hash) {"
    }

    {
        "file_name":"robin_hash_function_18.cpp",
        "line_count":4,
        "code":"void max_load_factor(float ml) {\n        m_max_load_factor = std::max(0.1f, std::min(ml, 0.95f));\n        m_load_threshold = size_type(float(bucket_count())*m_max_load_factor);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the maximum load factor and load threshold for a data structure. \n>>> void max_load_factor(float ml) { *\/",
        "query_nlx":"\/* Define a function that calculates the maximum load factor and load threshold based on the input value.\n>>> max_load_factor(0.8) \n>>> max_load_factor(0.5) *\/ \nvoid max_load_factor(float ml) {"
    }

    {
        "file_name":"robin_hash_function_19.cpp",
        "line_count":4,
        "code":"void rehash(size_type count) {\n        count = std::max(count, size_type(std::ceil(float(size())\/max_load_factor())));\n        rehash_impl(count);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Rehash the data structure to optimize its size based on the given count.\n   >>> rehash(10) *\/ \nvoid rehash(size_type count) {",
        "query_nlx":"\/* Define a function rehash that adjusts the count parameter to be the maximum value between the given count and the result of dividing the current size by the maximum load factor, rounded up to the nearest integer. \n>>> rehash(10) \n*\/ \nvoid rehash(size_type count) {"
    }

    {
        "file_name":"robin_hash_function_21.cpp",
        "line_count":3,
        "code":"iterator mutable_iterator(const_iterator pos) {\n        return iterator(m_buckets.begin() + std::distance(m_buckets.cbegin(), pos.m_iterator));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Create a mutable iterator pointing to a position in a collection. \n>>> iterator mutable_iterator(const_iterator pos) { *\/",
        "query_nlx":"\/* Function named mutable_iterator takes a constant iterator position as input and returns a mutable iterator pointing to the same position in the container. \n>>> mutable_iterator({1, 2, 3}.cbegin()) { \n*\/"
    }

    {
        "file_name":"robin_hash_function_22.cpp",
        "line_count":3,
        "code":"iterator find_impl(const K& key, std::size_t hash) {\n        return mutable_iterator(static_cast<const robin_hash*>(this)->find(key, hash));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator pointing to an element in a data structure based on a given key and hash value.\n>>> iterator find_impl(const K& key, std::size_t hash) { *\/",
        "query_nlx":"\/* Function find_impl returns an iterator that finds a key in a data structure using a given hash value.\n   >>> find_impl(key, hash) iterator *\/ \niterator find_impl(const K& key, std::size_t hash) {"
    }

    {
        "file_name":"robin_hash_function_29.cpp",
        "line_count":10,
        "code":"bool grow_on_high_load() {\n        if(m_grow_on_next_insert || size() >= m_load_threshold) {\n            rehash_impl(GrowthPolicy::next_bucket_count());\n            m_grow_on_next_insert = false;\n            \n            return true;\n        }\n        \n        return false;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine whether to trigger a resizing operation based on current load conditions.\n   >>> grow_on_high_load() *\/ \nbool grow_on_high_load() {",
        "query_nlx":"\/* Function named grow_on_high_load determines whether to trigger a rehash operation based on the current load of a data structure. \n>>> grow_on_high_load() true \n>>> grow_on_high_load() false *\/ \nbool grow_on_high_load() {"
    }

    {
        "file_name":"robin_hash_function_8.cpp",
        "line_count":3,
        "code":"iterator emplace_hint(const_iterator hint, Args&&... args) {\n        return insert(hint, value_type(std::forward<Args>(args)...));        \n    }",
        "mark":8.0,
        "query_nsx":"\/* Define a function that inserts a new element into a container at a specified position, optimizing for performance by providing a hint for the insertion point.\n>>> iterator emplace_hint(const_iterator hint, Args&&... args) { *\/",
        "query_nlx":"\/* Define a function called emplace_hint that inserts a new element into a container at a specified position, using the provided arguments.\n   >>> emplace_hint(const_iterator hint, Args&&... args) *\/\niterator emplace_hint(const_iterator hint, Args&&... args) { "
    }

    {
        "file_name":"robin_map_function_1.cpp",
        "line_count":3,
        "code":"iterator insert(const_iterator hint, const value_type& value) { \n        return m_ht.insert(hint, value); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert a value into a container using a hint iterator position. \n    >>> iterator insert(const_iterator hint, const value_type& value) { *\/",
        "query_nlx":"\/* Define a function named insert that takes a hint iterator and a value as input, and returns an iterator. \n   >>> insert(hint, value) iterator *\/"
    }

    {
        "file_name":"robin_map_function_10.cpp",
        "line_count":3,
        "code":"iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args) {\n        return m_ht.try_emplace(hint, std::move(k), std::forward<Args>(args)...);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Attempt to insert a new element into a container at a specific position, utilizing the provided hint if possible.\n   >>> iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args) { *\/",
        "query_nlx":"\/* Define a function called try_emplace that attempts to insert a new element into a container at a specified position, utilizing perfect forwarding for the arguments.\n   >>> iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args) { *\/"
    }

    {
        "file_name":"robin_map_function_13.cpp",
        "line_count":1,
        "code":"iterator erase(const_iterator first, const_iterator last) { return m_ht.erase(first, last); }",
        "mark":8.0,
        "query_nsx":"\/* Remove elements from a container within a specified range.\n   >>> iterator erase(const_iterator first, const_iterator last) *\/",
        "query_nlx":"\/* Define a function named erase that removes elements in a container starting from the first iterator up to, but not including, the last iterator.\n   >>> erase({1, 2, 3, 4, 5}, {2, 3}) removes elements 2 and 3 from the container {1, 2, 3, 4, 5}.\n   >>> erase({'a', 'b', 'c', 'd'}, {'b', 'c'}) removes elements 'b' and 'c' from the container {'a', 'b', 'c', 'd'}. *\/ \niterator erase(const_iterator first, const_iterator last) { *\/"
    }

    {
        "file_name":"robin_map_function_14.cpp",
        "line_count":1,
        "code":"size_type erase(const key_type& key) { return m_ht.erase(key); }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from the data structure based on the provided key.\n   >>> erase(\"key\") size_type *\/",
        "query_nlx":"\/* Function named erase removes an element from a hash table based on a given key and returns the number of elements erased. \n>>> erase(\"key123\") 1 \n>>> erase(\"key456\") 0 *\/ \nsize_type erase(const key_type& key) { "
    }

    {
        "file_name":"robin_map_function_15.cpp",
        "line_count":3,
        "code":"size_type erase(const key_type& key, std::size_t precalculated_hash) { \n        return m_ht.erase(key, precalculated_hash); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from a hash table using a precalculated hash value.\n   >>> size_type erase(const key_type& key, std::size_t precalculated_hash) { *\/",
        "query_nlx":"\/* Function named erase removes an element from a hash table using a precalculated hash value.\n   >>> erase(\"key_value\", 123) returns the size of the hash table after removing the element with the key \"key_value\" using the precalculated hash value 123. *\/ \nsize_type erase(const key_type& key, std::size_t precalculated_hash) { "
    }

    {
        "file_name":"robin_map_function_16.cpp",
        "line_count":1,
        "code":"size_type erase(const K& key) { return m_ht.erase(key); }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from the data structure based on the provided key.\n   >>> erase(\"key\")  *\/ \nsize_type erase(const K& key) { ",
        "query_nlx":"\/* Function named erase removes an element from a hash table based on a given key.\n>>> erase(\"key\") returns the size of the hash table after removing the element with the specified key. *\/ \nsize_type erase(const K& key) { "
    }

    {
        "file_name":"robin_map_function_17.cpp",
        "line_count":3,
        "code":"size_type erase(const K& key, std::size_t precalculated_hash) { \n        return m_ht.erase(key, precalculated_hash); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from a data structure based on a provided key and precalculated hash value.\n   >>> size_type erase(const K& key, std::size_t precalculated_hash) { *\/",
        "query_nlx":"\/* Function named erase removes an element from a hash table using a precalculated hash value.\n>>> erase(\"key_value\", 12345) 5\n>>> erase(\"another_key\", 54321) 0 *\/ \nsize_type erase(const K& key, std::size_t precalculated_hash) { "
    }

    {
        "file_name":"robin_map_function_18.cpp",
        "line_count":1,
        "code":"void swap(robin_map& other) { other.m_ht.swap(m_ht); }",
        "mark":8.0,
        "query_nsx":"\/* Swap the contents of two hash tables. \n>>> void swap(robin_map& other) { *\/",
        "query_nlx":"\/* Function named swap exchanges the contents of two hash tables represented by robin_map objects.\n>>> swap(robin_map& other) swaps the contents of the current robin_map object with the robin_map object passed as a parameter. *\/ \nvoid swap(robin_map& other) { other.m_ht.swap(m_ht); }"
    }

    {
        "file_name":"robin_map_function_19.cpp",
        "line_count":1,
        "code":"iterator find(const Key& key) { return m_ht.find(key); }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator pointing to the element with the specified key in the data structure.\n   >>> find(\"key\") *\/ \niterator find(const Key& key) { ",
        "query_nlx":"\/* Function named find searches for a specific key in a data structure and returns an iterator pointing to the location of that key.\n   >>> find(\"apple\") \n   >>> find(42) *\/ \niterator find(const Key& key) { "
    }

    {
        "file_name":"robin_map_function_2.cpp",
        "line_count":3,
        "code":"iterator insert(const_iterator hint, P&& value) { \n        return m_ht.emplace_hint(hint, std::forward<P>(value));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert a value into a container using a given hint iterator position.\n   >>> iterator insert(const_iterator hint, P&& value); *\/",
        "query_nlx":"\/* Define a function named insert that takes a hint iterator and a value to insert, then returns an iterator pointing to the inserted element.\n   >>> insert(hint_iterator, value) iterator *\/\niterator insert(const_iterator hint, P&& value) {"
    }

    {
        "file_name":"robin_map_function_20.cpp",
        "line_count":1,
        "code":"iterator find(const Key& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator pointing to the element with a specified key and precalculated hash value in a data structure. \n>>> iterator find(const Key& key, std::size_t precalculated_hash) { *\/",
        "query_nlx":"\/* Function find searches for a key in a hash table using a precalculated hash value.\n   >>> find(\"example_key\", 12345) returns an iterator pointing to the location of the key in the hash table. *\/ \niterator find(const Key& key, std::size_t precalculated_hash) { "
    }

    {
        "file_name":"robin_map_function_21.cpp",
        "line_count":1,
        "code":"iterator find(const K& key) { return m_ht.find(key); }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator pointing to the element with the specified key in the data structure.\n   >>> iterator find(const K& key) { *\/",
        "query_nlx":"\/* Function named find searches for a specific key in a data structure and returns an iterator pointing to the location of that key.\n   >>> find(\"apple\") \n   >>> find(42) *\/ \niterator find(const K& key) { "
    }

    {
        "file_name":"robin_map_function_22.cpp",
        "line_count":1,
        "code":"iterator find(const K& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator pointing to the element with the specified key in a data structure using a precalculated hash value.\n>>> iterator find(const K& key, std::size_t precalculated_hash) { *\/",
        "query_nlx":"\/* Function find searches for an element with a specified key in a hash table using a precalculated hash value.\n>>> find(\"example_key\", 12345) returns an iterator pointing to the element with the key \"example_key\" in the hash table with the precalculated hash value 12345. *\/ \niterator find(const K& key, std::size_t precalculated_hash) { "
    }

    {
        "file_name":"robin_map_function_23.cpp",
        "line_count":1,
        "code":"void max_load_factor(float ml) { m_ht.max_load_factor(ml); }",
        "mark":8.0,
        "query_nsx":"\/* Set the maximum load factor for a data structure. \n>>> void max_load_factor(float ml) { *\/",
        "query_nlx":"\/* Define a function that sets the maximum load factor of a hash table to a given value.\n>>> max_load_factor(0.75) void max_load_factor(float ml) { m_ht.max_load_factor(ml); } *\/"
    }

    {
        "file_name":"robin_map_function_24.cpp",
        "line_count":1,
        "code":"void rehash(size_type count) { m_ht.rehash(count); }",
        "mark":8.0,
        "query_nsx":"\/* Rehash the internal data structure with a new size specified by the count parameter.\n   >>> rehash(100) *\/ \nvoid rehash(size_type count) { \/* function body omitted *\/ }",
        "query_nlx":"\/* Define a function called rehash that takes a single parameter, count, and rehashes the internal hash table with the specified count. \n   >>> rehash(100) *\/ \nvoid rehash(size_type count) { "
    }

    {
        "file_name":"robin_map_function_25.cpp",
        "line_count":1,
        "code":"void reserve(size_type count) { m_ht.reserve(count); }",
        "mark":8.0,
        "query_nsx":"\/* Reserve memory space for a data structure to optimize performance.\n   >>> reserve(size_type count) *\/",
        "query_nlx":"\/* Define a function called reserve that sets the capacity of a data structure to a specified count value.\n>>> reserve(100) *\/ \nvoid reserve(size_type count) { "
    }

    {
        "file_name":"robin_map_function_26.cpp",
        "line_count":3,
        "code":"iterator mutable_iterator(const_iterator pos) {\n        return m_ht.mutable_iterator(pos);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return a mutable iterator pointing to a specified position in the container.\n   >>> iterator mutable_iterator(const_iterator pos); *\/",
        "query_nlx":"\/* Function named mutable_iterator takes a constant iterator position as input and returns a mutable iterator from a data structure. \n>>> mutable_iterator(const_iterator pos) \n*\/"
    }

    {
        "file_name":"robin_map_function_27.cpp",
        "line_count":3,
        "code":"void swap(robin_map& lhs, robin_map& rhs) {\n        lhs.swap(rhs);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Swap the contents of two associative arrays. \n   >>> swap(robin_map& lhs, robin_map& rhs) *\/",
        "query_nlx":"        \/* Function named swap takes two robin_map data structures and swaps their contents.\n        >>> swap(lhs, rhs) swaps the contents of the robin_map data structures lhs and rhs *\/ \n        void swap(robin_map& lhs, robin_map& rhs) {"
    }

    {
        "file_name":"robin_map_function_3.cpp",
        "line_count":3,
        "code":"iterator insert(const_iterator hint, value_type&& value) { \n        return m_ht.insert(hint, std::move(value)); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert a value into a container using a hint iterator position.\n   >>> iterator insert(const_iterator hint, value_type&& value); *\/",
        "query_nlx":"\/* Define a function named insert that takes a hint iterator and a value to be moved, then inserts the value into a container using the hint position.\n   >>> insert(hint_iterator, value_to_move) returns an iterator pointing to the inserted value in the container *\/ \niterator insert(const_iterator hint, value_type&& value) {"
    }

    {
        "file_name":"robin_map_function_4.cpp",
        "line_count":3,
        "code":"void insert(InputIt first, InputIt last) { \n        m_ht.insert(first, last); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert elements from the input range into the hash table.\n   >>> insert({1, 2, 3, 4}, {5, 6, 7}) *\/ \nvoid insert(InputIt first, InputIt last) { ",
        "query_nlx":"\/* Define a function called insert that takes a range of elements specified by the iterators first and last and inserts them into a data structure. \n>>> insert({1, 2, 3, 4, 5}, {6, 7, 8}) *\/ \nvoid insert(InputIt first, InputIt last) { \n    \/\/ Function body omitted \n}"
    }

    {
        "file_name":"robin_map_function_5.cpp",
        "line_count":3,
        "code":"void insert(std::initializer_list<value_type> ilist) { \n        m_ht.insert(ilist.begin(), ilist.end()); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert elements from a given list into a data structure. \n>>> insert({5, 10, 15, 20}) *\/ \nvoid insert(std::initializer_list<value_type> ilist) { ",
        "query_nlx":"\/* Define a function that inserts the elements from an initializer list into a data structure.\n   >>> insert({1, 2, 3, 4})\n   *\/ \nvoid insert(std::initializer_list<value_type> ilist) { \n    \/\/ Function body omitted\n}"
    }

    {
        "file_name":"robin_map_function_6.cpp",
        "line_count":3,
        "code":"iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj) {\n        return m_ht.insert_or_assign(hint, k, std::forward<M>(obj));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert or update an element in a container at a specified position if possible.\n   >>> iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj) { *\/",
        "query_nlx":"\/* Define an iterator function called insert_or_assign that takes a hint iterator, a key, and an object to insert or assign in a data structure. \n   >>> insert_or_assign(hint, k, obj) iterator *\/"
    }

    {
        "file_name":"robin_map_function_7.cpp",
        "line_count":3,
        "code":"iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj) {\n        return m_ht.insert_or_assign(hint, std::move(k), std::forward<M>(obj));\n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert or update an element in a container at a specified position using a given key and value.\n>>> iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj) *\/",
        "query_nlx":"\/* Define an iterator function called insert_or_assign that takes a hint iterator, a key, and an object to insert or update in a data structure. \n   >>> insert_or_assign(hint, key, obj) returns an iterator after inserting or updating the key-value pair in the data structure *\/"
    }

    {
        "file_name":"robin_map_function_8.cpp",
        "line_count":3,
        "code":"iterator emplace_hint(const_iterator hint, Args&&... args) {\n        return m_ht.emplace_hint(hint, std::forward<Args>(args)...);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Emplace an element into a container using a hint for efficient insertion.\n   >>> iterator emplace_hint(const_iterator hint, Args&&... args) { *\/",
        "query_nlx":"\/* Define a function named emplace_hint that inserts elements into a container at a specified position, using a hint iterator for optimization.\n   >>> emplace_hint(const_iterator hint, Args&&... args) *\/"
    }

    {
        "file_name":"robin_map_function_9.cpp",
        "line_count":3,
        "code":"iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args) {\n        return m_ht.try_emplace(hint, k, std::forward<Args>(args)...);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Attempt to insert an element into a container at a specific position if possible.\n   >>> iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args) { *\/",
        "query_nlx":"\/* Define a function named try_emplace that attempts to insert a new element into a container at a specified position, using a provided key and additional arguments.\n   >>> iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args) { *\/"
    }

    {
        "file_name":"robin_set_function_1.cpp",
        "line_count":3,
        "code":"iterator insert(const_iterator hint, const value_type& value) { \n        return m_ht.insert(hint, value); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert a value into a container using a specified position hint.\n   >>> iterator insert(const_iterator hint, const value_type& value); *\/",
        "query_nlx":"\/* Define a function named insert that takes a hint iterator and a value as input, and returns an iterator. \n   >>> insert(hint, value) iterator *\/"
    }

    {
        "file_name":"robin_set_function_10.cpp",
        "line_count":3,
        "code":"size_type erase(const key_type& key, std::size_t precalculated_hash) { \n        return m_ht.erase(key, precalculated_hash); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from a hash table using a precalculated hash value.\n   >>> size_type erase(const key_type& key, std::size_t precalculated_hash) { *\/",
        "query_nlx":"\/* Function named erase removes an element from a hash table based on a provided key and precalculated hash value. \n>>> erase(\"example_key\", 12345) returns the size of the hash table after removing the element with the key \"example_key\" using the precalculated hash value 12345. *\/ \nsize_type erase(const key_type& key, std::size_t precalculated_hash) { "
    }

    {
        "file_name":"robin_set_function_11.cpp",
        "line_count":1,
        "code":"size_type erase(const K& key) { return m_ht.erase(key); }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from the data structure based on the provided key.\n   >>> erase(\"key\") size_type *\/",
        "query_nlx":"\/* Function named erase removes an element from a hash table based on a given key.\n>>> erase(\"key\") returns the size of the hash table after removing the element with the specified key. *\/ \nsize_type erase(const K& key) {  *\/"
    }

    {
        "file_name":"robin_set_function_12.cpp",
        "line_count":3,
        "code":"size_type erase(const K& key, std::size_t precalculated_hash) { \n        return m_ht.erase(key, precalculated_hash); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from the data structure based on the provided key and precalculated hash value.\n>>> size_type erase(const K& key, std::size_t precalculated_hash) { *\/",
        "query_nlx":"\/* Define a function that removes an element from a hash table using a precalculated hash value.\n   >>> erase(key, precalculated_hash) returns the size of the hash table after removing the specified key with the precalculated hash value. *\/ \nsize_type erase(const K& key, std::size_t precalculated_hash) { "
    }

    {
        "file_name":"robin_set_function_13.cpp",
        "line_count":1,
        "code":"void swap(robin_set& other) { other.m_ht.swap(m_ht); }",
        "mark":8.0,
        "query_nsx":"\/* Swap the contents of two sets. \n>>> void swap(robin_set& other) { *\/",
        "query_nlx":"\/* Function named swap exchanges the contents of two sets by swapping their internal hash tables.\n>>> swap(set1, set2) swaps the elements of set1 with set2 by exchanging their hash tables. *\/ \nvoid swap(robin_set& other) {  *\/"
    }

    {
        "file_name":"robin_set_function_14.cpp",
        "line_count":1,
        "code":"iterator find(const Key& key) { return m_ht.find(key); }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator pointing to the element with the specified key in the data structure.\n   >>> find(\"key\") *\/ \niterator find(const Key& key) { ",
        "query_nlx":"\/* Function named find searches for a specific key in a data structure and returns an iterator pointing to the location of that key.\n   >>> find(\"apple\") \n   >>> find(42) *\/ \niterator find(const Key& key) { "
    }

    {
        "file_name":"robin_set_function_15.cpp",
        "line_count":1,
        "code":"iterator find(const Key& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator pointing to the element with a specified key and precalculated hash value in a data structure. \n>>> iterator find(const Key& key, std::size_t precalculated_hash) { *\/",
        "query_nlx":"\/* Function named find searches for a key in a hash table using a precalculated hash value.\n   >>> find(\"example_key\", 12345) returns an iterator pointing to the location of the key in the hash table. *\/ \niterator find(const Key& key, std::size_t precalculated_hash) { "
    }

    {
        "file_name":"robin_set_function_16.cpp",
        "line_count":1,
        "code":"iterator find(const K& key) { return m_ht.find(key); }",
        "mark":8.0,
        "query_nsx":"\/* Find an iterator pointing to the element with the specified key in the data structure.\n   >>> iterator find(const K& key) { *\/",
        "query_nlx":"\/* Function named find searches for a specific key in a data structure and returns an iterator pointing to the location of that key.\n   >>> find(\"apple\") \n   >>> find(42) *\/ \niterator find(const K& key) { "
    }

    {
        "file_name":"robin_set_function_17.cpp",
        "line_count":1,
        "code":"iterator find(const K& key, std::size_t precalculated_hash) { return m_ht.find(key, precalculated_hash); }",
        "mark":8.0,
        "query_nsx":"\/* Find an element in a data structure using a precalculated hash value.\n   >>> iterator find(const K& key, std::size_t precalculated_hash) { *\/",
        "query_nlx":"\/* Find an iterator in a hash table using a precalculated hash value.\n   >>> find(\"key_value\", 12345) *\/ \niterator find(const K& key, std::size_t precalculated_hash) { "
    }

    {
        "file_name":"robin_set_function_18.cpp",
        "line_count":1,
        "code":"void max_load_factor(float ml) { m_ht.max_load_factor(ml); }",
        "mark":8.0,
        "query_nsx":"\/* Set the maximum load factor for a data structure. \n   >>> max_load_factor(0.75) *\/ \nvoid max_load_factor(float ml) { ",
        "query_nlx":"\/* Define a function called max_load_factor that sets the maximum load factor of a hash table to the given value.\n   >>> max_load_factor(0.75) *\/ \nvoid max_load_factor(float ml) { "
    }

    {
        "file_name":"robin_set_function_19.cpp",
        "line_count":1,
        "code":"void rehash(size_type count) { m_ht.rehash(count); }",
        "mark":8.0,
        "query_nsx":"\/* Rehash the internal data structure with a new size specified by the count parameter. \n>>> rehash(100) *\/ \nvoid rehash(size_type count) { \/* function body omitted *\/ }",
        "query_nlx":"\/* Define a function rehash that takes a count as input and rehashes the internal data structure with that count.\n   >>> rehash(10) *\/ \nvoid rehash(size_type count) { "
    }

    {
        "file_name":"robin_set_function_2.cpp",
        "line_count":3,
        "code":"iterator insert(const_iterator hint, value_type&& value) { \n        return m_ht.insert(hint, std::move(value)); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert a value into a container using a specified position as a hint.\n   >>> iterator insert(const_iterator hint, value_type&& value); *\/",
        "query_nlx":"\/* Define a function named insert that takes a hint iterator and a value to be moved, then inserts the value at the position suggested by the hint iterator in a container. \n>>> insert(const_iterator hint, value_type&& value) *\/"
    }

    {
        "file_name":"robin_set_function_20.cpp",
        "line_count":1,
        "code":"void reserve(size_type count) { m_ht.reserve(count); }",
        "mark":8.0,
        "query_nsx":"\/* Reserve memory space for a data structure to optimize performance.\n   >>> reserve(size_type count) *\/",
        "query_nlx":"\/* Define a function named reserve that sets the capacity of a data structure to a specified count value.\n   >>> reserve(100) *\/ \nvoid reserve(size_type count) { "
    }

    {
        "file_name":"robin_set_function_21.cpp",
        "line_count":3,
        "code":"iterator mutable_iterator(const_iterator pos) {\n        return m_ht.mutable_iterator(pos);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return a mutable iterator at the specified position in the container.\n   >>> iterator mutable_iterator(const_iterator pos) { *\/",
        "query_nlx":"\/* Function named mutable_iterator takes a constant iterator position as input and returns a mutable iterator from a data structure. \n>>> mutable_iterator(const_iterator pos) \n*\/"
    }

    {
        "file_name":"robin_set_function_22.cpp",
        "line_count":3,
        "code":"void swap(robin_set& lhs, robin_set& rhs) {\n        lhs.swap(rhs);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Swap the contents of two sets.\n   >>> swap(robin_set& lhs, robin_set& rhs) *\/",
        "query_nlx":"\/* Function named swap takes two robin_sets and swaps their contents.\n   >>> swap(lhs, rhs) swaps the contents of the robin_sets lhs and rhs *\/ \nvoid swap(robin_set& lhs, robin_set& rhs) {"
    }

    {
        "file_name":"robin_set_function_3.cpp",
        "line_count":3,
        "code":"void insert(InputIt first, InputIt last) { \n        m_ht.insert(first, last);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert elements from a range defined by two iterators into a data structure.\n   >>> insert(first, last) *\/ \nvoid insert(InputIt first, InputIt last) {",
        "query_nlx":"\/* Define a function called insert that takes a range of elements specified by the iterators first and last and inserts them into a data structure. \n   >>> insert({1, 2, 3, 4, 5}, {6, 7, 8}) *\/ \nvoid insert(InputIt first, InputIt last) { "
    }

    {
        "file_name":"robin_set_function_4.cpp",
        "line_count":3,
        "code":"void insert(std::initializer_list<value_type> ilist) { \n        m_ht.insert(ilist.begin(), ilist.end()); \n    }",
        "mark":8.0,
        "query_nsx":"\/* Insert elements from a list into a data structure. \n>>> insert({1, 2, 3}) *\/ \nvoid insert(std::initializer_list<value_type> ilist) { \n    \/\/ function body omitted \n}",
        "query_nlx":"\/* Define a function that inserts the elements from an initializer list into a data structure. \n   >>> insert({1, 2, 3, 4}) *\/ \nvoid insert(std::initializer_list<value_type> ilist) { \n    \/\/ Function body is omitted for evaluation \n}"
    }

    {
        "file_name":"robin_set_function_5.cpp",
        "line_count":3,
        "code":"iterator emplace_hint(const_iterator hint, Args&&... args) {\n        return m_ht.emplace_hint(hint, std::forward<Args>(args)...);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Return an iterator pointing to the position where a new element can be inserted in a container, using a hint for improved efficiency. \n>>> iterator emplace_hint(const_iterator hint, Args&&... args) { *\/",
        "query_nlx":"\/* Function named emplace_hint inserts a new element into a container at a specified position, using a hint iterator for optimization. \n>>> emplace_hint(const_iterator hint, Args&&... args) \n*\/"
    }

    {
        "file_name":"robin_set_function_8.cpp",
        "line_count":1,
        "code":"iterator erase(const_iterator first, const_iterator last) { return m_ht.erase(first, last); }",
        "mark":8.0,
        "query_nsx":"\/* Remove elements from a container based on the specified range.\n>>> iterator erase(const_iterator first, const_iterator last); *\/",
        "query_nlx":"\/* Define a function named erase that removes elements in a container starting from the first iterator up to, but not including, the last iterator.\n   >>> erase({1, 2, 3, 4, 5}, {2, 3}) removes elements 2 and 3 from the container {1, 2, 3, 4, 5}\n   >>> erase({'a', 'b', 'c', 'd'}, {'b', 'c'}) removes elements 'b' and 'c' from the container {'a', 'b', 'c', 'd'} *\/ \niterator erase(const_iterator first, const_iterator last) { *\/"
    }

    {
        "file_name":"robin_set_function_9.cpp",
        "line_count":1,
        "code":"size_type erase(const key_type& key) { return m_ht.erase(key); }",
        "mark":8.0,
        "query_nsx":"\/* Remove an element from a data structure based on a specified key.\n   >>> size_type erase(const key_type& key) { *\/",
        "query_nlx":"\/* Function named erase removes an element from a hash table based on a given key and returns the number of elements erased. \n>>> erase(\"key123\") 1 \n>>> erase(\"key456\") 0 *\/ \nsize_type erase(const key_type& key) { "
    }

    {
        "file_name":"rswrapper_function_1.cpp",
        "line_count":34,
        "code":"void\nreed_solomon_init(void) {\n#if defined(__x86_64__) || defined(__i386__)\n  if (__builtin_cpu_supports(\"avx512f\") && __builtin_cpu_supports(\"avx512bw\")) {\n    reed_solomon_new_fn = reed_solomon_new_avx512;\n    reed_solomon_release_fn = reed_solomon_release_avx512;\n    reed_solomon_encode_fn = reed_solomon_encode_avx512;\n    reed_solomon_decode_fn = reed_solomon_decode_avx512;\n    reed_solomon_init_avx512();\n  }\n  else if (__builtin_cpu_supports(\"avx2\")) {\n    reed_solomon_new_fn = reed_solomon_new_avx2;\n    reed_solomon_release_fn = reed_solomon_release_avx2;\n    reed_solomon_encode_fn = reed_solomon_encode_avx2;\n    reed_solomon_decode_fn = reed_solomon_decode_avx2;\n    reed_solomon_init_avx2();\n  }\n  else if (__builtin_cpu_supports(\"ssse3\")) {\n    reed_solomon_new_fn = reed_solomon_new_ssse3;\n    reed_solomon_release_fn = reed_solomon_release_ssse3;\n    reed_solomon_encode_fn = reed_solomon_encode_ssse3;\n    reed_solomon_decode_fn = reed_solomon_decode_ssse3;\n    reed_solomon_init_ssse3();\n  }\n  else\n#endif\n  {\n    reed_solomon_new_fn = reed_solomon_new_def;\n    reed_solomon_release_fn = reed_solomon_release_def;\n    reed_solomon_encode_fn = reed_solomon_encode_def;\n    reed_solomon_decode_fn = reed_solomon_decode_def;\n    reed_solomon_init_def();\n  }\n}",
        "mark":8.0,
        "query_nsx":"\/* Initialize the Reed-Solomon error correction functions based on CPU support for specific instruction sets.\n>>> reed_solomon_init() *\/ \nvoid reed_solomon_init(void) {",
        "query_nlx":"\/* Initialize the Reed-Solomon error correction functions based on CPU support for specific instruction sets.\n>>> reed_solomon_init() *\/ \nvoid reed_solomon_init(void) { \n    \/\/ Function body omitted for brevity \n}"
    }

    {
        "file_name":"safetyhook_function_21.cpp",
        "line_count":3,
        "code":"Error bad_allocation(Allocator::Error err) {\n            return {.type = BAD_ALLOCATION, .allocator_error = err};\n        }",
        "mark":8.0,
        "query_nsx":"\/* Create an error object indicating a bad allocation with the specific allocator error.\n   >>> Error bad_allocation(Allocator::Error err); *\/",
        "query_nlx":"\/* Define a function that creates an error object with a type of BAD_ALLOCATION and a specific allocator error.\n   >>> bad_allocation(Allocator::Error err) *\/\nError bad_allocation(Allocator::Error err) {"
    }

    {
        "file_name":"safetyhook_function_22.cpp",
        "line_count":3,
        "code":"Error bad_inline_hook(InlineHook::Error err) {\n            return {.type = BAD_INLINE_HOOK, .inline_hook_error = err};\n        }",
        "mark":8.0,
        "query_nsx":"\/* Create an error object indicating a bad inline hook with a specific error type and details.\n>>> Error bad_inline_hook(InlineHook::Error err); *\/",
        "query_nlx":"\/* Function named bad_inline_hook generates an error object with a specific type and inline hook error code.\n>>> bad_inline_hook(InlineHook::Error err) Error \n*\/ \nError bad_inline_hook(InlineHook::Error err) {"
    }

    {
        "file_name":"safetyhook_function_28.cpp",
        "line_count":3,
        "code":"Error bad_allocation(Allocator::Error err) {\n            return {.type = BAD_ALLOCATION, .allocator_error = err};\n        }",
        "mark":8.0,
        "query_nsx":"\/* Create an error object indicating a bad allocation with the specific allocator error.\n   >>> Error bad_allocation(Allocator::Error err); *\/",
        "query_nlx":"\/* Define a function that returns an error of type BAD_ALLOCATION along with the specific allocator error provided as input.\n   >>> bad_allocation(Allocator::Error err) BAD_ALLOCATION error with the specified allocator error *\/ \nError bad_allocation(Allocator::Error err) {"
    }

    {
        "file_name":"safetyhook_function_35.cpp",
        "line_count":13,
        "code":"SystemInfo system_info() {\n    SystemInfo info{};\n\n    SYSTEM_INFO si{};\n    GetSystemInfo(&si);\n\n    info.page_size = si.dwPageSize;\n    info.allocation_granularity = si.dwAllocationGranularity;\n    info.min_address = static_cast<uint8_t*>(si.lpMinimumApplicationAddress);\n    info.max_address = static_cast<uint8_t*>(si.lpMaximumApplicationAddress);\n\n    return info;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve system information such as page size, allocation granularity, and memory address limits.\n>>> SystemInfo system_info() { *\/",
        "query_nlx":"\/* Function named system_info retrieves system information such as page size, allocation granularity, minimum and maximum application addresses. \n>>> system_info() returns a SystemInfo struct containing page size, allocation granularity, minimum address, and maximum address. *\/ \nstruct SystemInfo { \n    uint32_t page_size; \n    uint32_t allocation_granularity; \n    uint8_t* min_address; \n    uint8_t* max_address; \n};"
    }

    {
        "file_name":"safetyhook_function_37.cpp",
        "line_count":3,
        "code":"bool is_executable(uint8_t* address) {\n    return vm_is_executable(address);\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the provided memory address is executable.\n>>> bool is_executable(uint8_t* address); *\/",
        "query_nlx":"\/* Function named is_executable determines if a given memory address is executable or not.\n>>> is_executable(address) returns a boolean value indicating whether the provided address is executable or not. *\/ \nbool is_executable(uint8_t* address) {"
    }

    {
        "file_name":"safetyhook_function_4.cpp",
        "line_count":3,
        "code":"Error bad_allocation(Allocator::Error err) {\n            return {.type = BAD_ALLOCATION, .allocator_error = err};\n        }",
        "mark":8.0,
        "query_nsx":"\/* Create an error object indicating a bad allocation with the specific allocator error.\n>>> Error bad_allocation(Allocator::Error err); *\/",
        "query_nlx":"\/* Define a function that creates an error object for a bad allocation with a specific allocator error.\n   >>> bad_allocation(Allocator::Error err) \n*\/"
    }

    {
        "file_name":"scheduler_function_1.cpp",
        "line_count":4,
        "code":"void work_started()\n  {\n    ++outstanding_work_;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Increment the count of outstanding work tasks.\n   >>> work_started() *\/ \nvoid work_started();",
        "query_nlx":"\/* Define a function that increments a variable representing outstanding work.\n   >>> work_started() *\/ \nvoid work_started() {"
    }

    {
        "file_name":"scheduler_function_2.cpp",
        "line_count":5,
        "code":"void work_finished()\n  {\n    if (--outstanding_work_ == 0)\n      stop();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine when all outstanding work is completed to stop the process.\n   >>> work_finished()\n*\/ \nvoid work_finished() {",
        "query_nlx":"\/* Function named work_finished decrements the value of an outstanding work variable and checks if it has reached zero, then calls a stop function.\n>>> work_finished() *\/ \nvoid work_finished() {"
    }

    {
        "file_name":"server_endpoint_function_1.cpp",
        "line_count":3,
        "code":"connection_ptr get_connection() {\n        return endpoint_type::create_connection();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a connection pointer from a specific type of endpoint. \n>>> connection_ptr get_connection() { *\/",
        "query_nlx":"\/* Function named get_connection returns a pointer to a connection object created by a specific type of endpoint.\n   >>> get_connection() connection_ptr *\/"
    }

    {
        "file_name":"sha1_function_1.cpp",
        "line_count":3,
        "code":"int rol(unsigned int value, unsigned int steps) {\n    return ((value << steps) | (value >> (32 - steps)));\n}",
        "mark":8.0,
        "query_nsx":"\/* Implement a function that performs a bitwise rotation operation on an unsigned integer value by a specified number of steps.\n>>> int rol(unsigned int value, unsigned int steps); *\/",
        "query_nlx":"\/* Function named rol performs a bitwise rotation operation on an unsigned integer value by a specified number of steps. \n>>> rol(5, 2) returns 20 \n>>> rol(10, 3) returns 80 *\/ \nint rol(unsigned int value, unsigned int steps) {"
    }

    {
        "file_name":"socket_holder_function_1.cpp",
        "line_count":10,
        "code":"void reset()\n  {\n    if (socket_ != invalid_socket)\n    {\n      asio::error_code ec;\n      socket_ops::state_type state = 0;\n      socket_ops::close(socket_, state, true, ec);\n      socket_ = invalid_socket;\n    }\n  }",
        "mark":8.0,
        "query_nsx":"\/* Reset the socket if it is valid, closing the connection and setting the socket to an invalid state.\n   >>> reset() *\/",
        "query_nlx":"\/* Reset the socket if it is not an invalid socket by closing the socket and setting it to an invalid state.\n   >>> reset() *\/ \nvoid reset() {"
    }

    {
        "file_name":"std_mutex_function_1.cpp",
        "line_count":4,
        "code":"void lock()\n  {\n    mutex_.lock();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Lock a resource to prevent concurrent access by multiple threads.\n   >>> void lock() *\/",
        "query_nlx":"\/* Define a function that locks a resource using a mutex.\n   >>> lock() *\/ \nvoid lock() {"
    }

    {
        "file_name":"std_mutex_function_2.cpp",
        "line_count":4,
        "code":"void unlock()\n  {\n    mutex_.unlock();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Unlock a mutex to allow other threads to access shared resources.\n   >>> unlock() *\/ \nvoid unlock() {",
        "query_nlx":"\/* Define a function that unlocks a mutex.\n   >>> unlock() *\/ \nvoid unlock() {"
    }

    {
        "file_name":"std_static_mutex_function_2.cpp",
        "line_count":4,
        "code":"void lock()\n  {\n    mutex_.lock();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Ensure exclusive access to a shared resource by acquiring a lock.\n   >>> void lock() *\/",
        "query_nlx":"\/* Define a function that locks a resource using a mutex.\n   >>> lock() *\/ \nvoid lock() {"
    }

    {
        "file_name":"std_static_mutex_function_3.cpp",
        "line_count":4,
        "code":"void unlock()\n  {\n    mutex_.unlock();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Unlock a mutex to allow other threads to access shared resources.\n   >>> unlock() *\/ \nvoid unlock() {",
        "query_nlx":"\/* Define a function that unlocks a mutex.\n   >>> unlock() *\/ \nvoid unlock() {"
    }

    {
        "file_name":"std_thread_function_1.cpp",
        "line_count":5,
        "code":"void join()\n  {\n    if (thread_.joinable())\n      thread_.join();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Ensure that the current thread has finished executing before proceeding. \n>>> void join() { *\/",
        "query_nlx":"\/* Function named join checks if a thread is joinable and if so, joins the thread. \n>>> join() *\/"
    }

    {
        "file_name":"std_thread_function_2.cpp",
        "line_count":4,
        "code":"size_t hardware_concurrency()\n  {\n    return std::thread::hardware_concurrency();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine the number of available processing units on the system.\n   >>> hardware_concurrency() \n*\/ \nsize_t hardware_concurrency();",
        "query_nlx":"\/* Function named hardware_concurrency returns the number of concurrent threads supported by the hardware.\n   >>> hardware_concurrency()  *\/ \nsize_t hardware_concurrency() { "
    }

    {
        "file_name":"stream_core_function_2.cpp",
        "line_count":4,
        "code":"time_type pos_infin()\n  {\n    return boost::posix_time::pos_infin;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a special time value representing positive infinity.\n>>> time_type pos_infin() *\/",
        "query_nlx":"\/* Define a function that returns a special time type representing positive infinity.\n   >>> pos_infin() returns a time type representing positive infinity *\/ \ntime_type pos_infin() {"
    }

    {
        "file_name":"stream_core_function_5.cpp",
        "line_count":4,
        "code":"time_point pos_infin()\n  {\n    return (asio::steady_timer::time_point::max)();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the maximum possible time point value for a steady timer.\n   >>> time_point pos_infin() { *\/",
        "query_nlx":"\/* Define a function that returns the maximum possible time point value for a steady timer.\n   >>> pos_infin() returns the maximum time point value for a steady timer *\/ \ntime_point pos_infin() { "
    }

    {
        "file_name":"stream_function_1.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return core_.engine_.native_handle();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the underlying native handle from the core engine.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"        \/* Retrieve the native handle from the engine's core and return it.\n        >>> native_handle_type native_handle() *\/"
    }

    {
        "file_name":"stream_function_28.cpp",
        "line_count":11,
        "code":"blocks\n      for (int x = 0; x < fec_blocks_needed; ++x) {\n        if (x == fec_blocks_needed - 1) {\n          \/\/ The last block must extend to the end of the payload\n          fec_blocks[x] = payload.substr(x * aligned_size);\n        }\n        else {\n          \/\/ Earlier blocks just extend to the next block offset\n          fec_blocks[x] = payload.substr(x * aligned_size, aligned_size);\n        }\n      }",
        "mark":8.0,
        "query_nsx":"        \/* Extract blocks of data from a payload based on specified block size.\n        >>> blocks(int fec_blocks_needed, string payload, int aligned_size) *\/",
        "query_nlx":"        \/* Create FEC blocks from a payload by dividing it into segments of a specified size, with the last block extending to the end of the payload.\n        >>> create_fec_blocks(payload, aligned_size, fec_blocks_needed)\n        *\/ \n        void create_fec_blocks(string payload, int aligned_size, int fec_blocks_needed) {"
    }

    {
        "file_name":"stream_function_36.cpp",
        "line_count":4,
        "code":"state_e\n    state(session_t &session) {\n      return session.state.load(std::memory_order_relaxed);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the current state of a session.\n   >>> state(session_t &session) \n*\/",
        "query_nlx":"\/* Define a function that retrieves the current state of a session by loading it with relaxed memory ordering.\n>>> state(session_t &session) *\/\nsession_t &session) {"
    }

    {
        "file_name":"stream_function_38.cpp",
        "line_count":4,
        "code":"string\n    uuid(const session_t& session) {\n      return session.device_uuid;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the unique identifier associated with a session.\n   >>> uuid(const session_t& session) *\/",
        "query_nlx":"\/* Function named uuid takes a session object as input and returns the device UUID associated with that session.\n>>> uuid(session_t session) *\/"
    }

    {
        "file_name":"stream_function_39.cpp",
        "line_count":4,
        "code":"bool\n    uuid_match(const session_t &session, const std::string& uuid) {\n      return session.device_uuid == uuid;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the session's device UUID matches the provided UUID.\n   >>> uuid_match(const session_t &session, const std::string& uuid) *\/",
        "query_nlx":"\/* Function named uuid_match checks if the device UUID stored in a session matches a given UUID string.\n>>> uuid_match(session, \"abc123\") true\n>>> uuid_match(session, \"def456\") false *\/ \nbool uuid_match(const session_t &session, const std::string& uuid) {"
    }

    {
        "file_name":"sudovda_function_11.cpp",
        "line_count":19,
        "code":"bool PingDriver(HANDLE hDevice) {\n\tDWORD bytesReturned;\n\tBOOL success = DeviceIoControl(\n\t\thDevice,\n\t\tIOCTL_DRIVER_PING,\n\t\tnullptr,\n\t\t0,\n\t\tnullptr,\n\t\t0,\n\t\t&bytesReturned,\n\t\tnullptr\n\t);\n\n\tif (!success) {\n\t\tstd::cerr << \"[SUVDA] PingDriver failed: \" << GetLastError() << std::endl;\n\t}\n\n\treturn success;\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the driver can be pinged successfully using the provided device handle.\n>>> PingDriver(hDevice) bool *\/",
        "query_nlx":"        \/* Function named PingDriver sends a ping signal to a device using a specified handle and returns a boolean indicating the success of the operation.\n        >>> PingDriver(handle) true\n        >>> PingDriver(handle) false *\/ \n        #include <windows.h>\n        bool PingDriver(HANDLE hDevice) {"
    }

    {
        "file_name":"sudovda_function_3.cpp",
        "line_count":20,
        "code":"bool RemoveVirtualDisplay(HANDLE hDevice, const GUID& MonitorGuid) {\n\tVIRTUAL_DISPLAY_REMOVE_PARAMS params{MonitorGuid};\n\tDWORD bytesReturned;\n\tBOOL success = DeviceIoControl(\n\t\thDevice,\n\t\tIOCTL_REMOVE_VIRTUAL_DISPLAY,\n\t\t(LPVOID)&params,\n\t\tsizeof(params),\n\t\tnullptr,\n\t\t0,\n\t\t&bytesReturned,\n\t\tnullptr\n\t);\n\n\tif (!success) {\n\t\tstd::cerr << \"[SUVDA] RemoveVirtualDisplay failed: \" << GetLastError() << std::endl;\n\t}\n\n\treturn success;\n}",
        "mark":8.0,
        "query_nsx":"\/* Remove a virtual display associated with a specific device using the provided monitor GUID.\n>>> bool RemoveVirtualDisplay(HANDLE hDevice, const GUID& MonitorGuid) { *\/",
        "query_nlx":"\/* Function named RemoveVirtualDisplay removes a virtual display identified by a given monitor GUID from a specified device.\n>>> RemoveVirtualDisplay(hDevice, MonitorGuid) returns a boolean indicating the success of removing the virtual display *\/"
    }

    {
        "file_name":"sudovda_function_4.cpp",
        "line_count":20,
        "code":"bool SetRenderAdapter(HANDLE hDevice, const LUID& AdapterLuid) {\n\tVIRTUAL_DISPLAY_SET_RENDER_ADAPTER_PARAMS params{AdapterLuid};\n\tDWORD bytesReturned;\n\tBOOL success = DeviceIoControl(\n\t\thDevice,\n\t\tIOCTL_SET_RENDER_ADAPTER,\n\t\t(LPVOID)&params,\n\t\tsizeof(params),\n\t\tnullptr,\n\t\t0,\n\t\t&bytesReturned,\n\t\tnullptr\n\t);\n\n\tif (!success) {\n\t\tstd::cerr << \"[SUVDA] SetRenderAdapter failed: \" << GetLastError() << std::endl;\n\t}\n\n\treturn success;\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the render adapter for a specified device using the provided adapter LUID.\n>>> bool SetRenderAdapter(HANDLE hDevice, const LUID& AdapterLuid) { *\/",
        "query_nlx":"\/* Function named SetRenderAdapter sets the render adapter for a given device using the provided AdapterLuid.\n>>> SetRenderAdapter(hDevice, AdapterLuid) returns a boolean indicating success or failure of setting the render adapter. *\/ \nbool SetRenderAdapter(HANDLE hDevice, const LUID& AdapterLuid) {"
    }

    {
        "file_name":"sudovda_function_6.cpp",
        "line_count":19,
        "code":"bool GetProtocolVersion(HANDLE hDevice, VIRTUAL_DISPLAY_GET_PROTOCOL_VERSION_OUT& output) {\n\tDWORD bytesReturned;\n\tBOOL success = DeviceIoControl(\n\t\thDevice,\n\t\tIOCTL_GET_PROTOCOL_VERSION,\n\t\tnullptr,\n\t\t0,\n\t\t(LPVOID)&output,\n\t\tsizeof(output),\n\t\t&bytesReturned,\n\t\tnullptr\n\t);\n\n\tif (!success) {\n\t\tstd::cerr << \"[SUVDA] GetProtocolVersion failed: \" << GetLastError() << std::endl;\n\t}\n\n\treturn success;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the protocol version from a device using the specified handle and store it in the provided output structure.\n>>> bool GetProtocolVersion(HANDLE hDevice, VIRTUAL_DISPLAY_GET_PROTOCOL_VERSION_OUT& output) { *\/",
        "query_nlx":"\/* Function named GetProtocolVersion retrieves the protocol version information from a given device handle using a specified IOCTL command and stores it in the provided output structure. \n>>> GetProtocolVersion(hDevice, output) returns a boolean indicating the success of retrieving the protocol version information. If unsuccessful, an error message is printed to the standard error stream. *\/ \n#include <windows.h> \n#include <iostream> \nbool GetProtocolVersion(HANDLE hDevice, VIRTUAL_DISPLAY_GET_PROTOCOL_VERSION_OUT& output) { "
    }

    {
        "file_name":"system_tray_function_1.cpp",
        "line_count":5,
        "code":"void\n  tray_open_ui_cb(struct tray_menu *item) {\n    BOOST_LOG(info) << \"Opening UI from system tray\"sv;\n    launch_ui();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Launches the user interface when the system tray menu item is clicked\n   >>> tray_open_ui_cb(struct tray_menu *item) *\/",
        "query_nlx":"\/* Function named tray_open_ui_cb defines a callback function that is triggered when a user interacts with a system tray menu item to open the user interface. \n>>> tray_open_ui_cb(item) logs a message indicating the opening of the UI from the system tray and launches the UI. *\/ \nvoid tray_open_ui_cb(struct tray_menu *item) { "
    }

    {
        "file_name":"tests_log_checker_function_1.cpp",
        "line_count":5,
        "code":"string\n  remove_timestamp_prefix(const std::string &line) {\n    static const std::regex timestamp_regex(R\"(\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\]: )\");\n    return std::regex_replace(line, timestamp_regex, \"\");\n  }",
        "mark":8.0,
        "query_nsx":"\/* Remove timestamp prefix from a given string line.\n   >>> remove_timestamp_prefix(const string &line) *\/",
        "query_nlx":"\/* Function named remove_timestamp_prefix takes a string as input and removes any timestamp prefix in the format '[YYYY-MM-DD HH:MM:SS.SSS]: ' from the beginning of the string. \n>>> remove_timestamp_prefix(\"[2022-10-15 08:30:45.123]: Hello, world!\") returns \"Hello, world!\"\n>>> remove_timestamp_prefix(\"[2023-01-05 15:20:10.456]: Error: Something went wrong.\") returns \"Error: Something went wrong.\" *\/ \nstring remove_timestamp_prefix(const std::string &line) { "
    }

    {
        "file_name":"test_mouse_function_1.cpp",
        "line_count":37,
        "code":"edges\n\nTEST_P(MouseHIDTest, MoveInputTest) {\n  util::point_t mouse_delta = GetParam();\n\n  BOOST_LOG(tests) << \"MoveInputTest:: got param: \" << mouse_delta;\n  platf::input_t input = platf::input();\n  BOOST_LOG(tests) << \"MoveInputTest:: init input\";\n\n  BOOST_LOG(tests) << \"MoveInputTest:: get current mouse loc\";\n  auto old_loc = platf::get_mouse_loc(input);\n  BOOST_LOG(tests) << \"MoveInputTest:: got current mouse loc: \" << old_loc;\n\n  BOOST_LOG(tests) << \"MoveInputTest:: move: \" << mouse_delta;\n  platf::move_mouse(input, mouse_delta.x, mouse_delta.y);\n  std::this_thread::sleep_for(std::chrono::milliseconds(200));\n  BOOST_LOG(tests) << \"MoveInputTest:: moved: \" << mouse_delta;\n\n  BOOST_LOG(tests) << \"MoveInputTest:: get updated mouse loc\";\n  auto new_loc = platf::get_mouse_loc(input);\n  BOOST_LOG(tests) << \"MoveInputTest:: got updated mouse loc: \" << new_loc;\n\n  bool has_input_moved = old_loc.x != new_loc.x && old_loc.y != new_loc.y;\n\n  if (!has_input_moved) {\n    BOOST_LOG(tests) << \"MoveInputTest:: haven't moved\";\n  }\n  else {\n    BOOST_LOG(tests) << \"MoveInputTest:: moved\";\n  }\n\n  EXPECT_TRUE(has_input_moved);\n\n  \/\/ Verify we moved as much as we requested\n  EXPECT_EQ(new_loc.x - old_loc.x, mouse_delta.x);\n  EXPECT_EQ(new_loc.y - old_loc.y, mouse_delta.y);\n}",
        "mark":8.0,
        "query_nsx":"\/* Verify if the mouse input movement matches the requested delta values.\n>>> TEST_P(MouseHIDTest, MoveInputTest) *\/",
        "query_nlx":"\/* Query for a test function named MoveInputTest that simulates moving a mouse input by a given delta and verifies the movement.\n>>> MoveInputTest({x, y}) \nThe test function initializes an input, retrieves the current mouse location, moves the mouse by the given delta, sleeps for 200 milliseconds, retrieves the updated mouse location, checks if the input has moved, and asserts the movement matches the requested delta. *\/ \nTEST_P(MouseHIDTest, MoveInputTest) {"
    }

    {
        "file_name":"thread_function_1.cpp",
        "line_count":4,
        "code":"void join()\n  {\n    impl_.join();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Execute the join operation using the internal implementation. \n>>> void join() *\/",
        "query_nlx":"\/* Function named join calls the join function of the implementation object to perform a specific action. \n>>> join() *\/ \nvoid join() { "
    }

    {
        "file_name":"timer_queue_function_6.cpp",
        "line_count":11,
        "code":"void up_heap(std::size_t index)\n  {\n    while (index > 0)\n    {\n      std::size_t parent = (index - 1) \/ 2;\n      if (!Time_Traits::less_than(heap_[index].time_, heap_[parent].time_))\n        break;\n      swap_heap(index, parent);\n      index = parent;\n    }\n  }",
        "mark":8.0,
        "query_nsx":"        \/* Implement a function that maintains the heap property by moving the element up the heap if necessary.\n        >>> void up_heap(std::size_t index) { *\/",
        "query_nlx":"\/* Define a function that performs an upward heap operation on a data structure. \n>>> up_heap(index) void { *\/"
    }

    {
        "file_name":"time_traits_function_4.cpp",
        "line_count":4,
        "code":"bool less_than(const time_type& t1, const time_type& t2)\n  {\n    return t1 < t2;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the first time is less than the second time.\n   >>> less_than(t1, t2) true\n   >>> less_than(t2, t1) false *\/ \nbool less_than(const time_type& t1, const time_type& t2) { ",
        "query_nlx":"\/* Function named less_than compares two time values to determine if the first time is less than the second time.\n   >>> less_than(10:30 AM, 2:00 PM) true\n   >>> less_than(8:00 PM, 8:00 AM) false *\/ \nbool less_than(const time_type& t1, const time_type& t2) { "
    }

    {
        "file_name":"tls_function_10.cpp",
        "line_count":3,
        "code":"void set_handle(connection_hdl hdl) {\n        m_hdl = hdl;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handle for a connection.\n    >>> set_handle(connection_hdl hdl) *\/",
        "query_nlx":"\/* Define a function that sets the handle to a given connection handle.\n   >>> set_handle(connection_hdl hdl) *\/"
    }

    {
        "file_name":"tls_function_12.cpp",
        "line_count":5,
        "code":"error_code cancel_socket() {\n        lib::asio::error_code ec;\n        get_raw_socket().cancel(ec);\n        return ec;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve and return the error code after canceling a socket operation.\n    >>> error_code cancel_socket() *\/",
        "query_nlx":"\/* Define a function that cancels a socket operation and returns an error code if any.\n   >>> cancel_socket() error_code *\/"
    }

    {
        "file_name":"tls_function_13.cpp",
        "line_count":7,
        "code":"void async_shutdown(socket::shutdown_handler callback) {\n        if (m_strand) {\n            m_socket->async_shutdown(m_strand->wrap(callback));\n        } else {\n            m_socket->async_shutdown(callback);\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Asynchronously shutdown a socket with the provided callback function.\n   >>> void async_shutdown(socket::shutdown_handler callback); *\/",
        "query_nlx":"        \/* Asynchronously shuts down a socket connection by invoking a provided callback function. If a strand is available, the callback function is wrapped within the strand before being executed.\n        >>> async_shutdown(shutdown_handler callback) *\/"
    }

    {
        "file_name":"tls_function_14.cpp",
        "line_count":11,
        "code":"error_code translate_ec(ErrorCodeType ec) {\n        if (ec.category() == lib::asio::error::get_ssl_category()) {\n            \/\/ We know it is a TLS related error, but otherwise don't know more.\n            \/\/ Pass through as TLS generic.\n            return make_error_code(transport::error::tls_error);\n        } else {\n            \/\/ We don't know any more information about this error so pass\n            \/\/ through\n            return make_error_code(transport::error::pass_through);\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Translate error codes related to SSL\/TLS errors to a generic TLS error code or pass through other errors.\n>>> translate_ec(ErrorCodeType ec) *\/\nerror_code translate_ec(ErrorCodeType ec) {",
        "query_nlx":"\/* Translate error codes to a more general category if they belong to a specific SSL category, otherwise pass them through.\n   >>> translate_ec(ErrorCodeType ec) *\/\nerror_code translate_ec(ErrorCodeType ec) {"
    }

    {
        "file_name":"tls_function_16.cpp",
        "line_count":7,
        "code":"handshake_type get_handshake_type() {\n        if (m_is_server) {\n            return lib::asio::ssl::stream_base::server;\n        } else {\n            return lib::asio::ssl::stream_base::client;\n        }\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine the type of handshake based on whether the entity is a server or a client.\n   >>> handshake_type get_handshake_type() { *\/",
        "query_nlx":"\/* Determine the type of handshake based on whether the entity is a server or a client.\n   >>> get_handshake_type() returns the handshake type as either server or client *\/ \nhandshake_type get_handshake_type() {"
    }

    {
        "file_name":"tls_function_18.cpp",
        "line_count":3,
        "code":"void set_socket_init_handler(socket_init_handler h) {\n        m_socket_init_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler function for initializing a socket.\n   >>> void set_socket_init_handler(socket_init_handler h); *\/",
        "query_nlx":"        \/* Define a function that sets a handler for initializing sockets.\n        >>> set_socket_init_handler(handler) void { *\/"
    }

    {
        "file_name":"tls_function_19.cpp",
        "line_count":3,
        "code":"void set_tls_init_handler(tls_init_handler h) {\n        m_tls_init_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler function for initializing thread-local storage.\n   >>> set_tls_init_handler(tls_init_handler h) *\/ \nvoid set_tls_init_handler(tls_init_handler h) {",
        "query_nlx":"\/* Define a function that sets a handler for initializing thread-local storage.\n   >>> set_tls_init_handler(handler) *\/ \nvoid set_tls_init_handler(tls_init_handler h) {"
    }

    {
        "file_name":"tls_function_3.cpp",
        "line_count":3,
        "code":"void set_socket_init_handler(socket_init_handler h) {\n        m_socket_init_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler function for initializing a socket.\n   >>> set_socket_init_handler(socket_init_handler h) *\/",
        "query_nlx":"        \/* Define a function that sets a handler for initializing sockets.\n        >>> set_socket_init_handler(handler) void { *\/"
    }

    {
        "file_name":"tls_function_4.cpp",
        "line_count":3,
        "code":"void set_tls_init_handler(tls_init_handler h) {\n        m_tls_init_handler = h;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the handler function for initializing thread-local storage.\n   >>> void set_tls_init_handler(tls_init_handler h); *\/",
        "query_nlx":"\/* Define a function that sets a handler for initializing TLS (Thread Local Storage).\n   >>> set_tls_init_handler(handler) *\/ \nvoid set_tls_init_handler(tls_init_handler h) {"
    }

    {
        "file_name":"tls_function_6.cpp",
        "line_count":3,
        "code":"void set_uri(uri_ptr u) {\n        m_uri = u;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the URI pointer to the provided value. \n    >>> void set_uri(uri_ptr u); *\/",
        "query_nlx":"\/* Function named set_uri assigns a given URI pointer to a member variable within the current context. \n>>> set_uri(u) *\/ \nvoid set_uri(uri_ptr u) { "
    }

    {
        "file_name":"unicode_iterator_function_10.cpp",
        "line_count":9,
        "code":"void invalid_sequence()\n   {\n      std::out_of_range e(\"Invalid UTF-8 sequence encountered while trying to encode UTF-32 character\");\n#ifndef BOOST_REGEX_STANDALONE\n      boost::throw_exception(e);\n#else\n      throw e;\n#endif\n   }",
        "mark":8.0,
        "query_nsx":"\/* Throw an exception when encountering an invalid UTF-8 sequence while encoding a UTF-32 character.\n   >>> void invalid_sequence() *\/",
        "query_nlx":"        \/* Define a function that handles encountering an invalid UTF-8 sequence while trying to encode a UTF-32 character. \n        >>> invalid_sequence() *\/ \n        void invalid_sequence() {"
    }

    {
        "file_name":"upnp_function_1.cpp",
        "line_count":15,
        "code":"string_view\n  status_string(int status) {\n    switch (status) {\n      case 0:\n        return \"No IGD device found\"sv;\n      case 1:\n        return \"Valid IGD device found\"sv;\n      case 2:\n        return \"Valid IGD device found,  but it isn't connected\"sv;\n      case 3:\n        return \"A UPnP device has been found,  but it wasn't recognized as an IGD\"sv;\n    }\n\n    return \"Unknown status\"sv;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine the status message based on the input status code.\n   >>> status_string(int status) *\/",
        "query_nlx":"\/* Function named status_string returns a string_view message based on the input status code. \n>>> status_string(0) returns \"No IGD device found\"sv \n>>> status_string(1) returns \"Valid IGD device found\"sv \n>>> status_string(2) returns \"Valid IGD device found, but it isn't connected\"sv \n>>> status_string(3) returns \"A UPnP device has been found, but it wasn't recognized as an IGD\"sv \n>>> status_string(4) returns \"Unknown status\"sv *\/ \nstring_view status_string(int status) { "
    }

    {
        "file_name":"use_future_function_4.cpp",
        "line_count":4,
        "code":"future_type get_future()\n  {\n    return p_->get_future();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve a future object from the underlying object pointed to by p.\n   >>> get_future() future_type *\/",
        "query_nlx":"\/* Define a function that returns a future type object by calling the get_future() method on a private member variable.\n>>> get_future() returns a future type object *\/ \nfuture_type get_future() {"
    }

    {
        "file_name":"utf8_validator_function_3.cpp",
        "line_count":14,
        "code":"bool decode (iterator_type begin, iterator_type end) {\n        for (iterator_type it = begin; it != end; ++it) {\n            unsigned int result = utf8_validator::decode(\n                &m_state,\n                &m_codepoint,\n                static_cast<uint8_t>(*it)\n            );\n\n            if (result == utf8_reject) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Decode a sequence of elements using a UTF-8 validator and determine if the decoding process is successful.\n    >>> bool decode(iterator_type begin, iterator_type end) *\/",
        "query_nlx":"\/* Function named decode takes an iterator range as input and decodes UTF-8 characters within that range. It iterates through the range, decoding each character using a UTF-8 validator function. If any character is invalid and cannot be decoded, the function returns false; otherwise, it returns true.\n>>> decode(begin, end) bool *\/"
    }

    {
        "file_name":"utf8_validator_function_4.cpp",
        "line_count":3,
        "code":"bool complete() {\n        return m_state == utf8_accept;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the current state is in a state of accepting UTF-8 characters.\n   >>> complete() *\/\nbool complete();",
        "query_nlx":"\/* Function named complete checks if the current state is equal to utf8_accept.\n   >>> complete() returns true if the current state is utf8_accept, otherwise false *\/ \nbool complete() {"
    }

    {
        "file_name":"utf8_validator_function_5.cpp",
        "line_count":4,
        "code":"void reset() {\n        m_state = utf8_accept;\n        m_codepoint = 0;\n    }",
        "mark":8.0,
        "query_nsx":"\/* Reset the state and codepoint values to their initial values.\n>>> reset() *\/ \nvoid reset() {",
        "query_nlx":"\/* Reset the state and codepoint variables to their initial values.\n   >>> reset()\n*\/ \nvoid reset() {"
    }

    {
        "file_name":"utf8_validator_function_6.cpp",
        "line_count":7,
        "code":"bool validate(std::string const & s) {\n    validator v;\n    if (!v.decode(s.begin(),s.end())) {\n        return false;\n    }\n    return v.complete();\n}",
        "mark":8.0,
        "query_nsx":"\/* Validate if a given string meets certain criteria.\n   >>> bool validate(std::string const & s) { *\/",
        "query_nlx":"\/* Validate a given string using a custom validator object by decoding the string and checking if it is complete.\n   >>> validate(\"example_string\") true\n   >>> validate(\"invalid_string\") false *\/\nbool validate(std::string const & s) {"
    }

    {
        "file_name":"utilities_function_3.cpp",
        "line_count":3,
        "code":"bool isPOT(size_t x) {\n    return !(x & (x - 1));\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if the given size is a power of two.\n>>> bool isPOT(size_t x) { *\/",
        "query_nlx":"\/* Function named isPOT checks if a given size_t number is a power of two.\n>>> isPOT(16) true\n>>> isPOT(15) false *\/ \nbool isPOT(size_t x) {"
    }

    {
        "file_name":"utilities_impl_function_1.cpp",
        "line_count":5,
        "code":"string to_lower(std::string const & in) {\n    std::string out = in;\n    std::transform(out.begin(),out.end(),out.begin(),::tolower);\n    return out;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a given string to lowercase.\n>>> string to_lower(std::string const & in) *\/",
        "query_nlx":"        \/* Function named to_lower converts all characters in a given string to lowercase.\n        >>> to_lower(\"Hello World!\") \"hello world!\" *\/ \n        std::string to_lower(std::string const & in) {"
    }

    {
        "file_name":"utils_function_1.cpp",
        "line_count":13,
        "code":"wstring acpToUtf16(const std::string& origStr) {\n\tauto acp = GetACP();\n\n\tint utf16Len = MultiByteToWideChar(acp, 0, origStr.c_str(), origStr.size(), NULL, 0);\n\tif (utf16Len == 0) {\n\t\treturn L\"\";\n\t}\n\n\tstd::wstring utf16Str(utf16Len, L'\\0');\n\tMultiByteToWideChar(acp, 0, origStr.c_str(), origStr.size(), &utf16Str[0], utf16Len);\n\n\treturn utf16Str;\n}",
        "mark":8.0,
        "query_nsx":"\/* Convert a given string from one character encoding to another and return the result as a wide string.\n   >>> acpToUtf16(\"example\") \"converted_string\" *\/ \nwstring acpToUtf16(const string& origStr) {",
        "query_nlx":"\/* Function acpToUtf16 converts a given string from the system's default encoding to UTF-16 format.\n   >>> acpToUtf16(\"Hello\") returns the UTF-16 representation of the input string\n   >>> acpToUtf16(\"\") returns an empty UTF-16 string *\/\nwstring acpToUtf16(const std::string& origStr) { *\/"
    }

    {
        "file_name":"utils_function_2.cpp",
        "line_count":13,
        "code":"string utf16ToAcp(const std::wstring& utf16Str) {\n\tauto acp = GetACP();\n\n\tint codepageLen = WideCharToMultiByte(acp, 0, utf16Str.c_str(), utf16Str.size(), NULL, 0, NULL, NULL);\n\tif (codepageLen == 0) {\n\t\treturn \"\";\n\t}\n\n\tstd::string codepageStr(codepageLen, '\\0');\n\tWideCharToMultiByte(acp, 0, utf16Str.c_str(), utf16Str.size(), &codepageStr[0], codepageLen, NULL, NULL);\n\n\treturn codepageStr;\n}",
        "mark":8.0,
        "query_nsx":"\n\/* Convert a UTF-16 encoded string to the system's default character encoding.\n>>> string utf16ToAcp(const std::wstring& utf16Str) { *\/",
        "query_nlx":"        \/* Convert a given UTF-16 string to the corresponding ANSI code page string using the system's active code page.\n        >>> utf16ToAcp(L\"example\") \"example\"\n        >>> utf16ToAcp(L\"12345\") \"12345\" *\/ \n        string utf16ToAcp(const std::wstring& utf16Str) {"
    }

    {
        "file_name":"verify_callback_function_1.cpp",
        "line_count":4,
        "code":"bool call(bool preverified, verify_context& ctx)\n  {\n    return callback_(preverified, ctx);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine if a callback function should be called based on preverification status and context.\n   >>> bool call(bool preverified, verify_context& ctx) *\/",
        "query_nlx":"\/* Function call takes a boolean value indicating preverification status and a verification context, then calls a callback function with these parameters and returns the result.\n>>> call(true, ctx) true\n>>> call(false, ctx) false *\/ \nbool call(bool preverified, verify_context& ctx) { "
    }

    {
        "file_name":"verify_context_function_1.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle()\n  {\n    return handle_;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the underlying native handle associated with an object.\n   >>> native_handle_type native_handle() *\/",
        "query_nlx":"\/* Function named native_handle retrieves the native handle associated with an object.\n   >>> native_handle() returns the native handle of the object *\/ \nnative_handle_type native_handle() {"
    }

    {
        "file_name":"video_function_46.cpp",
        "line_count":2,
        "code":"void\ndo_nothing(void *) {}",
        "mark":8.0,
        "query_nsx":"\/* Define a function that does nothing when called.\n   >>> do_nothing(void *) *\/ \nvoid do_nothing(void *) {",
        "query_nlx":"\/* Function named do_nothing takes in a pointer as input and does nothing with it. *\/ \nvoid do_nothing(void *) {"
    }

    {
        "file_name":"virtual_display_function_1.cpp",
        "line_count":4,
        "code":"LONG getDeviceSettings(const wchar_t* deviceName, DEVMODEW& devMode) {\n\tdevMode.dmSize = sizeof(DEVMODEW);\n\treturn EnumDisplaySettingsW(deviceName, ENUM_CURRENT_SETTINGS, &devMode);\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the current display settings for a specified device using the device name and store them in a provided structure. \n>>> LONG getDeviceSettings(const wchar_t* deviceName, DEVMODEW& devMode) { *\/",
        "query_nlx":"\/* Retrieve the device settings for a specified device by providing its name and storing the settings in a given structure. \n>>> getDeviceSettings(\"DeviceName\", devMode) returns a LONG value representing the success of retrieving the settings *\/ \nLONG getDeviceSettings(const wchar_t* deviceName, DEVMODEW& devMode) {"
    }

    {
        "file_name":"virtual_display_function_10.cpp",
        "line_count":9,
        "code":"void closeVDisplayDevice() {\n\tif (SUDOVDA_DRIVER_HANDLE == INVALID_HANDLE_VALUE) {\n\t\treturn;\n\t}\n\n\tCloseHandle(SUDOVDA_DRIVER_HANDLE);\n\n\tSUDOVDA_DRIVER_HANDLE = INVALID_HANDLE_VALUE;\n}",
        "mark":8.0,
        "query_nsx":"\/* Close the display device handle if it is valid.\n>>> void closeVDisplayDevice() { *\/",
        "query_nlx":"\/* Function named closeVDisplayDevice closes the handle to a virtual display device if it is valid.\n>>> closeVDisplayDevice() closes the handle to the virtual display device if it is not equal to INVALID_HANDLE_VALUE. *\/ \nvoid closeVDisplayDevice() {"
    }

    {
        "file_name":"virtual_display_function_3.cpp",
        "line_count":17,
        "code":"wstring getPrimaryDisplay() {\n\tDISPLAY_DEVICEW displayDevice;\n\tdisplayDevice.cb = sizeof(DISPLAY_DEVICE);\n\n\tstd::wstring primaryDeviceName;\n\n\tint deviceIndex = 0;\n\twhile (EnumDisplayDevicesW(NULL, deviceIndex, &displayDevice, 0)) {\n\t\tif (displayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) {\n\t\t\tprimaryDeviceName = displayDevice.DeviceName;\n\t\t\tbreak;\n\t\t}\n\t\tdeviceIndex++;\n\t}\n\n\treturn primaryDeviceName;\n}",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the name of the primary display device.\n>>> getPrimaryDisplay() returns the name of the primary display device. *\/",
        "query_nlx":"\n\/* Function named getPrimaryDisplay retrieves the name of the primary display device connected to the system.\n>>> getPrimaryDisplay() returns the name of the primary display device as a wide string. *\/ \nwstring getPrimaryDisplay() {"
    }

    {
        "file_name":"virtual_display_function_6.cpp",
        "line_count":13,
        "code":"bool getDisplayHDR(const LUID& adapterId, const uint32_t& targetId) {\n\tDISPLAYCONFIG_GET_ADVANCED_COLOR_INFO hdrInfo = {};\n\thdrInfo.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO;\n\thdrInfo.header.size = sizeof(hdrInfo);\n\thdrInfo.header.adapterId = adapterId;\n\thdrInfo.header.id = targetId;\n\n\tif (DisplayConfigGetDeviceInfo(&hdrInfo.header) != ERROR_SUCCESS) {\n\t\treturn false;\n\t}\n\n\treturn hdrInfo.advancedColorSupported && hdrInfo.advancedColorEnabled;\n}",
        "mark":8.0,
        "query_nsx":"\/* Determine if the display supports and has enabled advanced color features based on the provided adapter and target IDs.\n>>> bool getDisplayHDR(const LUID& adapterId, const uint32_t& targetId) { *\/",
        "query_nlx":"        \/* Function named getDisplayHDR retrieves information about advanced color capabilities for a specific display identified by the adapterId and targetId.\n        >>> getDisplayHDR(const LUID& adapterId, const uint32_t& targetId) *\/\n        #include <windows.h>\n        bool getDisplayHDR(const LUID& adapterId, const uint32_t& targetId) {"
    }

    {
        "file_name":"virtual_display_function_7.cpp",
        "line_count":10,
        "code":"bool setDisplayHDR(const LUID& adapterId, const uint32_t& targetId, bool enableAdvancedColor) {\n\tDISPLAYCONFIG_SET_ADVANCED_COLOR_STATE setHdrInfo = {};\n\tsetHdrInfo.header.type = DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE;\n\tsetHdrInfo.header.size = sizeof(setHdrInfo);\n\tsetHdrInfo.header.adapterId = adapterId;\n\tsetHdrInfo.header.id = targetId;\n\tsetHdrInfo.enableAdvancedColor = enableAdvancedColor;\n\n\treturn DisplayConfigSetDeviceInfo(&setHdrInfo.header) == ERROR_SUCCESS;\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the HDR display state for a specified adapter and target with the option to enable advanced color.\n>>> bool setDisplayHDR(const LUID& adapterId, const uint32_t& targetId, bool enableAdvancedColor) { *\/",
        "query_nlx":"\/* Function named setDisplayHDR sets the advanced color state for a specific display target identified by the adapterId and targetId provided. \n>>> setDisplayHDR({adapterId}, {targetId}, true) returns true if the advanced color state was successfully enabled for the specified display target, false otherwise. *\/ \nbool setDisplayHDR(const LUID& adapterId, const uint32_t& targetId, bool enableAdvancedColor) { "
    }

    {
        "file_name":"virtual_display_function_8.cpp",
        "line_count":10,
        "code":"bool getDisplayHDRByName(const wchar_t* displayName) {\n\tLUID adapterId;\n\tuint32_t targetId;\n\n\tif (!findDisplayIds(displayName, adapterId, targetId)) {\n\t\treturn false;\n\t}\n\n\treturn getDisplayHDR(adapterId, targetId);\n}",
        "mark":8.0,
        "query_nsx":"\/* Check if a display with a specific name supports HDR (High Dynamic Range) output.\n>>> bool getDisplayHDRByName(const wchar_t* displayName) { *\/",
        "query_nlx":"\/* Function named getDisplayHDRByName retrieves the HDR status of a display identified by its name.\n>>> getDisplayHDRByName(\"Display1\") true\n>>> getDisplayHDRByName(\"Display2\") false *\/ \nbool getDisplayHDRByName(const wchar_t* displayName) {"
    }

    {
        "file_name":"virtual_display_function_9.cpp",
        "line_count":10,
        "code":"bool setDisplayHDRByName(const wchar_t* displayName, bool enableAdvancedColor) {\n\tLUID adapterId;\n\tuint32_t targetId;\n\n\tif (!findDisplayIds(displayName, adapterId, targetId)) {\n\t\treturn false;\n\t}\n\n\treturn setDisplayHDR(adapterId, targetId, enableAdvancedColor);\n}",
        "mark":8.0,
        "query_nsx":"\/* Set the HDR display by name with the option to enable advanced color settings.\n>>> bool setDisplayHDRByName(const wchar_t* displayName, bool enableAdvancedColor) { *\/",
        "query_nlx":"        \/* Function setDisplayHDRByName takes a display name and a boolean value to enable advanced color settings, then attempts to find the display IDs corresponding to the given display name and sets the HDR display mode based on the found IDs.\n        >>> setDisplayHDRByName(L\"Display1\", true) true\n        >>> setDisplayHDRByName(L\"Display2\", false) false *\/ \n        bool setDisplayHDRByName(const wchar_t* displayName, bool enableAdvancedColor) {"
    }

    {
        "file_name":"winapp_thread_function_2.cpp",
        "line_count":6,
        "code":"size_t hardware_concurrency()\n  {\n    SYSTEM_INFO system_info;\n    ::GetNativeSystemInfo(&system_info);\n    return system_info.dwNumberOfProcessors;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine the number of processors available on the hardware system.\n   >>> hardware_concurrency() \n*\/",
        "query_nlx":"\/* Function named hardware_concurrency retrieves the number of processors available on the system.\n>>> hardware_concurrency() returns the number of processors available on the system. *\/ \nsize_t hardware_concurrency() { "
    }

    {
        "file_name":"wince_thread_function_2.cpp",
        "line_count":6,
        "code":"size_t hardware_concurrency()\n  {\n    SYSTEM_INFO system_info;\n    ::GetSystemInfo(&system_info);\n    return system_info.dwNumberOfProcessors;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Determine the number of available processors on the system.\n   >>> hardware_concurrency() \n*\/ \nsize_t hardware_concurrency();",
        "query_nlx":"\/* Function named hardware_concurrency retrieves the number of processors available on the system.\n>>> hardware_concurrency() returns the number of processors available on the system. *\/ \nsize_t hardware_concurrency() { "
    }

    {
        "file_name":"winrt_ssocket_service_base_function_1.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle(base_implementation_type& impl)\n  {\n    return impl.socket_;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the native handle associated with the base implementation type.\n   >>> native_handle_type native_handle(base_implementation_type& impl) *\/",
        "query_nlx":"\/* Function named native_handle retrieves the native handle from a given base implementation type by accessing its socket member variable. \n>>> native_handle(base_implementation_type& impl) *\/"
    }

    {
        "file_name":"winrt_ssocket_service_function_1.cpp",
        "line_count":4,
        "code":"void shutdown()\n  {\n    this->base_shutdown();\n  }",
        "mark":8.0,
        "query_nsx":"\/* Perform a shutdown operation.\n   >>> shutdown() *\/ \nvoid shutdown();",
        "query_nlx":"\/* Function named shutdown calls the base_shutdown function within the current object to initiate a shutdown process.\n>>> shutdown() *\/ \nvoid shutdown() {"
    }

    {
        "file_name":"win_iocp_file_service_function_1.cpp",
        "line_count":6,
        "code":"void construct(implementation_type& impl)\n  {\n    handle_service_.construct(impl);\n    impl.offset_ = 0;\n    impl.is_stream_ = false;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Construct an implementation with specific attributes and initialize them.\n   >>> construct(implementation_type& impl) *\/",
        "query_nlx":"\/* Function named construct initializes the given implementation by setting its offset to 0 and is_stream flag to false after constructing the handle service.\n>>> construct(impl) *\/ \nvoid construct(implementation_type& impl) {"
    }

    {
        "file_name":"win_iocp_file_service_function_4.cpp",
        "line_count":4,
        "code":"void destroy(implementation_type& impl)\n  {\n    handle_service_.destroy(impl);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Destroy the implementation type using the handle service.\n   >>> destroy(implementation_type& impl) *\/",
        "query_nlx":"\/* Function named destroy takes an implementation type object and destroys it using a handle service.\n>>> destroy(impl) *\/ \nvoid destroy(implementation_type& impl) {"
    }

    {
        "file_name":"win_iocp_file_service_function_5.cpp",
        "line_count":4,
        "code":"void set_is_stream(implementation_type& impl, bool is_stream)\n  {\n    impl.is_stream_ = is_stream;\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag indicating whether the implementation is a stream or not.\n   >>> void set_is_stream(implementation_type& impl, bool is_stream) { *\/",
        "query_nlx":"\/* Function named set_is_stream modifies the state of a given implementation by setting a boolean flag to indicate whether it is a stream or not.\n>>> set_is_stream(impl, true) \n>>> set_is_stream(impl, false) *\/ \nvoid set_is_stream(implementation_type& impl, bool is_stream) { "
    }

    {
        "file_name":"win_iocp_io_context_function_3.cpp",
        "line_count":4,
        "code":"void work_started()\n  {\n    ::InterlockedIncrement(&outstanding_work_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Increment the count of outstanding work being processed.\n   >>> work_started() *\/ \nvoid work_started();",
        "query_nlx":"\/* Increment the value of a variable representing outstanding work using an atomic operation. \n>>> work_started() *\/ \nvoid work_started() {"
    }

    {
        "file_name":"win_iocp_io_context_function_6.cpp",
        "line_count":4,
        "code":"void post_private_immediate_completion(win_iocp_operation* op)\n  {\n    post_immediate_completion(op, false);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Post an immediate completion for a private operation without delay.\n   >>> void post_private_immediate_completion(win_iocp_operation* op) *\/",
        "query_nlx":"\/* Function named post_private_immediate_completion posts an immediate completion operation with private access to a specified IOCP operation.\n>>> post_private_immediate_completion(op) *\/ \nvoid post_private_immediate_completion(win_iocp_operation* op) { "
    }

    {
        "file_name":"win_iocp_serial_port_service_function_1.cpp",
        "line_count":4,
        "code":"void construct(implementation_type& impl)\n  {\n    handle_service_.construct(impl);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Construct the implementation using the handle service.\n   >>> construct(implementation_type& impl) *\/",
        "query_nlx":"\/* Function named construct initializes a given implementation by calling the construct function of the handle_service_ object.\n>>> construct(impl) *\/ \nvoid construct(implementation_type& impl) { "
    }

    {
        "file_name":"win_iocp_serial_port_service_function_4.cpp",
        "line_count":4,
        "code":"void destroy(implementation_type& impl)\n  {\n    handle_service_.destroy(impl);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Destroy the implementation type using the handle service.\n   >>> destroy(implementation_type& impl) *\/",
        "query_nlx":"\/* Function named destroy takes an implementation type object and calls a method on a handle service to destroy it.\n>>> destroy(impl_type) void *\/"
    }

    {
        "file_name":"win_iocp_serial_port_service_function_7.cpp",
        "line_count":4,
        "code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    return handle_service_.native_handle(impl);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the native handle associated with the implementation type.\n   >>> native_handle_type native_handle(implementation_type& impl) *\/",
        "query_nlx":"\/* Retrieve the native handle from the implementation type using the handle service.\n   >>> native_handle(implementation_type& impl) native_handle_type *\/"
    }

    {
        "file_name":"win_iocp_socket_service_function_6.cpp",
        "line_count":6,
        "code":"native_handle_type native_handle(implementation_type& impl)\n  {\n    if (impl.have_remote_endpoint_)\n      return native_handle_type(impl.socket_, impl.remote_endpoint_);\n    return native_handle_type(impl.socket_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Return the native handle based on the implementation, considering a remote endpoint if available.\n   >>> native_handle_type native_handle(implementation_type& impl) { *\/",
        "query_nlx":"\/* Function named native_handle retrieves the native handle associated with the given implementation. If the implementation has a remote endpoint, it returns the native handle with the socket and remote endpoint; otherwise, it returns the native handle with just the socket.\n>>> native_handle(implementation_type& impl) native_handle_type { *\/\n#include <iostream>\n#include <string>\nusing namespace std;\nnative_handle_type native_handle(implementation_type& impl) { "
    }

    {
        "file_name":"win_static_mutex_function_2.cpp",
        "line_count":4,
        "code":"void unlock()\n  {\n    ::LeaveCriticalSection(&crit_section_);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Unlock a critical section to allow other threads to access shared resources.\n   >>> void unlock() *\/",
        "query_nlx":"\/* Function named unlock releases the lock on a critical section.\n>>> unlock() *\/ \nvoid unlock() {"
    }

    {
        "file_name":"win_thread_function_2.cpp",
        "line_count":4,
        "code":"void set_terminate_threads(bool b)\n  {\n    ::InterlockedExchange(&terminate_threads_, b ? 1 : 0);\n  }",
        "mark":8.0,
        "query_nsx":"\/* Set a flag to terminate threads based on the input boolean value.\n   >>> void set_terminate_threads(bool b); *\/",
        "query_nlx":"\/* Function named set_terminate_threads sets a flag to indicate whether threads should be terminated or not.\n>>> set_terminate_threads(true) sets the flag to true\n>>> set_terminate_threads(false) sets the flag to false *\/ \nvoid set_terminate_threads(bool b) { "
    }

    {
        "file_name":"wrapped_swapchain_function_10.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetLastPresentCount(UINT* pLastPresentCount)\n    {\n        return m_pReal->GetLastPresentCount(pLastPresentCount);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the count of the last presentation from the system.\n   >>> GetLastPresentCount(UINT* pLastPresentCount) *\/",
        "query_nlx":"\/* Function named GetLastPresentCount retrieves the last count of a present value by calling a method from an external object and returning the result.\n   >>> GetLastPresentCount(pLastPresentCount) *\/ \nSTDMETHODCALLTYPE GetLastPresentCount(UINT* pLastPresentCount) {"
    }

    {
        "file_name":"wrapped_swapchain_function_11.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetDesc1(DXGI_SWAP_CHAIN_DESC1* pDesc)\n    {\n        return m_pReal1->GetDesc1(pDesc);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the description of a swap chain using the provided structure pointer.\n   >>> GetDesc1(DXGI_SWAP_CHAIN_DESC1* pDesc) *\/",
        "query_nlx":"\/* Function named GetDesc1 retrieves the description of a DXGI swap chain and stores it in the provided DXGI_SWAP_CHAIN_DESC1 pointer. \n>>> GetDesc1(pDesc) returns the description of the DXGI swap chain specified by the pointer pDesc. *\/ \nSTDMETHODIMP GetDesc1(DXGI_SWAP_CHAIN_DESC1* pDesc) { "
    }

    {
        "file_name":"wrapped_swapchain_function_15.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE IsTemporaryMonoSupported(void)\n    {\n        return m_pReal1->IsTemporaryMonoSupported();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Determine if the system supports temporary monochrome functionality.\n    >>> IsTemporaryMonoSupported() *\/ \n    STDMETHODCALLTYPE IsTemporaryMonoSupported(void) {",
        "query_nlx":"\/* Function named IsTemporaryMonoSupported checks if the support for temporary monochrome images is available by calling the corresponding function from a real object.\n>>> IsTemporaryMonoSupported() calls the IsTemporaryMonoSupported function of the real object m_pReal1 and returns the result. *\/ \nSTDMETHODIMP IsTemporaryMonoSupported(void) { "
    }

    {
        "file_name":"wrapped_swapchain_function_16.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE SetBackgroundColor(const DXGI_RGBA* pColor)\n    {\n        return m_pReal1->SetBackgroundColor(pColor);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set the background color using the provided RGBA color value.\n        >>> STDMETHODCALLTYPE SetBackgroundColor(const DXGI_RGBA* pColor) { *\/",
        "query_nlx":"\/* Define a function called SetBackgroundColor that takes a pointer to a DXGI_RGBA structure as input and returns a value. \n   >>> SetBackgroundColor(const DXGI_RGBA* pColor) *\/"
    }

    {
        "file_name":"wrapped_swapchain_function_21.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetSourceSize(UINT* pWidth, UINT* pHeight)\n    {\n        return m_pReal2->GetSourceSize(pWidth, pHeight);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the size of the source image.\n   >>> GetSourceSize(UINT* pWidth, UINT* pHeight) *\/",
        "query_nlx":"\/* Function named GetSourceSize retrieves the width and height of a source using pointers to store the values. \n>>> GetSourceSize(&width, &height) returns the width and height of the source. *\/ \nSTDMETHODIMP GetSourceSize(UINT* pWidth, UINT* pHeight) {"
    }

    {
        "file_name":"wrapped_swapchain_function_23.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetMaximumFrameLatency(UINT* pMaxLatency)\n    {\n        return m_pReal2->GetMaximumFrameLatency(pMaxLatency);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Retrieve the maximum frame latency value.\n        >>> STDMETHODCALLTYPE GetMaximumFrameLatency(UINT* pMaxLatency) { *\/",
        "query_nlx":"        \/* Function named GetMaximumFrameLatency retrieves the maximum frame latency value from a given pointer to an unsigned integer. \n        >>> GetMaximumFrameLatency(pMaxLatency) *\/ \n        STDMETHODIMP GetMaximumFrameLatency(UINT* pMaxLatency) {"
    }

    {
        "file_name":"wrapped_swapchain_function_24.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetFrameLatencyWaitableObject(void)\n    {\n        return m_pReal2->GetFrameLatencyWaitableObject();\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Retrieve the waitable object associated with the frame latency from the underlying implementation.\n        >>> GetFrameLatencyWaitableObject() \n        *\/",
        "query_nlx":"\/* Function named GetFrameLatencyWaitableObject retrieves the waitable object associated with the frame latency from the underlying object.\n>>> GetFrameLatencyWaitableObject() returns the waitable object for frame latency. *\/ \nSTDMETHODIMP GetFrameLatencyWaitableObject(void) {"
    }

    {
        "file_name":"wrapped_swapchain_function_25.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE SetMatrixTransform(const DXGI_MATRIX_3X2_F* pMatrix)\n    {\n        return m_pReal2->SetMatrixTransform(pMatrix);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Set a matrix transformation using the provided 3x2 matrix.\n        >>> SetMatrixTransform(const pMatrix) *\/",
        "query_nlx":"\/* Function named SetMatrixTransform takes a pointer to a 3x2 matrix as input and sets the matrix transformation using the provided matrix.\n   >>> SetMatrixTransform(const DXGI_MATRIX_3X2_F* pMatrix) *\/"
    }

    {
        "file_name":"wrapped_swapchain_function_27.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetCurrentBackBufferIndex(void)\n    {\n        return m_pReal3->GetCurrentBackBufferIndex();\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the index of the current back buffer.\n   >>> GetCurrentBackBufferIndex() \n*\/",
        "query_nlx":"\/* Function named GetCurrentBackBufferIndex retrieves the current index of the back buffer from the associated object.\n   >>> GetCurrentBackBufferIndex() returns the current index of the back buffer. *\/"
    }

    {
        "file_name":"wrapped_swapchain_function_28.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE CheckColorSpaceSupport(DXGI_COLOR_SPACE_TYPE ColorSpace, UINT* pColorSpaceSupport)\n    {\n        return m_pReal3->CheckColorSpaceSupport(ColorSpace, pColorSpaceSupport);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Check if the color space supports a specific type and return the support status.\n   >>> CheckColorSpaceSupport(ColorSpace, pColorSpaceSupport) *\/ \n   STDMETHODCALLTYPE CheckColorSpaceSupport(DXGI_COLOR_SPACE_TYPE ColorSpace, UINT* pColorSpaceSupport) {",
        "query_nlx":"        \/* Function named CheckColorSpaceSupport determines the support for a specific color space by calling a method on an object and returning the result.\n        >>> CheckColorSpaceSupport(DXGI_COLOR_SPACE_TYPE ColorSpace, UINT* pColorSpaceSupport) *\/\n    "
    }

    {
        "file_name":"wrapped_swapchain_function_29.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE SetColorSpace1(DXGI_COLOR_SPACE_TYPE ColorSpace)\n    {\n        return m_pReal3->SetColorSpace1(ColorSpace);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set the color space for an object using a specified color space type.\n   >>> SetColorSpace1(ColorSpace)\n*\/ \nvoid SetColorSpace1(DXGI_COLOR_SPACE_TYPE ColorSpace);",
        "query_nlx":"        \/* Function named SetColorSpace1 takes a parameter representing a color space type and sets the color space of an object to that type.\n        >>> SetColorSpace1(DXGI_COLOR_SPACE_TYPE ColorSpace) *\/"
    }

    {
        "file_name":"wrapped_swapchain_function_3.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE SetPrivateData(REFGUID Name, UINT DataSize, const void* pData)\n    {\n        return m_pReal->SetPrivateData(Name, DataSize, pData);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set private data with a specified name, size, and data pointer.\n>>> STDMETHODCALLTYPE SetPrivateData(REFGUID Name, UINT DataSize, const void* pData) *\/",
        "query_nlx":"        \/* Function named SetPrivateData sets private data with a given name, size, and data pointer.\n        >>> SetPrivateData({Name}, {DataSize}, {pData}) *\/\n        STDMETHOD(SetPrivateData)(REFGUID Name, UINT DataSize, const void* pData) {"
    }

    {
        "file_name":"wrapped_swapchain_function_30.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE SetHDRMetaData(DXGI_HDR_METADATA_TYPE Type, UINT Size, void* pMetaData)\n    {\n        return m_pReal4->SetHDRMetaData(Type, Size, pMetaData);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set HDR metadata of a specific type with given size and data.\n   >>> STDMETHODCALLTYPE SetHDRMetaData(DXGI_HDR_METADATA_TYPE Type, UINT Size, void* pMetaData); *\/",
        "query_nlx":"\/* Function named SetHDRMetaData sets the HDR metadata of a specified type with a given size and metadata pointer.\n>>> SetHDRMetaData(DXGI_HDR_METADATA_TYPE Type, UINT Size, void* pMetaData) *\/"
    }

    {
        "file_name":"wrapped_swapchain_function_4.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE SetPrivateDataInterface(REFGUID Name, const IUnknown* pUnknown)\n    {\n        return m_pReal->SetPrivateDataInterface(Name, pUnknown);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Set a private data interface with a specified name and unknown object.\n   >>> STDMETHODCALLTYPE SetPrivateDataInterface(REFGUID Name, const IUnknown* pUnknown) { *\/",
        "query_nlx":"        \/* Function named SetPrivateDataInterface sets a private data interface with a specified name and unknown pointer.\n        >>> SetPrivateDataInterface(REFGUID Name, const IUnknown* pUnknown) *\/"
    }

    {
        "file_name":"wrapped_swapchain_function_5.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetPrivateData(REFGUID Name, UINT* pDataSize, void* pData)\n    {\n        return m_pReal->GetPrivateData(Name, pDataSize, pData);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve private data associated with a specified name using the provided size and data pointers.\n    >>> STDMETHODCALLTYPE GetPrivateData(REFGUID Name, UINT* pDataSize, void* pData) *\/",
        "query_nlx":"\/* Define a function GetPrivateData that retrieves private data based on a given name, data size, and data pointer.\n   >>> GetPrivateData(REFGUID Name, UINT* pDataSize, void* pData) *\/"
    }

    {
        "file_name":"wrapped_swapchain_function_6.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetParent(REFIID riid, void** ppParent)\n    {\n        return m_pReal->GetParent(riid, ppParent);\n    }",
        "mark":8.0,
        "query_nsx":"\/* Retrieve the parent object based on the specified interface identifier.\n   >>> GetParent(REFIID riid, void** ppParent) *\/",
        "query_nlx":"\/* Define a method that retrieves the parent object based on a given interface ID and a pointer to the parent object.\n   >>> GetParent(riid, ppParent) returns the parent object associated with the specified interface ID. *\/ \nSTDMETHODIMP GetParent(REFIID riid, void** ppParent) {"
    }

    {
        "file_name":"wrapped_swapchain_function_7.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetDesc(DXGI_SWAP_CHAIN_DESC* pDesc)\n    {\n        return m_pReal->GetDesc(pDesc);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Retrieve the description of a DXGI swap chain.\n        >>> STDMETHODCALLTYPE GetDesc(DXGI_SWAP_CHAIN_DESC* pDesc); *\/",
        "query_nlx":"\/* Function named GetDesc retrieves the description of a DXGI swap chain based on the provided DXGI_SWAP_CHAIN_DESC pointer.\n>>> GetDesc(pDesc) returns the description of the DXGI swap chain pointed to by pDesc. *\/ \nSTDMETHODIMP GetDesc(DXGI_SWAP_CHAIN_DESC* pDesc) { "
    }

    {
        "file_name":"wrapped_swapchain_function_8.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE ResizeTarget(const DXGI_MODE_DESC* pNewTargetParameters)\n    {\n        return m_pReal->ResizeTarget(pNewTargetParameters);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Resize the target using the provided parameters.\n        >>> ResizeTarget(const DXGI_MODE_DESC* pNewTargetParameters){ *\/",
        "query_nlx":"\/* Define a function called ResizeTarget that takes a pointer to a DXGI_MODE_DESC structure as input and returns the result of calling the ResizeTarget function on a member variable m_pReal with the input parameter.\n>>> ResizeTarget(const DXGI_MODE_DESC* pNewTargetParameters) *\/"
    }

    {
        "file_name":"wrapped_swapchain_function_9.cpp",
        "line_count":4,
        "code":"STDMETHODCALLTYPE GetFrameStatistics(DXGI_FRAME_STATISTICS* pStats)\n    {\n        return m_pReal->GetFrameStatistics(pStats);\n    }",
        "mark":8.0,
        "query_nsx":"        \/* Retrieve frame statistics using the provided structure pointer.\n        >>> STDMETHODCALLTYPE GetFrameStatistics(DXGI_FRAME_STATISTICS* pStats){ *\/",
        "query_nlx":"\/* Function named GetFrameStatistics retrieves frame statistics using a pointer to a DXGI_FRAME_STATISTICS structure.\n>>> GetFrameStatistics(DXGI_FRAME_STATISTICS* pStats) *\/"
    }

